; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33519.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__4B783B3C_concurrencysal@h DB 01H
__137BB1BE_sal@h DB 01H
__805F4069_vadefs@h DB 01H
__1EAACA9B_vcruntime@h DB 01H
__1B0272D9_corecrt@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__46240030_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__5274102E_stb_image@h DB 01H
__CC8D90C0_stdarg@h DB 01H
__61CC25A1_errno@h DB 01H
__0504B279_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__19139D6C_assert@h DB 01H
__5BC5AF51_mmintrin@h DB 01H
__FA77ED4C_malloc@h DB 01H
__9E7FA6CF_xmmintrin@h DB 01H
__FB1D2F03_emmintrin@h DB 01H
__49ADACC4_intrin0@inl@h DB 01H
__6831C60C_setjmp@h DB 01H
__24BC478A_pmmintrin@h DB 01H
__94653408_tmmintrin@h DB 01H
__BD5E218B_smmintrin@h DB 01H
__D83CA847_nmmintrin@h DB 01H
__0D875209_wmmintrin@h DB 01H
__C6131F0E_zmmintrin@h DB 01H
__F107BDC4_immintrin@h DB 01H
__4BC45C81_ammintrin@h DB 01H
__4E077A7B_intrin@h DB 01H
__C5A6C9A6_stb_image@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
stbi__bmask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
?rgb@?5??stbi__process_frame_header@@9@9 DB 052H	; `stbi__process_frame_header'::`6'::rgb
	DB	047H
	DB	042H
	ORG $+9
stbi__jbias DD	00H
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
stbi__jpeg_dezigzag DB 00H
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
?tag@?O@??stbi__process_marker@@9@9 DB 04aH		; `stbi__process_marker'::`14'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	ORG $+3
?tag@?BA@??stbi__process_marker@@9@9 DB 041H		; `stbi__process_marker'::`16'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
	ORG $+2
stbi__zlength_base DD 03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
stbi__zlength_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
stbi__zdist_base DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
stbi__zdist_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9 DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+13
stbi__zdefault_length DB 08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
stbi__zdefault_distance DB 05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?png_sig@?1??stbi__check_png_header@@9@9 DB 089H	; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
stbi__depth_scale_table DB 00H
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
CONST	ENDS
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_from_callbacks
PUBLIC	stbi_load
PUBLIC	stbi_load_to_target
PUBLIC	stbi_load_from_file
PUBLIC	stbi_load_gif_from_memory
PUBLIC	stbi_load_16_from_memory
PUBLIC	stbi_load_16_from_callbacks
PUBLIC	stbi_load_16
PUBLIC	stbi_load_from_file_16
PUBLIC	stbi_loadf_from_memory
PUBLIC	stbi_loadf_from_callbacks
PUBLIC	stbi_loadf
PUBLIC	stbi_loadf_from_file
PUBLIC	stbi_hdr_to_ldr_gamma
PUBLIC	stbi_hdr_to_ldr_scale
PUBLIC	stbi_ldr_to_hdr_gamma
PUBLIC	stbi_ldr_to_hdr_scale
PUBLIC	stbi_is_hdr_from_callbacks
PUBLIC	stbi_is_hdr_from_memory
PUBLIC	stbi_is_hdr
PUBLIC	stbi_is_hdr_from_file
PUBLIC	stbi_failure_reason
PUBLIC	stbi_image_free
PUBLIC	stbi_info_from_memory
PUBLIC	stbi_info_from_callbacks
PUBLIC	stbi_is_16_bit_from_memory
PUBLIC	stbi_is_16_bit_from_callbacks
PUBLIC	stbi_info
PUBLIC	stbi_info_from_file
PUBLIC	stbi_is_16_bit
PUBLIC	stbi_is_16_bit_from_file
PUBLIC	stbi_set_unpremultiply_on_load
PUBLIC	stbi_convert_iphone_png_to_rgb
PUBLIC	stbi_set_flip_vertically_on_load
PUBLIC	stbi_set_unpremultiply_on_load_thread
PUBLIC	stbi_convert_iphone_png_to_rgb_thread
PUBLIC	stbi_set_flip_vertically_on_load_thread
PUBLIC	stbi_zlib_decode_malloc_guesssize
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_zlib_decode_malloc
PUBLIC	stbi_zlib_decode_buffer
PUBLIC	stbi_zlib_decode_noheader_malloc
PUBLIC	stbi_zlib_decode_noheader_buffer
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem@			; `string'
PUBLIC	??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@ ; `string'
PUBLIC	??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen@		; `string'
PUBLIC	??_C@_0CB@DDANHPKI@can?8t?5fopen?0?5Unable?5to?5open?5fil@ ; `string'
PUBLIC	??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_0M@MHDBFHD@unsupported@			; `string'
PUBLIC	??_C@_0O@DEFOLMLB@bad?5size?5list@		; `string'
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths@		; `string'
PUBLIC	??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ ; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code@		; `string'
PUBLIC	??_C@_09IFDKCGFO@bad?5delta@			; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@	; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker@		; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@	; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len@		; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit@			; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height@		; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large@			; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ@			; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height@		; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp@		; `string'
PUBLIC	??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ ; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes@			; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths@		; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit@	; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist@			; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer@		; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header@		; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression@		; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig@		; `string'
PUBLIC	??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ ; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels@		; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter@		; `string'
PUBLIC	??_C@_0O@MKGNGALN@invalid?5width@		; `string'
PUBLIC	??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ ; `string'
PUBLIC	??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ ; `string'
PUBLIC	??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@	; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype@			; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method@		; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method@		; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@		; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@		; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@		; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE@			; `string'
PUBLIC	??_C@_0BA@PLHGLONG@IDAT?5size?5limit@		; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT@			; `string'
PUBLIC	??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@	; `string'
PUBLIC	??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@ ; `string'
PUBLIC	??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ ; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP@			; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP@			; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE@			; `string'
PUBLIC	??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@		; `string'
PUBLIC	??_C@_0L@PJHPAMCH@bad?5header@			; `string'
PUBLIC	??_C@_0L@JDPIFELH@bad?5offset@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks@			; `string'
PUBLIC	??_C@_0L@DMAPJJO@bad?5format@			; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette@			; `string'
PUBLIC	??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ ; `string'
PUBLIC	??_C@_07ECNCNLIK@not?5PSD@			; `string'
PUBLIC	??_C@_0O@CHBCDKKC@wrong?5version@		; `string'
PUBLIC	??_C@_0BE@PJBNGDBE@wrong?5channel?5count@	; `string'
PUBLIC	??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@	; `string'
PUBLIC	??_C@_0BD@IOGGBMNK@wrong?5color?5format@	; `string'
PUBLIC	??_C@_07DPPMCAKL@corrupt@			; `string'
PUBLIC	??_C@_04KBFEPHFH@S?$IA?v4@			; `string'
PUBLIC	??_C@_04ELNJHLFH@PICT@				; `string'
PUBLIC	??_C@_08GGMBIFE@bad?5file@			; `string'
PUBLIC	??_C@_07KMJLPAII@not?5GIF@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0O@MGDACKOJ@no?5clear?5code@		; `string'
PUBLIC	??_C@_0P@GJNJCPDJ@too?5many?5codes@		; `string'
PUBLIC	??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@	; `string'
PUBLIC	??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@	; `string'
PUBLIC	??_C@_0BE@NAMJKDNF@missing?5color?5table@	; `string'
PUBLIC	??_C@_0N@DJABBOOH@unknown?5code@		; `string'
PUBLIC	??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@		; `string'
PUBLIC	??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@		; `string'
PUBLIC	??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@		; `string'
PUBLIC	??_C@_06NDOKKIDJ@?$CD?$DPRGBE@			; `string'
PUBLIC	??_C@_07NCIOKENI@not?5HDR@			; `string'
PUBLIC	??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@	; `string'
PUBLIC	??_C@_0BD@NKJFFLKL@unsupported?5format@		; `string'
PUBLIC	??_C@_03HKAKGGJN@?9Y?5@				; `string'
PUBLIC	??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@	; `string'
PUBLIC	??_C@_03FOKDFDHG@?$CLX?5@			; `string'
PUBLIC	??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ ; `string'
PUBLIC	??_C@_07IDKIDMGJ@bad?5PNM@			; `string'
PUBLIC	??_C@_0BH@OBINMOBC@integer?5parse?5overflow@	; `string'
PUBLIC	??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@	; `string'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@437f0000
PUBLIC	__real@477fff00
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	__imp_fopen_s:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	abs:PROC
EXTRN	_lrotl:PROC
EXTRN	__imp_strtol:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	pow:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	__imp__wassert:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
_TLS	SEGMENT
stbi__g_failure_reason DQ 01H DUP (?)
_TLS	ENDS
_BSS	SEGMENT
stbi__vertically_flip_on_load_global DD 01H DUP (?)
_BSS	ENDS
_TLS	SEGMENT
stbi__vertically_flip_on_load_local DD 01H DUP (?)
stbi__vertically_flip_on_load_set DD 01H DUP (?)
_TLS	ENDS
_BSS	SEGMENT
stbi__unpremultiply_on_load_global DD 01H DUP (?)
stbi__de_iphone_flag_global DD 01H DUP (?)
_BSS	ENDS
_TLS	SEGMENT
stbi__unpremultiply_on_load_local DD 01H DUP (?)
stbi__unpremultiply_on_load_set DD 01H DUP (?)
stbi__de_iphone_flag_local DD 01H DUP (?)
stbi__de_iphone_flag_set DD 01H DUP (?)
_TLS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_memory DD imagerel $LN3
	DD	imagerel $LN3+197
	DD	imagerel $unwind$stbi_load_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$stbi_load_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$stbi_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_to_target DD imagerel $LN4
	DD	imagerel $LN4+158
	DD	imagerel $unwind$stbi_load_to_target
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_file DD imagerel $LN4
	DD	imagerel $LN4+249
	DD	imagerel $unwind$stbi_load_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_gif_from_memory DD imagerel $LN6
	DD	imagerel $LN6+370
	DD	imagerel $unwind$stbi_load_gif_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_16_from_memory DD imagerel $LN3
	DD	imagerel $LN3+197
	DD	imagerel $unwind$stbi_load_16_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_16_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$stbi_load_16_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_16 DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$stbi_load_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_file_16 DD imagerel $LN4
	DD	imagerel $LN4+249
	DD	imagerel $unwind$stbi_load_from_file_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_loadf_from_memory DD imagerel $LN3
	DD	imagerel $LN3+197
	DD	imagerel $unwind$stbi_loadf_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_loadf_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$stbi_loadf_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_loadf DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$stbi_loadf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_loadf_from_file DD imagerel $LN3
	DD	imagerel $LN3+191
	DD	imagerel $unwind$stbi_loadf_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_hdr_to_ldr_gamma DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$stbi_hdr_to_ldr_gamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_hdr_to_ldr_scale DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$stbi_hdr_to_ldr_scale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_ldr_to_hdr_gamma DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$stbi_ldr_to_hdr_gamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_ldr_to_hdr_scale DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$stbi_ldr_to_hdr_scale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_hdr_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$stbi_is_hdr_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_hdr_from_memory DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$stbi_is_hdr_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_hdr DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$stbi_is_hdr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_hdr_from_file DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$stbi_is_hdr_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_failure_reason DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$stbi_failure_reason
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_image_free DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$stbi_image_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_info_from_memory DD imagerel $LN3
	DD	imagerel $LN3+187
	DD	imagerel $unwind$stbi_info_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_info_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+188
	DD	imagerel $unwind$stbi_info_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_16_bit_from_memory DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$stbi_is_16_bit_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_16_bit_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$stbi_is_16_bit_from_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_info DD imagerel $LN4
	DD	imagerel $LN4+146
	DD	imagerel $unwind$stbi_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_info_from_file DD imagerel $LN3
	DD	imagerel $LN3+226
	DD	imagerel $unwind$stbi_info_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_16_bit DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$stbi_is_16_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_is_16_bit_from_file DD imagerel $LN3
	DD	imagerel $LN3+190
	DD	imagerel $unwind$stbi_is_16_bit_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_set_unpremultiply_on_load DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$stbi_set_unpremultiply_on_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_convert_iphone_png_to_rgb DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$stbi_convert_iphone_png_to_rgb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_set_flip_vertically_on_load DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$stbi_set_flip_vertically_on_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_set_unpremultiply_on_load_thread DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$stbi_set_unpremultiply_on_load_thread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_convert_iphone_png_to_rgb_thread DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$stbi_convert_iphone_png_to_rgb_thread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_set_flip_vertically_on_load_thread DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$stbi_set_flip_vertically_on_load_thread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_malloc_guesssize DD imagerel $LN7
	DD	imagerel $LN7+308
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN7
	DD	imagerel $LN7+310
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_malloc DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$stbi_zlib_decode_malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_buffer DD imagerel $LN5
	DD	imagerel $LN5+236
	DD	imagerel $unwind$stbi_zlib_decode_buffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_noheader_malloc DD imagerel $LN7
	DD	imagerel $LN7+297
	DD	imagerel $unwind$stbi_zlib_decode_noheader_malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_noheader_buffer DD imagerel $LN5
	DD	imagerel $LN5+236
	DD	imagerel $unwind$stbi_zlib_decode_noheader_buffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__cpuid3 DD imagerel stbi__cpuid3
	DD	imagerel stbi__cpuid3+149
	DD	imagerel $unwind$stbi__cpuid3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__sse2_available DD imagerel stbi__sse2_available
	DD	imagerel stbi__sse2_available+86
	DD	imagerel $unwind$stbi__sse2_available
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__refill_buffer DD imagerel stbi__refill_buffer
	DD	imagerel stbi__refill_buffer+291
	DD	imagerel $unwind$stbi__refill_buffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__start_mem DD imagerel stbi__start_mem
	DD	imagerel stbi__start_mem+205
	DD	imagerel $unwind$stbi__start_mem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__start_callbacks DD imagerel stbi__start_callbacks
	DD	imagerel stbi__start_callbacks+241
	DD	imagerel $unwind$stbi__start_callbacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__stdio_read DD imagerel stbi__stdio_read
	DD	imagerel stbi__stdio_read+86
	DD	imagerel $unwind$stbi__stdio_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__stdio_skip DD imagerel stbi__stdio_skip
	DD	imagerel stbi__stdio_skip+108
	DD	imagerel $unwind$stbi__stdio_skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__stdio_eof DD imagerel stbi__stdio_eof
	DD	imagerel stbi__stdio_eof+103
	DD	imagerel $unwind$stbi__stdio_eof
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__start_file DD imagerel stbi__start_file
	DD	imagerel stbi__start_file+72
	DD	imagerel $unwind$stbi__start_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__rewind DD imagerel stbi__rewind
	DD	imagerel stbi__rewind+97
	DD	imagerel $unwind$stbi__rewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_test DD imagerel stbi__jpeg_test
	DD	imagerel stbi__jpeg_test+158
	DD	imagerel $unwind$stbi__jpeg_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_load DD imagerel stbi__jpeg_load
	DD	imagerel stbi__jpeg_load+224
	DD	imagerel $unwind$stbi__jpeg_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_info DD imagerel stbi__jpeg_info
	DD	imagerel stbi__jpeg_info+168
	DD	imagerel $unwind$stbi__jpeg_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__png_test DD imagerel stbi__png_test
	DD	imagerel stbi__png_test+71
	DD	imagerel $unwind$stbi__png_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__png_load DD imagerel stbi__png_load
	DD	imagerel stbi__png_load+198
	DD	imagerel $unwind$stbi__png_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__png_info DD imagerel stbi__png_info
	DD	imagerel stbi__png_info+176
	DD	imagerel $unwind$stbi__png_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__png_is16 DD imagerel stbi__png_is16
	DD	imagerel stbi__png_is16+180
	DD	imagerel $unwind$stbi__png_is16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_test DD imagerel stbi__bmp_test
	DD	imagerel stbi__bmp_test+71
	DD	imagerel $unwind$stbi__bmp_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_load DD imagerel stbi__bmp_load
	DD	imagerel stbi__bmp_load+4917
	DD	imagerel $unwind$stbi__bmp_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_info DD imagerel stbi__bmp_info
	DD	imagerel stbi__bmp_info+333
	DD	imagerel $unwind$stbi__bmp_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__tga_test DD imagerel stbi__tga_test
	DD	imagerel stbi__tga_test+395
	DD	imagerel $unwind$stbi__tga_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__tga_load DD imagerel stbi__tga_load
	DD	imagerel stbi__tga_load+3001
	DD	imagerel $unwind$stbi__tga_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__tga_info DD imagerel stbi__tga_info
	DD	imagerel stbi__tga_info+712
	DD	imagerel $unwind$stbi__tga_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__psd_test DD imagerel stbi__psd_test
	DD	imagerel stbi__psd_test+106
	DD	imagerel $unwind$stbi__psd_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__psd_load DD imagerel stbi__psd_load
	DD	imagerel stbi__psd_load+3120
	DD	imagerel $unwind$stbi__psd_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__psd_info DD imagerel stbi__psd_info
	DD	imagerel stbi__psd_info+471
	DD	imagerel $unwind$stbi__psd_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__psd_is16 DD imagerel stbi__psd_is16
	DD	imagerel stbi__psd_is16+238
	DD	imagerel $unwind$stbi__psd_is16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_test DD imagerel stbi__hdr_test
	DD	imagerel stbi__hdr_test+118
	DD	imagerel $unwind$stbi__hdr_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_load DD imagerel stbi__hdr_load
	DD	imagerel stbi__hdr_load+2640
	DD	imagerel $unwind$stbi__hdr_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_info DD imagerel stbi__hdr_info
	DD	imagerel stbi__hdr_info+635
	DD	imagerel $unwind$stbi__hdr_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_test DD imagerel stbi__pic_test
	DD	imagerel stbi__pic_test+71
	DD	imagerel $unwind$stbi__pic_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_load DD imagerel stbi__pic_load
	DD	imagerel stbi__pic_load+786
	DD	imagerel $unwind$stbi__pic_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_info DD imagerel stbi__pic_info
	DD	imagerel stbi__pic_info+699
	DD	imagerel $unwind$stbi__pic_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_test DD imagerel stbi__gif_test
	DD	imagerel stbi__gif_test+71
	DD	imagerel $unwind$stbi__gif_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_load DD imagerel stbi__gif_load
	DD	imagerel stbi__gif_load+358
	DD	imagerel $unwind$stbi__gif_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__load_gif_main DD imagerel stbi__load_gif_main
	DD	imagerel stbi__load_gif_main+1124
	DD	imagerel $unwind$stbi__load_gif_main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_info DD imagerel stbi__gif_info
	DD	imagerel stbi__gif_info+89
	DD	imagerel $unwind$stbi__gif_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_test DD imagerel stbi__pnm_test
	DD	imagerel stbi__pnm_test+119
	DD	imagerel $unwind$stbi__pnm_test
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_load DD imagerel stbi__pnm_load
	DD	imagerel stbi__pnm_load+904
	DD	imagerel $unwind$stbi__pnm_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_info DD imagerel stbi__pnm_info
	DD	imagerel stbi__pnm_info+579
	DD	imagerel $unwind$stbi__pnm_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_is16 DD imagerel stbi__pnm_is16
	DD	imagerel stbi__pnm_is16+75
	DD	imagerel $unwind$stbi__pnm_is16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__err DD imagerel stbi__err
	DD	imagerel stbi__err+80
	DD	imagerel $unwind$stbi__err
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__malloc DD imagerel stbi__malloc
	DD	imagerel stbi__malloc+54
	DD	imagerel $unwind$stbi__malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__addsizes_valid DD imagerel stbi__addsizes_valid
	DD	imagerel stbi__addsizes_valid+104
	DD	imagerel $unwind$stbi__addsizes_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__mul2sizes_valid DD imagerel stbi__mul2sizes_valid
	DD	imagerel stbi__mul2sizes_valid+130
	DD	imagerel $unwind$stbi__mul2sizes_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__mad2sizes_valid DD imagerel stbi__mad2sizes_valid
	DD	imagerel stbi__mad2sizes_valid+128
	DD	imagerel $unwind$stbi__mad2sizes_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__mad3sizes_valid DD imagerel stbi__mad3sizes_valid
	DD	imagerel stbi__mad3sizes_valid+170
	DD	imagerel $unwind$stbi__mad3sizes_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__mad4sizes_valid DD imagerel stbi__mad4sizes_valid
	DD	imagerel stbi__mad4sizes_valid+214
	DD	imagerel $unwind$stbi__mad4sizes_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__malloc_mad2 DD imagerel stbi__malloc_mad2
	DD	imagerel stbi__malloc_mad2+110
	DD	imagerel $unwind$stbi__malloc_mad2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__malloc_mad3 DD imagerel stbi__malloc_mad3
	DD	imagerel stbi__malloc_mad3+129
	DD	imagerel $unwind$stbi__malloc_mad3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__malloc_mad4 DD imagerel stbi__malloc_mad4
	DD	imagerel stbi__malloc_mad4+146
	DD	imagerel $unwind$stbi__malloc_mad4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__addints_valid DD imagerel stbi__addints_valid
	DD	imagerel stbi__addints_valid+241
	DD	imagerel $unwind$stbi__addints_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__mul2shorts_valid DD imagerel stbi__mul2shorts_valid
	DD	imagerel stbi__mul2shorts_valid+375
	DD	imagerel $unwind$stbi__mul2shorts_valid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__ldr_to_hdr DD imagerel stbi__ldr_to_hdr
	DD	imagerel stbi__ldr_to_hdr+536
	DD	imagerel $unwind$stbi__ldr_to_hdr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_to_ldr DD imagerel stbi__hdr_to_ldr
	DD	imagerel stbi__hdr_to_ldr+644
	DD	imagerel $unwind$stbi__hdr_to_ldr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__load_main DD imagerel stbi__load_main
	DD	imagerel stbi__load_main+933
	DD	imagerel $unwind$stbi__load_main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__convert_16_to_8 DD imagerel stbi__convert_16_to_8
	DD	imagerel stbi__convert_16_to_8+228
	DD	imagerel $unwind$stbi__convert_16_to_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__convert_8_to_16 DD imagerel stbi__convert_8_to_16
	DD	imagerel stbi__convert_8_to_16+244
	DD	imagerel $unwind$stbi__convert_8_to_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__vertical_flip DD imagerel stbi__vertical_flip
	DD	imagerel stbi__vertical_flip+511
	DD	imagerel $unwind$stbi__vertical_flip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__vertical_flip_slices DD imagerel stbi__vertical_flip_slices
	DD	imagerel stbi__vertical_flip_slices+166
	DD	imagerel $unwind$stbi__vertical_flip_slices
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__load_and_postprocess_8bit DD imagerel stbi__load_and_postprocess_8bit
	DD	imagerel stbi__load_and_postprocess_8bit+516
	DD	imagerel $unwind$stbi__load_and_postprocess_8bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__load_and_postprocess_16bit DD imagerel stbi__load_and_postprocess_16bit
	DD	imagerel stbi__load_and_postprocess_16bit+522
	DD	imagerel $unwind$stbi__load_and_postprocess_16bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__float_postprocess DD imagerel stbi__float_postprocess
	DD	imagerel stbi__float_postprocess+245
	DD	imagerel $unwind$stbi__float_postprocess
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__fopen DD imagerel stbi__fopen
	DD	imagerel stbi__fopen+165
	DD	imagerel $unwind$stbi__fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__loadf_main DD imagerel stbi__loadf_main
	DD	imagerel stbi__loadf_main+439
	DD	imagerel $unwind$stbi__loadf_main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get8 DD imagerel stbi__get8
	DD	imagerel stbi__get8+224
	DD	imagerel $unwind$stbi__get8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__at_eof DD imagerel stbi__at_eof
	DD	imagerel stbi__at_eof+162
	DD	imagerel $unwind$stbi__at_eof
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__skip DD imagerel stbi__skip
	DD	imagerel stbi__skip+261
	DD	imagerel $unwind$stbi__skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__getn DD imagerel stbi__getn
	DD	imagerel stbi__getn+412
	DD	imagerel $unwind$stbi__getn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get16be DD imagerel stbi__get16be
	DD	imagerel stbi__get16be+96
	DD	imagerel $unwind$stbi__get16be
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get32be DD imagerel stbi__get32be
	DD	imagerel stbi__get32be+90
	DD	imagerel $unwind$stbi__get32be
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get16le DD imagerel stbi__get16le
	DD	imagerel stbi__get16le+84
	DD	imagerel $unwind$stbi__get16le
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get32le DD imagerel stbi__get32le
	DD	imagerel stbi__get32le+84
	DD	imagerel $unwind$stbi__get32le
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__compute_y DD imagerel stbi__compute_y
	DD	imagerel stbi__compute_y+80
	DD	imagerel $unwind$stbi__compute_y
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__convert_format DD imagerel stbi__convert_format
	DD	imagerel stbi__convert_format+2744
	DD	imagerel $unwind$stbi__convert_format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__compute_y_16 DD imagerel stbi__compute_y_16
	DD	imagerel stbi__compute_y_16+80
	DD	imagerel $unwind$stbi__compute_y_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__convert_format16 DD imagerel stbi__convert_format16
	DD	imagerel stbi__convert_format16+2796
	DD	imagerel $unwind$stbi__convert_format16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__build_huffman DD imagerel stbi__build_huffman
	DD	imagerel stbi__build_huffman+696
	DD	imagerel $unwind$stbi__build_huffman
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__build_fast_ac DD imagerel stbi__build_fast_ac
	DD	imagerel stbi__build_fast_ac+439
	DD	imagerel $unwind$stbi__build_fast_ac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__grow_buffer_unsafe DD imagerel stbi__grow_buffer_unsafe
	DD	imagerel stbi__grow_buffer_unsafe+313
	DD	imagerel $unwind$stbi__grow_buffer_unsafe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_huff_decode DD imagerel stbi__jpeg_huff_decode
	DD	imagerel stbi__jpeg_huff_decode+756
	DD	imagerel $unwind$stbi__jpeg_huff_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__extend_receive DD imagerel stbi__extend_receive
	DD	imagerel stbi__extend_receive+283
	DD	imagerel $unwind$stbi__extend_receive
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_get_bits DD imagerel stbi__jpeg_get_bits
	DD	imagerel stbi__jpeg_get_bits+236
	DD	imagerel $unwind$stbi__jpeg_get_bits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_get_bit DD imagerel stbi__jpeg_get_bit
	DD	imagerel stbi__jpeg_get_bit+169
	DD	imagerel $unwind$stbi__jpeg_get_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_decode_block DD imagerel stbi__jpeg_decode_block
	DD	imagerel stbi__jpeg_decode_block+983
	DD	imagerel $unwind$stbi__jpeg_decode_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_decode_block_prog_dc DD imagerel stbi__jpeg_decode_block_prog_dc
	DD	imagerel stbi__jpeg_decode_block_prog_dc+590
	DD	imagerel $unwind$stbi__jpeg_decode_block_prog_dc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_decode_block_prog_ac DD imagerel stbi__jpeg_decode_block_prog_ac
	DD	imagerel stbi__jpeg_decode_block_prog_ac+1741
	DD	imagerel $unwind$stbi__jpeg_decode_block_prog_ac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__clamp DD imagerel stbi__clamp
	DD	imagerel stbi__clamp+88
	DD	imagerel $unwind$stbi__clamp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__idct_block DD imagerel stbi__idct_block
	DD	imagerel stbi__idct_block+3188
	DD	imagerel $unwind$stbi__idct_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__idct_simd DD imagerel stbi__idct_simd
	DD	imagerel stbi__idct_simd+5982
	DD	imagerel $unwind$stbi__idct_simd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get_marker DD imagerel stbi__get_marker
	DD	imagerel stbi__get_marker+167
	DD	imagerel $unwind$stbi__get_marker
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_reset DD imagerel stbi__jpeg_reset
	DD	imagerel stbi__jpeg_reset+297
	DD	imagerel $unwind$stbi__jpeg_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_entropy_coded_data DD imagerel stbi__parse_entropy_coded_data
	DD	imagerel stbi__parse_entropy_coded_data+3232
	DD	imagerel $unwind$stbi__parse_entropy_coded_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_dequantize DD imagerel stbi__jpeg_dequantize
	DD	imagerel stbi__jpeg_dequantize+119
	DD	imagerel $unwind$stbi__jpeg_dequantize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_finish DD imagerel stbi__jpeg_finish
	DD	imagerel stbi__jpeg_finish+492
	DD	imagerel $unwind$stbi__jpeg_finish
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__process_marker DD imagerel stbi__process_marker
	DD	imagerel stbi__process_marker+1902
	DD	imagerel $unwind$stbi__process_marker
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__process_scan_header DD imagerel stbi__process_scan_header
	DD	imagerel stbi__process_scan_header+905
	DD	imagerel $unwind$stbi__process_scan_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__free_jpeg_components DD imagerel stbi__free_jpeg_components
	DD	imagerel stbi__free_jpeg_components+393
	DD	imagerel $unwind$stbi__free_jpeg_components
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__process_frame_header DD imagerel stbi__process_frame_header
	DD	imagerel stbi__process_frame_header+2435
	DD	imagerel $unwind$stbi__process_frame_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__decode_jpeg_header DD imagerel stbi__decode_jpeg_header
	DD	imagerel stbi__decode_jpeg_header+397
	DD	imagerel $unwind$stbi__decode_jpeg_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__skip_jpeg_junk_at_end DD imagerel stbi__skip_jpeg_junk_at_end
	DD	imagerel stbi__skip_jpeg_junk_at_end+166
	DD	imagerel $unwind$stbi__skip_jpeg_junk_at_end
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__decode_jpeg_image DD imagerel stbi__decode_jpeg_image
	DD	imagerel stbi__decode_jpeg_image+559
	DD	imagerel $unwind$stbi__decode_jpeg_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$resample_row_1 DD imagerel resample_row_1
	DD	imagerel resample_row_1+63
	DD	imagerel $unwind$resample_row_1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__resample_row_v_2 DD imagerel stbi__resample_row_v_2
	DD	imagerel stbi__resample_row_v_2+147
	DD	imagerel $unwind$stbi__resample_row_v_2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__resample_row_h_2 DD imagerel stbi__resample_row_h_2
	DD	imagerel stbi__resample_row_h_2+521
	DD	imagerel $unwind$stbi__resample_row_h_2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__resample_row_hv_2 DD imagerel stbi__resample_row_hv_2
	DD	imagerel stbi__resample_row_hv_2+443
	DD	imagerel $unwind$stbi__resample_row_hv_2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__resample_row_hv_2_simd DD imagerel stbi__resample_row_hv_2_simd
	DD	imagerel stbi__resample_row_hv_2_simd+1192
	DD	imagerel $unwind$stbi__resample_row_hv_2_simd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__resample_row_generic DD imagerel stbi__resample_row_generic
	DD	imagerel stbi__resample_row_generic+165
	DD	imagerel $unwind$stbi__resample_row_generic
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__YCbCr_to_RGB_row DD imagerel stbi__YCbCr_to_RGB_row
	DD	imagerel stbi__YCbCr_to_RGB_row+509
	DD	imagerel $unwind$stbi__YCbCr_to_RGB_row
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__YCbCr_to_RGB_simd DD imagerel stbi__YCbCr_to_RGB_simd
	DD	imagerel stbi__YCbCr_to_RGB_simd+1390
	DD	imagerel $unwind$stbi__YCbCr_to_RGB_simd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__setup_jpeg DD imagerel stbi__setup_jpeg
	DD	imagerel stbi__setup_jpeg+176
	DD	imagerel $unwind$stbi__setup_jpeg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__cleanup_jpeg DD imagerel stbi__cleanup_jpeg
	DD	imagerel stbi__cleanup_jpeg+69
	DD	imagerel $unwind$stbi__cleanup_jpeg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__blinn_8x8 DD imagerel stbi__blinn_8x8
	DD	imagerel stbi__blinn_8x8+85
	DD	imagerel $unwind$stbi__blinn_8x8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_jpeg_image DD imagerel load_jpeg_image
	DD	imagerel load_jpeg_image+4816
	DD	imagerel $unwind$load_jpeg_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__jpeg_info_raw DD imagerel stbi__jpeg_info_raw
	DD	imagerel stbi__jpeg_info_raw+230
	DD	imagerel $unwind$stbi__jpeg_info_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bitreverse16 DD imagerel stbi__bitreverse16
	DD	imagerel stbi__bitreverse16+192
	DD	imagerel $unwind$stbi__bitreverse16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bit_reverse DD imagerel stbi__bit_reverse
	DD	imagerel stbi__bit_reverse+105
	DD	imagerel $unwind$stbi__bit_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zbuild_huffman DD imagerel stbi__zbuild_huffman
	DD	imagerel stbi__zbuild_huffman+960
	DD	imagerel $unwind$stbi__zbuild_huffman
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zeof DD imagerel stbi__zeof
	DD	imagerel stbi__zeof+92
	DD	imagerel $unwind$stbi__zeof
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zget8 DD imagerel stbi__zget8
	DD	imagerel stbi__zget8+118
	DD	imagerel $unwind$stbi__zget8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__fill_bits DD imagerel stbi__fill_bits
	DD	imagerel stbi__fill_bits+199
	DD	imagerel $unwind$stbi__fill_bits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zreceive DD imagerel stbi__zreceive
	DD	imagerel stbi__zreceive+198
	DD	imagerel $unwind$stbi__zreceive
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zhuffman_decode_slowpath DD imagerel stbi__zhuffman_decode_slowpath
	DD	imagerel stbi__zhuffman_decode_slowpath+323
	DD	imagerel $unwind$stbi__zhuffman_decode_slowpath
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zhuffman_decode DD imagerel stbi__zhuffman_decode
	DD	imagerel stbi__zhuffman_decode+239
	DD	imagerel $unwind$stbi__zhuffman_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__zexpand DD imagerel stbi__zexpand
	DD	imagerel stbi__zexpand+360
	DD	imagerel $unwind$stbi__zexpand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_huffman_block DD imagerel stbi__parse_huffman_block
	DD	imagerel stbi__parse_huffman_block+760
	DD	imagerel $unwind$stbi__parse_huffman_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__compute_huffman_codes DD imagerel stbi__compute_huffman_codes
	DD	imagerel stbi__compute_huffman_codes+946
	DD	imagerel $unwind$stbi__compute_huffman_codes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_uncompressed_block DD imagerel stbi__parse_uncompressed_block
	DD	imagerel stbi__parse_uncompressed_block+600
	DD	imagerel $unwind$stbi__parse_uncompressed_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_zlib_header DD imagerel stbi__parse_zlib_header
	DD	imagerel stbi__parse_zlib_header+203
	DD	imagerel $unwind$stbi__parse_zlib_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_zlib DD imagerel stbi__parse_zlib
	DD	imagerel stbi__parse_zlib+342
	DD	imagerel $unwind$stbi__parse_zlib
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__do_zlib DD imagerel stbi__do_zlib
	DD	imagerel stbi__do_zlib+157
	DD	imagerel $unwind$stbi__do_zlib
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__get_chunk_header DD imagerel stbi__get_chunk_header
	DD	imagerel stbi__get_chunk_header+122
	DD	imagerel $unwind$stbi__get_chunk_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__check_png_header DD imagerel stbi__check_png_header
	DD	imagerel stbi__check_png_header+119
	DD	imagerel $unwind$stbi__check_png_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__paeth DD imagerel stbi__paeth
	DD	imagerel stbi__paeth+189
	DD	imagerel $unwind$stbi__paeth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__create_png_image_raw DD imagerel stbi__create_png_image_raw
	DD	imagerel stbi__create_png_image_raw+7144
	DD	imagerel $unwind$stbi__create_png_image_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__create_png_image DD imagerel stbi__create_png_image
	DD	imagerel stbi__create_png_image+1304
	DD	imagerel $unwind$stbi__create_png_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__compute_transparency DD imagerel stbi__compute_transparency
	DD	imagerel stbi__compute_transparency+477
	DD	imagerel $unwind$stbi__compute_transparency
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__compute_transparency16 DD imagerel stbi__compute_transparency16
	DD	imagerel stbi__compute_transparency16+480
	DD	imagerel $unwind$stbi__compute_transparency16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__expand_png_palette DD imagerel stbi__expand_png_palette
	DD	imagerel stbi__expand_png_palette+612
	DD	imagerel $unwind$stbi__expand_png_palette
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__de_iphone DD imagerel stbi__de_iphone
	DD	imagerel stbi__de_iphone+822
	DD	imagerel $unwind$stbi__de_iphone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__parse_png_file DD imagerel stbi__parse_png_file
	DD	imagerel stbi__parse_png_file+3790
	DD	imagerel $unwind$stbi__parse_png_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__do_png DD imagerel stbi__do_png
	DD	imagerel stbi__do_png+689
	DD	imagerel $unwind$stbi__do_png
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__png_info_raw DD imagerel stbi__png_info_raw
	DD	imagerel stbi__png_info_raw+199
	DD	imagerel $unwind$stbi__png_info_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_test_raw DD imagerel stbi__bmp_test_raw
	DD	imagerel stbi__bmp_test_raw+219
	DD	imagerel $unwind$stbi__bmp_test_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__high_bit DD imagerel stbi__high_bit
	DD	imagerel stbi__high_bit+224
	DD	imagerel $unwind$stbi__high_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bitcount DD imagerel stbi__bitcount
	DD	imagerel stbi__bitcount+198
	DD	imagerel $unwind$stbi__bitcount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__shiftsigned DD imagerel stbi__shiftsigned
	DD	imagerel stbi__shiftsigned+267
	DD	imagerel $unwind$stbi__shiftsigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_set_mask_defaults DD imagerel stbi__bmp_set_mask_defaults
	DD	imagerel stbi__bmp_set_mask_defaults+285
	DD	imagerel $unwind$stbi__bmp_set_mask_defaults
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__bmp_parse_header DD imagerel stbi__bmp_parse_header
	DD	imagerel stbi__bmp_parse_header+1573
	DD	imagerel $unwind$stbi__bmp_parse_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__tga_get_comp DD imagerel stbi__tga_get_comp
	DD	imagerel stbi__tga_get_comp+203
	DD	imagerel $unwind$stbi__tga_get_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__tga_read_rgb16 DD imagerel stbi__tga_read_rgb16
	DD	imagerel stbi__tga_read_rgb16+224
	DD	imagerel $unwind$stbi__tga_read_rgb16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__psd_decode_rle DD imagerel stbi__psd_decode_rle
	DD	imagerel stbi__psd_decode_rle+335
	DD	imagerel $unwind$stbi__psd_decode_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_is4 DD imagerel stbi__pic_is4
	DD	imagerel stbi__pic_is4+114
	DD	imagerel $unwind$stbi__pic_is4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_test_core DD imagerel stbi__pic_test_core
	DD	imagerel stbi__pic_test_core+137
	DD	imagerel $unwind$stbi__pic_test_core
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__readval DD imagerel stbi__readval
	DD	imagerel stbi__readval+208
	DD	imagerel $unwind$stbi__readval
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__copyval DD imagerel stbi__copyval
	DD	imagerel stbi__copyval+137
	DD	imagerel $unwind$stbi__copyval
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pic_load_core DD imagerel stbi__pic_load_core
	DD	imagerel stbi__pic_load_core+1802
	DD	imagerel $unwind$stbi__pic_load_core
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_test_raw DD imagerel stbi__gif_test_raw
	DD	imagerel stbi__gif_test_raw+188
	DD	imagerel $unwind$stbi__gif_test_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_parse_colortable DD imagerel stbi__gif_parse_colortable
	DD	imagerel stbi__gif_parse_colortable+277
	DD	imagerel $unwind$stbi__gif_parse_colortable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_header DD imagerel stbi__gif_header
	DD	imagerel stbi__gif_header+607
	DD	imagerel $unwind$stbi__gif_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_info_raw DD imagerel stbi__gif_info_raw
	DD	imagerel stbi__gif_info_raw+216
	DD	imagerel $unwind$stbi__gif_info_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__out_gif_code DD imagerel stbi__out_gif_code
	DD	imagerel stbi__out_gif_code+751
	DD	imagerel $unwind$stbi__out_gif_code
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__process_gif_raster DD imagerel stbi__process_gif_raster
	DD	imagerel stbi__process_gif_raster+1260
	DD	imagerel $unwind$stbi__process_gif_raster
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__gif_load_next DD imagerel stbi__gif_load_next
	DD	imagerel stbi__gif_load_next+2511
	DD	imagerel $unwind$stbi__gif_load_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__load_gif_main_outofmem DD imagerel stbi__load_gif_main_outofmem
	DD	imagerel stbi__load_gif_main_outofmem+211
	DD	imagerel $unwind$stbi__load_gif_main_outofmem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_test_core DD imagerel stbi__hdr_test_core
	DD	imagerel stbi__hdr_test_core+139
	DD	imagerel $unwind$stbi__hdr_test_core
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_gettoken DD imagerel stbi__hdr_gettoken
	DD	imagerel stbi__hdr_gettoken+211
	DD	imagerel $unwind$stbi__hdr_gettoken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__hdr_convert DD imagerel stbi__hdr_convert
	DD	imagerel stbi__hdr_convert+689
	DD	imagerel $unwind$stbi__hdr_convert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_isspace DD imagerel stbi__pnm_isspace
	DD	imagerel stbi__pnm_isspace+140
	DD	imagerel $unwind$stbi__pnm_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_skip_whitespace DD imagerel stbi__pnm_skip_whitespace
	DD	imagerel stbi__pnm_skip_whitespace+211
	DD	imagerel $unwind$stbi__pnm_skip_whitespace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_isdigit DD imagerel stbi__pnm_isdigit
	DD	imagerel stbi__pnm_isdigit+92
	DD	imagerel $unwind$stbi__pnm_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__pnm_getinteger DD imagerel stbi__pnm_getinteger
	DD	imagerel stbi__pnm_getinteger+182
	DD	imagerel $unwind$stbi__pnm_getinteger
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__info_main DD imagerel stbi__info_main
	DD	imagerel stbi__info_main+482
	DD	imagerel $unwind$stbi__info_main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi__is_16_main DD imagerel stbi__is_16_main
	DD	imagerel stbi__is_16_main+112
	DD	imagerel $unwind$stbi__is_16_main
pdata	ENDS
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
CONST	SEGMENT
??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@ DB 'max value > 65535', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
CONST	SEGMENT
??_C@_0BH@OBINMOBC@integer?5parse?5overflow@ DB 'integer parse overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDKIDMGJ@bad?5PNM@
CONST	SEGMENT
??_C@_07IDKIDMGJ@bad?5PNM@ DB 'bad PNM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
CONST	SEGMENT
??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ DB 'invalid decode'
	DB	'd scanline length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOKDFDHG@?$CLX?5@
CONST	SEGMENT
??_C@_03FOKDFDHG@?$CLX?5@ DB '+X ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
CONST	SEGMENT
??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@ DB 'unsupported data layout'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKAKGGJN@?9Y?5@
CONST	SEGMENT
??_C@_03HKAKGGJN@?9Y?5@ DB '-Y ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKJFFLKL@unsupported?5format@
CONST	SEGMENT
??_C@_0BD@NKJFFLKL@unsupported?5format@ DB 'unsupported format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
CONST	SEGMENT
??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@ DB 'FORMAT=32-bit_rle_rgbe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCIOKENI@not?5HDR@
CONST	SEGMENT
??_C@_07NCIOKENI@not?5HDR@ DB 'not HDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
CONST	SEGMENT
??_C@_06NDOKKIDJ@?$CD?$DPRGBE@ DB '#?RGBE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
CONST	SEGMENT
??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@ DB '#?RADIANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
CONST	SEGMENT
??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@ DB '#?RGBE', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
CONST	SEGMENT
??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@ DB '#?RADIANCE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJABBOOH@unknown?5code@
CONST	SEGMENT
??_C@_0N@DJABBOOH@unknown?5code@ DB 'unknown code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAMJKDNF@missing?5color?5table@
CONST	SEGMENT
??_C@_0BE@NAMJKDNF@missing?5color?5table@ DB 'missing color table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
CONST	SEGMENT
??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@ DB 'bad Image Descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
CONST	SEGMENT
??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@ DB 'illegal code in raster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJNJCPDJ@too?5many?5codes@
CONST	SEGMENT
??_C@_0P@GJNJCPDJ@too?5many?5codes@ DB 'too many codes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGDACKOJ@no?5clear?5code@
CONST	SEGMENT
??_C@_0O@MGDACKOJ@no?5clear?5code@ DB 'no clear code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJLPAII@not?5GIF@
CONST	SEGMENT
??_C@_07KMJLPAII@not?5GIF@ DB 'not GIF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGMBIFE@bad?5file@
CONST	SEGMENT
??_C@_08GGMBIFE@bad?5file@ DB 'bad file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELNJHLFH@PICT@
CONST	SEGMENT
??_C@_04ELNJHLFH@PICT@ DB 'PICT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEPHFH@S?$IA?v4@
CONST	SEGMENT
??_C@_04KBFEPHFH@S?$IA?v4@ DB 'S', 080H, 0f6H, '4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPPMCAKL@corrupt@
CONST	SEGMENT
??_C@_07DPPMCAKL@corrupt@ DB 'corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOGGBMNK@wrong?5color?5format@
CONST	SEGMENT
??_C@_0BD@IOGGBMNK@wrong?5color?5format@ DB 'wrong color format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
CONST	SEGMENT
??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@ DB 'unsupported bit depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
CONST	SEGMENT
??_C@_0BE@PJBNGDBE@wrong?5channel?5count@ DB 'wrong channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHBCDKKC@wrong?5version@
CONST	SEGMENT
??_C@_0O@CHBCDKKC@wrong?5version@ DB 'wrong version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECNCNLIK@not?5PSD@
CONST	SEGMENT
??_C@_07ECNCNLIK@not?5PSD@ DB 'not PSD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
CONST	SEGMENT
??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ DB 't'
	DB	00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T'
	DB	00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette@ DB 'bad palette', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp@ DB 'bad bpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDPIFELH@bad?5offset@
CONST	SEGMENT
??_C@_0L@JDPIFELH@bad?5offset@ DB 'bad offset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJHPAMCH@bad?5header@
CONST	SEGMENT
??_C@_0L@PJHPAMCH@bad?5header@ DB 'bad header', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@
CONST	SEGMENT
??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@ DB 'BMP JPEG/PNG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE@ DB 'BMP RLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP@ DB 'unknown BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP@ DB 'bad BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP@ DB 'not BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
CONST	SEGMENT
??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '8', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@
CONST	SEGMENT
??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@ DB 'v', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, '2', 00H, '5', 00H, '6', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
CONST	SEGMENT
??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@ DB 'bad bits_per_channel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT@ DB 'no IDAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata@ DB 'outofdata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLHGLONG@IDAT?5size?5limit@
CONST	SEGMENT
??_C@_0BA@PLHGLONG@IDAT?5size?5limit@ DB 'IDAT size limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE@ DB 'no PLTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE@ DB 'invalid PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@ DB '1/2/4/8/16-bit only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
CONST	SEGMENT
??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
CONST	SEGMENT
??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKGNGALN@invalid?5width@
CONST	SEGMENT
??_C@_0O@MKGNGALN@invalid?5width@ DB 'invalid width', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
CONST	SEGMENT
??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '+'
	DB	00H, ' ', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig@ DB 'bad png sig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt@ DB 'zlib corrupt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist@ DB 'bad dist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
CONST	SEGMENT
??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '6', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp@ DB 'bad req_comp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len@ DB 'bad DNL len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width@ DB '0 width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit@ DB 'only 8-bit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len@ DB 'bad SOF len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS@ DB 'bad SOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff@ DB 'bad AC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff@ DB 'bad DC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len@ DB 'bad SOS len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@ DB 'bad SOS component coun'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len@ DB 'bad APP len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len@ DB 'bad COM len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len@ DB 'bad DRI len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@ DB 'can''t merge dc and ac'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFDKCGFO@bad?5delta@
CONST	SEGMENT
??_C@_09IFDKCGFO@bad?5delta@ DB 'bad delta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
CONST	SEGMENT
??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ DB '('
	DB	00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H
	DB	'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ']'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'h', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '['
	DB	00H, 'c', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEFOLMLB@bad?5size?5list@
CONST	SEGMENT
??_C@_0O@DEFOLMLB@bad?5size?5list@ DB 'bad size list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHDBFHD@unsupported@
CONST	SEGMENT
??_C@_0M@MHDBFHD@unsupported@ DB 'unsupported', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ DB 'r'
	DB	00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DDANHPKI@can?8t?5fopen?0?5Unable?5to?5open?5fil@
CONST	SEGMENT
??_C@_0CB@DDANHPKI@can?8t?5fopen?0?5Unable?5to?5open?5fil@ DB 'can''t fop'
	DB	'en, Unable to open file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen@ DB 'can''t fopen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
CONST	SEGMENT
??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '8', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'r', 00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, '6'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
CONST	SEGMENT
??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'N', 00H, 'i', 00H, 't', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'u'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'y', 00H, '\', 00H, 014H, 'x'
	DB	'vzy', 098H, 0eeH, 'v\', 00H, '1', 00H, '-', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, 'h', 00H, 'i', 00H, 'p', 00H
	DB	'\', 00H, 'T', 00H, 'H', 00H, '2', 00H, '0', 00H, '2', 00H, '0'
	DB	00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '\'
	DB	00H, 090H, 'n', 0e3H, 'N', 01H, 'x\', 00H, 'S', 00H, 't', 00H, 'g'
	DB	00H, 'S', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'p', 00H, 'C', 00H
	DB	'\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i', 00H, 'm'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem@ DB 'outofmem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type@ DB 'unknown image type', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
stbi__stdio_callbacks DQ FLAT:stbi__stdio_read
	DQ	FLAT:stbi__stdio_skip
	DQ	FLAT:stbi__stdio_eof
stbi__l2h_gamma DD 0400ccccdr			; 2.2
stbi__l2h_scale DD 03f800000r			; 1
stbi__h2l_gamma_i DD 03ee8ba2er			; 0.454545
stbi__h2l_scale_i DD 03f800000r			; 1
first_row_filter DB 00H
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
?invalid_chunk@?BP@??stbi__parse_png_file@@9@9 DB 'XXXX PNG chunk not kno'
	DB	'wn', 00H					; `stbi__parse_png_file'::`31'::invalid_chunk
	ORG $+7
?mul_table@?1??stbi__shiftsigned@@9@9 DD 00H		; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
	ORG $+4
?shift_table@?1??stbi__shiftsigned@@9@9 DD 00H		; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__is_16_main DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__info_main DD 025052201H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_getinteger DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_isdigit DD 025051201H
	DD	010d2312H
	DD	07006001fH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_skip_whitespace DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_isspace DD 025051201H
	DD	010d2312H
	DD	07006001fH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_convert DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_gettoken DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_test_core DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__load_gif_main_outofmem DD 025051d01H
	DD	0118231dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_load_next DD 025052201H
	DD	011d2322H
	DD	07016004dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__process_gif_raster DD 025051801H
	DD	01132318H
	DD	0700c0051H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__out_gif_code DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_info_raw DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_header DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_parse_colortable DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_test_raw DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	06f1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_load_core DD 025054b19H
	DD	011c2321H
	DD	070150083H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0400H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__pic_load_core$rtcName$0 DB 070H
	DB	061H
	DB	063H
	DB	06bH
	DB	065H
	DB	074H
	DB	073H
	DB	00H
stbi__pic_load_core$rtcName$1 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+2
stbi__pic_load_core$rtcName$2 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+10
stbi__pic_load_core$rtcVarDesc DD 0264H
	DD	04H
	DQ	FLAT:stbi__pic_load_core$rtcName$2
	DD	01e4H
	DD	04H
	DQ	FLAT:stbi__pic_load_core$rtcName$1
	DD	0a8H
	DD	01eH
	DQ	FLAT:stbi__pic_load_core$rtcName$0
	ORG $+144
stbi__pic_load_core$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__pic_load_core$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__copyval DD 025051c01H
	DD	0117231cH
	DD	070100025H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__readval DD 025051c01H
	DD	0117231cH
	DD	070100025H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_test_core DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_is4 DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__psd_decode_rle DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__tga_read_rgb16 DD 025051801H
	DD	01132318H
	DD	0700c0031H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__tga_get_comp DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_parse_header DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_set_mask_defaults DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__shiftsigned DD 025051b01H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bitcount DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__high_bit DD 025051201H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_test_raw DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__png_info_raw DD 025052201H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__do_png DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	0eb5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_png_file DD 045054619H
	DD	0117431cH
	DD	070100143H
	DD	0500fH
	DD	imagerel __GSHandlerCheck
	DD	0a00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__parse_png_file$rtcName$0 DB 070H
	DB	061H
	DB	06cH
	DB	065H
	DB	074H
	DB	074H
	DB	065H
	DB	00H
stbi__parse_png_file$rtcName$1 DB 074H
	DB	063H
	DB	00H
	ORG $+1
stbi__parse_png_file$rtcName$2 DB 074H
	DB	063H
	DB	031H
	DB	036H
	DB	00H
	ORG $+3
stbi__parse_png_file$rtcName$3 DB 063H
	DB	00H
	ORG $+2
stbi__parse_png_file$rtcName$4 DB 072H
	DB	061H
	DB	077H
	DB	05fH
	DB	06cH
	DB	065H
	DB	06eH
	DB	00H
stbi__parse_png_file$rtcVarDesc DD 06c4H
	DD	04H
	DQ	FLAT:stbi__parse_png_file$rtcName$4
	DD	0628H
	DD	08H
	DQ	FLAT:stbi__parse_png_file$rtcName$3
	DD	04c4H
	DD	06H
	DQ	FLAT:stbi__parse_png_file$rtcName$2
	DD	04a4H
	DD	03H
	DQ	FLAT:stbi__parse_png_file$rtcName$1
	DD	050H
	DD	0400H
	DQ	FLAT:stbi__parse_png_file$rtcName$0
	ORG $+240
stbi__parse_png_file$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:stbi__parse_png_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__de_iphone DD 025051301H
	DD	010e2313H
	DD	070070041H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__expand_png_palette DD 025052201H
	DD	011d2322H
	DD	070160039H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__compute_transparency16 DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__compute_transparency DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__create_png_image DD 045053b01H
	DD	011d4322H
	DD	070160085H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__create_png_image$rtcName$0 DB 078H
	DB	06fH
	DB	072H
	DB	069H
	DB	067H
	DB	00H
	ORG $+2
stbi__create_png_image$rtcName$1 DB 079H
	DB	06fH
	DB	072H
	DB	069H
	DB	067H
	DB	00H
	ORG $+2
stbi__create_png_image$rtcName$2 DB 078H
	DB	073H
	DB	070H
	DB	063H
	DB	00H
	ORG $+3
stbi__create_png_image$rtcName$3 DB 079H
	DB	073H
	DB	070H
	DB	063H
	DB	00H
	ORG $+3
stbi__create_png_image$rtcVarDesc DD 0188H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$3
	DD	0148H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$2
	DD	0108H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$1
	DD	0c8H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$0
	ORG $+192
stbi__create_png_image$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:stbi__create_png_image$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__create_png_image_raw DD 025052201H
	DD	011d2322H
	DD	07016008dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__paeth DD 025051b01H
	DD	0116231bH
	DD	0700f002dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__check_png_header DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get_chunk_header DD 025052c01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__get_chunk_header$rtcName$0 DB 063H
	DB	00H
	ORG $+14
stbi__get_chunk_header$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:stbi__get_chunk_header$rtcName$0
	ORG $+48
stbi__get_chunk_header$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__get_chunk_header$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__do_zlib DD 025052201H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_zlib DD 025051701H
	DD	01122317H
	DD	0700b0025H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_zlib_header DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_uncompressed_block DD 025052c01H
	DD	010e2313H
	DD	07007002dH
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__parse_uncompressed_block$rtcName$0 DB 068H
	DB	065H
	DB	061H
	DB	064H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
stbi__parse_uncompressed_block$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:stbi__parse_uncompressed_block$rtcName$0
	ORG $+48
stbi__parse_uncompressed_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__parse_uncompressed_block$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03cH
	DW	0399H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__compute_huffman_codes DD 025054319H
	DD	01142319H
	DD	070070201H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0ff0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__compute_huffman_codes$rtcName$0 DB 07aH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	06cH
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	00H
	ORG $+3
stbi__compute_huffman_codes$rtcName$1 DB 06cH
	DB	065H
	DB	06eH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	073H
	DB	00H
	ORG $+7
stbi__compute_huffman_codes$rtcName$2 DB 063H
	DB	06fH
	DB	064H
	DB	065H
	DB	06cH
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+15
stbi__compute_huffman_codes$rtcVarDesc DD 0a28H
	DD	013H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$2
	DD	0840H
	DD	01c7H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$1
	DD	030H
	DD	07e4H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$0
	ORG $+144
stbi__compute_huffman_codes$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__compute_huffman_codes$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_huffman_block DD 025051301H
	DD	010e2313H
	DD	070070035H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zexpand DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zhuffman_decode DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zhuffman_decode_slowpath DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zreceive DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__fill_bits DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zget8 DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zeof DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	03a7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__zbuild_huffman DD 025054719H
	DD	0118231dH
	DD	070110053H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0288H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__zbuild_huffman$rtcName$0 DB 06eH
	DB	065H
	DB	078H
	DB	074H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+2
stbi__zbuild_huffman$rtcName$1 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+14
stbi__zbuild_huffman$rtcVarDesc DD 0f0H
	DD	044H
	DQ	FLAT:stbi__zbuild_huffman$rtcName$1
	DD	090H
	DD	040H
	DQ	FLAT:stbi__zbuild_huffman$rtcName$0
	ORG $+96
stbi__zbuild_huffman$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__zbuild_huffman$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bit_reverse DD 025051601H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bitreverse16 DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_info_raw DD 025052201H
	DD	011d2322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	012b7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_jpeg_image DD 035054c19H
	DD	011d3322H
	DD	0701600a9H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0538H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
load_jpeg_image$rtcName$0 DB 063H
	DB	06fH
	DB	075H
	DB	074H
	DB	070H
	DB	075H
	DB	074H
	DB	00H
load_jpeg_image$rtcName$1 DB 072H
	DB	065H
	DB	073H
	DB	05fH
	DB	063H
	DB	06fH
	DB	06dH
	DB	070H
	DB	00H
	ORG $+15
load_jpeg_image$rtcVarDesc DD 0160H
	DD	0c0H
	DQ	FLAT:load_jpeg_image$rtcName$1
	DD	0118H
	DD	020H
	DQ	FLAT:load_jpeg_image$rtcName$0
	ORG $+96
load_jpeg_image$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:load_jpeg_image$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__blinn_8x8 DD 025051601H
	DD	01112316H
	DD	0700a0021H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__cleanup_jpeg DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__setup_jpeg DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__YCbCr_to_RGB_simd DD 025052201H
	DD	011d2322H
	DD	070160147H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__YCbCr_to_RGB_row DD 025052201H
	DD	011d2322H
	DD	070160039H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__resample_row_generic DD 025052201H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__resample_row_hv_2_simd DD 025052201H
	DD	011d2322H
	DD	0701600e9H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__resample_row_hv_2 DD 025052201H
	DD	011d2322H
	DD	070160029H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__resample_row_h_2 DD 025052201H
	DD	011d2322H
	DD	070160029H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__resample_row_v_2 DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resample_row_1 DD 025052201H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__decode_jpeg_image DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__skip_jpeg_junk_at_end DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__decode_jpeg_header DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__process_frame_header DD 025051701H
	DD	01122317H
	DD	0700b003dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__free_jpeg_components DD 025051c01H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__process_scan_header DD 025051301H
	DD	010e2313H
	DD	070070035H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	0755H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__process_marker DD 025054119H
	DD	01122317H
	DD	0700b0081H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	03f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__process_marker$rtcName$0 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+10
stbi__process_marker$rtcVarDesc DD 0110H
	DD	040H
	DQ	FLAT:stbi__process_marker$rtcName$0
	ORG $+48
stbi__process_marker$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__process_marker$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_finish DD 025051301H
	DD	010e2313H
	DD	070070035H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_dequantize DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0c87H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__parse_entropy_coded_data DD 045053d19H
	DD	010e4313H
	DD	0700700f5H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0798H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__parse_entropy_coded_data$rtcName$0 DB 064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
stbi__parse_entropy_coded_data$rtcName$1 DB 064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
stbi__parse_entropy_coded_data$rtcVarDesc DD 0250H
	DD	080H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcName$1
	DD	090H
	DD	080H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcName$0
	ORG $+96
stbi__parse_entropy_coded_data$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_reset DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get_marker DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__idct_simd DD 025052201H
	DD	011d2322H
	DD	0701004afH
	DD	0500fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	0c5bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__idct_block DD 025054619H
	DD	0117231cH
	DD	0701000edH
	DD	0500fH
	DD	imagerel __GSHandlerCheck
	DD	0758H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__idct_block$rtcName$0 DB 076H
	DB	061H
	DB	06cH
	DB	00H
	ORG $+12
stbi__idct_block$rtcVarDesc DD 050H
	DD	0100H
	DQ	FLAT:stbi__idct_block$rtcName$0
	ORG $+48
stbi__idct_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__idct_block$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__clamp DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_decode_block_prog_ac DD 025052201H
	DD	011d2322H
	DD	070160051H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_decode_block_prog_dc DD 025052201H
	DD	011d2322H
	DD	070160029H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_decode_block DD 025052201H
	DD	011d2322H
	DD	070160041H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_get_bit DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_get_bits DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__extend_receive DD 025051701H
	DD	01122317H
	DD	0700b0025H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_huff_decode DD 025051801H
	DD	01132318H
	DD	0700c002dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__grow_buffer_unsafe DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__build_fast_ac DD 025051801H
	DD	01132318H
	DD	0700c003dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__build_huffman DD 025051801H
	DD	01132318H
	DD	0700c0039H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__convert_format16 DD 025052101H
	DD	011c2321H
	DD	070150031H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__compute_y_16 DD 025051b01H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__convert_format DD 025052101H
	DD	011c2321H
	DD	070150031H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__compute_y DD 025051b01H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get32le DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get16le DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get32be DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get16be DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__getn DD 025051d01H
	DD	0118231dH
	DD	070110029H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__skip DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__at_eof DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__get8 DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	019eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__loadf_main DD 035054c19H
	DD	011d3322H
	DD	07016002fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0160H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__loadf_main$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__loadf_main$rtcVarDesc DD 058H
	DD	0cH
	DQ	FLAT:stbi__loadf_main$rtcName$0
	ORG $+48
stbi__loadf_main$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__loadf_main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	08cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__fopen DD 025054219H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__fopen$rtcName$0 DB 066H
	DB	00H
	ORG $+14
stbi__fopen$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:stbi__fopen$rtcName$0
	ORG $+48
stbi__fopen$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__fopen$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__float_postprocess DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	01f1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__load_and_postprocess_16bit DD 045054c19H
	DD	011d4322H
	DD	07016002fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__load_and_postprocess_16bit$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__load_and_postprocess_16bit$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:stbi__load_and_postprocess_16bit$rtcName$0
	ORG $+48
stbi__load_and_postprocess_16bit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_and_postprocess_16bit$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	01ebH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__load_and_postprocess_8bit DD 045054c19H
	DD	011d4322H
	DD	07016002fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__load_and_postprocess_8bit$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__load_and_postprocess_8bit$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:stbi__load_and_postprocess_8bit$rtcName$0
	ORG $+48
stbi__load_and_postprocess_8bit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_and_postprocess_8bit$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__vertical_flip_slices DD 025052101H
	DD	011c2321H
	DD	070150029H
	DD	05014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	01e6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__vertical_flip DD 025054b19H
	DD	011c2321H
	DD	07015019fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0ce0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__vertical_flip$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+11
stbi__vertical_flip$rtcVarDesc DD 070H
	DD	0800H
	DQ	FLAT:stbi__vertical_flip$rtcName$0
	ORG $+48
stbi__vertical_flip$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__vertical_flip$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__convert_8_to_16 DD 025052101H
	DD	011c2321H
	DD	070150029H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__convert_16_to_8 DD 025052101H
	DD	011c2321H
	DD	070150029H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__load_main DD 045052201H
	DD	011d4322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_to_ldr DD 025052101H
	DD	011c2321H
	DD	070150035H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__ldr_to_hdr DD 035052101H
	DD	011c3321H
	DD	07015002fH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__mul2shorts_valid DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__addints_valid DD 025051601H
	DD	01112316H
	DD	0700a001fH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__malloc_mad4 DD 035052001H
	DD	011b3320H
	DD	07014001fH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__malloc_mad3 DD 025052001H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__malloc_mad2 DD 025051b01H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__mad4sizes_valid DD 025052001H
	DD	011b2320H
	DD	07014001fH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__mad3sizes_valid DD 025052001H
	DD	011b2320H
	DD	07014001fH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__mad2sizes_valid DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__mul2sizes_valid DD 025051601H
	DD	01112316H
	DD	0700a001fH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__addsizes_valid DD 025051601H
	DD	01112316H
	DD	0700a001fH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__malloc DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__err DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_is16 DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	022aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_info DD 025054c19H
	DD	011d2322H
	DD	070160031H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0178H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__pnm_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+2
stbi__pnm_info$rtcName$1 DB 063H
	DB	00H
	ORG $+6
stbi__pnm_info$rtcVarDesc DD 064H
	DD	01H
	DQ	FLAT:stbi__pnm_info$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:stbi__pnm_info$rtcName$0
	ORG $+96
stbi__pnm_info$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__pnm_info$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_load DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pnm_test DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_info DD 025052201H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	04bH
	DW	044bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__load_gif_main DD 035055219H
	DD	01233328H
	DD	0701611ffH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	08fe0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__load_gif_main$rtcName$0 DB 067H
	DB	00H
	ORG $+14
stbi__load_gif_main$rtcVarDesc DD 0c0H
	DD	08870H
	DQ	FLAT:stbi__load_gif_main$rtcName$0
	ORG $+48
stbi__load_gif_main$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_gif_main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	04bH
	DW	014dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_load DD 035055219H
	DD	01233328H
	DD	0701611ddH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	08ed8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__gif_load$rtcName$0 DB 067H
	DB	00H
	ORG $+14
stbi__gif_load$rtcVarDesc DD 060H
	DD	08870H
	DQ	FLAT:stbi__gif_load$rtcName$0
	ORG $+48
stbi__gif_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__gif_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__gif_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	02a2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_info DD 025054c19H
	DD	011d2322H
	DD	070160039H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01b8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__pic_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+2
stbi__pic_info$rtcName$1 DB 070H
	DB	061H
	DB	063H
	DB	06bH
	DB	065H
	DB	074H
	DB	073H
	DB	00H
stbi__pic_info$rtcVarDesc DD 0a8H
	DD	01eH
	DQ	FLAT:stbi__pic_info$rtcName$1
	DD	084H
	DD	04H
	DQ	FLAT:stbi__pic_info$rtcName$0
	ORG $+96
stbi__pic_info$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__pic_info$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	02f9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_load DD 035054c19H
	DD	011d3322H
	DD	070160035H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0190H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__pic_load$rtcName$0 DB 069H
	DB	06eH
	DB	074H
	DB	065H
	DB	072H
	DB	06eH
	DB	061H
	DB	06cH
	DB	05fH
	DB	063H
	DB	06fH
	DB	06dH
	DB	070H
	DB	00H
	ORG $+2
stbi__pic_load$rtcVarDesc DD 0b4H
	DD	04H
	DQ	FLAT:stbi__pic_load$rtcName$0
	ORG $+48
stbi__pic_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__pic_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__pic_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0262H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_info DD 025054c19H
	DD	011d2322H
	DD	0701600ddH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	06d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__hdr_info$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
stbi__hdr_info$rtcName$1 DB 074H
	DB	06fH
	DB	06bH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+2
stbi__hdr_info$rtcName$2 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+10
stbi__hdr_info$rtcVarDesc DD 0484H
	DD	04H
	DQ	FLAT:stbi__hdr_info$rtcName$2
	DD	0448H
	DD	08H
	DQ	FLAT:stbi__hdr_info$rtcName$1
	DD	030H
	DD	0400H
	DQ	FLAT:stbi__hdr_info$rtcName$0
	ORG $+144
stbi__hdr_info$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__hdr_info$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0a37H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_load DD 035054c19H
	DD	011d3322H
	DD	070160139H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	09b0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__hdr_load$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
stbi__hdr_load$rtcName$1 DB 074H
	DB	06fH
	DB	06bH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+2
stbi__hdr_load$rtcName$2 DB 072H
	DB	067H
	DB	062H
	DB	065H
	DB	00H
	ORG $+3
stbi__hdr_load$rtcName$3 DB 072H
	DB	067H
	DB	062H
	DB	065H
	DB	00H
	ORG $+3
stbi__hdr_load$rtcVarDesc DD 0674H
	DD	04H
	DQ	FLAT:stbi__hdr_load$rtcName$3
	DD	0654H
	DD	04H
	DQ	FLAT:stbi__hdr_load$rtcName$2
	DD	0458H
	DD	08H
	DQ	FLAT:stbi__hdr_load$rtcName$1
	DD	040H
	DD	0400H
	DQ	FLAT:stbi__hdr_load$rtcName$0
	ORG $+192
stbi__hdr_load$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:stbi__hdr_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__hdr_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__psd_is16 DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	01beH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__psd_info DD 025054c19H
	DD	011d2322H
	DD	070160029H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__psd_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+10
stbi__psd_info$rtcVarDesc DD 044H
	DD	04H
	DQ	FLAT:stbi__psd_info$rtcName$0
	ORG $+48
stbi__psd_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__psd_info$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__psd_load DD 035052201H
	DD	011d3322H
	DD	070160097H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__psd_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__tga_info DD 025052201H
	DD	011d2322H
	DD	07016003dH
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0ba0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__tga_load DD 035054c19H
	DD	011d3322H
	DD	0701600d5H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0690H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__tga_load$rtcName$0 DB 074H
	DB	067H
	DB	061H
	DB	05fH
	DB	072H
	DB	067H
	DB	062H
	DB	031H
	DB	036H
	DB	00H
	ORG $+6
stbi__tga_load$rtcName$1 DB 072H
	DB	061H
	DB	077H
	DB	05fH
	DB	064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+7
stbi__tga_load$rtcVarDesc DD 0294H
	DD	04H
	DQ	FLAT:stbi__tga_load$rtcName$1
	DD	01d4H
	DD	04H
	DQ	FLAT:stbi__tga_load$rtcName$0
	ORG $+96
stbi__tga_load$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__tga_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__tga_test DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0134H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_info DD 025054c19H
	DD	011d2322H
	DD	070160029H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__bmp_info$rtcName$0 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+11
stbi__bmp_info$rtcVarDesc DD 048H
	DD	024H
	DQ	FLAT:stbi__bmp_info$rtcName$0
	ORG $+48
stbi__bmp_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__bmp_info$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0131cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_load DD 035054c19H
	DD	011d3322H
	DD	0701601a9H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0d30H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__bmp_load$rtcName$0 DB 070H
	DB	061H
	DB	06cH
	DB	00H
stbi__bmp_load$rtcName$1 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+7
stbi__bmp_load$rtcVarDesc DD 05f8H
	DD	024H
	DQ	FLAT:stbi__bmp_load$rtcName$1
	DD	0100H
	DD	0400H
	DQ	FLAT:stbi__bmp_load$rtcName$0
	ORG $+96
stbi__bmp_load$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__bmp_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__bmp_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	09bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__png_is16 DD 025053d19H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__png_is16$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_is16$rtcVarDesc DD 028H
	DD	028H
	DQ	FLAT:stbi__png_is16$rtcName$0
	ORG $+48
stbi__png_is16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_is16$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	097H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__png_info DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__png_info$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_info$rtcVarDesc DD 028H
	DD	028H
	DQ	FLAT:stbi__png_info$rtcName$0
	ORG $+48
stbi__png_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_info$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0adH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__png_load DD 035054c19H
	DD	011d3322H
	DD	070160027H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0128H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__png_load$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_load$rtcVarDesc DD 038H
	DD	028H
	DQ	FLAT:stbi__png_load$rtcName$0
	ORG $+48
stbi__png_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_load$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__png_test DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_info DD 025052201H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_load DD 035052201H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__jpeg_test DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__rewind DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__start_file DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__stdio_eof DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__stdio_skip DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__stdio_read DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__start_callbacks DD 025061e01H
	DD	0119231eH
	DD	07012001eH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__start_mem DD 025051d01H
	DD	0118231dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__refill_buffer DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__sse2_available DD 025050f01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02bH
	DB	07bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi__cpuid3 DD 025063219H
	DD	010b2310H
	DD	070040022H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0108H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi__cpuid3$rtcName$0 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+11
stbi__cpuid3$rtcVarDesc DD 028H
	DD	010H
	DQ	FLAT:stbi__cpuid3$rtcName$0
	ORG $+48
stbi__cpuid3$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__cpuid3$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	04aH
	DB	0d3H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_noheader_buffer DD 035055119H
	DD	01223327H
	DD	0701502cbH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01648H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_zlib_decode_noheader_buffer$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_noheader_buffer$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_noheader_buffer$rtcName$0
	ORG $+48
stbi_zlib_decode_noheader_buffer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_noheader_buffer$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0110H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_noheader_malloc DD 035054c19H
	DD	011d3322H
	DD	0701002cfH
	DD	0500fH
	DD	imagerel __GSHandlerCheck
	DD	01668H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_zlib_decode_noheader_malloc$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_noheader_malloc$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_noheader_malloc$rtcName$0
	ORG $+48
stbi_zlib_decode_noheader_malloc$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_noheader_malloc$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	04aH
	DB	0d3H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_buffer DD 035055119H
	DD	01223327H
	DD	0701502cbH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01648H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_zlib_decode_buffer$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_buffer$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_buffer$rtcName$0
	ORG $+48
stbi_zlib_decode_buffer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_buffer$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_malloc DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	04aH
	DW	011dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 035055119H
	DD	01223327H
	DD	0701502cfH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01668H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_zlib_decode_malloc_guesssize_headerflag$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_malloc_guesssize_headerflag$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcName$0
	ORG $+48
stbi_zlib_decode_malloc_guesssize_headerflag$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	04aH
	DW	011bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_malloc_guesssize DD 035055119H
	DD	01223327H
	DD	0701502cfH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01668H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_zlib_decode_malloc_guesssize$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_malloc_guesssize$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize$rtcName$0
	ORG $+48
stbi_zlib_decode_malloc_guesssize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_set_flip_vertically_on_load_thread DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_convert_iphone_png_to_rgb_thread DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_set_unpremultiply_on_load_thread DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_set_flip_vertically_on_load DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_convert_iphone_png_to_rgb DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_set_unpremultiply_on_load DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0a5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_16_bit_from_file DD 025053d19H
	DD	010e2313H
	DD	070070045H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_16_bit_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_file$rtcVarDesc DD 050H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_file$rtcName$0
	ORG $+48
stbi_is_16_bit_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_16_bit DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0c9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_info_from_file DD 025054c19H
	DD	011d2322H
	DD	070160045H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_info_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_file$rtcVarDesc DD 050H
	DD	0e0H
	DQ	FLAT:stbi_info_from_file$rtcName$0
	ORG $+48
stbi_info_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_info DD 025052201H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	084H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_16_bit_from_callbacks DD 025054219H
	DD	01132318H
	DD	0700c003dH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_16_bit_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_callbacks$rtcName$0
	ORG $+48
stbi_is_16_bit_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	083H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_16_bit_from_memory DD 025054119H
	DD	01122317H
	DD	0700b003dH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_16_bit_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_memory$rtcName$0
	ORG $+48
stbi_is_16_bit_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0a3H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_info_from_callbacks DD 025054c19H
	DD	011d2322H
	DD	07016003dH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_info_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_info_from_callbacks$rtcName$0
	ORG $+48
stbi_info_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	044H
	DB	0a2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_info_from_memory DD 025054b19H
	DD	011c2321H
	DD	07015003dH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_info_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_info_from_memory$rtcName$0
	ORG $+48
stbi_info_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_image_free DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_failure_reason DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	09fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_hdr_from_file DD 025053d19H
	DD	010e2313H
	DD	070070045H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_hdr_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_file$rtcVarDesc DD 070H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_file$rtcName$0
	ORG $+48
stbi_is_hdr_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_hdr DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	083H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_hdr_from_memory DD 025054119H
	DD	01122317H
	DD	0700b003dH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_hdr_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_memory$rtcName$0
	ORG $+48
stbi_is_hdr_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	084H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_is_hdr_from_callbacks DD 025054219H
	DD	01132318H
	DD	0700c003dH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_is_hdr_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_callbacks$rtcName$0
	ORG $+48
stbi_is_hdr_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_ldr_to_hdr_scale DD 025051401H
	DD	010f2314H
	DD	07008001dH
	DD	05007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_ldr_to_hdr_gamma DD 025051401H
	DD	010f2314H
	DD	07008001dH
	DD	05007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_hdr_to_ldr_scale DD 025051401H
	DD	010f2314H
	DD	07008001dH
	DD	05007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_hdr_to_ldr_gamma DD 025051401H
	DD	010f2314H
	DD	07008001dH
	DD	05007H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0a6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_loadf_from_file DD 035054c19H
	DD	011d3322H
	DD	07016003fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_loadf_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_file$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_file$rtcName$0
	ORG $+48
stbi_loadf_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_loadf DD 035052201H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0adH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_loadf_from_callbacks DD 035054c19H
	DD	011d3322H
	DD	07016003fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_loadf_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_callbacks$rtcName$0
	ORG $+48
stbi_loadf_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	044H
	DB	0acH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_loadf_from_memory DD 035054b19H
	DD	011c3321H
	DD	07015003fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_loadf_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_memory$rtcName$0
	ORG $+48
stbi_loadf_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0e0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_file_16 DD 035054c19H
	DD	011d3322H
	DD	070160043H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_from_file_16$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_file_16$rtcVarDesc DD 060H
	DD	0e0H
	DQ	FLAT:stbi_load_from_file_16$rtcName$0
	ORG $+48
stbi_load_from_file_16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_file_16$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_16 DD 035052201H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0adH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_16_from_callbacks DD 035054c19H
	DD	011d3322H
	DD	07016003fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_16_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_16_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_16_from_callbacks$rtcName$0
	ORG $+48
stbi_load_16_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_16_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	044H
	DB	0acH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_16_from_memory DD 035054b19H
	DD	011c3321H
	DD	07015003fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_16_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_16_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_16_from_memory$rtcName$0
	ORG $+48
stbi_load_16_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_16_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	0159H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_gif_from_memory DD 045054b19H
	DD	011c4321H
	DD	070150045H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_gif_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_gif_from_memory$rtcVarDesc DD 070H
	DD	0e0H
	DQ	FLAT:stbi_load_gif_from_memory$rtcName$0
	ORG $+48
stbi_load_gif_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_gif_from_memory$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0e0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_file DD 035054c19H
	DD	011d3322H
	DD	070160043H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_file$rtcVarDesc DD 060H
	DD	0e0H
	DQ	FLAT:stbi_load_from_file$rtcName$0
	ORG $+48
stbi_load_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_file$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_to_target DD 035052201H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load DD 035052201H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0adH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_callbacks DD 035054c19H
	DD	011d3322H
	DD	07016003fH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_from_callbacks$rtcName$0
	ORG $+48
stbi_load_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_callbacks$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	044H
	DB	0acH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_memory DD 035054b19H
	DD	011c3321H
	DD	07015003fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	01e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
stbi_load_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_from_memory$rtcName$0
	ORG $+48
stbi_load_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_memory$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__is_16_main
_TEXT	SEGMENT
s$ = 224
stbi__is_16_main PROC					; COMDAT

; 7244 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7245 : #ifndef STBI_NO_PNG
; 7246 :     if (stbi__png_is16(s))  return 1;

  0001f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__png_is16
  0002b	85 c0		 test	 eax, eax
  0002d	74 07		 je	 SHORT $LN2@stbi__is_1
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	eb 30		 jmp	 SHORT $LN1@stbi__is_1
$LN2@stbi__is_1:

; 7247 : #endif
; 7248 : 
; 7249 : #ifndef STBI_NO_PSD
; 7250 :     if (stbi__psd_is16(s))  return 1;

  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003d	e8 00 00 00 00	 call	 stbi__psd_is16
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN3@stbi__is_1
  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	eb 19		 jmp	 SHORT $LN1@stbi__is_1
$LN3@stbi__is_1:

; 7251 : #endif
; 7252 : 
; 7253 : #ifndef STBI_NO_PNM
; 7254 :     if (stbi__pnm_is16(s))  return 1;

  0004d	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00054	e8 00 00 00 00	 call	 stbi__pnm_is16
  00059	85 c0		 test	 eax, eax
  0005b	74 07		 je	 SHORT $LN4@stbi__is_1
  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	eb 02		 jmp	 SHORT $LN1@stbi__is_1
$LN4@stbi__is_1:

; 7255 : #endif
; 7256 :     return 0;

  00064	33 c0		 xor	 eax, eax
$LN1@stbi__is_1:

; 7257 : }

  00066	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006d	5f		 pop	 rdi
  0006e	5d		 pop	 rbp
  0006f	c3		 ret	 0
stbi__is_16_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__info_main
_TEXT	SEGMENT
s$ = 224
x$ = 232
y$ = 240
comp$ = 248
stbi__info_main PROC					; COMDAT

; 7202 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7203 : #ifndef STBI_NO_JPEG
; 7204 :     if (stbi__jpeg_info(s, x, y, comp)) return 1;

  0002e	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00035	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0003c	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00043	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004a	e8 00 00 00 00	 call	 stbi__jpeg_info
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN2@stbi__info
  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	e9 7b 01 00 00	 jmp	 $LN1@stbi__info
$LN2@stbi__info:

; 7205 : #endif
; 7206 : 
; 7207 : #ifndef STBI_NO_PNG
; 7208 :     if (stbi__png_info(s, x, y, comp))  return 1;

  0005d	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00064	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0006b	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00072	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00079	e8 00 00 00 00	 call	 stbi__png_info
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN3@stbi__info
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	e9 4c 01 00 00	 jmp	 $LN1@stbi__info
$LN3@stbi__info:

; 7209 : #endif
; 7210 : 
; 7211 : #ifndef STBI_NO_GIF
; 7212 :     if (stbi__gif_info(s, x, y, comp))  return 1;

  0008c	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00093	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0009a	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000a1	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a8	e8 00 00 00 00	 call	 stbi__gif_info
  000ad	85 c0		 test	 eax, eax
  000af	74 0a		 je	 SHORT $LN4@stbi__info
  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	e9 1d 01 00 00	 jmp	 $LN1@stbi__info
$LN4@stbi__info:

; 7213 : #endif
; 7214 : 
; 7215 : #ifndef STBI_NO_BMP
; 7216 :     if (stbi__bmp_info(s, x, y, comp))  return 1;

  000bb	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000c2	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000c9	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000d0	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d7	e8 00 00 00 00	 call	 stbi__bmp_info
  000dc	85 c0		 test	 eax, eax
  000de	74 0a		 je	 SHORT $LN5@stbi__info
  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	e9 ee 00 00 00	 jmp	 $LN1@stbi__info
$LN5@stbi__info:

; 7217 : #endif
; 7218 : 
; 7219 : #ifndef STBI_NO_PSD
; 7220 :     if (stbi__psd_info(s, x, y, comp))  return 1;

  000ea	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000f1	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000f8	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000ff	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00106	e8 00 00 00 00	 call	 stbi__psd_info
  0010b	85 c0		 test	 eax, eax
  0010d	74 0a		 je	 SHORT $LN6@stbi__info
  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	e9 bf 00 00 00	 jmp	 $LN1@stbi__info
$LN6@stbi__info:

; 7221 : #endif
; 7222 : 
; 7223 : #ifndef STBI_NO_PIC
; 7224 :     if (stbi__pic_info(s, x, y, comp))  return 1;

  00119	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00120	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00127	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0012e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00135	e8 00 00 00 00	 call	 stbi__pic_info
  0013a	85 c0		 test	 eax, eax
  0013c	74 0a		 je	 SHORT $LN7@stbi__info
  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	e9 90 00 00 00	 jmp	 $LN1@stbi__info
$LN7@stbi__info:

; 7225 : #endif
; 7226 : 
; 7227 : #ifndef STBI_NO_PNM
; 7228 :     if (stbi__pnm_info(s, x, y, comp))  return 1;

  00148	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0014f	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00156	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0015d	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00164	e8 00 00 00 00	 call	 stbi__pnm_info
  00169	85 c0		 test	 eax, eax
  0016b	74 07		 je	 SHORT $LN8@stbi__info
  0016d	b8 01 00 00 00	 mov	 eax, 1
  00172	eb 64		 jmp	 SHORT $LN1@stbi__info
$LN8@stbi__info:

; 7229 : #endif
; 7230 : 
; 7231 : #ifndef STBI_NO_HDR
; 7232 :     if (stbi__hdr_info(s, x, y, comp))  return 1;

  00174	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0017b	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00182	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00189	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00190	e8 00 00 00 00	 call	 stbi__hdr_info
  00195	85 c0		 test	 eax, eax
  00197	74 07		 je	 SHORT $LN9@stbi__info
  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	eb 38		 jmp	 SHORT $LN1@stbi__info
$LN9@stbi__info:

; 7233 : #endif
; 7234 : 
; 7235 :     // test tga last because it's a crappy test!
; 7236 : #ifndef STBI_NO_TGA
; 7237 :     if (stbi__tga_info(s, x, y, comp))

  001a0	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  001a7	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  001ae	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  001b5	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001bc	e8 00 00 00 00	 call	 stbi__tga_info
  001c1	85 c0		 test	 eax, eax
  001c3	74 07		 je	 SHORT $LN10@stbi__info

; 7238 :         return 1;

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	eb 0c		 jmp	 SHORT $LN1@stbi__info
$LN10@stbi__info:

; 7239 : #endif
; 7240 :     return stbi__err("unknown image type", "Image not of any known type, or corrupt");

  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  001d3	e8 00 00 00 00	 call	 stbi__err
$LN1@stbi__info:

; 7241 : }

  001d8	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  001df	5f		 pop	 rdi
  001e0	5d		 pop	 rbp
  001e1	c3		 ret	 0
stbi__info_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_getinteger
_TEXT	SEGMENT
value$ = 4
s$ = 256
c$ = 264
stbi__pnm_getinteger PROC				; COMDAT

; 7137 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7138 :     int value = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR value$[rbp], 0
$LN2@stbi__pnm_:

; 7139 : 
; 7140 :     while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

  0002b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00032	e8 00 00 00 00	 call	 stbi__at_eof
  00037	85 c0		 test	 eax, eax
  00039	75 6e		 jne	 SHORT $LN3@stbi__pnm_
  0003b	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  00042	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00045	e8 00 00 00 00	 call	 stbi__pnm_isdigit
  0004a	85 c0		 test	 eax, eax
  0004c	74 5b		 je	 SHORT $LN3@stbi__pnm_

; 7141 :         value = value * 10 + (*c - '0');

  0004e	6b 45 04 0a	 imul	 eax, DWORD PTR value$[rbp], 10
  00052	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR c$[rbp]
  00059	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0005c	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00060	89 45 04	 mov	 DWORD PTR value$[rbp], eax

; 7142 :         *c = (char)stbi__get8(s);

  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__get8
  0006f	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR c$[rbp]
  00076	88 01		 mov	 BYTE PTR [rcx], al

; 7143 :         if ((value > 214748364) || (value == 214748364 && *c > '7'))

  00078	81 7d 04 cc cc
	cc 0c		 cmp	 DWORD PTR value$[rbp], 214748364 ; 0cccccccH
  0007f	7f 18		 jg	 SHORT $LN5@stbi__pnm_
  00081	81 7d 04 cc cc
	cc 0c		 cmp	 DWORD PTR value$[rbp], 214748364 ; 0cccccccH
  00088	75 1d		 jne	 SHORT $LN4@stbi__pnm_
  0008a	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  00091	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00094	83 f8 37	 cmp	 eax, 55			; 00000037H
  00097	7e 0e		 jle	 SHORT $LN4@stbi__pnm_
$LN5@stbi__pnm_:

; 7144 :             return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");

  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
  000a0	e8 00 00 00 00	 call	 stbi__err
  000a5	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7145 :     }

  000a7	eb 82		 jmp	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7146 : 
; 7147 :     return value;

  000a9	8b 45 04	 mov	 eax, DWORD PTR value$[rbp]
$LN1@stbi__pnm_:

; 7148 : }

  000ac	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000b3	5f		 pop	 rdi
  000b4	5d		 pop	 rbp
  000b5	c3		 ret	 0
stbi__pnm_getinteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_isdigit
_TEXT	SEGMENT
tv68 = 192
c$ = 240
stbi__pnm_isdigit PROC					; COMDAT

; 7132 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7133 :     return c >= '0' && c <= '9';

  0001e	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00025	83 f8 30	 cmp	 eax, 48			; 00000030H
  00028	7c 18		 jl	 SHORT $LN3@stbi__pnm_
  0002a	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00031	83 f8 39	 cmp	 eax, 57			; 00000039H
  00034	7f 0c		 jg	 SHORT $LN3@stbi__pnm_
  00036	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv68[rbp], 1
  00040	eb 0a		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  00042	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv68[rbp], 0
$LN4@stbi__pnm_:
  0004c	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv68[rbp]

; 7134 : }

  00052	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
stbi__pnm_isdigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_skip_whitespace
_TEXT	SEGMENT
s$ = 224
c$ = 232
stbi__pnm_skip_whitespace PROC				; COMDAT

; 7118 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@stbi__pnm_:
$LN5@stbi__pnm_:

; 7119 :     for (;;) {
; 7120 :         while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

  00024	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002b	e8 00 00 00 00	 call	 stbi__at_eof
  00030	85 c0		 test	 eax, eax
  00032	75 2a		 jne	 SHORT $LN6@stbi__pnm_
  00034	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  0003b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003e	e8 00 00 00 00	 call	 stbi__pnm_isspace
  00043	85 c0		 test	 eax, eax
  00045	74 17		 je	 SHORT $LN6@stbi__pnm_

; 7121 :             *c = (char)stbi__get8(s);

  00047	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004e	e8 00 00 00 00	 call	 stbi__get8
  00053	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR c$[rbp]
  0005a	88 01		 mov	 BYTE PTR [rcx], al
  0005c	eb c6		 jmp	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7122 : 
; 7123 :         if (stbi__at_eof(s) || *c != '#')

  0005e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00065	e8 00 00 00 00	 call	 stbi__at_eof
  0006a	85 c0		 test	 eax, eax
  0006c	75 0f		 jne	 SHORT $LN10@stbi__pnm_
  0006e	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  00075	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00078	83 f8 23	 cmp	 eax, 35			; 00000023H
  0007b	74 02		 je	 SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 7124 :             break;

  0007d	eb 4a		 jmp	 SHORT $LN3@stbi__pnm_
$LN9@stbi__pnm_:
$LN7@stbi__pnm_:

; 7125 : 
; 7126 :         while (!stbi__at_eof(s) && *c != '\n' && *c != '\r')

  0007f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00086	e8 00 00 00 00	 call	 stbi__at_eof
  0008b	85 c0		 test	 eax, eax
  0008d	75 35		 jne	 SHORT $LN8@stbi__pnm_
  0008f	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  00096	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00099	83 f8 0a	 cmp	 eax, 10
  0009c	74 26		 je	 SHORT $LN8@stbi__pnm_
  0009e	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR c$[rbp]
  000a5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a8	83 f8 0d	 cmp	 eax, 13
  000ab	74 17		 je	 SHORT $LN8@stbi__pnm_

; 7127 :             *c = (char)stbi__get8(s);

  000ad	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b4	e8 00 00 00 00	 call	 stbi__get8
  000b9	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR c$[rbp]
  000c0	88 01		 mov	 BYTE PTR [rcx], al
  000c2	eb bb		 jmp	 SHORT $LN7@stbi__pnm_
$LN8@stbi__pnm_:

; 7128 :     }

  000c4	e9 5b ff ff ff	 jmp	 $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7129 : }

  000c9	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000d0	5f		 pop	 rdi
  000d1	5d		 pop	 rbp
  000d2	c3		 ret	 0
stbi__pnm_skip_whitespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_isspace
_TEXT	SEGMENT
tv76 = 192
c$ = 240
stbi__pnm_isspace PROC					; COMDAT

; 7113 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7114 :     return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

  0001e	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00025	83 f8 20	 cmp	 eax, 32			; 00000020H
  00028	74 48		 je	 SHORT $LN3@stbi__pnm_
  0002a	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00031	83 f8 09	 cmp	 eax, 9
  00034	74 3c		 je	 SHORT $LN3@stbi__pnm_
  00036	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  0003d	83 f8 0a	 cmp	 eax, 10
  00040	74 30		 je	 SHORT $LN3@stbi__pnm_
  00042	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00049	83 f8 0b	 cmp	 eax, 11
  0004c	74 24		 je	 SHORT $LN3@stbi__pnm_
  0004e	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00055	83 f8 0c	 cmp	 eax, 12
  00058	74 18		 je	 SHORT $LN3@stbi__pnm_
  0005a	0f be 85 f0 00
	00 00		 movsx	 eax, BYTE PTR c$[rbp]
  00061	83 f8 0d	 cmp	 eax, 13
  00064	74 0c		 je	 SHORT $LN3@stbi__pnm_
  00066	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv76[rbp], 0
  00070	eb 0a		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  00072	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv76[rbp], 1
$LN4@stbi__pnm_:
  0007c	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv76[rbp]

; 7115 : }

  00082	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00089	5f		 pop	 rdi
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
stbi__pnm_isspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_convert
_TEXT	SEGMENT
f1$1 = 4
tv152 = 212
output$ = 256
input$ = 264
req_comp$ = 272
stbi__hdr_convert PROC					; COMDAT

; 6697 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6698 :     if (input[3] != 0) {

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	48 6b c0 03	 imul	 rax, rax, 3
  00032	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 8d 01 00
	00		 je	 $LN4@stbi__hdr_

; 6699 :         float f1;
; 6700 :         // Exponent
; 6701 :         f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	48 6b c0 03	 imul	 rax, rax, 3
  0004e	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  00055	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00059	2d 88 00 00 00	 sub	 eax, 136		; 00000088H
  0005e	8b d0		 mov	 edx, eax
  00060	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0006e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00072	f3 0f 11 45 04	 movss	 DWORD PTR f1$1[rbp], xmm0

; 6702 :         if (req_comp <= 2)

  00077	83 bd 10 01 00
	00 02		 cmp	 DWORD PTR req_comp$[rbp], 2
  0007e	7f 6b		 jg	 SHORT $LN6@stbi__hdr_

; 6703 :             output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	48 6b c0 00	 imul	 rax, rax, 0
  00089	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  00090	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	48 6b c9 01	 imul	 rcx, rcx, 1
  0009d	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR input$[rbp]
  000a4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000a8	03 c1		 add	 eax, ecx
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	48 6b c9 02	 imul	 rcx, rcx, 2
  000b3	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR input$[rbp]
  000ba	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000be	03 c1		 add	 eax, ecx
  000c0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000c4	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR f1$1[rbp]
  000c9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  000d1	b8 04 00 00 00	 mov	 eax, 4
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  000e1	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  000e6	e9 96 00 00 00	 jmp	 $LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 6704 :         else {
; 6705 :             output[0] = input[0] * f1;

  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	48 6b c0 00	 imul	 rax, rax, 0
  000f4	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00103	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR f1$1[rbp]
  00108	b8 04 00 00 00	 mov	 eax, 4
  0010d	48 6b c0 00	 imul	 rax, rax, 0
  00111	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00118	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 6706 :             output[1] = input[1] * f1;

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	48 6b c0 01	 imul	 rax, rax, 1
  00126	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  0012d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00131	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00135	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR f1$1[rbp]
  0013a	b8 04 00 00 00	 mov	 eax, 4
  0013f	48 6b c0 01	 imul	 rax, rax, 1
  00143	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0014a	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 6707 :             output[2] = input[2] * f1;

  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	48 6b c0 02	 imul	 rax, rax, 2
  00158	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR input$[rbp]
  0015f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00163	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00167	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR f1$1[rbp]
  0016c	b8 04 00 00 00	 mov	 eax, 4
  00171	48 6b c0 02	 imul	 rax, rax, 2
  00175	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0017c	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN7@stbi__hdr_:

; 6708 :         }
; 6709 :         if (req_comp == 2) output[1] = 1;

  00181	83 bd 10 01 00
	00 02		 cmp	 DWORD PTR req_comp$[rbp], 2
  00188	75 1d		 jne	 SHORT $LN8@stbi__hdr_
  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	48 6b c0 01	 imul	 rax, rax, 1
  00193	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0019a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a2	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN8@stbi__hdr_:

; 6710 :         if (req_comp == 4) output[3] = 1;

  001a7	83 bd 10 01 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  001ae	75 1d		 jne	 SHORT $LN9@stbi__hdr_
  001b0	b8 04 00 00 00	 mov	 eax, 4
  001b5	48 6b c0 03	 imul	 rax, rax, 3
  001b9	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  001c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001c8	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN9@stbi__hdr_:

; 6711 :     }

  001cd	e9 d5 00 00 00	 jmp	 $LN5@stbi__hdr_
$LN4@stbi__hdr_:

; 6712 :     else {
; 6713 :         switch (req_comp) {

  001d2	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  001d8	89 85 d4 00 00
	00		 mov	 DWORD PTR tv152[rbp], eax
  001de	83 bd d4 00 00
	00 01		 cmp	 DWORD PTR tv152[rbp], 1
  001e5	0f 84 a4 00 00
	00		 je	 $LN13@stbi__hdr_
  001eb	83 bd d4 00 00
	00 02		 cmp	 DWORD PTR tv152[rbp], 2
  001f2	74 7e		 je	 SHORT $LN12@stbi__hdr_
  001f4	83 bd d4 00 00
	00 03		 cmp	 DWORD PTR tv152[rbp], 3
  001fb	74 2b		 je	 SHORT $LN11@stbi__hdr_
  001fd	83 bd d4 00 00
	00 04		 cmp	 DWORD PTR tv152[rbp], 4
  00204	74 05		 je	 SHORT $LN10@stbi__hdr_
  00206	e9 9c 00 00 00	 jmp	 $LN2@stbi__hdr_
$LN10@stbi__hdr_:

; 6714 :         case 4: output[3] = 1; /* fallthrough */

  0020b	b8 04 00 00 00	 mov	 eax, 4
  00210	48 6b c0 03	 imul	 rax, rax, 3
  00214	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0021b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00223	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN11@stbi__hdr_:

; 6715 :         case 3: output[0] = output[1] = output[2] = 0;

  00228	b8 04 00 00 00	 mov	 eax, 4
  0022d	48 6b c0 02	 imul	 rax, rax, 2
  00231	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00238	0f 57 c0	 xorps	 xmm0, xmm0
  0023b	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  00240	b8 04 00 00 00	 mov	 eax, 4
  00245	48 6b c0 01	 imul	 rax, rax, 1
  00249	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00250	0f 57 c0	 xorps	 xmm0, xmm0
  00253	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  00258	b8 04 00 00 00	 mov	 eax, 4
  0025d	48 6b c0 00	 imul	 rax, rax, 0
  00261	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00268	0f 57 c0	 xorps	 xmm0, xmm0
  0026b	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 6716 :             break;

  00270	eb 35		 jmp	 SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 6717 :         case 2: output[1] = 1; /* fallthrough */

  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	48 6b c0 01	 imul	 rax, rax, 1
  0027b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00282	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0028a	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN13@stbi__hdr_:

; 6718 :         case 1: output[0] = 0;

  0028f	b8 04 00 00 00	 mov	 eax, 4
  00294	48 6b c0 00	 imul	 rax, rax, 0
  00298	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0029f	0f 57 c0	 xorps	 xmm0, xmm0
  002a2	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN2@stbi__hdr_:
$LN5@stbi__hdr_:

; 6719 :             break;
; 6720 :         }
; 6721 :     }
; 6722 : }

  002a7	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  002ae	5f		 pop	 rdi
  002af	5d		 pop	 rbp
  002b0	c3		 ret	 0
stbi__hdr_convert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_gettoken
_TEXT	SEGMENT
len$ = 4
c$ = 36
z$ = 288
buffer$ = 296
stbi__hdr_gettoken PROC					; COMDAT

; 6675 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6676 :     int len = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR len$[rbp], 0

; 6677 :     char c = '\0';

  0002b	c6 45 24 00	 mov	 BYTE PTR c$[rbp], 0

; 6678 : 
; 6679 :     c = (char)stbi__get8(z);

  0002f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00036	e8 00 00 00 00	 call	 stbi__get8
  0003b	88 45 24	 mov	 BYTE PTR c$[rbp], al
$LN2@stbi__hdr_:

; 6680 : 
; 6681 :     while (!stbi__at_eof(z) && c != '\n') {

  0003e	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00045	e8 00 00 00 00	 call	 stbi__at_eof
  0004a	85 c0		 test	 eax, eax
  0004c	75 65		 jne	 SHORT $LN3@stbi__hdr_
  0004e	0f be 45 24	 movsx	 eax, BYTE PTR c$[rbp]
  00052	83 f8 0a	 cmp	 eax, 10
  00055	74 5c		 je	 SHORT $LN3@stbi__hdr_

; 6682 :         buffer[len++] = c;

  00057	48 63 45 04	 movsxd	 rax, DWORD PTR len$[rbp]
  0005b	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00062	0f b6 55 24	 movzx	 edx, BYTE PTR c$[rbp]
  00066	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00069	8b 45 04	 mov	 eax, DWORD PTR len$[rbp]
  0006c	ff c0		 inc	 eax
  0006e	89 45 04	 mov	 DWORD PTR len$[rbp], eax

; 6683 :         if (len == STBI__HDR_BUFLEN - 1) {

  00071	81 7d 04 ff 03
	00 00		 cmp	 DWORD PTR len$[rbp], 1023 ; 000003ffH
  00078	75 28		 jne	 SHORT $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 6684 :             // flush to end of line
; 6685 :             while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

  0007a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00081	e8 00 00 00 00	 call	 stbi__at_eof
  00086	85 c0		 test	 eax, eax
  00088	75 16		 jne	 SHORT $LN5@stbi__hdr_
  0008a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00091	e8 00 00 00 00	 call	 stbi__get8
  00096	0f b6 c0	 movzx	 eax, al
  00099	83 f8 0a	 cmp	 eax, 10
  0009c	74 02		 je	 SHORT $LN5@stbi__hdr_

; 6686 :                 ;

  0009e	eb da		 jmp	 SHORT $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 6687 :             break;

  000a0	eb 11		 jmp	 SHORT $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 6688 :         }
; 6689 :         c = (char)stbi__get8(z);

  000a2	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000a9	e8 00 00 00 00	 call	 stbi__get8
  000ae	88 45 24	 mov	 BYTE PTR c$[rbp], al

; 6690 :     }

  000b1	eb 8b		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6691 : 
; 6692 :     buffer[len] = 0;

  000b3	48 63 45 04	 movsxd	 rax, DWORD PTR len$[rbp]
  000b7	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  000be	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 6693 :     return buffer;

  000c2	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR buffer$[rbp]

; 6694 : }

  000c9	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000d0	5f		 pop	 rdi
  000d1	5d		 pop	 rbp
  000d2	c3		 ret	 0
stbi__hdr_gettoken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_test_core
_TEXT	SEGMENT
i$ = 4
s$ = 256
signature$ = 264
stbi__hdr_test_core PROC				; COMDAT

; 6653 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6654 :     int i;
; 6655 :     for (i = 0; signature[i]; ++i)

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  0002d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00030	ff c0		 inc	 eax
  00032	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__hdr_:
  00035	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00039	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR signature$[rbp]
  00040	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00044	85 c0		 test	 eax, eax
  00046	74 28		 je	 SHORT $LN3@stbi__hdr_

; 6656 :         if (stbi__get8(s) != signature[i])

  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004f	e8 00 00 00 00	 call	 stbi__get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  0005b	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR signature$[rbp]
  00062	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00066	3b c1		 cmp	 eax, ecx
  00068	74 04		 je	 SHORT $LN5@stbi__hdr_

; 6657 :             return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 13		 jmp	 SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
  0006e	eb bd		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6658 :     stbi__rewind(s);

  00070	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00077	e8 00 00 00 00	 call	 stbi__rewind

; 6659 :     return 1;

  0007c	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 6660 : }

  00081	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00088	5f		 pop	 rdi
  00089	5d		 pop	 rbp
  0008a	c3		 ret	 0
stbi__hdr_test_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__load_gif_main_outofmem
_TEXT	SEGMENT
tv78 = 192
g$ = 240
out$ = 248
delays$ = 256
stbi__load_gif_main_outofmem PROC			; COMDAT

; 6515 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6516 :     STBI_FREE(g->out);

  00029	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6517 :     STBI_FREE(g->history);

  0003a	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00041	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6518 :     STBI_FREE(g->background);

  0004b	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00052	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6519 : 
; 6520 :     if (out) STBI_FREE(out);

  0005c	48 83 bd f8 00
	00 00 00	 cmp	 QWORD PTR out$[rbp], 0
  00064	74 0d		 je	 SHORT $LN2@stbi__load
  00066	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@stbi__load:

; 6521 :     if (delays && *delays) STBI_FREE(*delays);

  00073	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR delays$[rbp], 0
  0007b	74 1d		 je	 SHORT $LN3@stbi__load
  0007d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  00084	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00088	74 10		 je	 SHORT $LN3@stbi__load
  0008a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  00091	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@stbi__load:

; 6522 :     return stbi__errpuc("outofmem", "Out of memory");

  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000a1	e8 00 00 00 00	 call	 stbi__err
  000a6	85 c0		 test	 eax, eax
  000a8	74 0d		 je	 SHORT $LN5@stbi__load
  000aa	48 c7 85 c0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv78[rbp], 0
  000b5	eb 0b		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:
  000b7	48 c7 85 c0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv78[rbp], 0
$LN6@stbi__load:
  000c2	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR tv78[rbp]

; 6523 : }

  000c9	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000d0	5f		 pop	 rdi
  000d1	5d		 pop	 rbp
  000d2	c3		 ret	 0
stbi__load_gif_main_outofmem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_load_next
_TEXT	SEGMENT
dispose$ = 4
first_frame$ = 36
pi$ = 68
pcount$ = 100
tag$1 = 132
x$2 = 164
y$3 = 196
w$4 = 228
h$5 = 260
o$6 = 296
len$7 = 324
ext$8 = 356
tv296 = 564
tv232 = 564
tv578 = 568
tv409 = 568
tv315 = 568
tv250 = 568
tv142 = 568
tv83 = 568
s$ = 608
g$ = 616
comp$ = 624
req_comp$ = 632
two_back$ = 640
stbi__gif_load_next PROC				; COMDAT

; 6333 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6334 :     int dispose;
; 6335 :     int first_frame;
; 6336 :     int pi;
; 6337 :     int pcount;
; 6338 :     STBI_NOTUSED(req_comp);
; 6339 : 
; 6340 :     // on first frame, any non-written pixels get the background colour (non-transparent)
; 6341 :     first_frame = 0;

  0002e	c7 45 24 00 00
	00 00		 mov	 DWORD PTR first_frame$[rbp], 0

; 6342 :     if (g->out == 0) {

  00035	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	0f 85 a2 01 00
	00		 jne	 $LN18@stbi__gif_

; 6343 :         if (!stbi__gif_header(s, g, comp, 0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

  00047	45 33 c9	 xor	 r9d, r9d
  0004a	4c 8b 85 70 02
	00 00		 mov	 r8, QWORD PTR comp$[rbp]
  00051	48 8b 95 68 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  00058	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__gif_header
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN20@stbi__gif_
  00068	33 c0		 xor	 eax, eax
  0006a	e9 56 09 00 00	 jmp	 $LN1@stbi__gif_
$LN20@stbi__gif_:

; 6344 :         if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

  0006f	45 33 c9	 xor	 r9d, r9d
  00072	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00079	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0007d	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00084	8b 10		 mov	 edx, DWORD PTR [rax]
  00086	b9 04 00 00 00	 mov	 ecx, 4
  0008b	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00090	85 c0		 test	 eax, eax
  00092	75 34		 jne	 SHORT $LN21@stbi__gif_

; 6345 :             return stbi__errpuc("too large", "GIF image is too large");

  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0009b	e8 00 00 00 00	 call	 stbi__err
  000a0	85 c0		 test	 eax, eax
  000a2	74 0d		 je	 SHORT $LN55@stbi__gif_
  000a4	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv83[rbp], 0
  000af	eb 0b		 jmp	 SHORT $LN56@stbi__gif_
$LN55@stbi__gif_:
  000b1	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv83[rbp], 0
$LN56@stbi__gif_:
  000bc	48 8b 85 38 02
	00 00		 mov	 rax, QWORD PTR tv83[rbp]
  000c3	e9 fd 08 00 00	 jmp	 $LN1@stbi__gif_
$LN21@stbi__gif_:

; 6346 :         pcount = g->w * g->h;

  000c8	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  000cf	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000d6	8b 00		 mov	 eax, DWORD PTR [rax]
  000d8	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  000dc	89 45 64	 mov	 DWORD PTR pcount$[rbp], eax

; 6347 :         g->out = (stbi_uc*)stbi__malloc(4 * pcount);

  000df	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  000e2	c1 e0 02	 shl	 eax, 2
  000e5	48 98		 cdqe
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 stbi__malloc
  000ef	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000f6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6348 :         g->background = (stbi_uc*)stbi__malloc(4 * pcount);

  000fa	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  000fd	c1 e0 02	 shl	 eax, 2
  00100	48 98		 cdqe
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 stbi__malloc
  0010a	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00111	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 6349 :         g->history = (stbi_uc*)stbi__malloc(pcount);

  00115	48 63 45 64	 movsxd	 rax, DWORD PTR pcount$[rbp]
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 stbi__malloc
  00121	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00128	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 6350 :         if (!g->out || !g->background || !g->history)

  0012c	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00133	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00138	74 1c		 je	 SHORT $LN23@stbi__gif_
  0013a	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00141	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00146	74 0e		 je	 SHORT $LN23@stbi__gif_
  00148	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0014f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00154	75 34		 jne	 SHORT $LN22@stbi__gif_
$LN23@stbi__gif_:

; 6351 :             return stbi__errpuc("outofmem", "Out of memory");

  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0015d	e8 00 00 00 00	 call	 stbi__err
  00162	85 c0		 test	 eax, eax
  00164	74 0d		 je	 SHORT $LN57@stbi__gif_
  00166	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv142[rbp], 0
  00171	eb 0b		 jmp	 SHORT $LN58@stbi__gif_
$LN57@stbi__gif_:
  00173	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv142[rbp], 0
$LN58@stbi__gif_:
  0017e	48 8b 85 38 02
	00 00		 mov	 rax, QWORD PTR tv142[rbp]
  00185	e9 3b 08 00 00	 jmp	 $LN1@stbi__gif_
$LN22@stbi__gif_:

; 6352 : 
; 6353 :         // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6354 :         // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6355 :         // color refers to the color that was there the previous frame.
; 6356 :         memset(g->out, 0x00, 4 * pcount);

  0018a	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  0018d	c1 e0 02	 shl	 eax, 2
  00190	48 98		 cdqe
  00192	4c 8b c0	 mov	 r8, rax
  00195	33 d2		 xor	 edx, edx
  00197	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0019e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001a2	e8 00 00 00 00	 call	 memset

; 6357 :         memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

  001a7	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  001aa	c1 e0 02	 shl	 eax, 2
  001ad	48 98		 cdqe
  001af	4c 8b c0	 mov	 r8, rax
  001b2	33 d2		 xor	 edx, edx
  001b4	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001bb	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001bf	e8 00 00 00 00	 call	 memset

; 6358 :         memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

  001c4	48 63 45 64	 movsxd	 rax, DWORD PTR pcount$[rbp]
  001c8	4c 8b c0	 mov	 r8, rax
  001cb	33 d2		 xor	 edx, edx
  001cd	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001d4	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001d8	e8 00 00 00 00	 call	 memset

; 6359 :         first_frame = 1;

  001dd	c7 45 24 01 00
	00 00		 mov	 DWORD PTR first_frame$[rbp], 1

; 6360 :     }

  001e4	e9 68 01 00 00	 jmp	 $LN19@stbi__gif_
$LN18@stbi__gif_:

; 6361 :     else {
; 6362 :         // second frame - how do we dispose of the previous one?
; 6363 :         dispose = (g->eflags & 0x1C) >> 2;

  001e9	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001f0	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001f3	83 e0 1c	 and	 eax, 28
  001f6	c1 f8 02	 sar	 eax, 2
  001f9	89 45 04	 mov	 DWORD PTR dispose$[rbp], eax

; 6364 :         pcount = g->w * g->h;

  001fc	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00203	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0020a	8b 00		 mov	 eax, DWORD PTR [rax]
  0020c	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00210	89 45 64	 mov	 DWORD PTR pcount$[rbp], eax

; 6365 : 
; 6366 :         if ((dispose == 3) && (two_back == 0)) {

  00213	83 7d 04 03	 cmp	 DWORD PTR dispose$[rbp], 3
  00217	75 11		 jne	 SHORT $LN24@stbi__gif_
  00219	48 83 bd 80 02
	00 00 00	 cmp	 QWORD PTR two_back$[rbp], 0
  00221	75 07		 jne	 SHORT $LN24@stbi__gif_

; 6367 :             dispose = 2; // if I don't have an image to revert back to, default to the old background

  00223	c7 45 04 02 00
	00 00		 mov	 DWORD PTR dispose$[rbp], 2
$LN24@stbi__gif_:

; 6368 :         }
; 6369 : 
; 6370 :         if (dispose == 3) { // use previous graphic

  0022a	83 7d 04 03	 cmp	 DWORD PTR dispose$[rbp], 3
  0022e	75 71		 jne	 SHORT $LN25@stbi__gif_

; 6371 :             for (pi = 0; pi < pcount; ++pi) {

  00230	c7 45 44 00 00
	00 00		 mov	 DWORD PTR pi$[rbp], 0
  00237	eb 08		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00239	8b 45 44	 mov	 eax, DWORD PTR pi$[rbp]
  0023c	ff c0		 inc	 eax
  0023e	89 45 44	 mov	 DWORD PTR pi$[rbp], eax
$LN4@stbi__gif_:
  00241	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  00244	39 45 44	 cmp	 DWORD PTR pi$[rbp], eax
  00247	7d 56		 jge	 SHORT $LN3@stbi__gif_

; 6372 :                 if (g->history[pi]) {

  00249	48 63 45 44	 movsxd	 rax, DWORD PTR pi$[rbp]
  0024d	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00254	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00258	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025c	85 c0		 test	 eax, eax
  0025e	74 3d		 je	 SHORT $LN27@stbi__gif_

; 6373 :                     memcpy(&g->out[pi * 4], &two_back[pi * 4], 4);

  00260	8b 45 44	 mov	 eax, DWORD PTR pi$[rbp]
  00263	c1 e0 02	 shl	 eax, 2
  00266	48 98		 cdqe
  00268	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR two_back$[rbp]
  0026f	48 03 c8	 add	 rcx, rax
  00272	48 8b c1	 mov	 rax, rcx
  00275	8b 4d 44	 mov	 ecx, DWORD PTR pi$[rbp]
  00278	c1 e1 02	 shl	 ecx, 2
  0027b	48 63 c9	 movsxd	 rcx, ecx
  0027e	48 8b 95 68 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  00285	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00289	48 03 d1	 add	 rdx, rcx
  0028c	48 8b ca	 mov	 rcx, rdx
  0028f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00295	48 8b d0	 mov	 rdx, rax
  00298	e8 00 00 00 00	 call	 memcpy
$LN27@stbi__gif_:

; 6374 :                 }
; 6375 :             }

  0029d	eb 9a		 jmp	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6376 :         }

  0029f	eb 79		 jmp	 SHORT $LN26@stbi__gif_
$LN25@stbi__gif_:

; 6377 :         else if (dispose == 2) {

  002a1	83 7d 04 02	 cmp	 DWORD PTR dispose$[rbp], 2
  002a5	75 73		 jne	 SHORT $LN28@stbi__gif_

; 6378 :             // restore what was changed last frame to background before that frame;
; 6379 :             for (pi = 0; pi < pcount; ++pi) {

  002a7	c7 45 44 00 00
	00 00		 mov	 DWORD PTR pi$[rbp], 0
  002ae	eb 08		 jmp	 SHORT $LN7@stbi__gif_
$LN5@stbi__gif_:
  002b0	8b 45 44	 mov	 eax, DWORD PTR pi$[rbp]
  002b3	ff c0		 inc	 eax
  002b5	89 45 44	 mov	 DWORD PTR pi$[rbp], eax
$LN7@stbi__gif_:
  002b8	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  002bb	39 45 44	 cmp	 DWORD PTR pi$[rbp], eax
  002be	7d 5a		 jge	 SHORT $LN6@stbi__gif_

; 6380 :                 if (g->history[pi]) {

  002c0	48 63 45 44	 movsxd	 rax, DWORD PTR pi$[rbp]
  002c4	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  002cb	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d3	85 c0		 test	 eax, eax
  002d5	74 41		 je	 SHORT $LN30@stbi__gif_

; 6381 :                     memcpy(&g->out[pi * 4], &g->background[pi * 4], 4);

  002d7	8b 45 44	 mov	 eax, DWORD PTR pi$[rbp]
  002da	c1 e0 02	 shl	 eax, 2
  002dd	48 98		 cdqe
  002df	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  002e6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	8b 4d 44	 mov	 ecx, DWORD PTR pi$[rbp]
  002f3	c1 e1 02	 shl	 ecx, 2
  002f6	48 63 c9	 movsxd	 rcx, ecx
  002f9	48 8b 95 68 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  00300	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00304	48 03 d1	 add	 rdx, rcx
  00307	48 8b ca	 mov	 rcx, rdx
  0030a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00310	48 8b d0	 mov	 rdx, rax
  00313	e8 00 00 00 00	 call	 memcpy
$LN30@stbi__gif_:

; 6382 :                 }
; 6383 :             }

  00318	eb 96		 jmp	 SHORT $LN5@stbi__gif_
$LN6@stbi__gif_:
$LN28@stbi__gif_:
$LN26@stbi__gif_:

; 6384 :         }
; 6385 :         else {
; 6386 :             // This is a non-disposal case eithe way, so just
; 6387 :             // leave the pixels as is, and they will become the new background
; 6388 :             // 1: do not dispose
; 6389 :             // 0:  not specified.
; 6390 :         }
; 6391 : 
; 6392 :         // background is what out is after the undoing of the previou frame;
; 6393 :         memcpy(g->background, g->out, 4 * g->w * g->h);

  0031a	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00321	8b 00		 mov	 eax, DWORD PTR [rax]
  00323	c1 e0 02	 shl	 eax, 2
  00326	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0032d	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00331	48 98		 cdqe
  00333	4c 8b c0	 mov	 r8, rax
  00336	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0033d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00341	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00348	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0034c	e8 00 00 00 00	 call	 memcpy
$LN19@stbi__gif_:

; 6394 :     }
; 6395 : 
; 6396 :     // clear my history;
; 6397 :     memset(g->history, 0x00, g->w * g->h);        // pixels that were affected previous frame

  00351	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00358	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0035f	8b 00		 mov	 eax, DWORD PTR [rax]
  00361	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00365	48 98		 cdqe
  00367	4c 8b c0	 mov	 r8, rax
  0036a	33 d2		 xor	 edx, edx
  0036c	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00373	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00377	e8 00 00 00 00	 call	 memset
$LN8@stbi__gif_:

; 6398 : 
; 6399 :     for (;;) {
; 6400 :         int tag = stbi__get8(s);

  0037c	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00383	e8 00 00 00 00	 call	 stbi__get8
  00388	0f b6 c0	 movzx	 eax, al
  0038b	89 85 84 00 00
	00		 mov	 DWORD PTR tag$1[rbp], eax

; 6401 :         switch (tag) {

  00391	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR tag$1[rbp]
  00397	89 85 34 02 00
	00		 mov	 DWORD PTR tv232[rbp], eax
  0039d	83 bd 34 02 00
	00 21		 cmp	 DWORD PTR tv232[rbp], 33 ; 00000021H
  003a4	0f 84 69 04 00
	00		 je	 $LN44@stbi__gif_
  003aa	83 bd 34 02 00
	00 2c		 cmp	 DWORD PTR tv232[rbp], 44 ; 0000002cH
  003b1	74 12		 je	 SHORT $LN31@stbi__gif_
  003b3	83 bd 34 02 00
	00 3b		 cmp	 DWORD PTR tv232[rbp], 59 ; 0000003bH
  003ba	0f 84 c6 05 00
	00		 je	 $LN52@stbi__gif_
  003c0	e9 ca 05 00 00	 jmp	 $LN53@stbi__gif_
$LN31@stbi__gif_:

; 6402 :         case 0x2C: /* Image Descriptor */
; 6403 :         {
; 6404 :             stbi__int32 x, y, w, h;
; 6405 :             stbi_uc* o;
; 6406 : 
; 6407 :             x = stbi__get16le(s);

  003c5	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003cc	e8 00 00 00 00	 call	 stbi__get16le
  003d1	89 85 a4 00 00
	00		 mov	 DWORD PTR x$2[rbp], eax

; 6408 :             y = stbi__get16le(s);

  003d7	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003de	e8 00 00 00 00	 call	 stbi__get16le
  003e3	89 85 c4 00 00
	00		 mov	 DWORD PTR y$3[rbp], eax

; 6409 :             w = stbi__get16le(s);

  003e9	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003f0	e8 00 00 00 00	 call	 stbi__get16le
  003f5	89 85 e4 00 00
	00		 mov	 DWORD PTR w$4[rbp], eax

; 6410 :             h = stbi__get16le(s);

  003fb	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00402	e8 00 00 00 00	 call	 stbi__get16le
  00407	89 85 04 01 00
	00		 mov	 DWORD PTR h$5[rbp], eax

; 6411 :             if (((x + w) > (g->w)) || ((y + h) > (g->h)))

  0040d	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR w$4[rbp]
  00413	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR x$2[rbp]
  00419	03 c8		 add	 ecx, eax
  0041b	8b c1		 mov	 eax, ecx
  0041d	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00424	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00426	7f 1c		 jg	 SHORT $LN33@stbi__gif_
  00428	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR h$5[rbp]
  0042e	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR y$3[rbp]
  00434	03 c8		 add	 ecx, eax
  00436	8b c1		 mov	 eax, ecx
  00438	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0043f	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00442	7e 34		 jle	 SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 6412 :                 return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
  0044b	e8 00 00 00 00	 call	 stbi__err
  00450	85 c0		 test	 eax, eax
  00452	74 0d		 je	 SHORT $LN59@stbi__gif_
  00454	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv250[rbp], 0
  0045f	eb 0b		 jmp	 SHORT $LN60@stbi__gif_
$LN59@stbi__gif_:
  00461	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv250[rbp], 0
$LN60@stbi__gif_:
  0046c	48 8b 85 38 02
	00 00		 mov	 rax, QWORD PTR tv250[rbp]
  00473	e9 4d 05 00 00	 jmp	 $LN1@stbi__gif_
$LN32@stbi__gif_:

; 6413 : 
; 6414 :             g->line_size = g->w * 4;

  00478	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0047f	8b 00		 mov	 eax, DWORD PTR [rax]
  00481	c1 e0 02	 shl	 eax, 2
  00484	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0048b	89 81 64 88 00
	00		 mov	 DWORD PTR [rcx+34916], eax

; 6415 :             g->start_x = x * 4;

  00491	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR x$2[rbp]
  00497	c1 e0 02	 shl	 eax, 2
  0049a	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  004a1	89 81 4c 88 00
	00		 mov	 DWORD PTR [rcx+34892], eax

; 6416 :             g->start_y = y * g->line_size;

  004a7	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  004ae	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR y$3[rbp]
  004b4	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  004bb	8b c1		 mov	 eax, ecx
  004bd	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  004c4	89 81 50 88 00
	00		 mov	 DWORD PTR [rcx+34896], eax

; 6417 :             g->max_x = g->start_x + w * 4;

  004ca	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  004d1	8b 80 4c 88 00
	00		 mov	 eax, DWORD PTR [rax+34892]
  004d7	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR w$4[rbp]
  004dd	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  004e0	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  004e7	89 81 54 88 00
	00		 mov	 DWORD PTR [rcx+34900], eax

; 6418 :             g->max_y = g->start_y + h * g->line_size;

  004ed	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  004f4	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR h$5[rbp]
  004fa	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  00501	8b c1		 mov	 eax, ecx
  00503	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0050a	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  00510	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00517	89 81 58 88 00
	00		 mov	 DWORD PTR [rcx+34904], eax

; 6419 :             g->cur_x = g->start_x;

  0051d	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00524	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0052b	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  00531	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6420 :             g->cur_y = g->start_y;

  00537	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0053e	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00545	8b 89 50 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34896]
  0054b	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx

; 6421 : 
; 6422 :             // if the width of the specified rectangle is 0, that means
; 6423 :             // we may not see *any* pixels or the image is malformed;
; 6424 :             // to make sure this is caught, move the current y down to
; 6425 :             // max_y (which is what out_gif_code checks).
; 6426 :             if (w == 0)

  00551	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR w$4[rbp], 0
  00558	75 1a		 jne	 SHORT $LN34@stbi__gif_

; 6427 :                 g->cur_y = g->max_y;

  0055a	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00561	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00568	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  0056e	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx
$LN34@stbi__gif_:

; 6428 : 
; 6429 :             g->lflags = stbi__get8(s);

  00574	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0057b	e8 00 00 00 00	 call	 stbi__get8
  00580	0f b6 c0	 movzx	 eax, al
  00583	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0058a	89 81 48 88 00
	00		 mov	 DWORD PTR [rcx+34888], eax

; 6430 : 
; 6431 :             if (g->lflags & 0x40) {

  00590	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00597	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  0059d	83 e0 40	 and	 eax, 64			; 00000040H
  005a0	85 c0		 test	 eax, eax
  005a2	74 30		 je	 SHORT $LN35@stbi__gif_

; 6432 :                 g->step = 8 * g->line_size; // first interlaced spacing

  005a4	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  005ab	8b 80 64 88 00
	00		 mov	 eax, DWORD PTR [rax+34916]
  005b1	c1 e0 03	 shl	 eax, 3
  005b4	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  005bb	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6433 :                 g->parse = 3;

  005c1	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  005c8	c7 80 40 88 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+34880], 3

; 6434 :             }

  005d2	eb 2b		 jmp	 SHORT $LN36@stbi__gif_
$LN35@stbi__gif_:

; 6435 :             else {
; 6436 :                 g->step = g->line_size;

  005d4	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  005db	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  005e2	8b 89 64 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34916]
  005e8	89 88 44 88 00
	00		 mov	 DWORD PTR [rax+34884], ecx

; 6437 :                 g->parse = 0;

  005ee	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  005f5	c7 80 40 88 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+34880], 0
$LN36@stbi__gif_:

; 6438 :             }
; 6439 : 
; 6440 :             if (g->lflags & 0x80) {

  005ff	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00606	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  0060c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00611	85 c0		 test	 eax, eax
  00613	0f 84 97 00 00
	00		 je	 $LN37@stbi__gif_

; 6441 :                 stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

  00619	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00620	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00623	83 e0 01	 and	 eax, 1
  00626	85 c0		 test	 eax, eax
  00628	74 12		 je	 SHORT $LN61@stbi__gif_
  0062a	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00631	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00634	89 85 34 02 00
	00		 mov	 DWORD PTR tv296[rbp], eax
  0063a	eb 0a		 jmp	 SHORT $LN62@stbi__gif_
$LN61@stbi__gif_:
  0063c	c7 85 34 02 00
	00 ff ff ff ff	 mov	 DWORD PTR tv296[rbp], -1
$LN62@stbi__gif_:
  00646	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0064d	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00653	83 e0 07	 and	 eax, 7
  00656	b9 02 00 00 00	 mov	 ecx, 2
  0065b	89 8d 38 02 00
	00		 mov	 DWORD PTR tv578[rbp], ecx
  00661	0f b6 c8	 movzx	 ecx, al
  00664	8b 85 38 02 00
	00		 mov	 eax, DWORD PTR tv578[rbp]
  0066a	d3 e0		 shl	 eax, cl
  0066c	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00673	48 81 c1 34 04
	00 00		 add	 rcx, 1076		; 00000434H
  0067a	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR tv296[rbp]
  00681	44 8b c0	 mov	 r8d, eax
  00684	48 8b d1	 mov	 rdx, rcx
  00687	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0068e	e8 00 00 00 00	 call	 stbi__gif_parse_colortable

; 6442 :                 g->color_table = (stbi_uc*)g->lpal;

  00693	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  0069a	48 05 34 04 00
	00		 add	 rax, 1076		; 00000434H
  006a0	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  006a7	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax

; 6443 :             }

  006ae	eb 62		 jmp	 SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 6444 :             else if (g->flags & 0x80) {

  006b0	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  006b7	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  006ba	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006bf	85 c0		 test	 eax, eax
  006c1	74 1b		 je	 SHORT $LN39@stbi__gif_

; 6445 :                 g->color_table = (stbi_uc*)g->pal;

  006c3	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  006ca	48 83 c0 34	 add	 rax, 52			; 00000034H
  006ce	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  006d5	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax

; 6446 :             }

  006dc	eb 34		 jmp	 SHORT $LN40@stbi__gif_
$LN39@stbi__gif_:

; 6447 :             else
; 6448 :                 return stbi__errpuc("missing color table", "Corrupt GIF");

  006de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@NAMJKDNF@missing?5color?5table@
  006e5	e8 00 00 00 00	 call	 stbi__err
  006ea	85 c0		 test	 eax, eax
  006ec	74 0d		 je	 SHORT $LN63@stbi__gif_
  006ee	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv315[rbp], 0
  006f9	eb 0b		 jmp	 SHORT $LN64@stbi__gif_
$LN63@stbi__gif_:
  006fb	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv315[rbp], 0
$LN64@stbi__gif_:
  00706	48 8b 85 38 02
	00 00		 mov	 rax, QWORD PTR tv315[rbp]
  0070d	e9 b3 02 00 00	 jmp	 $LN1@stbi__gif_
$LN40@stbi__gif_:
$LN38@stbi__gif_:

; 6449 : 
; 6450 :             o = stbi__process_gif_raster(s, g);

  00712	48 8b 95 68 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  00719	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00720	e8 00 00 00 00	 call	 stbi__process_gif_raster
  00725	48 89 85 28 01
	00 00		 mov	 QWORD PTR o$6[rbp], rax

; 6451 :             if (!o) return NULL;

  0072c	48 83 bd 28 01
	00 00 00	 cmp	 QWORD PTR o$6[rbp], 0
  00734	75 07		 jne	 SHORT $LN41@stbi__gif_
  00736	33 c0		 xor	 eax, eax
  00738	e9 88 02 00 00	 jmp	 $LN1@stbi__gif_
$LN41@stbi__gif_:

; 6452 : 
; 6453 :             // if this was the first frame,
; 6454 :             pcount = g->w * g->h;

  0073d	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00744	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0074b	8b 00		 mov	 eax, DWORD PTR [rax]
  0074d	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00751	89 45 64	 mov	 DWORD PTR pcount$[rbp], eax

; 6455 :             if (first_frame && (g->bgindex > 0)) {

  00754	83 7d 24 00	 cmp	 DWORD PTR first_frame$[rbp], 0
  00758	0f 84 a9 00 00
	00		 je	 $LN42@stbi__gif_
  0075e	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00765	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00769	0f 8e 98 00 00
	00		 jle	 $LN42@stbi__gif_

; 6456 :                 // if first frame, any pixel not drawn to gets the background color
; 6457 :                 for (pi = 0; pi < pcount; ++pi) {

  0076f	c7 45 44 00 00
	00 00		 mov	 DWORD PTR pi$[rbp], 0
  00776	eb 08		 jmp	 SHORT $LN15@stbi__gif_
$LN13@stbi__gif_:
  00778	8b 45 44	 mov	 eax, DWORD PTR pi$[rbp]
  0077b	ff c0		 inc	 eax
  0077d	89 45 44	 mov	 DWORD PTR pi$[rbp], eax
$LN15@stbi__gif_:
  00780	8b 45 64	 mov	 eax, DWORD PTR pcount$[rbp]
  00783	39 45 44	 cmp	 DWORD PTR pi$[rbp], eax
  00786	7d 7f		 jge	 SHORT $LN14@stbi__gif_

; 6458 :                     if (g->history[pi] == 0) {

  00788	48 63 45 44	 movsxd	 rax, DWORD PTR pi$[rbp]
  0078c	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00793	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00797	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0079b	85 c0		 test	 eax, eax
  0079d	75 63		 jne	 SHORT $LN43@stbi__gif_

; 6459 :                         g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;

  0079f	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  007a6	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007aa	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  007b1	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  007b6	b9 01 00 00 00	 mov	 ecx, 1
  007bb	48 6b c9 03	 imul	 rcx, rcx, 3
  007bf	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 6460 :                         memcpy(&g->out[pi * 4], &g->pal[g->bgindex], 4);

  007c3	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  007ca	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007ce	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  007d5	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  007da	8b 4d 44	 mov	 ecx, DWORD PTR pi$[rbp]
  007dd	c1 e1 02	 shl	 ecx, 2
  007e0	48 63 c9	 movsxd	 rcx, ecx
  007e3	48 8b 95 68 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  007ea	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  007ee	48 03 d1	 add	 rdx, rcx
  007f1	48 8b ca	 mov	 rcx, rdx
  007f4	41 b8 04 00 00
	00		 mov	 r8d, 4
  007fa	48 8b d0	 mov	 rdx, rax
  007fd	e8 00 00 00 00	 call	 memcpy
$LN43@stbi__gif_:

; 6461 :                     }
; 6462 :                 }

  00802	e9 71 ff ff ff	 jmp	 $LN13@stbi__gif_
$LN14@stbi__gif_:
$LN42@stbi__gif_:

; 6463 :             }
; 6464 : 
; 6465 :             return o;

  00807	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR o$6[rbp]
  0080e	e9 b2 01 00 00	 jmp	 $LN1@stbi__gif_
$LN44@stbi__gif_:

; 6466 :         }
; 6467 : 
; 6468 :         case 0x21: // Comment Extension.
; 6469 :         {
; 6470 :             int len;
; 6471 :             int ext = stbi__get8(s);

  00813	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0081a	e8 00 00 00 00	 call	 stbi__get8
  0081f	0f b6 c0	 movzx	 eax, al
  00822	89 85 64 01 00
	00		 mov	 DWORD PTR ext$8[rbp], eax

; 6472 :             if (ext == 0xF9) { // Graphic Control Extension.

  00828	81 bd 64 01 00
	00 f9 00 00 00	 cmp	 DWORD PTR ext$8[rbp], 249 ; 000000f9H
  00832	0f 85 1a 01 00
	00		 jne	 $LN45@stbi__gif_

; 6473 :                 len = stbi__get8(s);

  00838	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0083f	e8 00 00 00 00	 call	 stbi__get8
  00844	0f b6 c0	 movzx	 eax, al
  00847	89 85 44 01 00
	00		 mov	 DWORD PTR len$7[rbp], eax

; 6474 :                 if (len == 4) {

  0084d	83 bd 44 01 00
	00 04		 cmp	 DWORD PTR len$7[rbp], 4
  00854	0f 85 e4 00 00
	00		 jne	 $LN46@stbi__gif_

; 6475 :                     g->eflags = stbi__get8(s);

  0085a	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00861	e8 00 00 00 00	 call	 stbi__get8
  00866	0f b6 c0	 movzx	 eax, al
  00869	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00870	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 6476 :                     g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

  00873	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0087a	e8 00 00 00 00	 call	 stbi__get16le
  0087f	6b c0 0a	 imul	 eax, eax, 10
  00882	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00889	89 81 68 88 00
	00		 mov	 DWORD PTR [rcx+34920], eax

; 6477 : 
; 6478 :                     // unset old transparent
; 6479 :                     if (g->transparent >= 0) {

  0088f	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00896	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0089a	7c 24		 jl	 SHORT $LN48@stbi__gif_

; 6480 :                         g->pal[g->transparent][3] = 255;

  0089c	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  008a3	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  008a7	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  008ae	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  008b3	b9 01 00 00 00	 mov	 ecx, 1
  008b8	48 6b c9 03	 imul	 rcx, rcx, 3
  008bc	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH
$LN48@stbi__gif_:

; 6481 :                     }
; 6482 :                     if (g->eflags & 0x01) {

  008c0	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  008c7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  008ca	83 e0 01	 and	 eax, 1
  008cd	85 c0		 test	 eax, eax
  008cf	74 4c		 je	 SHORT $LN49@stbi__gif_

; 6483 :                         g->transparent = stbi__get8(s);

  008d1	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  008d8	e8 00 00 00 00	 call	 stbi__get8
  008dd	0f b6 c0	 movzx	 eax, al
  008e0	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  008e7	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 6484 :                         if (g->transparent >= 0) {

  008ea	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  008f1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  008f5	7c 24		 jl	 SHORT $LN51@stbi__gif_

; 6485 :                             g->pal[g->transparent][3] = 0;

  008f7	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  008fe	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00902	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00909	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  0090e	b9 01 00 00 00	 mov	 ecx, 1
  00913	48 6b c9 03	 imul	 rcx, rcx, 3
  00917	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN51@stbi__gif_:

; 6486 :                         }
; 6487 :                     }

  0091b	eb 1f		 jmp	 SHORT $LN50@stbi__gif_
$LN49@stbi__gif_:

; 6488 :                     else {
; 6489 :                         // don't need transparent
; 6490 :                         stbi__skip(s, 1);

  0091d	ba 01 00 00 00	 mov	 edx, 1
  00922	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00929	e8 00 00 00 00	 call	 stbi__skip

; 6491 :                         g->transparent = -1;

  0092e	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00935	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1
$LN50@stbi__gif_:

; 6492 :                     }
; 6493 :                 }

  0093c	eb 14		 jmp	 SHORT $LN47@stbi__gif_
$LN46@stbi__gif_:

; 6494 :                 else {
; 6495 :                     stbi__skip(s, len);

  0093e	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR len$7[rbp]
  00944	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0094b	e8 00 00 00 00	 call	 stbi__skip

; 6496 :                     break;

  00950	eb 6e		 jmp	 SHORT $LN11@stbi__gif_
$LN47@stbi__gif_:
$LN45@stbi__gif_:
$LN16@stbi__gif_:

; 6497 :                 }
; 6498 :             }
; 6499 :             while ((len = stbi__get8(s)) != 0) {

  00952	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00959	e8 00 00 00 00	 call	 stbi__get8
  0095e	0f b6 c0	 movzx	 eax, al
  00961	89 85 44 01 00
	00		 mov	 DWORD PTR len$7[rbp], eax
  00967	83 bd 44 01 00
	00 00		 cmp	 DWORD PTR len$7[rbp], 0
  0096e	74 14		 je	 SHORT $LN17@stbi__gif_

; 6500 :                 stbi__skip(s, len);

  00970	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR len$7[rbp]
  00976	48 8b 8d 60 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0097d	e8 00 00 00 00	 call	 stbi__skip

; 6501 :             }

  00982	eb ce		 jmp	 SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 6502 :             break;

  00984	eb 3a		 jmp	 SHORT $LN11@stbi__gif_
$LN52@stbi__gif_:

; 6503 :         }
; 6504 : 
; 6505 :         case 0x3B: // gif stream termination code
; 6506 :             return (stbi_uc*)s; // using '1' causes warning on some compilers

  00986	48 8b 85 60 02
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0098d	eb 36		 jmp	 SHORT $LN1@stbi__gif_
$LN53@stbi__gif_:

; 6507 : 
; 6508 :         default:
; 6509 :             return stbi__errpuc("unknown code", "Corrupt GIF");

  0098f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DJABBOOH@unknown?5code@
  00996	e8 00 00 00 00	 call	 stbi__err
  0099b	85 c0		 test	 eax, eax
  0099d	74 0d		 je	 SHORT $LN65@stbi__gif_
  0099f	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv409[rbp], 0
  009aa	eb 0b		 jmp	 SHORT $LN66@stbi__gif_
$LN65@stbi__gif_:
  009ac	48 c7 85 38 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv409[rbp], 0
$LN66@stbi__gif_:
  009b7	48 8b 85 38 02
	00 00		 mov	 rax, QWORD PTR tv409[rbp]
  009be	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN11@stbi__gif_:

; 6510 :         }
; 6511 :     }

  009c0	e9 b7 f9 ff ff	 jmp	 $LN8@stbi__gif_
$LN1@stbi__gif_:

; 6512 : }

  009c5	48 8d a5 48 02
	00 00		 lea	 rsp, QWORD PTR [rbp+584]
  009cc	5f		 pop	 rdi
  009cd	5d		 pop	 rbp
  009ce	c3		 ret	 0
stbi__gif_load_next ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__process_gif_raster
_TEXT	SEGMENT
lzw_cs$ = 4
len$ = 36
init_code$ = 68
first$ = 100
codesize$ = 132
codemask$ = 164
avail$ = 196
oldcode$ = 228
bits$ = 260
valid_bits$ = 292
clear$ = 324
p$ = 360
code$1 = 388
tv297 = 596
tv273 = 596
tv246 = 596
tv242 = 596
tv192 = 596
tv210 = 600
tv198 = 600
tv174 = 600
tv163 = 600
s$ = 640
g$ = 648
stbi__process_gif_raster PROC				; COMDAT

; 6241 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6242 :     stbi_uc lzw_cs;
; 6243 :     stbi__int32 len, init_code;
; 6244 :     stbi__uint32 first;
; 6245 :     stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6246 :     stbi__gif_lzw* p;
; 6247 : 
; 6248 :     lzw_cs = stbi__get8(s);

  00024	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002b	e8 00 00 00 00	 call	 stbi__get8
  00030	88 45 04	 mov	 BYTE PTR lzw_cs$[rbp], al

; 6249 :     if (lzw_cs > 12) return NULL;

  00033	0f b6 45 04	 movzx	 eax, BYTE PTR lzw_cs$[rbp]
  00037	83 f8 0c	 cmp	 eax, 12
  0003a	7e 07		 jle	 SHORT $LN10@stbi__proc
  0003c	33 c0		 xor	 eax, eax
  0003e	e9 9f 04 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 6250 :     clear = 1 << lzw_cs;

  00043	0f b6 45 04	 movzx	 eax, BYTE PTR lzw_cs$[rbp]
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	89 8d 54 02 00
	00		 mov	 DWORD PTR tv242[rbp], ecx
  00052	0f b6 c8	 movzx	 ecx, al
  00055	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv242[rbp]
  0005b	d3 e0		 shl	 eax, cl
  0005d	89 85 44 01 00
	00		 mov	 DWORD PTR clear$[rbp], eax

; 6251 :     first = 1;

  00063	c7 45 64 01 00
	00 00		 mov	 DWORD PTR first$[rbp], 1

; 6252 :     codesize = lzw_cs + 1;

  0006a	0f b6 45 04	 movzx	 eax, BYTE PTR lzw_cs$[rbp]
  0006e	ff c0		 inc	 eax
  00070	89 85 84 00 00
	00		 mov	 DWORD PTR codesize$[rbp], eax

; 6253 :     codemask = (1 << codesize) - 1;

  00076	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	89 8d 54 02 00
	00		 mov	 DWORD PTR tv246[rbp], ecx
  00087	0f b6 c8	 movzx	 ecx, al
  0008a	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv246[rbp]
  00090	d3 e0		 shl	 eax, cl
  00092	ff c8		 dec	 eax
  00094	89 85 a4 00 00
	00		 mov	 DWORD PTR codemask$[rbp], eax

; 6254 :     bits = 0;

  0009a	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR bits$[rbp], 0

; 6255 :     valid_bits = 0;

  000a4	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR valid_bits$[rbp], 0

; 6256 :     for (init_code = 0; init_code < clear; init_code++) {

  000ae	c7 45 44 00 00
	00 00		 mov	 DWORD PTR init_code$[rbp], 0
  000b5	eb 08		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  000b7	8b 45 44	 mov	 eax, DWORD PTR init_code$[rbp]
  000ba	ff c0		 inc	 eax
  000bc	89 45 44	 mov	 DWORD PTR init_code$[rbp], eax
$LN4@stbi__proc:
  000bf	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR clear$[rbp]
  000c5	39 45 44	 cmp	 DWORD PTR init_code$[rbp], eax
  000c8	7d 46		 jge	 SHORT $LN3@stbi__proc

; 6257 :         g->codes[init_code].prefix = -1;

  000ca	48 63 45 44	 movsxd	 rax, DWORD PTR init_code$[rbp]
  000ce	b9 ff ff ff ff	 mov	 ecx, -1
  000d3	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  000da	66 89 8c 82 34
	08 00 00	 mov	 WORD PTR [rdx+rax*4+2100], cx

; 6258 :         g->codes[init_code].first = (stbi_uc)init_code;

  000e2	48 63 45 44	 movsxd	 rax, DWORD PTR init_code$[rbp]
  000e6	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000ed	0f b6 55 44	 movzx	 edx, BYTE PTR init_code$[rbp]
  000f1	88 94 81 36 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2102], dl

; 6259 :         g->codes[init_code].suffix = (stbi_uc)init_code;

  000f8	48 63 45 44	 movsxd	 rax, DWORD PTR init_code$[rbp]
  000fc	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00103	0f b6 55 44	 movzx	 edx, BYTE PTR init_code$[rbp]
  00107	88 94 81 37 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2103], dl

; 6260 :     }

  0010e	eb a7		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 6261 : 
; 6262 :     // support no starting clear code
; 6263 :     avail = clear + 2;

  00110	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR clear$[rbp]
  00116	83 c0 02	 add	 eax, 2
  00119	89 85 c4 00 00
	00		 mov	 DWORD PTR avail$[rbp], eax

; 6264 :     oldcode = -1;

  0011f	c7 85 e4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR oldcode$[rbp], -1

; 6265 : 
; 6266 :     len = 0;

  00129	c7 45 24 00 00
	00 00		 mov	 DWORD PTR len$[rbp], 0
$LN5@stbi__proc:

; 6267 :     for (;;) {
; 6268 :         if (valid_bits < codesize) {

  00130	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  00136	39 85 24 01 00
	00		 cmp	 DWORD PTR valid_bits$[rbp], eax
  0013c	7d 71		 jge	 SHORT $LN11@stbi__proc

; 6269 :             if (len == 0) {

  0013e	83 7d 24 00	 cmp	 DWORD PTR len$[rbp], 0
  00142	75 28		 jne	 SHORT $LN13@stbi__proc

; 6270 :                 len = stbi__get8(s); // start new block

  00144	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0014b	e8 00 00 00 00	 call	 stbi__get8
  00150	0f b6 c0	 movzx	 eax, al
  00153	89 45 24	 mov	 DWORD PTR len$[rbp], eax

; 6271 :                 if (len == 0)

  00156	83 7d 24 00	 cmp	 DWORD PTR len$[rbp], 0
  0015a	75 10		 jne	 SHORT $LN14@stbi__proc

; 6272 :                     return g->out;

  0015c	48 8b 85 88 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00163	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00167	e9 76 03 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:
$LN13@stbi__proc:

; 6273 :             }
; 6274 :             --len;

  0016c	8b 45 24	 mov	 eax, DWORD PTR len$[rbp]
  0016f	ff c8		 dec	 eax
  00171	89 45 24	 mov	 DWORD PTR len$[rbp], eax

; 6275 :             bits |= (stbi__int32)stbi__get8(s) << valid_bits;

  00174	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0017b	e8 00 00 00 00	 call	 stbi__get8
  00180	0f b6 c0	 movzx	 eax, al
  00183	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR valid_bits$[rbp]
  00189	d3 e0		 shl	 eax, cl
  0018b	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR bits$[rbp]
  00191	0b c8		 or	 ecx, eax
  00193	8b c1		 mov	 eax, ecx
  00195	89 85 04 01 00
	00		 mov	 DWORD PTR bits$[rbp], eax

; 6276 :             valid_bits += 8;

  0019b	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR valid_bits$[rbp]
  001a1	83 c0 08	 add	 eax, 8
  001a4	89 85 24 01 00
	00		 mov	 DWORD PTR valid_bits$[rbp], eax

; 6277 :         }

  001aa	e9 2e 03 00 00	 jmp	 $LN12@stbi__proc
$LN11@stbi__proc:

; 6278 :         else {
; 6279 :             stbi__int32 code = bits & codemask;

  001af	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR codemask$[rbp]
  001b5	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR bits$[rbp]
  001bb	23 c8		 and	 ecx, eax
  001bd	8b c1		 mov	 eax, ecx
  001bf	89 85 84 01 00
	00		 mov	 DWORD PTR code$1[rbp], eax

; 6280 :             bits >>= codesize;

  001c5	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  001cb	0f b6 c8	 movzx	 ecx, al
  001ce	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR bits$[rbp]
  001d4	d3 f8		 sar	 eax, cl
  001d6	89 85 04 01 00
	00		 mov	 DWORD PTR bits$[rbp], eax

; 6281 :             valid_bits -= codesize;

  001dc	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  001e2	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR valid_bits$[rbp]
  001e8	2b c8		 sub	 ecx, eax
  001ea	8b c1		 mov	 eax, ecx
  001ec	89 85 24 01 00
	00		 mov	 DWORD PTR valid_bits$[rbp], eax

; 6282 :             // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6283 :             if (code == clear) {  // clear code

  001f2	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR clear$[rbp]
  001f8	39 85 84 01 00
	00		 cmp	 DWORD PTR code$1[rbp], eax
  001fe	75 55		 jne	 SHORT $LN15@stbi__proc

; 6284 :                 codesize = lzw_cs + 1;

  00200	0f b6 45 04	 movzx	 eax, BYTE PTR lzw_cs$[rbp]
  00204	ff c0		 inc	 eax
  00206	89 85 84 00 00
	00		 mov	 DWORD PTR codesize$[rbp], eax

; 6285 :                 codemask = (1 << codesize) - 1;

  0020c	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  00212	b9 01 00 00 00	 mov	 ecx, 1
  00217	89 8d 54 02 00
	00		 mov	 DWORD PTR tv273[rbp], ecx
  0021d	0f b6 c8	 movzx	 ecx, al
  00220	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv273[rbp]
  00226	d3 e0		 shl	 eax, cl
  00228	ff c8		 dec	 eax
  0022a	89 85 a4 00 00
	00		 mov	 DWORD PTR codemask$[rbp], eax

; 6286 :                 avail = clear + 2;

  00230	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR clear$[rbp]
  00236	83 c0 02	 add	 eax, 2
  00239	89 85 c4 00 00
	00		 mov	 DWORD PTR avail$[rbp], eax

; 6287 :                 oldcode = -1;

  0023f	c7 85 e4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR oldcode$[rbp], -1

; 6288 :                 first = 0;

  00249	c7 45 64 00 00
	00 00		 mov	 DWORD PTR first$[rbp], 0

; 6289 :             }

  00250	e9 88 02 00 00	 jmp	 $LN16@stbi__proc
$LN15@stbi__proc:

; 6290 :             else if (code == clear + 1) { // end of stream code

  00255	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR clear$[rbp]
  0025b	ff c0		 inc	 eax
  0025d	39 85 84 01 00
	00		 cmp	 DWORD PTR code$1[rbp], eax
  00263	75 4d		 jne	 SHORT $LN17@stbi__proc

; 6291 :                 stbi__skip(s, len);

  00265	8b 55 24	 mov	 edx, DWORD PTR len$[rbp]
  00268	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0026f	e8 00 00 00 00	 call	 stbi__skip
$LN8@stbi__proc:

; 6292 :                 while ((len = stbi__get8(s)) > 0)

  00274	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0027b	e8 00 00 00 00	 call	 stbi__get8
  00280	0f b6 c0	 movzx	 eax, al
  00283	89 45 24	 mov	 DWORD PTR len$[rbp], eax
  00286	83 7d 24 00	 cmp	 DWORD PTR len$[rbp], 0
  0028a	7e 11		 jle	 SHORT $LN9@stbi__proc

; 6293 :                     stbi__skip(s, len);

  0028c	8b 55 24	 mov	 edx, DWORD PTR len$[rbp]
  0028f	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00296	e8 00 00 00 00	 call	 stbi__skip
  0029b	eb d7		 jmp	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 6294 :                 return g->out;

  0029d	48 8b 85 88 02
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  002a4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002a8	e9 35 02 00 00	 jmp	 $LN1@stbi__proc

; 6295 :             }

  002ad	e9 2b 02 00 00	 jmp	 $LN18@stbi__proc
$LN17@stbi__proc:

; 6296 :             else if (code <= avail) {

  002b2	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR avail$[rbp]
  002b8	39 85 84 01 00
	00		 cmp	 DWORD PTR code$1[rbp], eax
  002be	0f 8f e8 01 00
	00		 jg	 $LN19@stbi__proc

; 6297 :                 if (first) {

  002c4	83 7d 64 00	 cmp	 DWORD PTR first$[rbp], 0
  002c8	74 34		 je	 SHORT $LN21@stbi__proc

; 6298 :                     return stbi__errpuc("no clear code", "Corrupt GIF");

  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MGDACKOJ@no?5clear?5code@
  002d1	e8 00 00 00 00	 call	 stbi__err
  002d6	85 c0		 test	 eax, eax
  002d8	74 0d		 je	 SHORT $LN28@stbi__proc
  002da	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv163[rbp], 0
  002e5	eb 0b		 jmp	 SHORT $LN29@stbi__proc
$LN28@stbi__proc:
  002e7	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv163[rbp], 0
$LN29@stbi__proc:
  002f2	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv163[rbp]
  002f9	e9 e4 01 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 6299 :                 }
; 6300 : 
; 6301 :                 if (oldcode >= 0) {

  002fe	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR oldcode$[rbp], 0
  00305	0f 8c ec 00 00
	00		 jl	 $LN22@stbi__proc

; 6302 :                     p = &g->codes[avail++];

  0030b	48 63 85 c4 00
	00 00		 movsxd	 rax, DWORD PTR avail$[rbp]
  00312	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00319	48 8d 84 81 34
	08 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+2100]
  00321	48 89 85 68 01
	00 00		 mov	 QWORD PTR p$[rbp], rax
  00328	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR avail$[rbp]
  0032e	ff c0		 inc	 eax
  00330	89 85 c4 00 00
	00		 mov	 DWORD PTR avail$[rbp], eax

; 6303 :                     if (avail > 8192) {

  00336	81 bd c4 00 00
	00 00 20 00 00	 cmp	 DWORD PTR avail$[rbp], 8192 ; 00002000H
  00340	7e 34		 jle	 SHORT $LN24@stbi__proc

; 6304 :                         return stbi__errpuc("too many codes", "Corrupt GIF");

  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@GJNJCPDJ@too?5many?5codes@
  00349	e8 00 00 00 00	 call	 stbi__err
  0034e	85 c0		 test	 eax, eax
  00350	74 0d		 je	 SHORT $LN30@stbi__proc
  00352	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv174[rbp], 0
  0035d	eb 0b		 jmp	 SHORT $LN31@stbi__proc
$LN30@stbi__proc:
  0035f	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv174[rbp], 0
$LN31@stbi__proc:
  0036a	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv174[rbp]
  00371	e9 6c 01 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 6305 :                     }
; 6306 : 
; 6307 :                     p->prefix = (stbi__int16)oldcode;

  00376	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0037d	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR oldcode$[rbp]
  00384	66 89 08	 mov	 WORD PTR [rax], cx

; 6308 :                     p->first = g->codes[oldcode].first;

  00387	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR oldcode$[rbp]
  0038e	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00395	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR g$[rbp]
  0039c	0f b6 84 82 36
	08 00 00	 movzx	 eax, BYTE PTR [rdx+rax*4+2102]
  003a4	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6309 :                     p->suffix = (code == avail) ? p->first : g->codes[code].first;

  003a7	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR avail$[rbp]
  003ad	39 85 84 01 00
	00		 cmp	 DWORD PTR code$1[rbp], eax
  003b3	75 13		 jne	 SHORT $LN32@stbi__proc
  003b5	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  003bc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003c0	89 85 54 02 00
	00		 mov	 DWORD PTR tv192[rbp], eax
  003c6	eb 1c		 jmp	 SHORT $LN33@stbi__proc
$LN32@stbi__proc:
  003c8	48 63 85 84 01
	00 00		 movsxd	 rax, DWORD PTR code$1[rbp]
  003cf	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  003d6	0f b6 84 81 36
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2102]
  003de	89 85 54 02 00
	00		 mov	 DWORD PTR tv192[rbp], eax
$LN33@stbi__proc:
  003e4	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  003eb	0f b6 8d 54 02
	00 00		 movzx	 ecx, BYTE PTR tv192[rbp]
  003f2	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 6310 :                 }

  003f5	eb 42		 jmp	 SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 6311 :                 else if (code == avail)

  003f7	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR avail$[rbp]
  003fd	39 85 84 01 00
	00		 cmp	 DWORD PTR code$1[rbp], eax
  00403	75 34		 jne	 SHORT $LN25@stbi__proc

; 6312 :                     return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
  0040c	e8 00 00 00 00	 call	 stbi__err
  00411	85 c0		 test	 eax, eax
  00413	74 0d		 je	 SHORT $LN34@stbi__proc
  00415	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv198[rbp], 0
  00420	eb 0b		 jmp	 SHORT $LN35@stbi__proc
$LN34@stbi__proc:
  00422	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv198[rbp], 0
$LN35@stbi__proc:
  0042d	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv198[rbp]
  00434	e9 a9 00 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:
$LN23@stbi__proc:

; 6313 : 
; 6314 :                 stbi__out_gif_code(g, (stbi__uint16)code);

  00439	0f b7 95 84 01
	00 00		 movzx	 edx, WORD PTR code$1[rbp]
  00440	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00447	e8 00 00 00 00	 call	 stbi__out_gif_code

; 6315 : 
; 6316 :                 if ((avail & codemask) == 0 && avail <= 0x0FFF) {

  0044c	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR codemask$[rbp]
  00452	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR avail$[rbp]
  00458	23 c8		 and	 ecx, eax
  0045a	8b c1		 mov	 eax, ecx
  0045c	85 c0		 test	 eax, eax
  0045e	75 3e		 jne	 SHORT $LN26@stbi__proc
  00460	81 bd c4 00 00
	00 ff 0f 00 00	 cmp	 DWORD PTR avail$[rbp], 4095 ; 00000fffH
  0046a	7f 32		 jg	 SHORT $LN26@stbi__proc

; 6317 :                     codesize++;

  0046c	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  00472	ff c0		 inc	 eax
  00474	89 85 84 00 00
	00		 mov	 DWORD PTR codesize$[rbp], eax

; 6318 :                     codemask = (1 << codesize) - 1;

  0047a	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR codesize$[rbp]
  00480	b9 01 00 00 00	 mov	 ecx, 1
  00485	89 8d 54 02 00
	00		 mov	 DWORD PTR tv297[rbp], ecx
  0048b	0f b6 c8	 movzx	 ecx, al
  0048e	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv297[rbp]
  00494	d3 e0		 shl	 eax, cl
  00496	ff c8		 dec	 eax
  00498	89 85 a4 00 00
	00		 mov	 DWORD PTR codemask$[rbp], eax
$LN26@stbi__proc:

; 6319 :                 }
; 6320 : 
; 6321 :                 oldcode = code;

  0049e	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR code$1[rbp]
  004a4	89 85 e4 00 00
	00		 mov	 DWORD PTR oldcode$[rbp], eax

; 6322 :             }

  004aa	eb 31		 jmp	 SHORT $LN20@stbi__proc
$LN19@stbi__proc:

; 6323 :             else {
; 6324 :                 return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
  004b3	e8 00 00 00 00	 call	 stbi__err
  004b8	85 c0		 test	 eax, eax
  004ba	74 0d		 je	 SHORT $LN36@stbi__proc
  004bc	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv210[rbp], 0
  004c7	eb 0b		 jmp	 SHORT $LN37@stbi__proc
$LN36@stbi__proc:
  004c9	48 c7 85 58 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv210[rbp], 0
$LN37@stbi__proc:
  004d4	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv210[rbp]
  004db	eb 05		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:
$LN18@stbi__proc:
$LN16@stbi__proc:
$LN12@stbi__proc:

; 6325 :             }
; 6326 :         }
; 6327 :     }

  004dd	e9 4e fc ff ff	 jmp	 $LN5@stbi__proc
$LN1@stbi__proc:

; 6328 : }

  004e2	48 8d a5 68 02
	00 00		 lea	 rsp, QWORD PTR [rbp+616]
  004e9	5f		 pop	 rdi
  004ea	5d		 pop	 rbp
  004eb	c3		 ret	 0
stbi__process_gif_raster ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__out_gif_code
_TEXT	SEGMENT
p$ = 8
c$ = 40
idx$ = 68
tv257 = 276
g$ = 320
code$ = 328
stbi__out_gif_code PROC					; COMDAT

; 6204 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6205 :     stbi_uc* p, * c;
; 6206 :     int idx;
; 6207 : 
; 6208 :     // recurse to decode the prefixes, since the linked-list is backwards,
; 6209 :     // and working backwards through an interleaved image would be nasty
; 6210 :     if (g->codes[code].prefix >= 0)

  00024	0f b7 85 48 01
	00 00		 movzx	 eax, WORD PTR code$[rbp]
  0002b	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00032	0f bf 84 81 34
	08 00 00	 movsx	 eax, WORD PTR [rcx+rax*4+2100]
  0003a	85 c0		 test	 eax, eax
  0003c	7c 22		 jl	 SHORT $LN4@stbi__out_

; 6211 :         stbi__out_gif_code(g, g->codes[code].prefix);

  0003e	0f b7 85 48 01
	00 00		 movzx	 eax, WORD PTR code$[rbp]
  00045	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0004c	0f b7 94 81 34
	08 00 00	 movzx	 edx, WORD PTR [rcx+rax*4+2100]
  00054	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0005b	e8 00 00 00 00	 call	 stbi__out_gif_code
$LN4@stbi__out_:

; 6212 : 
; 6213 :     if (g->cur_y >= g->max_y) return;

  00060	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00067	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0006e	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00074	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  0007a	7c 05		 jl	 SHORT $LN5@stbi__out_
  0007c	e9 64 02 00 00	 jmp	 $LN1@stbi__out_
$LN5@stbi__out_:

; 6214 : 
; 6215 :     idx = g->cur_x + g->cur_y;

  00081	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00088	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  0008e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00095	03 81 60 88 00
	00		 add	 eax, DWORD PTR [rcx+34912]
  0009b	89 45 44	 mov	 DWORD PTR idx$[rbp], eax

; 6216 :     p = &g->out[idx];

  0009e	48 63 45 44	 movsxd	 rax, DWORD PTR idx$[rbp]
  000a2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000a9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax

; 6217 :     g->history[idx / 4] = 1;

  000b7	8b 45 44	 mov	 eax, DWORD PTR idx$[rbp]
  000ba	99		 cdq
  000bb	83 e2 03	 and	 edx, 3
  000be	03 c2		 add	 eax, edx
  000c0	c1 f8 02	 sar	 eax, 2
  000c3	48 98		 cdqe
  000c5	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000cc	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000d0	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 6218 : 
; 6219 :     c = &g->color_table[g->codes[code].suffix * 4];

  000d4	0f b7 85 48 01
	00 00		 movzx	 eax, WORD PTR code$[rbp]
  000db	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000e2	0f b6 84 81 37
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2103]
  000ea	c1 e0 02	 shl	 eax, 2
  000ed	48 98		 cdqe
  000ef	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  000f6	48 8b 89 38 88
	00 00		 mov	 rcx, QWORD PTR [rcx+34872]
  000fd	48 03 c8	 add	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 45 28	 mov	 QWORD PTR c$[rbp], rax

; 6220 :     if (c[3] > 128) { // don't render transparent pixels;

  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	48 6b c0 03	 imul	 rax, rax, 3
  00110	48 8b 4d 28	 mov	 rcx, QWORD PTR c$[rbp]
  00114	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00118	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0011d	0f 8e 88 00 00
	00		 jle	 $LN6@stbi__out_

; 6221 :         p[0] = c[2];

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	48 6b c0 02	 imul	 rax, rax, 2
  0012c	b9 01 00 00 00	 mov	 ecx, 1
  00131	48 6b c9 00	 imul	 rcx, rcx, 0
  00135	48 8b 55 08	 mov	 rdx, QWORD PTR p$[rbp]
  00139	4c 8b 45 28	 mov	 r8, QWORD PTR c$[rbp]
  0013d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00142	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6222 :         p[1] = c[1];

  00145	b8 01 00 00 00	 mov	 eax, 1
  0014a	48 6b c0 01	 imul	 rax, rax, 1
  0014e	b9 01 00 00 00	 mov	 ecx, 1
  00153	48 6b c9 01	 imul	 rcx, rcx, 1
  00157	48 8b 55 08	 mov	 rdx, QWORD PTR p$[rbp]
  0015b	4c 8b 45 28	 mov	 r8, QWORD PTR c$[rbp]
  0015f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00164	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6223 :         p[2] = c[0];

  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	48 6b c0 00	 imul	 rax, rax, 0
  00170	b9 01 00 00 00	 mov	 ecx, 1
  00175	48 6b c9 02	 imul	 rcx, rcx, 2
  00179	48 8b 55 08	 mov	 rdx, QWORD PTR p$[rbp]
  0017d	4c 8b 45 28	 mov	 r8, QWORD PTR c$[rbp]
  00181	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00186	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6224 :         p[3] = c[3];

  00189	b8 01 00 00 00	 mov	 eax, 1
  0018e	48 6b c0 03	 imul	 rax, rax, 3
  00192	b9 01 00 00 00	 mov	 ecx, 1
  00197	48 6b c9 03	 imul	 rcx, rcx, 3
  0019b	48 8b 55 08	 mov	 rdx, QWORD PTR p$[rbp]
  0019f	4c 8b 45 28	 mov	 r8, QWORD PTR c$[rbp]
  001a3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001a8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN6@stbi__out_:

; 6225 :     }
; 6226 :     g->cur_x += 4;

  001ab	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001b2	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  001b8	83 c0 04	 add	 eax, 4
  001bb	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  001c2	89 81 5c 88 00
	00		 mov	 DWORD PTR [rcx+34908], eax

; 6227 : 
; 6228 :     if (g->cur_x >= g->max_x) {

  001c8	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001cf	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  001d6	8b 89 54 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34900]
  001dc	39 88 5c 88 00
	00		 cmp	 DWORD PTR [rax+34908], ecx
  001e2	0f 8c fd 00 00
	00		 jl	 $LN7@stbi__out_

; 6229 :         g->cur_x = g->start_x;

  001e8	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001ef	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  001f6	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  001fc	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6230 :         g->cur_y += g->step;

  00202	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00209	8b 80 60 88 00
	00		 mov	 eax, DWORD PTR [rax+34912]
  0020f	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00216	03 81 44 88 00
	00		 add	 eax, DWORD PTR [rcx+34884]
  0021c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00223	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax
$LN2@stbi__out_:

; 6231 : 
; 6232 :         while (g->cur_y >= g->max_y && g->parse > 0) {

  00229	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00230	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00237	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  0023d	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00243	0f 8c 9c 00 00
	00		 jl	 $LN3@stbi__out_
  00249	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00250	83 b8 40 88 00
	00 00		 cmp	 DWORD PTR [rax+34880], 0
  00257	0f 8e 88 00 00
	00		 jle	 $LN3@stbi__out_

; 6233 :             g->step = (1 << g->parse) * g->line_size;

  0025d	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00264	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  0026a	b9 01 00 00 00	 mov	 ecx, 1
  0026f	89 8d 14 01 00
	00		 mov	 DWORD PTR tv257[rbp], ecx
  00275	0f b6 c8	 movzx	 ecx, al
  00278	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv257[rbp]
  0027e	d3 e0		 shl	 eax, cl
  00280	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00287	0f af 81 64 88
	00 00		 imul	 eax, DWORD PTR [rcx+34916]
  0028e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00295	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6234 :             g->cur_y = g->start_y + (g->step >> 1);

  0029b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  002a2	8b 80 44 88 00
	00		 mov	 eax, DWORD PTR [rax+34884]
  002a8	d1 f8		 sar	 eax, 1
  002aa	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  002b1	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  002b7	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  002be	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax

; 6235 :             --g->parse;

  002c4	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  002cb	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  002d1	ff c8		 dec	 eax
  002d3	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  002da	89 81 40 88 00
	00		 mov	 DWORD PTR [rcx+34880], eax

; 6236 :         }

  002e0	e9 44 ff ff ff	 jmp	 $LN2@stbi__out_
$LN3@stbi__out_:
$LN7@stbi__out_:
$LN1@stbi__out_:

; 6237 :     }
; 6238 : }

  002e5	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  002ec	5f		 pop	 rdi
  002ed	5d		 pop	 rbp
  002ee	c3		 ret	 0
stbi__out_gif_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_info_raw
_TEXT	SEGMENT
g$ = 8
s$ = 256
x$ = 264
y$ = 272
comp$ = 280
stbi__gif_info_raw PROC					; COMDAT

; 6189 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6190 :     stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));

  0002e	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  00033	e8 00 00 00 00	 call	 stbi__malloc
  00038	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 6191 :     if (!g) return stbi__err("outofmem", "Out of memory");

  0003c	48 83 7d 08 00	 cmp	 QWORD PTR g$[rbp], 0
  00041	75 0e		 jne	 SHORT $LN2@stbi__gif_
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	eb 7d		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6192 :     if (!stbi__gif_header(s, g, comp, 1)) {

  00051	41 b9 01 00 00
	00		 mov	 r9d, 1
  00057	4c 8b 85 18 01
	00 00		 mov	 r8, QWORD PTR comp$[rbp]
  0005e	48 8b 55 08	 mov	 rdx, QWORD PTR g$[rbp]
  00062	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__gif_header
  0006e	85 c0		 test	 eax, eax
  00070	75 1a		 jne	 SHORT $LN3@stbi__gif_

; 6193 :         STBI_FREE(g);

  00072	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6194 :         stbi__rewind(s);

  0007c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00083	e8 00 00 00 00	 call	 stbi__rewind

; 6195 :         return 0;

  00088	33 c0		 xor	 eax, eax
  0008a	eb 42		 jmp	 SHORT $LN1@stbi__gif_
$LN3@stbi__gif_:

; 6196 :     }
; 6197 :     if (x) *x = g->w;

  0008c	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00094	74 0f		 je	 SHORT $LN4@stbi__gif_
  00096	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  0009d	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  000a1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000a3	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__gif_:

; 6198 :     if (y) *y = g->h;

  000a5	48 83 bd 10 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  000ad	74 10		 je	 SHORT $LN5@stbi__gif_
  000af	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  000b6	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  000ba	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000bd	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__gif_:

; 6199 :     STBI_FREE(g);

  000bf	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6200 :     return 1;

  000c9	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6201 : }

  000ce	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000d5	5f		 pop	 rdi
  000d6	5d		 pop	 rbp
  000d7	c3		 ret	 0
stbi__gif_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_header
_TEXT	SEGMENT
version$ = 4
tv225 = 212
s$ = 256
g$ = 264
comp$ = 272
is_info$ = 280
stbi__gif_header PROC					; COMDAT

; 6158 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6159 :     stbi_uc version;
; 6160 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__get8
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	83 f8 47	 cmp	 eax, 71			; 00000047H
  00040	75 3c		 jne	 SHORT $LN3@stbi__gif_
  00042	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00049	e8 00 00 00 00	 call	 stbi__get8
  0004e	0f b6 c0	 movzx	 eax, al
  00051	83 f8 49	 cmp	 eax, 73			; 00000049H
  00054	75 28		 jne	 SHORT $LN3@stbi__gif_
  00056	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005d	e8 00 00 00 00	 call	 stbi__get8
  00062	0f b6 c0	 movzx	 eax, al
  00065	83 f8 46	 cmp	 eax, 70			; 00000046H
  00068	75 14		 jne	 SHORT $LN3@stbi__gif_
  0006a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00071	e8 00 00 00 00	 call	 stbi__get8
  00076	0f b6 c0	 movzx	 eax, al
  00079	83 f8 38	 cmp	 eax, 56			; 00000038H
  0007c	74 11		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6161 :         return stbi__err("not GIF", "Corrupt GIF");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  00085	e8 00 00 00 00	 call	 stbi__err
  0008a	e9 c6 01 00 00	 jmp	 $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6162 : 
; 6163 :     version = stbi__get8(s);

  0008f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00096	e8 00 00 00 00	 call	 stbi__get8
  0009b	88 45 04	 mov	 BYTE PTR version$[rbp], al

; 6164 :     if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

  0009e	0f b6 45 04	 movzx	 eax, BYTE PTR version$[rbp]
  000a2	83 f8 37	 cmp	 eax, 55			; 00000037H
  000a5	74 1a		 je	 SHORT $LN4@stbi__gif_
  000a7	0f b6 45 04	 movzx	 eax, BYTE PTR version$[rbp]
  000ab	83 f8 39	 cmp	 eax, 57			; 00000039H
  000ae	74 11		 je	 SHORT $LN4@stbi__gif_
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  000b7	e8 00 00 00 00	 call	 stbi__err
  000bc	e9 94 01 00 00	 jmp	 $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6165 :     if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

  000c1	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c8	e8 00 00 00 00	 call	 stbi__get8
  000cd	0f b6 c0	 movzx	 eax, al
  000d0	83 f8 61	 cmp	 eax, 97			; 00000061H
  000d3	74 11		 je	 SHORT $LN5@stbi__gif_
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  000dc	e8 00 00 00 00	 call	 stbi__err
  000e1	e9 6f 01 00 00	 jmp	 $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6166 : 
; 6167 :     stbi__g_failure_reason = "";

  000e6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  000eb	8b c0		 mov	 eax, eax
  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000f3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000fc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00107	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 6168 :     g->w = stbi__get16le(s);

  0010b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00112	e8 00 00 00 00	 call	 stbi__get16le
  00117	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0011e	89 01		 mov	 DWORD PTR [rcx], eax

; 6169 :     g->h = stbi__get16le(s);

  00120	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00127	e8 00 00 00 00	 call	 stbi__get16le
  0012c	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00133	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 6170 :     g->flags = stbi__get8(s);

  00136	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0013d	e8 00 00 00 00	 call	 stbi__get8
  00142	0f b6 c0	 movzx	 eax, al
  00145	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0014c	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 6171 :     g->bgindex = stbi__get8(s);

  0014f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00156	e8 00 00 00 00	 call	 stbi__get8
  0015b	0f b6 c0	 movzx	 eax, al
  0015e	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00165	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 6172 :     g->ratio = stbi__get8(s);

  00168	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0016f	e8 00 00 00 00	 call	 stbi__get8
  00174	0f b6 c0	 movzx	 eax, al
  00177	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  0017e	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 6173 :     g->transparent = -1;

  00181	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00188	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1

; 6174 : 
; 6175 :     if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  0018f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00196	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  0019c	7e 11		 jle	 SHORT $LN6@stbi__gif_
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  001a5	e8 00 00 00 00	 call	 stbi__err
  001aa	e9 a6 00 00 00	 jmp	 $LN1@stbi__gif_
$LN6@stbi__gif_:

; 6176 :     if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  001af	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001b6	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  001bd	7e 11		 jle	 SHORT $LN7@stbi__gif_
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  001c6	e8 00 00 00 00	 call	 stbi__err
  001cb	e9 85 00 00 00	 jmp	 $LN1@stbi__gif_
$LN7@stbi__gif_:

; 6177 : 
; 6178 :     if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

  001d0	48 83 bd 10 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  001d8	74 0d		 je	 SHORT $LN8@stbi__gif_
  001da	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  001e1	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN8@stbi__gif_:

; 6179 : 
; 6180 :     if (is_info) return 1;

  001e7	83 bd 18 01 00
	00 00		 cmp	 DWORD PTR is_info$[rbp], 0
  001ee	74 07		 je	 SHORT $LN9@stbi__gif_
  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	eb 5e		 jmp	 SHORT $LN1@stbi__gif_
$LN9@stbi__gif_:

; 6181 : 
; 6182 :     if (g->flags & 0x80)

  001f7	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  001fe	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00201	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00206	85 c0		 test	 eax, eax
  00208	74 46		 je	 SHORT $LN10@stbi__gif_

; 6183 :         stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

  0020a	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  00211	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00214	83 e0 07	 and	 eax, 7
  00217	b9 02 00 00 00	 mov	 ecx, 2
  0021c	89 8d d4 00 00
	00		 mov	 DWORD PTR tv225[rbp], ecx
  00222	0f b6 c8	 movzx	 ecx, al
  00225	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv225[rbp]
  0022b	d3 e0		 shl	 eax, cl
  0022d	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR g$[rbp]
  00234	48 83 c1 34	 add	 rcx, 52			; 00000034H
  00238	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  0023e	44 8b c0	 mov	 r8d, eax
  00241	48 8b d1	 mov	 rdx, rcx
  00244	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0024b	e8 00 00 00 00	 call	 stbi__gif_parse_colortable
$LN10@stbi__gif_:

; 6184 : 
; 6185 :     return 1;

  00250	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6186 : }

  00255	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0025c	5f		 pop	 rdi
  0025d	5d		 pop	 rbp
  0025e	c3		 ret	 0
stbi__gif_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_parse_colortable
_TEXT	SEGMENT
i$ = 4
tv93 = 212
s$ = 256
pal$ = 264
num_entries$ = 272
transp$ = 280
stbi__gif_parse_colortable PROC				; COMDAT

; 6147 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6148 :     int i;
; 6149 :     for (i = 0; i < num_entries; ++i) {

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00035	eb 08		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00037	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0003a	ff c0		 inc	 eax
  0003c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__gif_:
  0003f	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR num_entries$[rbp]
  00045	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00048	0f 8d bd 00 00
	00		 jge	 $LN3@stbi__gif_

; 6150 :         pal[i][2] = stbi__get8(s);

  0004e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00055	e8 00 00 00 00	 call	 stbi__get8
  0005a	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  0005e	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR pal$[rbp]
  00065	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 6b d2 02	 imul	 rdx, rdx, 2
  00072	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6151 :         pal[i][1] = stbi__get8(s);

  00075	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0007c	e8 00 00 00 00	 call	 stbi__get8
  00081	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00085	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR pal$[rbp]
  0008c	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00090	ba 01 00 00 00	 mov	 edx, 1
  00095	48 6b d2 01	 imul	 rdx, rdx, 1
  00099	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6152 :         pal[i][0] = stbi__get8(s);

  0009c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a3	e8 00 00 00 00	 call	 stbi__get8
  000a8	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  000ac	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR pal$[rbp]
  000b3	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	48 6b d2 00	 imul	 rdx, rdx, 0
  000c0	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6153 :         pal[i][3] = transp == i ? 0 : 255;

  000c3	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000c6	39 85 18 01 00
	00		 cmp	 DWORD PTR transp$[rbp], eax
  000cc	75 0c		 jne	 SHORT $LN6@stbi__gif_
  000ce	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv93[rbp], 0
  000d8	eb 0a		 jmp	 SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
  000da	c7 85 d4 00 00
	00 ff 00 00 00	 mov	 DWORD PTR tv93[rbp], 255 ; 000000ffH
$LN7@stbi__gif_:
  000e4	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000e8	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR pal$[rbp]
  000ef	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	48 6b c9 03	 imul	 rcx, rcx, 3
  000fc	0f b6 95 d4 00
	00 00		 movzx	 edx, BYTE PTR tv93[rbp]
  00103	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 6154 :     }

  00106	e9 2c ff ff ff	 jmp	 $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6155 : }

  0010b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00112	5f		 pop	 rdi
  00113	5d		 pop	 rbp
  00114	c3		 ret	 0
stbi__gif_parse_colortable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_test_raw
_TEXT	SEGMENT
sz$ = 4
s$ = 256
stbi__gif_test_raw PROC					; COMDAT

; 6130 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6131 :     int sz;
; 6132 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get8
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	83 f8 47	 cmp	 eax, 71			; 00000047H
  00031	75 3c		 jne	 SHORT $LN3@stbi__gif_
  00033	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003a	e8 00 00 00 00	 call	 stbi__get8
  0003f	0f b6 c0	 movzx	 eax, al
  00042	83 f8 49	 cmp	 eax, 73			; 00000049H
  00045	75 28		 jne	 SHORT $LN3@stbi__gif_
  00047	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004e	e8 00 00 00 00	 call	 stbi__get8
  00053	0f b6 c0	 movzx	 eax, al
  00056	83 f8 46	 cmp	 eax, 70			; 00000046H
  00059	75 14		 jne	 SHORT $LN3@stbi__gif_
  0005b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00062	e8 00 00 00 00	 call	 stbi__get8
  00067	0f b6 c0	 movzx	 eax, al
  0006a	83 f8 38	 cmp	 eax, 56			; 00000038H
  0006d	74 04		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
  0006f	33 c0		 xor	 eax, eax
  00071	eb 3f		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6133 :     sz = stbi__get8(s);

  00073	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0007a	e8 00 00 00 00	 call	 stbi__get8
  0007f	0f b6 c0	 movzx	 eax, al
  00082	89 45 04	 mov	 DWORD PTR sz$[rbp], eax

; 6134 :     if (sz != '9' && sz != '7') return 0;

  00085	83 7d 04 39	 cmp	 DWORD PTR sz$[rbp], 57	; 00000039H
  00089	74 0a		 je	 SHORT $LN4@stbi__gif_
  0008b	83 7d 04 37	 cmp	 DWORD PTR sz$[rbp], 55	; 00000037H
  0008f	74 04		 je	 SHORT $LN4@stbi__gif_
  00091	33 c0		 xor	 eax, eax
  00093	eb 1d		 jmp	 SHORT $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6135 :     if (stbi__get8(s) != 'a') return 0;

  00095	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009c	e8 00 00 00 00	 call	 stbi__get8
  000a1	0f b6 c0	 movzx	 eax, al
  000a4	83 f8 61	 cmp	 eax, 97			; 00000061H
  000a7	74 04		 je	 SHORT $LN5@stbi__gif_
  000a9	33 c0		 xor	 eax, eax
  000ab	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6136 :     return 1;

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6137 : }

  000b2	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000b9	5f		 pop	 rdi
  000ba	5d		 pop	 rbp
  000bb	c3		 ret	 0
stbi__gif_test_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_load_core
_TEXT	SEGMENT
act_comp$ = 4
num_packets$ = 36
y$ = 68
chained$ = 100
packets$ = 136
packet$6 = 200
packet_idx$7 = 228
packet$8 = 264
dest$9 = 296
x$10 = 324
left$11 = 356
i$12 = 388
count$13 = 420
value$14 = 452
left$15 = 484
count$16 = 516
i$17 = 548
value$18 = 580
tv152 = 980
tv138 = 980
tv238 = 984
tv217 = 984
tv207 = 984
tv176 = 984
tv156 = 984
tv134 = 984
tv95 = 984
tv69 = 984
__$ArrayPad$ = 992
s$ = 1040
width$ = 1048
height$ = 1056
comp$ = 1064
result$ = 1072
stbi__pic_load_core PROC				; COMDAT

; 5939 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 18 04
	00 00		 sub	 rsp, 1048		; 00000418H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00026	b9 9e 00 00 00	 mov	 ecx, 158		; 0000009eH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 38
	04 00 00	 mov	 rcx, QWORD PTR [rsp+1080]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 e0 03
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5940 :     int act_comp = 0, num_packets = 0, y, chained;

  00057	c7 45 04 00 00
	00 00		 mov	 DWORD PTR act_comp$[rbp], 0
  0005e	c7 45 24 00 00
	00 00		 mov	 DWORD PTR num_packets$[rbp], 0
$LN4@stbi__pic_:

; 5941 :     stbi__pic_packet packets[10];
; 5942 : 
; 5943 :     // this will (should...) cater for even some bizarre stuff like having data
; 5944 :      // for the same channel in multiple packets.
; 5945 :     do {
; 5946 :         stbi__pic_packet* packet;
; 5947 : 
; 5948 :         if (num_packets == sizeof(packets) / sizeof(packets[0]))

  00065	48 63 45 24	 movsxd	 rax, DWORD PTR num_packets$[rbp]
  00069	48 83 f8 0a	 cmp	 rax, 10
  0006d	75 34		 jne	 SHORT $LN29@stbi__pic_

; 5949 :             return stbi__errpuc("bad format", "too many packets");

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00076	e8 00 00 00 00	 call	 stbi__err
  0007b	85 c0		 test	 eax, eax
  0007d	74 0d		 je	 SHORT $LN50@stbi__pic_
  0007f	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv69[rbp], 0
  0008a	eb 0b		 jmp	 SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
  0008c	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv69[rbp], 0
$LN51@stbi__pic_:
  00097	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv69[rbp]
  0009e	e9 38 06 00 00	 jmp	 $LN1@stbi__pic_
$LN29@stbi__pic_:

; 5950 : 
; 5951 :         packet = &packets[num_packets++];

  000a3	48 63 45 24	 movsxd	 rax, DWORD PTR num_packets$[rbp]
  000a7	48 6b c0 03	 imul	 rax, rax, 3
  000ab	48 8d 84 05 88
	00 00 00	 lea	 rax, QWORD PTR packets$[rbp+rax]
  000b3	48 89 85 c8 00
	00 00		 mov	 QWORD PTR packet$6[rbp], rax
  000ba	8b 45 24	 mov	 eax, DWORD PTR num_packets$[rbp]
  000bd	ff c0		 inc	 eax
  000bf	89 45 24	 mov	 DWORD PTR num_packets$[rbp], eax

; 5952 : 
; 5953 :         chained = stbi__get8(s);

  000c2	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c9	e8 00 00 00 00	 call	 stbi__get8
  000ce	0f b6 c0	 movzx	 eax, al
  000d1	89 45 64	 mov	 DWORD PTR chained$[rbp], eax

; 5954 :         packet->size = stbi__get8(s);

  000d4	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000db	e8 00 00 00 00	 call	 stbi__get8
  000e0	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$6[rbp]
  000e7	88 01		 mov	 BYTE PTR [rcx], al

; 5955 :         packet->type = stbi__get8(s);

  000e9	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f0	e8 00 00 00 00	 call	 stbi__get8
  000f5	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$6[rbp]
  000fc	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 5956 :         packet->channel = stbi__get8(s);

  000ff	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00106	e8 00 00 00 00	 call	 stbi__get8
  0010b	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$6[rbp]
  00112	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 5957 : 
; 5958 :         act_comp |= packet->channel;

  00115	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR packet$6[rbp]
  0011c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00120	8b 4d 04	 mov	 ecx, DWORD PTR act_comp$[rbp]
  00123	0b c8		 or	 ecx, eax
  00125	8b c1		 mov	 eax, ecx
  00127	89 45 04	 mov	 DWORD PTR act_comp$[rbp], eax

; 5959 : 
; 5960 :         if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");

  0012a	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00131	e8 00 00 00 00	 call	 stbi__at_eof
  00136	85 c0		 test	 eax, eax
  00138	74 34		 je	 SHORT $LN30@stbi__pic_
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00141	e8 00 00 00 00	 call	 stbi__err
  00146	85 c0		 test	 eax, eax
  00148	74 0d		 je	 SHORT $LN52@stbi__pic_
  0014a	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv95[rbp], 0
  00155	eb 0b		 jmp	 SHORT $LN53@stbi__pic_
$LN52@stbi__pic_:
  00157	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv95[rbp], 0
$LN53@stbi__pic_:
  00162	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv95[rbp]
  00169	e9 6d 05 00 00	 jmp	 $LN1@stbi__pic_
$LN30@stbi__pic_:

; 5961 :         if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");

  0016e	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR packet$6[rbp]
  00175	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00178	83 f8 08	 cmp	 eax, 8
  0017b	74 34		 je	 SHORT $LN31@stbi__pic_
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00184	e8 00 00 00 00	 call	 stbi__err
  00189	85 c0		 test	 eax, eax
  0018b	74 0d		 je	 SHORT $LN54@stbi__pic_
  0018d	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv134[rbp], 0
  00198	eb 0b		 jmp	 SHORT $LN55@stbi__pic_
$LN54@stbi__pic_:
  0019a	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv134[rbp], 0
$LN55@stbi__pic_:
  001a5	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv134[rbp]
  001ac	e9 2a 05 00 00	 jmp	 $LN1@stbi__pic_
$LN31@stbi__pic_:

; 5962 :     } while (chained);

  001b1	83 7d 64 00	 cmp	 DWORD PTR chained$[rbp], 0
  001b5	0f 85 aa fe ff
	ff		 jne	 $LN4@stbi__pic_

; 5963 : 
; 5964 :     *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

  001bb	8b 45 04	 mov	 eax, DWORD PTR act_comp$[rbp]
  001be	83 e0 10	 and	 eax, 16
  001c1	85 c0		 test	 eax, eax
  001c3	74 0c		 je	 SHORT $LN56@stbi__pic_
  001c5	c7 85 d4 03 00
	00 04 00 00 00	 mov	 DWORD PTR tv138[rbp], 4
  001cf	eb 0a		 jmp	 SHORT $LN57@stbi__pic_
$LN56@stbi__pic_:
  001d1	c7 85 d4 03 00
	00 03 00 00 00	 mov	 DWORD PTR tv138[rbp], 3
$LN57@stbi__pic_:
  001db	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  001e2	8b 8d d4 03 00
	00		 mov	 ecx, DWORD PTR tv138[rbp]
  001e8	89 08		 mov	 DWORD PTR [rax], ecx

; 5965 : 
; 5966 :     for (y = 0; y < height; ++y) {

  001ea	c7 45 44 00 00
	00 00		 mov	 DWORD PTR y$[rbp], 0
  001f1	eb 08		 jmp	 SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
  001f3	8b 45 44	 mov	 eax, DWORD PTR y$[rbp]
  001f6	ff c0		 inc	 eax
  001f8	89 45 44	 mov	 DWORD PTR y$[rbp], eax
$LN7@stbi__pic_:
  001fb	8b 85 20 04 00
	00		 mov	 eax, DWORD PTR height$[rbp]
  00201	39 45 44	 cmp	 DWORD PTR y$[rbp], eax
  00204	0f 8d ca 04 00
	00		 jge	 $LN6@stbi__pic_

; 5967 :         int packet_idx;
; 5968 : 
; 5969 :         for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {

  0020a	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR packet_idx$7[rbp], 0
  00214	eb 0e		 jmp	 SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
  00216	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR packet_idx$7[rbp]
  0021c	ff c0		 inc	 eax
  0021e	89 85 e4 00 00
	00		 mov	 DWORD PTR packet_idx$7[rbp], eax
$LN10@stbi__pic_:
  00224	8b 45 24	 mov	 eax, DWORD PTR num_packets$[rbp]
  00227	39 85 e4 00 00
	00		 cmp	 DWORD PTR packet_idx$7[rbp], eax
  0022d	0f 8d 9c 04 00
	00		 jge	 $LN9@stbi__pic_

; 5970 :             stbi__pic_packet* packet = &packets[packet_idx];

  00233	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR packet_idx$7[rbp]
  0023a	48 6b c0 03	 imul	 rax, rax, 3
  0023e	48 8d 84 05 88
	00 00 00	 lea	 rax, QWORD PTR packets$[rbp+rax]
  00246	48 89 85 08 01
	00 00		 mov	 QWORD PTR packet$8[rbp], rax

; 5971 :             stbi_uc* dest = result + y * width * 4;

  0024d	8b 45 44	 mov	 eax, DWORD PTR y$[rbp]
  00250	0f af 85 18 04
	00 00		 imul	 eax, DWORD PTR width$[rbp]
  00257	c1 e0 02	 shl	 eax, 2
  0025a	48 98		 cdqe
  0025c	48 8b 8d 30 04
	00 00		 mov	 rcx, QWORD PTR result$[rbp]
  00263	48 03 c8	 add	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	48 89 85 28 01
	00 00		 mov	 QWORD PTR dest$9[rbp], rax

; 5972 : 
; 5973 :             switch (packet->type) {

  00270	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  00277	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0027b	88 85 d4 03 00
	00		 mov	 BYTE PTR tv152[rbp], al
  00281	80 bd d4 03 00
	00 00		 cmp	 BYTE PTR tv152[rbp], 0
  00288	74 4e		 je	 SHORT $LN33@stbi__pic_
  0028a	80 bd d4 03 00
	00 01		 cmp	 BYTE PTR tv152[rbp], 1
  00291	0f 84 ae 00 00
	00		 je	 $LN35@stbi__pic_
  00297	80 bd d4 03 00
	00 02		 cmp	 BYTE PTR tv152[rbp], 2
  0029e	0f 84 d6 01 00
	00		 je	 $LN39@stbi__pic_

; 5974 :             default:
; 5975 :                 return stbi__errpuc("bad format", "packet has bad compression type");

  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  002ab	e8 00 00 00 00	 call	 stbi__err
  002b0	85 c0		 test	 eax, eax
  002b2	74 0d		 je	 SHORT $LN58@stbi__pic_
  002b4	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv156[rbp], 0
  002bf	eb 0b		 jmp	 SHORT $LN59@stbi__pic_
$LN58@stbi__pic_:
  002c1	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv156[rbp], 0
$LN59@stbi__pic_:
  002cc	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv156[rbp]
  002d3	e9 03 04 00 00	 jmp	 $LN1@stbi__pic_
$LN33@stbi__pic_:

; 5976 : 
; 5977 :             case 0: {//uncompressed
; 5978 :                 int x;
; 5979 : 
; 5980 :                 for (x = 0; x < width; ++x, dest += 4)

  002d8	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR x$10[rbp], 0
  002e2	eb 20		 jmp	 SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
  002e4	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR x$10[rbp]
  002ea	ff c0		 inc	 eax
  002ec	89 85 44 01 00
	00		 mov	 DWORD PTR x$10[rbp], eax
  002f2	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR dest$9[rbp]
  002f9	48 83 c0 04	 add	 rax, 4
  002fd	48 89 85 28 01
	00 00		 mov	 QWORD PTR dest$9[rbp], rax
$LN15@stbi__pic_:
  00304	8b 85 18 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  0030a	39 85 44 01 00
	00		 cmp	 DWORD PTR x$10[rbp], eax
  00310	7d 2e		 jge	 SHORT $LN14@stbi__pic_

; 5981 :                     if (!stbi__readval(s, packet->channel, dest))

  00312	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  00319	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0031d	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR dest$9[rbp]
  00324	8b d0		 mov	 edx, eax
  00326	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0032d	e8 00 00 00 00	 call	 stbi__readval
  00332	48 85 c0	 test	 rax, rax
  00335	75 07		 jne	 SHORT $LN34@stbi__pic_

; 5982 :                         return 0;

  00337	33 c0		 xor	 eax, eax
  00339	e9 9d 03 00 00	 jmp	 $LN1@stbi__pic_
$LN34@stbi__pic_:
  0033e	eb a4		 jmp	 SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 5983 :                 break;

  00340	e9 85 03 00 00	 jmp	 $LN11@stbi__pic_
$LN35@stbi__pic_:

; 5984 :             }
; 5985 : 
; 5986 :             case 1://Pure RLE
; 5987 :             {
; 5988 :                 int left = width, i;

  00345	8b 85 18 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  0034b	89 85 64 01 00
	00		 mov	 DWORD PTR left$11[rbp], eax
$LN16@stbi__pic_:

; 5989 : 
; 5990 :                 while (left > 0) {

  00351	83 bd 64 01 00
	00 00		 cmp	 DWORD PTR left$11[rbp], 0
  00358	0f 8e 17 01 00
	00		 jle	 $LN17@stbi__pic_

; 5991 :                     stbi_uc count, value[4];
; 5992 : 
; 5993 :                     count = stbi__get8(s);

  0035e	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00365	e8 00 00 00 00	 call	 stbi__get8
  0036a	88 85 a4 01 00
	00		 mov	 BYTE PTR count$13[rbp], al

; 5994 :                     if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

  00370	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00377	e8 00 00 00 00	 call	 stbi__at_eof
  0037c	85 c0		 test	 eax, eax
  0037e	74 34		 je	 SHORT $LN36@stbi__pic_
  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00387	e8 00 00 00 00	 call	 stbi__err
  0038c	85 c0		 test	 eax, eax
  0038e	74 0d		 je	 SHORT $LN60@stbi__pic_
  00390	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv176[rbp], 0
  0039b	eb 0b		 jmp	 SHORT $LN61@stbi__pic_
$LN60@stbi__pic_:
  0039d	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv176[rbp], 0
$LN61@stbi__pic_:
  003a8	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv176[rbp]
  003af	e9 27 03 00 00	 jmp	 $LN1@stbi__pic_
$LN36@stbi__pic_:

; 5995 : 
; 5996 :                     if (count > left)

  003b4	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR count$13[rbp]
  003bb	3b 85 64 01 00
	00		 cmp	 eax, DWORD PTR left$11[rbp]
  003c1	7e 0d		 jle	 SHORT $LN37@stbi__pic_

; 5997 :                         count = (stbi_uc)left;

  003c3	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR left$11[rbp]
  003ca	88 85 a4 01 00
	00		 mov	 BYTE PTR count$13[rbp], al
$LN37@stbi__pic_:

; 5998 : 
; 5999 :                     if (!stbi__readval(s, packet->channel, value))  return 0;

  003d0	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  003d7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003db	4c 8d 85 c4 01
	00 00		 lea	 r8, QWORD PTR value$14[rbp]
  003e2	8b d0		 mov	 edx, eax
  003e4	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003eb	e8 00 00 00 00	 call	 stbi__readval
  003f0	48 85 c0	 test	 rax, rax
  003f3	75 07		 jne	 SHORT $LN38@stbi__pic_
  003f5	33 c0		 xor	 eax, eax
  003f7	e9 df 02 00 00	 jmp	 $LN1@stbi__pic_
$LN38@stbi__pic_:

; 6000 : 
; 6001 :                     for (i = 0; i < count; ++i, dest += 4)

  003fc	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR i$12[rbp], 0
  00406	eb 20		 jmp	 SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
  00408	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR i$12[rbp]
  0040e	ff c0		 inc	 eax
  00410	89 85 84 01 00
	00		 mov	 DWORD PTR i$12[rbp], eax
  00416	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR dest$9[rbp]
  0041d	48 83 c0 04	 add	 rax, 4
  00421	48 89 85 28 01
	00 00		 mov	 QWORD PTR dest$9[rbp], rax
$LN20@stbi__pic_:
  00428	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR count$13[rbp]
  0042f	39 85 84 01 00
	00		 cmp	 DWORD PTR i$12[rbp], eax
  00435	7d 22		 jge	 SHORT $LN19@stbi__pic_

; 6002 :                         stbi__copyval(packet->channel, dest, value);

  00437	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  0043e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00442	4c 8d 85 c4 01
	00 00		 lea	 r8, QWORD PTR value$14[rbp]
  00449	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR dest$9[rbp]
  00450	8b c8		 mov	 ecx, eax
  00452	e8 00 00 00 00	 call	 stbi__copyval
  00457	eb af		 jmp	 SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 6003 :                     left -= count;

  00459	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR count$13[rbp]
  00460	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR left$11[rbp]
  00466	2b c8		 sub	 ecx, eax
  00468	8b c1		 mov	 eax, ecx
  0046a	89 85 64 01 00
	00		 mov	 DWORD PTR left$11[rbp], eax

; 6004 :                 }

  00470	e9 dc fe ff ff	 jmp	 $LN16@stbi__pic_
$LN17@stbi__pic_:

; 6005 :             }
; 6006 :             break;

  00475	e9 50 02 00 00	 jmp	 $LN11@stbi__pic_
$LN39@stbi__pic_:

; 6007 : 
; 6008 :             case 2: {//Mixed RLE
; 6009 :                 int left = width;

  0047a	8b 85 18 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  00480	89 85 e4 01 00
	00		 mov	 DWORD PTR left$15[rbp], eax
$LN21@stbi__pic_:

; 6010 :                 while (left > 0) {

  00486	83 bd e4 01 00
	00 00		 cmp	 DWORD PTR left$15[rbp], 0
  0048d	0f 8e 37 02 00
	00		 jle	 $LN22@stbi__pic_

; 6011 :                     int count = stbi__get8(s), i;

  00493	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0049a	e8 00 00 00 00	 call	 stbi__get8
  0049f	0f b6 c0	 movzx	 eax, al
  004a2	89 85 04 02 00
	00		 mov	 DWORD PTR count$16[rbp], eax

; 6012 :                     if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

  004a8	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004af	e8 00 00 00 00	 call	 stbi__at_eof
  004b4	85 c0		 test	 eax, eax
  004b6	74 34		 je	 SHORT $LN40@stbi__pic_
  004b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  004bf	e8 00 00 00 00	 call	 stbi__err
  004c4	85 c0		 test	 eax, eax
  004c6	74 0d		 je	 SHORT $LN62@stbi__pic_
  004c8	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv207[rbp], 0
  004d3	eb 0b		 jmp	 SHORT $LN63@stbi__pic_
$LN62@stbi__pic_:
  004d5	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv207[rbp], 0
$LN63@stbi__pic_:
  004e0	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv207[rbp]
  004e7	e9 ef 01 00 00	 jmp	 $LN1@stbi__pic_
$LN40@stbi__pic_:

; 6013 : 
; 6014 :                     if (count >= 128) { // Repeated

  004ec	81 bd 04 02 00
	00 80 00 00 00	 cmp	 DWORD PTR count$16[rbp], 128 ; 00000080H
  004f6	0f 8c fe 00 00
	00		 jl	 $LN41@stbi__pic_

; 6015 :                         stbi_uc value[4];
; 6016 : 
; 6017 :                         if (count == 128)

  004fc	81 bd 04 02 00
	00 80 00 00 00	 cmp	 DWORD PTR count$16[rbp], 128 ; 00000080H
  00506	75 14		 jne	 SHORT $LN43@stbi__pic_

; 6018 :                             count = stbi__get16be(s);

  00508	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0050f	e8 00 00 00 00	 call	 stbi__get16be
  00514	89 85 04 02 00
	00		 mov	 DWORD PTR count$16[rbp], eax
  0051a	eb 0f		 jmp	 SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6019 :                         else
; 6020 :                             count -= 127;

  0051c	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR count$16[rbp]
  00522	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00525	89 85 04 02 00
	00		 mov	 DWORD PTR count$16[rbp], eax
$LN44@stbi__pic_:

; 6021 :                         if (count > left)

  0052b	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR left$15[rbp]
  00531	39 85 04 02 00
	00		 cmp	 DWORD PTR count$16[rbp], eax
  00537	7e 34		 jle	 SHORT $LN45@stbi__pic_

; 6022 :                             return stbi__errpuc("bad file", "scanline overrun");

  00539	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00540	e8 00 00 00 00	 call	 stbi__err
  00545	85 c0		 test	 eax, eax
  00547	74 0d		 je	 SHORT $LN64@stbi__pic_
  00549	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv217[rbp], 0
  00554	eb 0b		 jmp	 SHORT $LN65@stbi__pic_
$LN64@stbi__pic_:
  00556	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv217[rbp], 0
$LN65@stbi__pic_:
  00561	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv217[rbp]
  00568	e9 6e 01 00 00	 jmp	 $LN1@stbi__pic_
$LN45@stbi__pic_:

; 6023 : 
; 6024 :                         if (!stbi__readval(s, packet->channel, value))

  0056d	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  00574	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00578	4c 8d 85 44 02
	00 00		 lea	 r8, QWORD PTR value$18[rbp]
  0057f	8b d0		 mov	 edx, eax
  00581	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00588	e8 00 00 00 00	 call	 stbi__readval
  0058d	48 85 c0	 test	 rax, rax
  00590	75 07		 jne	 SHORT $LN46@stbi__pic_

; 6025 :                             return 0;

  00592	33 c0		 xor	 eax, eax
  00594	e9 42 01 00 00	 jmp	 $LN1@stbi__pic_
$LN46@stbi__pic_:

; 6026 : 
; 6027 :                         for (i = 0; i < count; ++i, dest += 4)

  00599	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$17[rbp], 0
  005a3	eb 20		 jmp	 SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
  005a5	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$17[rbp]
  005ab	ff c0		 inc	 eax
  005ad	89 85 24 02 00
	00		 mov	 DWORD PTR i$17[rbp], eax
  005b3	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR dest$9[rbp]
  005ba	48 83 c0 04	 add	 rax, 4
  005be	48 89 85 28 01
	00 00		 mov	 QWORD PTR dest$9[rbp], rax
$LN25@stbi__pic_:
  005c5	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR count$16[rbp]
  005cb	39 85 24 02 00
	00		 cmp	 DWORD PTR i$17[rbp], eax
  005d1	7d 22		 jge	 SHORT $LN24@stbi__pic_

; 6028 :                             stbi__copyval(packet->channel, dest, value);

  005d3	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  005da	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005de	4c 8d 85 44 02
	00 00		 lea	 r8, QWORD PTR value$18[rbp]
  005e5	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR dest$9[rbp]
  005ec	8b c8		 mov	 ecx, eax
  005ee	e8 00 00 00 00	 call	 stbi__copyval
  005f3	eb b0		 jmp	 SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 6029 :                     }

  005f5	e9 b5 00 00 00	 jmp	 $LN42@stbi__pic_
$LN41@stbi__pic_:

; 6030 :                     else { // Raw
; 6031 :                         ++count;

  005fa	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR count$16[rbp]
  00600	ff c0		 inc	 eax
  00602	89 85 04 02 00
	00		 mov	 DWORD PTR count$16[rbp], eax

; 6032 :                         if (count > left) return stbi__errpuc("bad file", "scanline overrun");

  00608	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR left$15[rbp]
  0060e	39 85 04 02 00
	00		 cmp	 DWORD PTR count$16[rbp], eax
  00614	7e 34		 jle	 SHORT $LN47@stbi__pic_
  00616	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  0061d	e8 00 00 00 00	 call	 stbi__err
  00622	85 c0		 test	 eax, eax
  00624	74 0d		 je	 SHORT $LN66@stbi__pic_
  00626	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv238[rbp], 0
  00631	eb 0b		 jmp	 SHORT $LN67@stbi__pic_
$LN66@stbi__pic_:
  00633	48 c7 85 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR tv238[rbp], 0
$LN67@stbi__pic_:
  0063e	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv238[rbp]
  00645	e9 91 00 00 00	 jmp	 $LN1@stbi__pic_
$LN47@stbi__pic_:

; 6033 : 
; 6034 :                         for (i = 0; i < count; ++i, dest += 4)

  0064a	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$17[rbp], 0
  00654	eb 20		 jmp	 SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
  00656	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$17[rbp]
  0065c	ff c0		 inc	 eax
  0065e	89 85 24 02 00
	00		 mov	 DWORD PTR i$17[rbp], eax
  00664	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR dest$9[rbp]
  0066b	48 83 c0 04	 add	 rax, 4
  0066f	48 89 85 28 01
	00 00		 mov	 QWORD PTR dest$9[rbp], rax
$LN28@stbi__pic_:
  00676	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR count$16[rbp]
  0067c	39 85 24 02 00
	00		 cmp	 DWORD PTR i$17[rbp], eax
  00682	7d 2b		 jge	 SHORT $LN27@stbi__pic_

; 6035 :                             if (!stbi__readval(s, packet->channel, dest))

  00684	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR packet$8[rbp]
  0068b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0068f	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR dest$9[rbp]
  00696	8b d0		 mov	 edx, eax
  00698	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0069f	e8 00 00 00 00	 call	 stbi__readval
  006a4	48 85 c0	 test	 rax, rax
  006a7	75 04		 jne	 SHORT $LN48@stbi__pic_

; 6036 :                                 return 0;

  006a9	33 c0		 xor	 eax, eax
  006ab	eb 2e		 jmp	 SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
  006ad	eb a7		 jmp	 SHORT $LN26@stbi__pic_
$LN27@stbi__pic_:
$LN42@stbi__pic_:

; 6037 :                     }
; 6038 :                     left -= count;

  006af	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR count$16[rbp]
  006b5	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR left$15[rbp]
  006bb	2b c8		 sub	 ecx, eax
  006bd	8b c1		 mov	 eax, ecx
  006bf	89 85 e4 01 00
	00		 mov	 DWORD PTR left$15[rbp], eax

; 6039 :                 }

  006c5	e9 bc fd ff ff	 jmp	 $LN21@stbi__pic_
$LN22@stbi__pic_:
$LN11@stbi__pic_:

; 6040 :                 break;
; 6041 :             }
; 6042 :             }
; 6043 :         }

  006ca	e9 47 fb ff ff	 jmp	 $LN8@stbi__pic_
$LN9@stbi__pic_:

; 6044 :     }

  006cf	e9 1f fb ff ff	 jmp	 $LN5@stbi__pic_
$LN6@stbi__pic_:

; 6045 : 
; 6046 :     return result;

  006d4	48 8b 85 30 04
	00 00		 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__pic_:

; 6047 : }

  006db	48 8b f8	 mov	 rdi, rax
  006de	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  006e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_load_core$rtcFrameData
  006e9	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  006ee	48 8b c7	 mov	 rax, rdi
  006f1	48 8b 8d e0 03
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  006f8	48 33 cd	 xor	 rcx, rbp
  006fb	e8 00 00 00 00	 call	 __security_check_cookie
  00700	48 8d a5 f8 03
	00 00		 lea	 rsp, QWORD PTR [rbp+1016]
  00707	5f		 pop	 rdi
  00708	5d		 pop	 rbp
  00709	c3		 ret	 0
stbi__pic_load_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__copyval
_TEXT	SEGMENT
mask$ = 4
i$ = 36
channel$ = 288
dest$ = 296
src$ = 304
stbi__copyval PROC					; COMDAT

; 5930 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5931 :     int mask = 0x80, i;

  00028	c7 45 04 80 00
	00 00		 mov	 DWORD PTR mask$[rbp], 128 ; 00000080H

; 5932 : 
; 5933 :     for (i = 0; i < 4; ++i, mask >>= 1)

  0002f	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00036	eb 10		 jmp	 SHORT $LN4@stbi__copy
$LN2@stbi__copy:
  00038	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0003b	ff c0		 inc	 eax
  0003d	89 45 24	 mov	 DWORD PTR i$[rbp], eax
  00040	8b 45 04	 mov	 eax, DWORD PTR mask$[rbp]
  00043	d1 f8		 sar	 eax, 1
  00045	89 45 04	 mov	 DWORD PTR mask$[rbp], eax
$LN4@stbi__copy:
  00048	83 7d 24 04	 cmp	 DWORD PTR i$[rbp], 4
  0004c	7d 31		 jge	 SHORT $LN3@stbi__copy

; 5934 :         if (channel & mask)

  0004e	8b 45 04	 mov	 eax, DWORD PTR mask$[rbp]
  00051	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR channel$[rbp]
  00057	23 c8		 and	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	85 c0		 test	 eax, eax
  0005d	74 1e		 je	 SHORT $LN5@stbi__copy

; 5935 :             dest[i] = src[i];

  0005f	48 63 45 24	 movsxd	 rax, DWORD PTR i$[rbp]
  00063	48 63 4d 24	 movsxd	 rcx, DWORD PTR i$[rbp]
  00067	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR dest$[rbp]
  0006e	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR src$[rbp]
  00075	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0007a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__copy:
  0007d	eb b9		 jmp	 SHORT $LN2@stbi__copy
$LN3@stbi__copy:

; 5936 : }

  0007f	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00086	5f		 pop	 rdi
  00087	5d		 pop	 rbp
  00088	c3		 ret	 0
stbi__copyval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__readval
_TEXT	SEGMENT
mask$ = 4
i$ = 36
tv75 = 248
s$ = 288
channel$ = 296
dest$ = 304
stbi__readval PROC					; COMDAT

; 5916 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5917 :     int mask = 0x80, i;

  00028	c7 45 04 80 00
	00 00		 mov	 DWORD PTR mask$[rbp], 128 ; 00000080H

; 5918 : 
; 5919 :     for (i = 0; i < 4; ++i, mask >>= 1) {

  0002f	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00036	eb 10		 jmp	 SHORT $LN4@stbi__read
$LN2@stbi__read:
  00038	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0003b	ff c0		 inc	 eax
  0003d	89 45 24	 mov	 DWORD PTR i$[rbp], eax
  00040	8b 45 04	 mov	 eax, DWORD PTR mask$[rbp]
  00043	d1 f8		 sar	 eax, 1
  00045	89 45 04	 mov	 DWORD PTR mask$[rbp], eax
$LN4@stbi__read:
  00048	83 7d 24 04	 cmp	 DWORD PTR i$[rbp], 4
  0004c	7d 71		 jge	 SHORT $LN3@stbi__read

; 5920 :         if (channel & mask) {

  0004e	8b 45 04	 mov	 eax, DWORD PTR mask$[rbp]
  00051	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR channel$[rbp]
  00057	23 c8		 and	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	85 c0		 test	 eax, eax
  0005d	74 5b		 je	 SHORT $LN5@stbi__read

; 5921 :             if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");

  0005f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00066	e8 00 00 00 00	 call	 stbi__at_eof
  0006b	85 c0		 test	 eax, eax
  0006d	74 31		 je	 SHORT $LN6@stbi__read
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00076	e8 00 00 00 00	 call	 stbi__err
  0007b	85 c0		 test	 eax, eax
  0007d	74 0d		 je	 SHORT $LN8@stbi__read
  0007f	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
  0008a	eb 0b		 jmp	 SHORT $LN9@stbi__read
$LN8@stbi__read:
  0008c	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
$LN9@stbi__read:
  00097	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv75[rbp]
  0009e	eb 26		 jmp	 SHORT $LN1@stbi__read
$LN6@stbi__read:

; 5922 :             dest[i] = stbi__get8(s);

  000a0	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a7	e8 00 00 00 00	 call	 stbi__get8
  000ac	48 63 4d 24	 movsxd	 rcx, DWORD PTR i$[rbp]
  000b0	48 8b 95 30 01
	00 00		 mov	 rdx, QWORD PTR dest$[rbp]
  000b7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__read:

; 5923 :         }
; 5924 :     }

  000ba	e9 79 ff ff ff	 jmp	 $LN2@stbi__read
$LN3@stbi__read:

; 5925 : 
; 5926 :     return dest;

  000bf	48 8b 85 30 01
	00 00		 mov	 rax, QWORD PTR dest$[rbp]
$LN1@stbi__read:

; 5927 : }

  000c6	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000cd	5f		 pop	 rdi
  000ce	5d		 pop	 rbp
  000cf	c3		 ret	 0
stbi__readval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_test_core
_TEXT	SEGMENT
i$ = 4
s$ = 256
stbi__pic_test_core PROC				; COMDAT

; 5895 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5896 :     int i;
; 5897 : 
; 5898 :     if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
  00026	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002d	e8 00 00 00 00	 call	 stbi__pic_is4
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN5@stbi__pic_

; 5899 :         return 0;

  00036	33 c0		 xor	 eax, eax
  00038	eb 45		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:

; 5900 : 
; 5901 :     for (i = 0; i < 84; ++i)

  0003a	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00041	eb 08		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00043	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00046	ff c0		 inc	 eax
  00048	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__pic_:
  0004b	83 7d 04 54	 cmp	 DWORD PTR i$[rbp], 84	; 00000054H
  0004f	7d 0e		 jge	 SHORT $LN3@stbi__pic_

; 5902 :         stbi__get8(s);

  00051	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00058	e8 00 00 00 00	 call	 stbi__get8
  0005d	eb e4		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 5903 : 
; 5904 :     if (!stbi__pic_is4(s, "PICT"))

  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
  00066	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006d	e8 00 00 00 00	 call	 stbi__pic_is4
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN6@stbi__pic_

; 5905 :         return 0;

  00076	33 c0		 xor	 eax, eax
  00078	eb 05		 jmp	 SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 5906 : 
; 5907 :     return 1;

  0007a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 5908 : }

  0007f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00086	5f		 pop	 rdi
  00087	5d		 pop	 rbp
  00088	c3		 ret	 0
stbi__pic_test_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_is4
_TEXT	SEGMENT
i$ = 4
s$ = 256
str$ = 264
stbi__pic_is4 PROC					; COMDAT

; 5885 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5886 :     int i;
; 5887 :     for (i = 0; i < 4; ++i)

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0002d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00030	ff c0		 inc	 eax
  00032	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__pic_:
  00035	83 7d 04 04	 cmp	 DWORD PTR i$[rbp], 4
  00039	7d 28		 jge	 SHORT $LN3@stbi__pic_

; 5888 :         if (stbi__get8(s) != (stbi_uc)str[i])

  0003b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00042	e8 00 00 00 00	 call	 stbi__get8
  00047	0f b6 c0	 movzx	 eax, al
  0004a	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  0004e	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  00055	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00059	3b c1		 cmp	 eax, ecx
  0005b	74 04		 je	 SHORT $LN5@stbi__pic_

; 5889 :             return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 07		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
  00061	eb ca		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 5890 : 
; 5891 :     return 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 5892 : }

  00068	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0006f	5f		 pop	 rdi
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
stbi__pic_is4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__psd_decode_rle
_TEXT	SEGMENT
count$ = 4
nleft$ = 36
len$ = 68
val$1 = 100
s$ = 352
p$ = 360
pixelCount$ = 368
stbi__psd_decode_rle PROC				; COMDAT

; 5628 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5629 :     int count, nleft, len;
; 5630 : 
; 5631 :     count = 0;

  00029	c7 45 04 00 00
	00 00		 mov	 DWORD PTR count$[rbp], 0
$LN2@stbi__psd_:

; 5632 :     while ((nleft = pixelCount - count) > 0) {

  00030	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00033	8b 8d 70 01 00
	00		 mov	 ecx, DWORD PTR pixelCount$[rbp]
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 45 24	 mov	 DWORD PTR nleft$[rbp], eax
  00040	83 7d 24 00	 cmp	 DWORD PTR nleft$[rbp], 0
  00044	0f 8e f6 00 00
	00		 jle	 $LN3@stbi__psd_

; 5633 :         len = stbi__get8(s);

  0004a	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00051	e8 00 00 00 00	 call	 stbi__get8
  00056	0f b6 c0	 movzx	 eax, al
  00059	89 45 44	 mov	 DWORD PTR len$[rbp], eax

; 5634 :         if (len == 128) {

  0005c	81 7d 44 80 00
	00 00		 cmp	 DWORD PTR len$[rbp], 128 ; 00000080H
  00063	75 05		 jne	 SHORT $LN8@stbi__psd_

; 5635 :             // No-op.
; 5636 :         }

  00065	e9 d1 00 00 00	 jmp	 $LN9@stbi__psd_
$LN8@stbi__psd_:

; 5637 :         else if (len < 128) {

  0006a	81 7d 44 80 00
	00 00		 cmp	 DWORD PTR len$[rbp], 128 ; 00000080H
  00071	7d 5d		 jge	 SHORT $LN10@stbi__psd_

; 5638 :             // Copy next len+1 bytes literally.
; 5639 :             len++;

  00073	8b 45 44	 mov	 eax, DWORD PTR len$[rbp]
  00076	ff c0		 inc	 eax
  00078	89 45 44	 mov	 DWORD PTR len$[rbp], eax

; 5640 :             if (len > nleft) return 0; // corrupt data

  0007b	8b 45 24	 mov	 eax, DWORD PTR nleft$[rbp]
  0007e	39 45 44	 cmp	 DWORD PTR len$[rbp], eax
  00081	7e 07		 jle	 SHORT $LN12@stbi__psd_
  00083	33 c0		 xor	 eax, eax
  00085	e9 bb 00 00 00	 jmp	 $LN1@stbi__psd_
$LN12@stbi__psd_:

; 5641 :             count += len;

  0008a	8b 45 44	 mov	 eax, DWORD PTR len$[rbp]
  0008d	8b 4d 04	 mov	 ecx, DWORD PTR count$[rbp]
  00090	03 c8		 add	 ecx, eax
  00092	8b c1		 mov	 eax, ecx
  00094	89 45 04	 mov	 DWORD PTR count$[rbp], eax
$LN4@stbi__psd_:

; 5642 :             while (len) {

  00097	83 7d 44 00	 cmp	 DWORD PTR len$[rbp], 0
  0009b	74 31		 je	 SHORT $LN5@stbi__psd_

; 5643 :                 *p = stbi__get8(s);

  0009d	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a4	e8 00 00 00 00	 call	 stbi__get8
  000a9	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  000b0	88 01		 mov	 BYTE PTR [rcx], al

; 5644 :                 p += 4;

  000b2	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  000b9	48 83 c0 04	 add	 rax, 4
  000bd	48 89 85 68 01
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 5645 :                 len--;

  000c4	8b 45 44	 mov	 eax, DWORD PTR len$[rbp]
  000c7	ff c8		 dec	 eax
  000c9	89 45 44	 mov	 DWORD PTR len$[rbp], eax

; 5646 :             }

  000cc	eb c9		 jmp	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 5647 :         }

  000ce	eb 6b		 jmp	 SHORT $LN11@stbi__psd_
$LN10@stbi__psd_:

; 5648 :         else if (len > 128) {

  000d0	81 7d 44 80 00
	00 00		 cmp	 DWORD PTR len$[rbp], 128 ; 00000080H
  000d7	7e 62		 jle	 SHORT $LN13@stbi__psd_

; 5649 :             stbi_uc   val;
; 5650 :             // Next -len+1 bytes in the dest are replicated from next source byte.
; 5651 :             // (Interpret len as a negative 8-bit int.)
; 5652 :             len = 257 - len;

  000d9	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  000de	2b 45 44	 sub	 eax, DWORD PTR len$[rbp]
  000e1	89 45 44	 mov	 DWORD PTR len$[rbp], eax

; 5653 :             if (len > nleft) return 0; // corrupt data

  000e4	8b 45 24	 mov	 eax, DWORD PTR nleft$[rbp]
  000e7	39 45 44	 cmp	 DWORD PTR len$[rbp], eax
  000ea	7e 04		 jle	 SHORT $LN14@stbi__psd_
  000ec	33 c0		 xor	 eax, eax
  000ee	eb 55		 jmp	 SHORT $LN1@stbi__psd_
$LN14@stbi__psd_:

; 5654 :             val = stbi__get8(s);

  000f0	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f7	e8 00 00 00 00	 call	 stbi__get8
  000fc	88 45 64	 mov	 BYTE PTR val$1[rbp], al

; 5655 :             count += len;

  000ff	8b 45 44	 mov	 eax, DWORD PTR len$[rbp]
  00102	8b 4d 04	 mov	 ecx, DWORD PTR count$[rbp]
  00105	03 c8		 add	 ecx, eax
  00107	8b c1		 mov	 eax, ecx
  00109	89 45 04	 mov	 DWORD PTR count$[rbp], eax
$LN6@stbi__psd_:

; 5656 :             while (len) {

  0010c	83 7d 44 00	 cmp	 DWORD PTR len$[rbp], 0
  00110	74 29		 je	 SHORT $LN7@stbi__psd_

; 5657 :                 *p = val;

  00112	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00119	0f b6 4d 64	 movzx	 ecx, BYTE PTR val$1[rbp]
  0011d	88 08		 mov	 BYTE PTR [rax], cl

; 5658 :                 p += 4;

  0011f	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00126	48 83 c0 04	 add	 rax, 4
  0012a	48 89 85 68 01
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 5659 :                 len--;

  00131	8b 45 44	 mov	 eax, DWORD PTR len$[rbp]
  00134	ff c8		 dec	 eax
  00136	89 45 44	 mov	 DWORD PTR len$[rbp], eax

; 5660 :             }

  00139	eb d1		 jmp	 SHORT $LN6@stbi__psd_
$LN7@stbi__psd_:
$LN13@stbi__psd_:
$LN11@stbi__psd_:
$LN9@stbi__psd_:

; 5661 :         }
; 5662 :     }

  0013b	e9 f0 fe ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 5663 : 
; 5664 :     return 1;

  00140	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 5665 : }

  00145	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  0014c	5f		 pop	 rdi
  0014d	5d		 pop	 rbp
  0014e	c3		 ret	 0
stbi__psd_decode_rle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__tga_read_rgb16
_TEXT	SEGMENT
px$ = 4
fiveBitMask$ = 36
r$ = 68
g$ = 100
b$ = 132
s$ = 384
out$ = 392
stbi__tga_read_rgb16 PROC				; COMDAT

; 5386 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5387 :     stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

  00024	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002b	e8 00 00 00 00	 call	 stbi__get16le
  00030	66 89 45 04	 mov	 WORD PTR px$[rbp], ax

; 5388 :     stbi__uint16 fiveBitMask = 31;

  00034	b8 1f 00 00 00	 mov	 eax, 31
  00039	66 89 45 24	 mov	 WORD PTR fiveBitMask$[rbp], ax

; 5389 :     // we have 3 channels with 5bits each
; 5390 :     int r = (px >> 10) & fiveBitMask;

  0003d	0f b7 45 04	 movzx	 eax, WORD PTR px$[rbp]
  00041	c1 f8 0a	 sar	 eax, 10
  00044	0f b7 4d 24	 movzx	 ecx, WORD PTR fiveBitMask$[rbp]
  00048	23 c1		 and	 eax, ecx
  0004a	89 45 44	 mov	 DWORD PTR r$[rbp], eax

; 5391 :     int g = (px >> 5) & fiveBitMask;

  0004d	0f b7 45 04	 movzx	 eax, WORD PTR px$[rbp]
  00051	c1 f8 05	 sar	 eax, 5
  00054	0f b7 4d 24	 movzx	 ecx, WORD PTR fiveBitMask$[rbp]
  00058	23 c1		 and	 eax, ecx
  0005a	89 45 64	 mov	 DWORD PTR g$[rbp], eax

; 5392 :     int b = px & fiveBitMask;

  0005d	0f b7 45 04	 movzx	 eax, WORD PTR px$[rbp]
  00061	0f b7 4d 24	 movzx	 ecx, WORD PTR fiveBitMask$[rbp]
  00065	23 c1		 and	 eax, ecx
  00067	89 85 84 00 00
	00		 mov	 DWORD PTR b$[rbp], eax

; 5393 :     // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5394 :     out[0] = (stbi_uc)((r * 255) / 31);

  0006d	69 45 44 ff 00
	00 00		 imul	 eax, DWORD PTR r$[rbp], 255 ; 000000ffH
  00074	99		 cdq
  00075	b9 1f 00 00 00	 mov	 ecx, 31
  0007a	f7 f9		 idiv	 ecx
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	48 6b c9 00	 imul	 rcx, rcx, 0
  00085	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0008c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5395 :     out[1] = (stbi_uc)((g * 255) / 31);

  0008f	69 45 64 ff 00
	00 00		 imul	 eax, DWORD PTR g$[rbp], 255 ; 000000ffH
  00096	99		 cdq
  00097	b9 1f 00 00 00	 mov	 ecx, 31
  0009c	f7 f9		 idiv	 ecx
  0009e	b9 01 00 00 00	 mov	 ecx, 1
  000a3	48 6b c9 01	 imul	 rcx, rcx, 1
  000a7	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  000ae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5396 :     out[2] = (stbi_uc)((b * 255) / 31);

  000b1	69 85 84 00 00
	00 ff 00 00 00	 imul	 eax, DWORD PTR b$[rbp], 255 ; 000000ffH
  000bb	99		 cdq
  000bc	b9 1f 00 00 00	 mov	 ecx, 31
  000c1	f7 f9		 idiv	 ecx
  000c3	b9 01 00 00 00	 mov	 ecx, 1
  000c8	48 6b c9 02	 imul	 rcx, rcx, 2
  000cc	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  000d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5397 : 
; 5398 :     // some people claim that the most significant bit might be used for alpha
; 5399 :     // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5400 :     // but that only made 16bit test images completely translucent..
; 5401 :     // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5402 : }

  000d6	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  000dd	5f		 pop	 rdi
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
stbi__tga_read_rgb16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__tga_get_comp
_TEXT	SEGMENT
tv65 = 192
bits_per_pixel$ = 240
is_grey$ = 248
is_rgb16$ = 256
stbi__tga_get_comp PROC					; COMDAT

; 5270 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5271 :     // only RGB or RGBA (incl. 16bit) or grey allowed
; 5272 :     if (is_rgb16) *is_rgb16 = 0;

  00027	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR is_rgb16$[rbp], 0
  0002f	74 0d		 je	 SHORT $LN4@stbi__tga_
  00031	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR is_rgb16$[rbp]
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@stbi__tga_:

; 5273 :     switch (bits_per_pixel) {

  0003e	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR bits_per_pixel$[rbp]
  00044	89 85 c0 00 00
	00		 mov	 DWORD PTR tv65[rbp], eax
  0004a	83 bd c0 00 00
	00 08		 cmp	 DWORD PTR tv65[rbp], 8
  00051	74 26		 je	 SHORT $LN5@stbi__tga_
  00053	83 bd c0 00 00
	00 0f		 cmp	 DWORD PTR tv65[rbp], 15
  0005a	74 34		 je	 SHORT $LN8@stbi__tga_
  0005c	83 bd c0 00 00
	00 10		 cmp	 DWORD PTR tv65[rbp], 16
  00063	74 1b		 je	 SHORT $LN6@stbi__tga_
  00065	83 bd c0 00 00
	00 18		 cmp	 DWORD PTR tv65[rbp], 24
  0006c	74 40		 je	 SHORT $LN10@stbi__tga_
  0006e	83 bd c0 00 00
	00 20		 cmp	 DWORD PTR tv65[rbp], 32	; 00000020H
  00075	74 37		 je	 SHORT $LN11@stbi__tga_
  00077	eb 46		 jmp	 SHORT $LN12@stbi__tga_
$LN5@stbi__tga_:

; 5274 :     case 8:  return STBI_grey;

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	eb 41		 jmp	 SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5275 :     case 16: if (is_grey) return STBI_grey_alpha;

  00080	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR is_grey$[rbp], 0
  00087	74 07		 je	 SHORT $LN7@stbi__tga_
  00089	b8 02 00 00 00	 mov	 eax, 2
  0008e	eb 31		 jmp	 SHORT $LN1@stbi__tga_
$LN7@stbi__tga_:
$LN8@stbi__tga_:

; 5276 :         // fallthrough
; 5277 :     case 15: if (is_rgb16) *is_rgb16 = 1;

  00090	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR is_rgb16$[rbp], 0
  00098	74 0d		 je	 SHORT $LN9@stbi__tga_
  0009a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR is_rgb16$[rbp]
  000a1	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN9@stbi__tga_:

; 5278 :         return STBI_rgb;

  000a7	b8 03 00 00 00	 mov	 eax, 3
  000ac	eb 13		 jmp	 SHORT $LN1@stbi__tga_
$LN10@stbi__tga_:
$LN11@stbi__tga_:

; 5279 :     case 24: // fallthrough
; 5280 :     case 32: return bits_per_pixel / 8;

  000ae	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR bits_per_pixel$[rbp]
  000b4	99		 cdq
  000b5	83 e2 07	 and	 edx, 7
  000b8	03 c2		 add	 eax, edx
  000ba	c1 f8 03	 sar	 eax, 3
  000bd	eb 02		 jmp	 SHORT $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5281 :     default: return 0;

  000bf	33 c0		 xor	 eax, eax
$LN1@stbi__tga_:

; 5282 :     }
; 5283 : }

  000c1	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000c8	5f		 pop	 rdi
  000c9	5d		 pop	 rbp
  000ca	c3		 ret	 0
stbi__tga_get_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_parse_header
_TEXT	SEGMENT
hsz$ = 4
compress$1 = 36
i$2 = 68
tv234 = 280
tv228 = 280
tv224 = 280
tv182 = 280
tv173 = 280
tv168 = 280
tv156 = 280
tv136 = 280
tv95 = 280
tv75 = 280
s$ = 320
info$ = 328
stbi__bmp_parse_header PROC				; COMDAT

; 4970 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4971 :     int hsz;
; 4972 :     if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

  00024	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002b	e8 00 00 00 00	 call	 stbi__get8
  00030	0f b6 c0	 movzx	 eax, al
  00033	83 f8 42	 cmp	 eax, 66			; 00000042H
  00036	75 14		 jne	 SHORT $LN6@stbi__bmp_
  00038	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003f	e8 00 00 00 00	 call	 stbi__get8
  00044	0f b6 c0	 movzx	 eax, al
  00047	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0004a	74 34		 je	 SHORT $LN5@stbi__bmp_
$LN6@stbi__bmp_:
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IANEBNLB@not?5BMP@
  00053	e8 00 00 00 00	 call	 stbi__err
  00058	85 c0		 test	 eax, eax
  0005a	74 0d		 je	 SHORT $LN32@stbi__bmp_
  0005c	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
  00067	eb 0b		 jmp	 SHORT $LN33@stbi__bmp_
$LN32@stbi__bmp_:
  00069	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
$LN33@stbi__bmp_:
  00074	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv75[rbp]
  0007b	e9 9b 05 00 00	 jmp	 $LN1@stbi__bmp_
$LN5@stbi__bmp_:

; 4973 :     stbi__get32le(s); // discard filesize

  00080	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00087	e8 00 00 00 00	 call	 stbi__get32le

; 4974 :     stbi__get16le(s); // discard reserved

  0008c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00093	e8 00 00 00 00	 call	 stbi__get16le

; 4975 :     stbi__get16le(s); // discard reserved

  00098	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009f	e8 00 00 00 00	 call	 stbi__get16le

; 4976 :     info->offset = stbi__get32le(s);

  000a4	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ab	e8 00 00 00 00	 call	 stbi__get32le
  000b0	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  000b7	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 4977 :     info->hsz = hsz = stbi__get32le(s);

  000ba	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c1	e8 00 00 00 00	 call	 stbi__get32le
  000c6	89 45 04	 mov	 DWORD PTR hsz$[rbp], eax
  000c9	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000d0	8b 4d 04	 mov	 ecx, DWORD PTR hsz$[rbp]
  000d3	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 4978 :     info->mr = info->mg = info->mb = info->ma = 0;

  000d6	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000dd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000e4	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000eb	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000f2	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000f9	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  00100	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00107	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 4979 :     info->extra_read = 14;

  0010e	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00115	c7 40 20 0e 00
	00 00		 mov	 DWORD PTR [rax+32], 14

; 4980 : 
; 4981 :     if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

  0011c	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00123	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00127	7d 34		 jge	 SHORT $LN7@stbi__bmp_
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  00130	e8 00 00 00 00	 call	 stbi__err
  00135	85 c0		 test	 eax, eax
  00137	74 0d		 je	 SHORT $LN34@stbi__bmp_
  00139	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv95[rbp], 0
  00144	eb 0b		 jmp	 SHORT $LN35@stbi__bmp_
$LN34@stbi__bmp_:
  00146	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv95[rbp], 0
$LN35@stbi__bmp_:
  00151	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv95[rbp]
  00158	e9 be 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 4982 : 
; 4983 :     if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

  0015d	83 7d 04 0c	 cmp	 DWORD PTR hsz$[rbp], 12
  00161	74 4c		 je	 SHORT $LN8@stbi__bmp_
  00163	83 7d 04 28	 cmp	 DWORD PTR hsz$[rbp], 40	; 00000028H
  00167	74 46		 je	 SHORT $LN8@stbi__bmp_
  00169	83 7d 04 38	 cmp	 DWORD PTR hsz$[rbp], 56	; 00000038H
  0016d	74 40		 je	 SHORT $LN8@stbi__bmp_
  0016f	83 7d 04 6c	 cmp	 DWORD PTR hsz$[rbp], 108 ; 0000006cH
  00173	74 3a		 je	 SHORT $LN8@stbi__bmp_
  00175	83 7d 04 7c	 cmp	 DWORD PTR hsz$[rbp], 124 ; 0000007cH
  00179	74 34		 je	 SHORT $LN8@stbi__bmp_
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KHBIBJBG@unknown?5BMP@
  00182	e8 00 00 00 00	 call	 stbi__err
  00187	85 c0		 test	 eax, eax
  00189	74 0d		 je	 SHORT $LN36@stbi__bmp_
  0018b	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv136[rbp], 0
  00196	eb 0b		 jmp	 SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:
  00198	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv136[rbp], 0
$LN37@stbi__bmp_:
  001a3	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv136[rbp]
  001aa	e9 6c 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN8@stbi__bmp_:

; 4984 :     if (hsz == 12) {

  001af	83 7d 04 0c	 cmp	 DWORD PTR hsz$[rbp], 12
  001b3	75 2d		 jne	 SHORT $LN9@stbi__bmp_

; 4985 :         s->img_x = stbi__get16le(s);

  001b5	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001bc	e8 00 00 00 00	 call	 stbi__get16le
  001c1	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001c8	89 01		 mov	 DWORD PTR [rcx], eax

; 4986 :         s->img_y = stbi__get16le(s);

  001ca	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001d1	e8 00 00 00 00	 call	 stbi__get16le
  001d6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001dd	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 4987 :     }

  001e0	eb 2b		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:

; 4988 :     else {
; 4989 :         s->img_x = stbi__get32le(s);

  001e2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001e9	e8 00 00 00 00	 call	 stbi__get32le
  001ee	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001f5	89 01		 mov	 DWORD PTR [rcx], eax

; 4990 :         s->img_y = stbi__get32le(s);

  001f7	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001fe	e8 00 00 00 00	 call	 stbi__get32le
  00203	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0020a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@stbi__bmp_:

; 4991 :     }
; 4992 :     if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

  0020d	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00214	e8 00 00 00 00	 call	 stbi__get16le
  00219	83 f8 01	 cmp	 eax, 1
  0021c	74 34		 je	 SHORT $LN11@stbi__bmp_
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  00225	e8 00 00 00 00	 call	 stbi__err
  0022a	85 c0		 test	 eax, eax
  0022c	74 0d		 je	 SHORT $LN38@stbi__bmp_
  0022e	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv156[rbp], 0
  00239	eb 0b		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:
  0023b	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv156[rbp], 0
$LN39@stbi__bmp_:
  00246	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv156[rbp]
  0024d	e9 c9 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN11@stbi__bmp_:

; 4993 :     info->bpp = stbi__get16le(s);

  00252	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00259	e8 00 00 00 00	 call	 stbi__get16le
  0025e	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00265	89 01		 mov	 DWORD PTR [rcx], eax

; 4994 :     if (hsz != 12) {

  00267	83 7d 04 0c	 cmp	 DWORD PTR hsz$[rbp], 12
  0026b	0f 84 a5 03 00
	00		 je	 $LN12@stbi__bmp_

; 4995 :         int compress = stbi__get32le(s);

  00271	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00278	e8 00 00 00 00	 call	 stbi__get32le
  0027d	89 45 24	 mov	 DWORD PTR compress$1[rbp], eax

; 4996 :         if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

  00280	83 7d 24 01	 cmp	 DWORD PTR compress$1[rbp], 1
  00284	74 06		 je	 SHORT $LN14@stbi__bmp_
  00286	83 7d 24 02	 cmp	 DWORD PTR compress$1[rbp], 2
  0028a	75 34		 jne	 SHORT $LN13@stbi__bmp_
$LN14@stbi__bmp_:
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IMHMNOIB@BMP?5RLE@
  00293	e8 00 00 00 00	 call	 stbi__err
  00298	85 c0		 test	 eax, eax
  0029a	74 0d		 je	 SHORT $LN40@stbi__bmp_
  0029c	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv168[rbp], 0
  002a7	eb 0b		 jmp	 SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:
  002a9	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv168[rbp], 0
$LN41@stbi__bmp_:
  002b4	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv168[rbp]
  002bb	e9 5b 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN13@stbi__bmp_:

; 4997 :         if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

  002c0	83 7d 24 04	 cmp	 DWORD PTR compress$1[rbp], 4
  002c4	7c 34		 jl	 SHORT $LN15@stbi__bmp_
  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@
  002cd	e8 00 00 00 00	 call	 stbi__err
  002d2	85 c0		 test	 eax, eax
  002d4	74 0d		 je	 SHORT $LN42@stbi__bmp_
  002d6	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv173[rbp], 0
  002e1	eb 0b		 jmp	 SHORT $LN43@stbi__bmp_
$LN42@stbi__bmp_:
  002e3	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv173[rbp], 0
$LN43@stbi__bmp_:
  002ee	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv173[rbp]
  002f5	e9 21 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN15@stbi__bmp_:

; 4998 :         if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel

  002fa	83 7d 24 03	 cmp	 DWORD PTR compress$1[rbp], 3
  002fe	75 4c		 jne	 SHORT $LN16@stbi__bmp_
  00300	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00307	83 38 10	 cmp	 DWORD PTR [rax], 16
  0030a	74 40		 je	 SHORT $LN16@stbi__bmp_
  0030c	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00313	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  00316	74 34		 je	 SHORT $LN16@stbi__bmp_
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  0031f	e8 00 00 00 00	 call	 stbi__err
  00324	85 c0		 test	 eax, eax
  00326	74 0d		 je	 SHORT $LN44@stbi__bmp_
  00328	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv182[rbp], 0
  00333	eb 0b		 jmp	 SHORT $LN45@stbi__bmp_
$LN44@stbi__bmp_:
  00335	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv182[rbp], 0
$LN45@stbi__bmp_:
  00340	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv182[rbp]
  00347	e9 cf 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN16@stbi__bmp_:

; 4999 :         stbi__get32le(s); // discard sizeof

  0034c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00353	e8 00 00 00 00	 call	 stbi__get32le

; 5000 :         stbi__get32le(s); // discard hres

  00358	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0035f	e8 00 00 00 00	 call	 stbi__get32le

; 5001 :         stbi__get32le(s); // discard vres

  00364	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0036b	e8 00 00 00 00	 call	 stbi__get32le

; 5002 :         stbi__get32le(s); // discard colorsused

  00370	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00377	e8 00 00 00 00	 call	 stbi__get32le

; 5003 :         stbi__get32le(s); // discard max important

  0037c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00383	e8 00 00 00 00	 call	 stbi__get32le

; 5004 :         if (hsz == 40 || hsz == 56) {

  00388	83 7d 04 28	 cmp	 DWORD PTR hsz$[rbp], 40	; 00000028H
  0038c	74 0a		 je	 SHORT $LN19@stbi__bmp_
  0038e	83 7d 04 38	 cmp	 DWORD PTR hsz$[rbp], 56	; 00000038H
  00392	0f 85 6a 01 00
	00		 jne	 $LN17@stbi__bmp_
$LN19@stbi__bmp_:

; 5005 :             if (hsz == 56) {

  00398	83 7d 04 38	 cmp	 DWORD PTR hsz$[rbp], 56	; 00000038H
  0039c	75 30		 jne	 SHORT $LN20@stbi__bmp_

; 5006 :                 stbi__get32le(s);

  0039e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003a5	e8 00 00 00 00	 call	 stbi__get32le

; 5007 :                 stbi__get32le(s);

  003aa	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003b1	e8 00 00 00 00	 call	 stbi__get32le

; 5008 :                 stbi__get32le(s);

  003b6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003bd	e8 00 00 00 00	 call	 stbi__get32le

; 5009 :                 stbi__get32le(s);

  003c2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003c9	e8 00 00 00 00	 call	 stbi__get32le
$LN20@stbi__bmp_:

; 5010 :             }
; 5011 :             if (info->bpp == 16 || info->bpp == 32) {

  003ce	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  003d5	83 38 10	 cmp	 DWORD PTR [rax], 16
  003d8	74 10		 je	 SHORT $LN22@stbi__bmp_
  003da	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  003e1	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  003e4	0f 85 13 01 00
	00		 jne	 $LN21@stbi__bmp_
$LN22@stbi__bmp_:

; 5012 :                 if (compress == 0) {

  003ea	83 7d 24 00	 cmp	 DWORD PTR compress$1[rbp], 0
  003ee	75 14		 jne	 SHORT $LN23@stbi__bmp_

; 5013 :                     stbi__bmp_set_mask_defaults(info, compress);

  003f0	8b 55 24	 mov	 edx, DWORD PTR compress$1[rbp]
  003f3	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  003fa	e8 00 00 00 00	 call	 stbi__bmp_set_mask_defaults

; 5014 :                 }

  003ff	e9 f9 00 00 00	 jmp	 $LN24@stbi__bmp_
$LN23@stbi__bmp_:

; 5015 :                 else if (compress == 3) {

  00404	83 7d 24 03	 cmp	 DWORD PTR compress$1[rbp], 3
  00408	0f 85 bb 00 00
	00		 jne	 $LN25@stbi__bmp_

; 5016 :                     info->mr = stbi__get32le(s);

  0040e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00415	e8 00 00 00 00	 call	 stbi__get32le
  0041a	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00421	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5017 :                     info->mg = stbi__get32le(s);

  00424	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0042b	e8 00 00 00 00	 call	 stbi__get32le
  00430	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00437	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5018 :                     info->mb = stbi__get32le(s);

  0043a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00441	e8 00 00 00 00	 call	 stbi__get32le
  00446	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  0044d	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5019 :                     info->extra_read += 12;

  00450	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00457	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0045a	83 c0 0c	 add	 eax, 12
  0045d	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00464	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 5020 :                     // not documented, but generated by photoshop and handled by mspaint
; 5021 :                     if (info->mr == info->mg && info->mg == info->mb) {

  00467	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  0046e	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00475	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00478	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  0047b	75 4a		 jne	 SHORT $LN27@stbi__bmp_
  0047d	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00484	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  0048b	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0048e	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00491	75 34		 jne	 SHORT $LN27@stbi__bmp_

; 5022 :                         // ?!?!?
; 5023 :                         return stbi__errpuc("bad BMP", "bad BMP");

  00493	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  0049a	e8 00 00 00 00	 call	 stbi__err
  0049f	85 c0		 test	 eax, eax
  004a1	74 0d		 je	 SHORT $LN46@stbi__bmp_
  004a3	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv224[rbp], 0
  004ae	eb 0b		 jmp	 SHORT $LN47@stbi__bmp_
$LN46@stbi__bmp_:
  004b0	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv224[rbp], 0
$LN47@stbi__bmp_:
  004bb	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv224[rbp]
  004c2	e9 54 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN27@stbi__bmp_:

; 5024 :                     }
; 5025 :                 }

  004c7	eb 34		 jmp	 SHORT $LN26@stbi__bmp_
$LN25@stbi__bmp_:

; 5026 :                 else
; 5027 :                     return stbi__errpuc("bad BMP", "bad BMP");

  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  004d0	e8 00 00 00 00	 call	 stbi__err
  004d5	85 c0		 test	 eax, eax
  004d7	74 0d		 je	 SHORT $LN48@stbi__bmp_
  004d9	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv228[rbp], 0
  004e4	eb 0b		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:
  004e6	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv228[rbp], 0
$LN49@stbi__bmp_:
  004f1	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv228[rbp]
  004f8	e9 1e 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN26@stbi__bmp_:
$LN24@stbi__bmp_:
$LN21@stbi__bmp_:

; 5028 :             }
; 5029 :         }

  004fd	e9 14 01 00 00	 jmp	 $LN18@stbi__bmp_
$LN17@stbi__bmp_:

; 5030 :         else {
; 5031 :             // V4/V5 header
; 5032 :             int i;
; 5033 :             if (hsz != 108 && hsz != 124)

  00502	83 7d 04 6c	 cmp	 DWORD PTR hsz$[rbp], 108 ; 0000006cH
  00506	74 3a		 je	 SHORT $LN28@stbi__bmp_
  00508	83 7d 04 7c	 cmp	 DWORD PTR hsz$[rbp], 124 ; 0000007cH
  0050c	74 34		 je	 SHORT $LN28@stbi__bmp_

; 5034 :                 return stbi__errpuc("bad BMP", "bad BMP");

  0050e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  00515	e8 00 00 00 00	 call	 stbi__err
  0051a	85 c0		 test	 eax, eax
  0051c	74 0d		 je	 SHORT $LN50@stbi__bmp_
  0051e	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv234[rbp], 0
  00529	eb 0b		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:
  0052b	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv234[rbp], 0
$LN51@stbi__bmp_:
  00536	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv234[rbp]
  0053d	e9 d9 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN28@stbi__bmp_:

; 5035 :             info->mr = stbi__get32le(s);

  00542	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00549	e8 00 00 00 00	 call	 stbi__get32le
  0054e	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00555	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5036 :             info->mg = stbi__get32le(s);

  00558	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0055f	e8 00 00 00 00	 call	 stbi__get32le
  00564	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  0056b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5037 :             info->mb = stbi__get32le(s);

  0056e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00575	e8 00 00 00 00	 call	 stbi__get32le
  0057a	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00581	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5038 :             info->ma = stbi__get32le(s);

  00584	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0058b	e8 00 00 00 00	 call	 stbi__get32le
  00590	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  00597	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 5039 :             if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs

  0059a	83 7d 24 03	 cmp	 DWORD PTR compress$1[rbp], 3
  0059e	74 0f		 je	 SHORT $LN29@stbi__bmp_

; 5040 :                 stbi__bmp_set_mask_defaults(info, compress);

  005a0	8b 55 24	 mov	 edx, DWORD PTR compress$1[rbp]
  005a3	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR info$[rbp]
  005aa	e8 00 00 00 00	 call	 stbi__bmp_set_mask_defaults
$LN29@stbi__bmp_:

; 5041 :             stbi__get32le(s); // discard color space

  005af	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005b6	e8 00 00 00 00	 call	 stbi__get32le

; 5042 :             for (i = 0; i < 12; ++i)

  005bb	c7 45 44 00 00
	00 00		 mov	 DWORD PTR i$2[rbp], 0
  005c2	eb 08		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  005c4	8b 45 44	 mov	 eax, DWORD PTR i$2[rbp]
  005c7	ff c0		 inc	 eax
  005c9	89 45 44	 mov	 DWORD PTR i$2[rbp], eax
$LN4@stbi__bmp_:
  005cc	83 7d 44 0c	 cmp	 DWORD PTR i$2[rbp], 12
  005d0	7d 0e		 jge	 SHORT $LN3@stbi__bmp_

; 5043 :                 stbi__get32le(s); // discard color space parameters

  005d2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005d9	e8 00 00 00 00	 call	 stbi__get32le
  005de	eb e4		 jmp	 SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5044 :             if (hsz == 124) {

  005e0	83 7d 04 7c	 cmp	 DWORD PTR hsz$[rbp], 124 ; 0000007cH
  005e4	75 30		 jne	 SHORT $LN30@stbi__bmp_

; 5045 :                 stbi__get32le(s); // discard rendering intent

  005e6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005ed	e8 00 00 00 00	 call	 stbi__get32le

; 5046 :                 stbi__get32le(s); // discard offset of profile data

  005f2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005f9	e8 00 00 00 00	 call	 stbi__get32le

; 5047 :                 stbi__get32le(s); // discard size of profile data

  005fe	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00605	e8 00 00 00 00	 call	 stbi__get32le

; 5048 :                 stbi__get32le(s); // discard reserved

  0060a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00611	e8 00 00 00 00	 call	 stbi__get32le
$LN30@stbi__bmp_:
$LN18@stbi__bmp_:
$LN12@stbi__bmp_:

; 5049 :             }
; 5050 :         }
; 5051 :     }
; 5052 :     return (void*)1;

  00616	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 5053 : }

  0061b	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00622	5f		 pop	 rdi
  00623	5d		 pop	 rbp
  00624	c3		 ret	 0
stbi__bmp_parse_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_set_mask_defaults
_TEXT	SEGMENT
info$ = 224
compress$ = 232
stbi__bmp_set_mask_defaults PROC			; COMDAT

; 4942 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4943 :     // BI_BITFIELDS specifies masks explicitly, don't override
; 4944 :     if (compress == 3)

  00023	83 bd e8 00 00
	00 03		 cmp	 DWORD PTR compress$[rbp], 3
  0002a	75 0a		 jne	 SHORT $LN2@stbi__bmp_

; 4945 :         return 1;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e9 dd 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 4946 : 
; 4947 :     if (compress == 0) {

  00036	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR compress$[rbp], 0
  0003d	0f 85 ce 00 00
	00		 jne	 $LN3@stbi__bmp_

; 4948 :         if (info->bpp == 16) {

  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  0004a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0004d	75 2f		 jne	 SHORT $LN4@stbi__bmp_

; 4949 :             info->mr = 31u << 10;

  0004f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00056	c7 40 0c 00 7c
	00 00		 mov	 DWORD PTR [rax+12], 31744 ; 00007c00H

; 4950 :             info->mg = 31u << 5;

  0005d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00064	c7 40 10 e0 03
	00 00		 mov	 DWORD PTR [rax+16], 992	; 000003e0H

; 4951 :             info->mb = 31u << 0;

  0006b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00072	c7 40 14 1f 00
	00 00		 mov	 DWORD PTR [rax+20], 31

; 4952 :         }

  00079	e9 8c 00 00 00	 jmp	 $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 4953 :         else if (info->bpp == 32) {

  0007e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00085	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  00088	75 48		 jne	 SHORT $LN6@stbi__bmp_

; 4954 :             info->mr = 0xffu << 16;

  0008a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00091	c7 40 0c 00 00
	ff 00		 mov	 DWORD PTR [rax+12], 16711680 ; 00ff0000H

; 4955 :             info->mg = 0xffu << 8;

  00098	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  0009f	c7 40 10 00 ff
	00 00		 mov	 DWORD PTR [rax+16], 65280 ; 0000ff00H

; 4956 :             info->mb = 0xffu << 0;

  000a6	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000ad	c7 40 14 ff 00
	00 00		 mov	 DWORD PTR [rax+20], 255	; 000000ffH

; 4957 :             info->ma = 0xffu << 24;

  000b4	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000bb	c7 40 18 00 00
	00 ff		 mov	 DWORD PTR [rax+24], -16777216 ; ff000000H

; 4958 :             info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

  000c2	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000c9	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 4959 :         }

  000d0	eb 38		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 4960 :         else {
; 4961 :             // otherwise, use defaults, which is all-0
; 4962 :             info->mr = info->mg = info->mb = info->ma = 0;

  000d2	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000d9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000e0	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000e7	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000ee	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000f5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000fc	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  00103	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 4963 :         }
; 4964 :         return 1;

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	eb 02		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 4965 :     }
; 4966 :     return 0; // error

  00111	33 c0		 xor	 eax, eax
$LN1@stbi__bmp_:

; 4967 : }

  00113	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0011a	5f		 pop	 rdi
  0011b	5d		 pop	 rbp
  0011c	c3		 ret	 0
stbi__bmp_set_mask_defaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__shiftsigned
_TEXT	SEGMENT
v$ = 224
shift$ = 232
bits$ = 240
stbi__shiftsigned PROC					; COMDAT

; 4915 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4916 :     static unsigned int mul_table[9] = {
; 4917 :        0,
; 4918 :        0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 4919 :        0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 4920 :     };
; 4921 :     static unsigned int shift_table[9] = {
; 4922 :        0, 0,0,1,0,2,4,6,0,
; 4923 :     };
; 4924 :     if (shift < 0)

  00027	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR shift$[rbp], 0
  0002e	7d 1b		 jge	 SHORT $LN2@stbi__shif

; 4925 :         v <<= -shift;

  00030	8b 85 e8 00 00
	00		 mov	 eax, DWORD PTR shift$[rbp]
  00036	f7 d8		 neg	 eax
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR v$[rbp]
  00041	d3 e0		 shl	 eax, cl
  00043	89 85 e0 00 00
	00		 mov	 DWORD PTR v$[rbp], eax
  00049	eb 17		 jmp	 SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 4926 :     else
; 4927 :         v >>= shift;

  0004b	8b 85 e8 00 00
	00		 mov	 eax, DWORD PTR shift$[rbp]
  00051	0f b6 c8	 movzx	 ecx, al
  00054	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR v$[rbp]
  0005a	d3 e8		 shr	 eax, cl
  0005c	89 85 e0 00 00
	00		 mov	 DWORD PTR v$[rbp], eax
$LN3@stbi__shif:

; 4928 :     STBI_ASSERT(v < 256);

  00062	81 bd e0 00 00
	00 00 01 00 00	 cmp	 DWORD PTR v$[rbp], 256	; 00000100H
  0006c	72 1c		 jb	 SHORT $LN5@stbi__shif
  0006e	41 b8 40 13 00
	00		 mov	 r8d, 4928		; 00001340H
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00088	33 c0		 xor	 eax, eax
$LN5@stbi__shif:

; 4929 :     v >>= (8 - bits);

  0008a	b8 08 00 00 00	 mov	 eax, 8
  0008f	2b 85 f0 00 00
	00		 sub	 eax, DWORD PTR bits$[rbp]
  00095	0f b6 c8	 movzx	 ecx, al
  00098	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR v$[rbp]
  0009e	d3 e8		 shr	 eax, cl
  000a0	89 85 e0 00 00
	00		 mov	 DWORD PTR v$[rbp], eax

; 4930 :     STBI_ASSERT(bits >= 0 && bits <= 8);

  000a6	83 bd f0 00 00
	00 00		 cmp	 DWORD PTR bits$[rbp], 0
  000ad	7c 09		 jl	 SHORT $LN6@stbi__shif
  000af	83 bd f0 00 00
	00 08		 cmp	 DWORD PTR bits$[rbp], 8
  000b6	7e 1c		 jle	 SHORT $LN7@stbi__shif
$LN6@stbi__shif:
  000b8	41 b8 42 13 00
	00		 mov	 r8d, 4930		; 00001342H
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d2	33 c0		 xor	 eax, eax
$LN7@stbi__shif:

; 4931 :     return (int)((unsigned)v * mul_table[bits]) >> shift_table[bits];

  000d4	48 63 85 f0 00
	00 00		 movsxd	 rax, DWORD PTR bits$[rbp]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mul_table@?1??stbi__shiftsigned@@9@9
  000e2	8b 95 e0 00 00
	00		 mov	 edx, DWORD PTR v$[rbp]
  000e8	0f af 14 81	 imul	 edx, DWORD PTR [rcx+rax*4]
  000ec	8b c2		 mov	 eax, edx
  000ee	48 63 8d f0 00
	00 00		 movsxd	 rcx, DWORD PTR bits$[rbp]
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?shift_table@?1??stbi__shiftsigned@@9@9
  000fc	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  000ff	d3 f8		 sar	 eax, cl

; 4932 : }

  00101	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00108	5f		 pop	 rdi
  00109	5d		 pop	 rbp
  0010a	c3		 ret	 0
stbi__shiftsigned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bitcount
_TEXT	SEGMENT
a$ = 224
stbi__bitcount PROC					; COMDAT

; 4902 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4903 :     a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00024	25 55 55 55 55	 and	 eax, 1431655765		; 55555555H
  00029	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  0002f	d1 e9		 shr	 ecx, 1
  00031	81 e1 55 55 55
	55		 and	 ecx, 1431655765		; 55555555H
  00037	03 c1		 add	 eax, ecx
  00039	89 85 e0 00 00
	00		 mov	 DWORD PTR a$[rbp], eax

; 4904 :     a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4

  0003f	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00045	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  0004a	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00050	c1 e9 02	 shr	 ecx, 2
  00053	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H
  00059	03 c1		 add	 eax, ecx
  0005b	89 85 e0 00 00
	00		 mov	 DWORD PTR a$[rbp], eax

; 4905 :     a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

  00061	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00067	c1 e8 04	 shr	 eax, 4
  0006a	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	25 0f 0f 0f 0f	 and	 eax, 252645135		; 0f0f0f0fH
  00079	89 85 e0 00 00
	00		 mov	 DWORD PTR a$[rbp], eax

; 4906 :     a = (a + (a >> 8)); // max 16 per 8 bits

  0007f	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00085	c1 e8 08	 shr	 eax, 8
  00088	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  0008e	03 c8		 add	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	89 85 e0 00 00
	00		 mov	 DWORD PTR a$[rbp], eax

; 4907 :     a = (a + (a >> 16)); // max 32 per 8 bits

  00098	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0009e	c1 e8 10	 shr	 eax, 16
  000a1	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  000a7	03 c8		 add	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	89 85 e0 00 00
	00		 mov	 DWORD PTR a$[rbp], eax

; 4908 :     return a & 0xff;

  000b1	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  000b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 4909 : }

  000bc	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi__bitcount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__high_bit
_TEXT	SEGMENT
n$ = 4
z$ = 256
stbi__high_bit PROC					; COMDAT

; 4890 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4891 :     int n = 0;

  0001e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR n$[rbp], 0

; 4892 :     if (z == 0) return -1;

  00025	83 bd 00 01 00
	00 00		 cmp	 DWORD PTR z$[rbp], 0
  0002c	75 0a		 jne	 SHORT $LN2@stbi__high
  0002e	b8 ff ff ff ff	 mov	 eax, -1
  00033	e9 9e 00 00 00	 jmp	 $LN1@stbi__high
$LN2@stbi__high:

; 4893 :     if (z >= 0x10000) { n += 16; z >>= 16; }

  00038	81 bd 00 01 00
	00 00 00 01 00	 cmp	 DWORD PTR z$[rbp], 65536 ; 00010000H
  00042	72 18		 jb	 SHORT $LN3@stbi__high
  00044	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
  00047	83 c0 10	 add	 eax, 16
  0004a	89 45 04	 mov	 DWORD PTR n$[rbp], eax
  0004d	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  00053	c1 e8 10	 shr	 eax, 16
  00056	89 85 00 01 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN3@stbi__high:

; 4894 :     if (z >= 0x00100) { n += 8; z >>= 8; }

  0005c	81 bd 00 01 00
	00 00 01 00 00	 cmp	 DWORD PTR z$[rbp], 256	; 00000100H
  00066	72 18		 jb	 SHORT $LN4@stbi__high
  00068	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
  0006b	83 c0 08	 add	 eax, 8
  0006e	89 45 04	 mov	 DWORD PTR n$[rbp], eax
  00071	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  00077	c1 e8 08	 shr	 eax, 8
  0007a	89 85 00 01 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN4@stbi__high:

; 4895 :     if (z >= 0x00010) { n += 4; z >>= 4; }

  00080	83 bd 00 01 00
	00 10		 cmp	 DWORD PTR z$[rbp], 16
  00087	72 18		 jb	 SHORT $LN5@stbi__high
  00089	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
  0008c	83 c0 04	 add	 eax, 4
  0008f	89 45 04	 mov	 DWORD PTR n$[rbp], eax
  00092	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  00098	c1 e8 04	 shr	 eax, 4
  0009b	89 85 00 01 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN5@stbi__high:

; 4896 :     if (z >= 0x00004) { n += 2; z >>= 2; }

  000a1	83 bd 00 01 00
	00 04		 cmp	 DWORD PTR z$[rbp], 4
  000a8	72 18		 jb	 SHORT $LN6@stbi__high
  000aa	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
  000ad	83 c0 02	 add	 eax, 2
  000b0	89 45 04	 mov	 DWORD PTR n$[rbp], eax
  000b3	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  000b9	c1 e8 02	 shr	 eax, 2
  000bc	89 85 00 01 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN6@stbi__high:

; 4897 :     if (z >= 0x00002) { n += 1;/* >>=  1;*/ }

  000c2	83 bd 00 01 00
	00 02		 cmp	 DWORD PTR z$[rbp], 2
  000c9	72 08		 jb	 SHORT $LN7@stbi__high
  000cb	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
  000ce	ff c0		 inc	 eax
  000d0	89 45 04	 mov	 DWORD PTR n$[rbp], eax
$LN7@stbi__high:

; 4898 :     return n;

  000d3	8b 45 04	 mov	 eax, DWORD PTR n$[rbp]
$LN1@stbi__high:

; 4899 : }

  000d6	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000dd	5f		 pop	 rdi
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
stbi__high_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_test_raw
_TEXT	SEGMENT
r$ = 4
sz$ = 36
tv83 = 244
s$ = 288
stbi__bmp_test_raw PROC					; COMDAT

; 4867 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4868 :     int r;
; 4869 :     int sz;
; 4870 :     if (stbi__get8(s) != 'B') return 0;

  0001f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get8
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	83 f8 42	 cmp	 eax, 66			; 00000042H
  00031	74 07		 je	 SHORT $LN2@stbi__bmp_
  00033	33 c0		 xor	 eax, eax
  00035	e9 97 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 4871 :     if (stbi__get8(s) != 'M') return 0;

  0003a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00041	e8 00 00 00 00	 call	 stbi__get8
  00046	0f b6 c0	 movzx	 eax, al
  00049	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0004c	74 04		 je	 SHORT $LN3@stbi__bmp_
  0004e	33 c0		 xor	 eax, eax
  00050	eb 7f		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 4872 :     stbi__get32le(s); // discard filesize

  00052	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00059	e8 00 00 00 00	 call	 stbi__get32le

; 4873 :     stbi__get16le(s); // discard reserved

  0005e	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00065	e8 00 00 00 00	 call	 stbi__get16le

; 4874 :     stbi__get16le(s); // discard reserved

  0006a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00071	e8 00 00 00 00	 call	 stbi__get16le

; 4875 :     stbi__get32le(s); // discard data offset

  00076	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0007d	e8 00 00 00 00	 call	 stbi__get32le

; 4876 :     sz = stbi__get32le(s);

  00082	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00089	e8 00 00 00 00	 call	 stbi__get32le
  0008e	89 45 24	 mov	 DWORD PTR sz$[rbp], eax

; 4877 :     r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

  00091	83 7d 24 0c	 cmp	 DWORD PTR sz$[rbp], 12
  00095	74 24		 je	 SHORT $LN5@stbi__bmp_
  00097	83 7d 24 28	 cmp	 DWORD PTR sz$[rbp], 40	; 00000028H
  0009b	74 1e		 je	 SHORT $LN5@stbi__bmp_
  0009d	83 7d 24 38	 cmp	 DWORD PTR sz$[rbp], 56	; 00000038H
  000a1	74 18		 je	 SHORT $LN5@stbi__bmp_
  000a3	83 7d 24 6c	 cmp	 DWORD PTR sz$[rbp], 108	; 0000006cH
  000a7	74 12		 je	 SHORT $LN5@stbi__bmp_
  000a9	83 7d 24 7c	 cmp	 DWORD PTR sz$[rbp], 124	; 0000007cH
  000ad	74 0c		 je	 SHORT $LN5@stbi__bmp_
  000af	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv83[rbp], 0
  000b9	eb 0a		 jmp	 SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
  000bb	c7 85 f4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv83[rbp], 1
$LN6@stbi__bmp_:
  000c5	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR tv83[rbp]
  000cb	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 4878 :     return r;

  000ce	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]
$LN1@stbi__bmp_:

; 4879 : }

  000d1	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000d8	5f		 pop	 rdi
  000d9	5d		 pop	 rbp
  000da	c3		 ret	 0
stbi__bmp_test_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__png_info_raw
_TEXT	SEGMENT
p$ = 224
x$ = 232
y$ = 240
comp$ = 248
stbi__png_info_raw PROC					; COMDAT

; 4831 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4832 :     if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

  0002e	45 33 c0	 xor	 r8d, r8d
  00031	ba 02 00 00 00	 mov	 edx, 2
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  0003d	e8 00 00 00 00	 call	 stbi__parse_png_file
  00042	85 c0		 test	 eax, eax
  00044	75 13		 jne	 SHORT $LN2@stbi__png_

; 4833 :         stbi__rewind(p->s);

  00046	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0004d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00050	e8 00 00 00 00	 call	 stbi__rewind

; 4834 :         return 0;

  00055	33 c0		 xor	 eax, eax
  00057	eb 64		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 4835 :     }
; 4836 :     if (x) *x = p->s->img_x;

  00059	48 83 bd e8 00
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00061	74 15		 je	 SHORT $LN3@stbi__png_
  00063	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00074	8b 00		 mov	 eax, DWORD PTR [rax]
  00076	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__png_:

; 4837 :     if (y) *y = p->s->img_y;

  00078	48 83 bd f0 00
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00080	74 16		 je	 SHORT $LN4@stbi__png_
  00082	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  00093	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00096	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__png_:

; 4838 :     if (comp) *comp = p->s->img_n;

  00098	48 83 bd f8 00
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  000a0	74 16		 je	 SHORT $LN5@stbi__png_
  000a2	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR comp$[rbp]
  000b3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b6	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__png_:

; 4839 :     return 1;

  000b8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 4840 : }

  000bd	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000c4	5f		 pop	 rdi
  000c5	5d		 pop	 rbp
  000c6	c3		 ret	 0
stbi__png_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__do_png
_TEXT	SEGMENT
result$ = 8
tv84 = 216
tv69 = 216
p$ = 256
x$ = 264
y$ = 272
n$ = 280
req_comp$ = 288
ri$ = 296
stbi__do_png PROC					; COMDAT

; 4784 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4785 :     void* result = NULL;

  0002e	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR result$[rbp], 0

; 4786 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  00036	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  0003d	7c 09		 jl	 SHORT $LN3@stbi__do_p
  0003f	83 bd 20 01 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  00046	7e 34		 jle	 SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KBPNPPBJ@bad?5req_comp@
  0004f	e8 00 00 00 00	 call	 stbi__err
  00054	85 c0		 test	 eax, eax
  00056	74 0d		 je	 SHORT $LN15@stbi__do_p
  00058	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv69[rbp], 0
  00063	eb 0b		 jmp	 SHORT $LN16@stbi__do_p
$LN15@stbi__do_p:
  00065	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv69[rbp], 0
$LN16@stbi__do_p:
  00070	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv69[rbp]
  00077	e9 2b 02 00 00	 jmp	 $LN1@stbi__do_p
$LN2@stbi__do_p:

; 4787 :     if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

  0007c	44 8b 85 20 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00083	33 d2		 xor	 edx, edx
  00085	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  0008c	e8 00 00 00 00	 call	 stbi__parse_png_file
  00091	85 c0		 test	 eax, eax
  00093	0f 84 aa 01 00
	00		 je	 $LN4@stbi__do_p

; 4788 :         if (p->depth <= 8)

  00099	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  000a0	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  000a4	7f 0f		 jg	 SHORT $LN5@stbi__do_p

; 4789 :             ri->bits_per_channel = 8;

  000a6	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  000ad	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
  000b3	eb 50		 jmp	 SHORT $LN6@stbi__do_p
$LN5@stbi__do_p:

; 4790 :         else if (p->depth == 16)

  000b5	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  000bc	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  000c0	75 0f		 jne	 SHORT $LN7@stbi__do_p

; 4791 :             ri->bits_per_channel = 16;

  000c2	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  000c9	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16
  000cf	eb 34		 jmp	 SHORT $LN8@stbi__do_p
$LN7@stbi__do_p:

; 4792 :         else
; 4793 :             return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");

  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
  000d8	e8 00 00 00 00	 call	 stbi__err
  000dd	85 c0		 test	 eax, eax
  000df	74 0d		 je	 SHORT $LN17@stbi__do_p
  000e1	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv84[rbp], 0
  000ec	eb 0b		 jmp	 SHORT $LN18@stbi__do_p
$LN17@stbi__do_p:
  000ee	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv84[rbp], 0
$LN18@stbi__do_p:
  000f9	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv84[rbp]
  00100	e9 a2 01 00 00	 jmp	 $LN1@stbi__do_p
$LN8@stbi__do_p:
$LN6@stbi__do_p:

; 4794 :         result = p->out;

  00105	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0010c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00110	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 4795 :         p->out = NULL;

  00114	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0011b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4796 :         if (req_comp && req_comp != p->s->img_out_n) {

  00123	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  0012a	0f 84 c8 00 00
	00		 je	 $LN9@stbi__do_p
  00130	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00137	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0013d	39 85 20 01 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  00143	0f 84 af 00 00
	00		 je	 $LN9@stbi__do_p

; 4797 :             if (ri->bits_per_channel == 8)

  00149	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00150	83 38 08	 cmp	 DWORD PTR [rax], 8
  00153	75 41		 jne	 SHORT $LN10@stbi__do_p

; 4798 :                 result = stbi__convert_format((unsigned char*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00155	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0015c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00166	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00169	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  00170	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00173	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00176	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017a	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  0017d	44 8b 85 20 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00184	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00187	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  0018b	e8 00 00 00 00	 call	 stbi__convert_format
  00190	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax
  00194	eb 3f		 jmp	 SHORT $LN11@stbi__do_p
$LN10@stbi__do_p:

; 4799 :             else
; 4800 :                 result = stbi__convert_format16((stbi__uint16*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00196	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0019d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a0	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  001a7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001aa	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  001b1	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001b4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001bb	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  001be	44 8b 85 20 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  001c5	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  001c8	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  001cc	e8 00 00 00 00	 call	 stbi__convert_format16
  001d1	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax
$LN11@stbi__do_p:

; 4801 :             p->s->img_out_n = req_comp;

  001d5	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  001dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001df	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR req_comp$[rbp]
  001e5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 4802 :             if (result == NULL) return result;

  001e8	48 83 7d 08 00	 cmp	 QWORD PTR result$[rbp], 0
  001ed	75 09		 jne	 SHORT $LN12@stbi__do_p
  001ef	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
  001f3	e9 af 00 00 00	 jmp	 $LN1@stbi__do_p
$LN12@stbi__do_p:
$LN9@stbi__do_p:

; 4803 :         }
; 4804 :         *x = p->s->img_x;

  001f8	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  001ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00202	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00209	8b 00		 mov	 eax, DWORD PTR [rax]
  0020b	89 01		 mov	 DWORD PTR [rcx], eax

; 4805 :         *y = p->s->img_y;

  0020d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00214	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00217	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  0021e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00221	89 01		 mov	 DWORD PTR [rcx], eax

; 4806 :         if (n) *n = p->s->img_n;

  00223	48 83 bd 18 01
	00 00 00	 cmp	 QWORD PTR n$[rbp], 0
  0022b	74 16		 je	 SHORT $LN13@stbi__do_p
  0022d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  00234	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00237	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR n$[rbp]
  0023e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00241	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@stbi__do_p:
$LN4@stbi__do_p:

; 4807 :     }
; 4808 :     STBI_FREE(p->out);      p->out = NULL;

  00243	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0024a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00254	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0025b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4809 :     STBI_FREE(p->expanded); p->expanded = NULL;

  00263	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0026a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00274	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0027b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4810 :     STBI_FREE(p->idata);    p->idata = NULL;

  00283	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0028a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00294	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
  0029b	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 4811 : 
; 4812 :     return result;

  002a3	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__do_p:

; 4813 : }

  002a7	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  002ae	5f		 pop	 rdi
  002af	5d		 pop	 rbp
  002b0	c3		 ret	 0
stbi__do_png ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_png_file
_TEXT	SEGMENT
palette$ = 16
pal_img_n$ = 1060
has_trans$ = 1092
tc$ = 1124
tc16$ = 1156
ioff$ = 1188
idata_limit$ = 1220
i$ = 1252
pal_len$ = 1284
first$ = 1316
k$ = 1348
interlace$ = 1380
color$ = 1412
is_iphone$ = 1444
s$ = 1480
c$8 = 1512
comp$9 = 1540
filter$10 = 1572
idata_limit_old$11 = 1604
p$12 = 1640
raw_len$13 = 1668
bpl$14 = 1700
tv461 = 2484
tv394 = 2484
tv345 = 2484
tv194 = 2484
tv78 = 2484
tv197 = 2488
__$ArrayPad$ = 2496
z$ = 2544
scan$ = 2552
req_comp$ = 2560
stbi__parse_png_file PROC				; COMDAT

; 4596 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 18 0a
	00 00		 sub	 rsp, 2584		; 00000a18H
  00017	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  0001c	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00021	b9 b6 01 00 00	 mov	 ecx, 438		; 000001b6H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 38
	0a 00 00	 mov	 rcx, QWORD PTR [rsp+2616]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c5	 xor	 rax, rbp
  0003f	48 89 85 c0 09
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4597 :     stbi_uc palette[1024], pal_img_n = 0;

  00052	c6 85 24 04 00
	00 00		 mov	 BYTE PTR pal_img_n$[rbp], 0

; 4598 :     stbi_uc has_trans = 0, tc[3] = { 0 };

  00059	c6 85 44 04 00
	00 00		 mov	 BYTE PTR has_trans$[rbp], 0
  00060	48 8d 85 64 04
	00 00		 lea	 rax, QWORD PTR tc$[rbp]
  00067	48 8b f8	 mov	 rdi, rax
  0006a	33 c0		 xor	 eax, eax
  0006c	b9 03 00 00 00	 mov	 ecx, 3
  00071	f3 aa		 rep stosb

; 4599 :     stbi__uint16 tc16[3];
; 4600 :     stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;

  00073	c7 85 a4 04 00
	00 00 00 00 00	 mov	 DWORD PTR ioff$[rbp], 0
  0007d	c7 85 c4 04 00
	00 00 00 00 00	 mov	 DWORD PTR idata_limit$[rbp], 0
  00087	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR pal_len$[rbp], 0

; 4601 :     int first = 1, k, interlace = 0, color = 0, is_iphone = 0;

  00091	c7 85 24 05 00
	00 01 00 00 00	 mov	 DWORD PTR first$[rbp], 1
  0009b	c7 85 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR interlace$[rbp], 0
  000a5	c7 85 84 05 00
	00 00 00 00 00	 mov	 DWORD PTR color$[rbp], 0
  000af	c7 85 a4 05 00
	00 00 00 00 00	 mov	 DWORD PTR is_iphone$[rbp], 0

; 4602 :     stbi__context* s = z->s;

  000b9	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 89 85 c8 05
	00 00		 mov	 QWORD PTR s$[rbp], rax

; 4603 : 
; 4604 :     z->expanded = NULL;

  000ca	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000d1	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4605 :     z->idata = NULL;

  000d9	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000e0	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 4606 :     z->out = NULL;

  000e8	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000ef	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4607 : 
; 4608 :     if (!stbi__check_png_header(s)) return 0;

  000f7	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000fe	e8 00 00 00 00	 call	 stbi__check_png_header
  00103	85 c0		 test	 eax, eax
  00105	75 07		 jne	 SHORT $LN21@stbi__pars
  00107	33 c0		 xor	 eax, eax
  00109	e9 91 0d 00 00	 jmp	 $LN1@stbi__pars
$LN21@stbi__pars:

; 4609 : 
; 4610 :     if (scan == STBI__SCAN_type) return 1;

  0010e	83 bd f8 09 00
	00 01		 cmp	 DWORD PTR scan$[rbp], 1
  00115	75 0a		 jne	 SHORT $LN22@stbi__pars
  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	e9 7e 0d 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:
$LN2@stbi__pars:

; 4611 : 
; 4612 :     for (;;) {
; 4613 :         stbi__pngchunk c = stbi__get_chunk_header(s);

  00121	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00128	e8 00 00 00 00	 call	 stbi__get_chunk_header
  0012d	48 89 85 e8 05
	00 00		 mov	 QWORD PTR c$8[rbp], rax

; 4614 :         switch (c.type) {

  00134	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  0013a	89 85 b4 09 00
	00		 mov	 DWORD PTR tv78[rbp], eax
  00140	81 bd b4 09 00
	00 52 44 48 49	 cmp	 DWORD PTR tv78[rbp], 1229472850 ; 49484452H
  0014a	77 3d		 ja	 SHORT $LN107@stbi__pars
  0014c	81 bd b4 09 00
	00 52 44 48 49	 cmp	 DWORD PTR tv78[rbp], 1229472850 ; 49484452H
  00156	74 77		 je	 SHORT $LN24@stbi__pars
  00158	81 bd b4 09 00
	00 49 42 67 43	 cmp	 DWORD PTR tv78[rbp], 1130840649 ; 43674249H
  00162	74 4a		 je	 SHORT $LN23@stbi__pars
  00164	81 bd b4 09 00
	00 54 41 44 49	 cmp	 DWORD PTR tv78[rbp], 1229209940 ; 49444154H
  0016e	0f 84 df 06 00
	00		 je	 $LN61@stbi__pars
  00174	81 bd b4 09 00
	00 44 4e 45 49	 cmp	 DWORD PTR tv78[rbp], 1229278788 ; 49454e44H
  0017e	0f 84 a6 08 00
	00		 je	 $LN72@stbi__pars
  00184	e9 37 0c 00 00	 jmp	 $LN93@stbi__pars
$LN107@stbi__pars:
  00189	81 bd b4 09 00
	00 45 54 4c 50	 cmp	 DWORD PTR tv78[rbp], 1347179589 ; 504c5445H
  00193	0f 84 7b 03 00
	00		 je	 $LN44@stbi__pars
  00199	81 bd b4 09 00
	00 53 4e 52 74	 cmp	 DWORD PTR tv78[rbp], 1951551059 ; 74524e53H
  001a3	0f 84 76 04 00
	00		 je	 $LN48@stbi__pars
  001a9	e9 12 0c 00 00	 jmp	 $LN93@stbi__pars
$LN23@stbi__pars:

; 4615 :         case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
; 4616 :             is_iphone = 1;

  001ae	c7 85 a4 05 00
	00 01 00 00 00	 mov	 DWORD PTR is_iphone$[rbp], 1

; 4617 :             stbi__skip(s, c.length);

  001b8	8b 95 e8 05 00
	00		 mov	 edx, DWORD PTR c$8[rbp]
  001be	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001c5	e8 00 00 00 00	 call	 stbi__skip

; 4618 :             break;

  001ca	e9 bf 0c 00 00	 jmp	 $LN5@stbi__pars
$LN24@stbi__pars:

; 4619 :         case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
; 4620 :             int comp, filter;
; 4621 :             if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");

  001cf	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  001d6	75 11		 jne	 SHORT $LN25@stbi__pars
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@KBHBNJOK@multiple?5IHDR@
  001df	e8 00 00 00 00	 call	 stbi__err
  001e4	e9 b6 0c 00 00	 jmp	 $LN1@stbi__pars
$LN25@stbi__pars:

; 4622 :             first = 0;

  001e9	c7 85 24 05 00
	00 00 00 00 00	 mov	 DWORD PTR first$[rbp], 0

; 4623 :             if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");

  001f3	83 bd e8 05 00
	00 0d		 cmp	 DWORD PTR c$8[rbp], 13
  001fa	74 11		 je	 SHORT $LN26@stbi__pars
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@POJLKMKK@bad?5IHDR?5len@
  00203	e8 00 00 00 00	 call	 stbi__err
  00208	e9 92 0c 00 00	 jmp	 $LN1@stbi__pars
$LN26@stbi__pars:

; 4624 :             s->img_x = stbi__get32be(s);

  0020d	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00214	e8 00 00 00 00	 call	 stbi__get32be
  00219	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00220	89 01		 mov	 DWORD PTR [rcx], eax

; 4625 :             s->img_y = stbi__get32be(s);

  00222	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00229	e8 00 00 00 00	 call	 stbi__get32be
  0022e	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00235	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 4626 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  00238	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0023f	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00246	76 11		 jbe	 SHORT $LN27@stbi__pars
  00248	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0024f	e8 00 00 00 00	 call	 stbi__err
  00254	e9 46 0c 00 00	 jmp	 $LN1@stbi__pars
$LN27@stbi__pars:

; 4627 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  00259	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00260	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00266	76 11		 jbe	 SHORT $LN28@stbi__pars
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0026f	e8 00 00 00 00	 call	 stbi__err
  00274	e9 26 0c 00 00	 jmp	 $LN1@stbi__pars
$LN28@stbi__pars:

; 4628 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only", "PNG not supported: 1/2/4/8/16-bit only");

  00279	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00280	e8 00 00 00 00	 call	 stbi__get8
  00285	0f b6 c0	 movzx	 eax, al
  00288	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0028f	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  00292	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00299	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  0029d	74 45		 je	 SHORT $LN29@stbi__pars
  0029f	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002a6	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  002aa	74 38		 je	 SHORT $LN29@stbi__pars
  002ac	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002b3	83 78 20 04	 cmp	 DWORD PTR [rax+32], 4
  002b7	74 2b		 je	 SHORT $LN29@stbi__pars
  002b9	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002c0	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  002c4	74 1e		 je	 SHORT $LN29@stbi__pars
  002c6	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002cd	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  002d1	74 11		 je	 SHORT $LN29@stbi__pars
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
  002da	e8 00 00 00 00	 call	 stbi__err
  002df	e9 bb 0b 00 00	 jmp	 $LN1@stbi__pars
$LN29@stbi__pars:

; 4629 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");

  002e4	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  002eb	e8 00 00 00 00	 call	 stbi__get8
  002f0	0f b6 c0	 movzx	 eax, al
  002f3	89 85 84 05 00
	00		 mov	 DWORD PTR color$[rbp], eax
  002f9	83 bd 84 05 00
	00 06		 cmp	 DWORD PTR color$[rbp], 6
  00300	7e 11		 jle	 SHORT $LN30@stbi__pars
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  00309	e8 00 00 00 00	 call	 stbi__err
  0030e	e9 8c 0b 00 00	 jmp	 $LN1@stbi__pars
$LN30@stbi__pars:

; 4630 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype", "Corrupt PNG");

  00313	83 bd 84 05 00
	00 03		 cmp	 DWORD PTR color$[rbp], 3
  0031a	75 1e		 jne	 SHORT $LN31@stbi__pars
  0031c	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00323	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00327	75 11		 jne	 SHORT $LN31@stbi__pars
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  00330	e8 00 00 00 00	 call	 stbi__err
  00335	e9 65 0b 00 00	 jmp	 $LN1@stbi__pars
$LN31@stbi__pars:

; 4631 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");

  0033a	83 bd 84 05 00
	00 03		 cmp	 DWORD PTR color$[rbp], 3
  00341	75 09		 jne	 SHORT $LN32@stbi__pars
  00343	c6 85 24 04 00
	00 03		 mov	 BYTE PTR pal_img_n$[rbp], 3
  0034a	eb 1e		 jmp	 SHORT $LN33@stbi__pars
$LN32@stbi__pars:
  0034c	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR color$[rbp]
  00352	83 e0 01	 and	 eax, 1
  00355	85 c0		 test	 eax, eax
  00357	74 11		 je	 SHORT $LN34@stbi__pars
  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  00360	e8 00 00 00 00	 call	 stbi__err
  00365	e9 35 0b 00 00	 jmp	 $LN1@stbi__pars
$LN34@stbi__pars:
$LN33@stbi__pars:

; 4632 :             comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");

  0036a	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00371	e8 00 00 00 00	 call	 stbi__get8
  00376	0f b6 c0	 movzx	 eax, al
  00379	89 85 04 06 00
	00		 mov	 DWORD PTR comp$9[rbp], eax
  0037f	83 bd 04 06 00
	00 00		 cmp	 DWORD PTR comp$9[rbp], 0
  00386	74 11		 je	 SHORT $LN35@stbi__pars
  00388	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDMBDDFG@bad?5comp?5method@
  0038f	e8 00 00 00 00	 call	 stbi__err
  00394	e9 06 0b 00 00	 jmp	 $LN1@stbi__pars
$LN35@stbi__pars:

; 4633 :             filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");

  00399	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003a0	e8 00 00 00 00	 call	 stbi__get8
  003a5	0f b6 c0	 movzx	 eax, al
  003a8	89 85 24 06 00
	00		 mov	 DWORD PTR filter$10[rbp], eax
  003ae	83 bd 24 06 00
	00 00		 cmp	 DWORD PTR filter$10[rbp], 0
  003b5	74 11		 je	 SHORT $LN36@stbi__pars
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GHLIKKMD@bad?5filter?5method@
  003be	e8 00 00 00 00	 call	 stbi__err
  003c3	e9 d7 0a 00 00	 jmp	 $LN1@stbi__pars
$LN36@stbi__pars:

; 4634 :             interlace = stbi__get8(s); if (interlace > 1) return stbi__err("bad interlace method", "Corrupt PNG");

  003c8	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003cf	e8 00 00 00 00	 call	 stbi__get8
  003d4	0f b6 c0	 movzx	 eax, al
  003d7	89 85 64 05 00
	00		 mov	 DWORD PTR interlace$[rbp], eax
  003dd	83 bd 64 05 00
	00 01		 cmp	 DWORD PTR interlace$[rbp], 1
  003e4	7e 11		 jle	 SHORT $LN37@stbi__pars
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
  003ed	e8 00 00 00 00	 call	 stbi__err
  003f2	e9 a8 0a 00 00	 jmp	 $LN1@stbi__pars
$LN37@stbi__pars:

; 4635 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");

  003f7	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  003fe	83 38 00	 cmp	 DWORD PTR [rax], 0
  00401	74 0d		 je	 SHORT $LN39@stbi__pars
  00403	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0040a	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0040e	75 11		 jne	 SHORT $LN38@stbi__pars
$LN39@stbi__pars:
  00410	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FNFBHCOO@0?9pixel?5image@
  00417	e8 00 00 00 00	 call	 stbi__err
  0041c	e9 7e 0a 00 00	 jmp	 $LN1@stbi__pars
$LN38@stbi__pars:

; 4636 :             if (!pal_img_n) {

  00421	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00428	85 c0		 test	 eax, eax
  0042a	0f 85 9b 00 00
	00		 jne	 $LN40@stbi__pars

; 4637 :                 s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

  00430	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR color$[rbp]
  00436	83 e0 02	 and	 eax, 2
  00439	85 c0		 test	 eax, eax
  0043b	74 0c		 je	 SHORT $LN97@stbi__pars
  0043d	c7 85 b4 09 00
	00 03 00 00 00	 mov	 DWORD PTR tv194[rbp], 3
  00447	eb 0a		 jmp	 SHORT $LN98@stbi__pars
$LN97@stbi__pars:
  00449	c7 85 b4 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv194[rbp], 1
$LN98@stbi__pars:
  00453	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR color$[rbp]
  00459	83 e0 04	 and	 eax, 4
  0045c	85 c0		 test	 eax, eax
  0045e	74 0c		 je	 SHORT $LN99@stbi__pars
  00460	c7 85 b8 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv197[rbp], 1
  0046a	eb 0a		 jmp	 SHORT $LN100@stbi__pars
$LN99@stbi__pars:
  0046c	c7 85 b8 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv197[rbp], 0
$LN100@stbi__pars:
  00476	8b 85 b8 09 00
	00		 mov	 eax, DWORD PTR tv197[rbp]
  0047c	8b 8d b4 09 00
	00		 mov	 ecx, DWORD PTR tv194[rbp]
  00482	03 c8		 add	 ecx, eax
  00484	8b c1		 mov	 eax, ecx
  00486	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0048d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4638 :                 if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

  00490	33 d2		 xor	 edx, edx
  00492	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00497	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0049e	f7 31		 div	 DWORD PTR [rcx]
  004a0	33 d2		 xor	 edx, edx
  004a2	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004a9	f7 71 08	 div	 DWORD PTR [rcx+8]
  004ac	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004b3	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  004b6	73 11		 jae	 SHORT $LN42@stbi__pars
  004b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  004bf	e8 00 00 00 00	 call	 stbi__err
  004c4	e9 d6 09 00 00	 jmp	 $LN1@stbi__pars
$LN42@stbi__pars:

; 4639 :             }

  004c9	eb 44		 jmp	 SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 4640 :             else {
; 4641 :                 // if paletted, then pal_n is our final components, and
; 4642 :                 // img_n is # components to decompress/filter.
; 4643 :                 s->img_n = 1;

  004cb	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  004d2	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1

; 4644 :                 if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");

  004d9	33 d2		 xor	 edx, edx
  004db	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  004e0	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004e7	f7 31		 div	 DWORD PTR [rcx]
  004e9	33 d2		 xor	 edx, edx
  004eb	b9 04 00 00 00	 mov	 ecx, 4
  004f0	f7 f1		 div	 ecx
  004f2	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004f9	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  004fc	73 11		 jae	 SHORT $LN43@stbi__pars
  004fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00505	e8 00 00 00 00	 call	 stbi__err
  0050a	e9 90 09 00 00	 jmp	 $LN1@stbi__pars
$LN43@stbi__pars:
$LN41@stbi__pars:

; 4645 :             }
; 4646 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 4647 :             break;

  0050f	e9 7a 09 00 00	 jmp	 $LN5@stbi__pars
$LN44@stbi__pars:

; 4648 :         }
; 4649 : 
; 4650 :         case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {
; 4651 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00514	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  0051b	74 11		 je	 SHORT $LN45@stbi__pars
  0051d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  00524	e8 00 00 00 00	 call	 stbi__err
  00529	e9 71 09 00 00	 jmp	 $LN1@stbi__pars
$LN45@stbi__pars:

; 4652 :             if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");

  0052e	81 bd e8 05 00
	00 00 03 00 00	 cmp	 DWORD PTR c$8[rbp], 768	; 00000300H
  00538	76 11		 jbe	 SHORT $LN46@stbi__pars
  0053a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JCPAJAKB@invalid?5PLTE@
  00541	e8 00 00 00 00	 call	 stbi__err
  00546	e9 54 09 00 00	 jmp	 $LN1@stbi__pars
$LN46@stbi__pars:

; 4653 :             pal_len = c.length / 3;

  0054b	33 d2		 xor	 edx, edx
  0054d	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  00553	b9 03 00 00 00	 mov	 ecx, 3
  00558	f7 f1		 div	 ecx
  0055a	89 85 04 05 00
	00		 mov	 DWORD PTR pal_len$[rbp], eax

; 4654 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");

  00560	6b 85 04 05 00
	00 03		 imul	 eax, DWORD PTR pal_len$[rbp], 3
  00567	3b 85 e8 05 00
	00		 cmp	 eax, DWORD PTR c$8[rbp]
  0056d	74 11		 je	 SHORT $LN47@stbi__pars
  0056f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JCPAJAKB@invalid?5PLTE@
  00576	e8 00 00 00 00	 call	 stbi__err
  0057b	e9 1f 09 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 4655 :             for (i = 0; i < pal_len; ++i) {

  00580	c7 85 e4 04 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  0058a	eb 0e		 jmp	 SHORT $LN9@stbi__pars
$LN7@stbi__pars:
  0058c	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00592	ff c0		 inc	 eax
  00594	89 85 e4 04 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN9@stbi__pars:
  0059a	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR pal_len$[rbp]
  005a0	39 85 e4 04 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  005a6	73 72		 jae	 SHORT $LN8@stbi__pars

; 4656 :                 palette[i * 4 + 0] = stbi__get8(s);

  005a8	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005af	e8 00 00 00 00	 call	 stbi__get8
  005b4	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  005ba	c1 e1 02	 shl	 ecx, 2
  005bd	8b c9		 mov	 ecx, ecx
  005bf	88 44 0d 10	 mov	 BYTE PTR palette$[rbp+rcx], al

; 4657 :                 palette[i * 4 + 1] = stbi__get8(s);

  005c3	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005ca	e8 00 00 00 00	 call	 stbi__get8
  005cf	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  005d5	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  005dc	8b c9		 mov	 ecx, ecx
  005de	88 44 0d 10	 mov	 BYTE PTR palette$[rbp+rcx], al

; 4658 :                 palette[i * 4 + 2] = stbi__get8(s);

  005e2	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005e9	e8 00 00 00 00	 call	 stbi__get8
  005ee	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  005f4	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  005fb	8b c9		 mov	 ecx, ecx
  005fd	88 44 0d 10	 mov	 BYTE PTR palette$[rbp+rcx], al

; 4659 :                 palette[i * 4 + 3] = 255;

  00601	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00607	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  0060e	8b c0		 mov	 eax, eax
  00610	c6 44 05 10 ff	 mov	 BYTE PTR palette$[rbp+rax], 255 ; 000000ffH

; 4660 :             }

  00615	e9 72 ff ff ff	 jmp	 $LN7@stbi__pars
$LN8@stbi__pars:

; 4661 :             break;

  0061a	e9 6f 08 00 00	 jmp	 $LN5@stbi__pars
$LN48@stbi__pars:

; 4662 :         }
; 4663 : 
; 4664 :         case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
; 4665 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0061f	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  00626	74 11		 je	 SHORT $LN49@stbi__pars
  00628	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  0062f	e8 00 00 00 00	 call	 stbi__err
  00634	e9 66 08 00 00	 jmp	 $LN1@stbi__pars
$LN49@stbi__pars:

; 4666 :             if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");

  00639	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00640	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00645	74 11		 je	 SHORT $LN50@stbi__pars
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
  0064e	e8 00 00 00 00	 call	 stbi__err
  00653	e9 47 08 00 00	 jmp	 $LN1@stbi__pars
$LN50@stbi__pars:

; 4667 :             if (pal_img_n) {

  00658	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  0065f	85 c0		 test	 eax, eax
  00661	0f 84 af 00 00
	00		 je	 $LN51@stbi__pars

; 4668 :                 if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

  00667	83 bd f8 09 00
	00 02		 cmp	 DWORD PTR scan$[rbp], 2
  0066e	75 18		 jne	 SHORT $LN53@stbi__pars
  00670	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00677	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [rax+8], 4
  0067e	b8 01 00 00 00	 mov	 eax, 1
  00683	e9 17 08 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 4669 :                 if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");

  00688	83 bd 04 05 00
	00 00		 cmp	 DWORD PTR pal_len$[rbp], 0
  0068f	75 11		 jne	 SHORT $LN54@stbi__pars
  00691	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
  00698	e8 00 00 00 00	 call	 stbi__err
  0069d	e9 fd 07 00 00	 jmp	 $LN1@stbi__pars
$LN54@stbi__pars:

; 4670 :                 if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");

  006a2	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR pal_len$[rbp]
  006a8	39 85 e8 05 00
	00		 cmp	 DWORD PTR c$8[rbp], eax
  006ae	76 11		 jbe	 SHORT $LN55@stbi__pars
  006b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
  006b7	e8 00 00 00 00	 call	 stbi__err
  006bc	e9 de 07 00 00	 jmp	 $LN1@stbi__pars
$LN55@stbi__pars:

; 4671 :                 pal_img_n = 4;

  006c1	c6 85 24 04 00
	00 04		 mov	 BYTE PTR pal_img_n$[rbp], 4

; 4672 :                 for (i = 0; i < c.length; ++i)

  006c8	c7 85 e4 04 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  006d2	eb 0e		 jmp	 SHORT $LN12@stbi__pars
$LN10@stbi__pars:
  006d4	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  006da	ff c0		 inc	 eax
  006dc	89 85 e4 04 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN12@stbi__pars:
  006e2	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  006e8	39 85 e4 04 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  006ee	73 21		 jae	 SHORT $LN11@stbi__pars

; 4673 :                     palette[i * 4 + 3] = stbi__get8(s);

  006f0	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  006f7	e8 00 00 00 00	 call	 stbi__get8
  006fc	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  00702	8d 0c 8d 03 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+3]
  00709	8b c9		 mov	 ecx, ecx
  0070b	88 44 0d 10	 mov	 BYTE PTR palette$[rbp+rcx], al
  0070f	eb c3		 jmp	 SHORT $LN10@stbi__pars
$LN11@stbi__pars:

; 4674 :             }

  00711	e9 38 01 00 00	 jmp	 $LN52@stbi__pars
$LN51@stbi__pars:

; 4675 :             else {
; 4676 :                 if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");

  00716	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0071d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00720	83 e0 01	 and	 eax, 1
  00723	85 c0		 test	 eax, eax
  00725	75 11		 jne	 SHORT $LN56@stbi__pars
  00727	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
  0072e	e8 00 00 00 00	 call	 stbi__err
  00733	e9 67 07 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 4677 :                 if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");

  00738	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0073f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00742	d1 e0		 shl	 eax, 1
  00744	39 85 e8 05 00
	00		 cmp	 DWORD PTR c$8[rbp], eax
  0074a	74 11		 je	 SHORT $LN57@stbi__pars
  0074c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
  00753	e8 00 00 00 00	 call	 stbi__err
  00758	e9 42 07 00 00	 jmp	 $LN1@stbi__pars
$LN57@stbi__pars:

; 4678 :                 has_trans = 1;

  0075d	c6 85 44 04 00
	00 01		 mov	 BYTE PTR has_trans$[rbp], 1

; 4679 :                 // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 4680 :                 if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }

  00764	83 bd f8 09 00
	00 02		 cmp	 DWORD PTR scan$[rbp], 2
  0076b	75 20		 jne	 SHORT $LN58@stbi__pars
  0076d	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00774	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00777	ff c0		 inc	 eax
  00779	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00780	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00783	b8 01 00 00 00	 mov	 eax, 1
  00788	e9 12 07 00 00	 jmp	 $LN1@stbi__pars
$LN58@stbi__pars:

; 4681 :                 if (z->depth == 16) {

  0078d	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00794	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00798	75 4b		 jne	 SHORT $LN59@stbi__pars

; 4682 :                     for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

  0079a	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  007a4	eb 0e		 jmp	 SHORT $LN15@stbi__pars
$LN13@stbi__pars:
  007a6	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  007ac	ff c0		 inc	 eax
  007ae	89 85 44 05 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN15@stbi__pars:
  007b4	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  007bb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  007be	39 85 44 05 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  007c4	7d 1d		 jge	 SHORT $LN14@stbi__pars
  007c6	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  007cd	e8 00 00 00 00	 call	 stbi__get16be
  007d2	48 63 8d 44 05
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  007d9	66 89 84 4d 84
	04 00 00	 mov	 WORD PTR tc16$[rbp+rcx*2], ax
  007e1	eb c3		 jmp	 SHORT $LN13@stbi__pars
$LN14@stbi__pars:

; 4683 :                 }

  007e3	eb 69		 jmp	 SHORT $LN60@stbi__pars
$LN59@stbi__pars:

; 4684 :                 else {
; 4685 :                     for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

  007e5	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  007ef	eb 0e		 jmp	 SHORT $LN18@stbi__pars
$LN16@stbi__pars:
  007f1	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  007f7	ff c0		 inc	 eax
  007f9	89 85 44 05 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN18@stbi__pars:
  007ff	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00806	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00809	39 85 44 05 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  0080f	7d 3d		 jge	 SHORT $LN17@stbi__pars
  00811	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00818	e8 00 00 00 00	 call	 stbi__get16be
  0081d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00822	0f b6 c0	 movzx	 eax, al
  00825	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0082c	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  00830	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__depth_scale_table
  00837	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0083b	0f af c1	 imul	 eax, ecx
  0083e	48 63 8d 44 05
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00845	88 84 0d 64 04
	00 00		 mov	 BYTE PTR tc$[rbp+rcx], al
  0084c	eb a3		 jmp	 SHORT $LN16@stbi__pars
$LN17@stbi__pars:
$LN60@stbi__pars:
$LN52@stbi__pars:

; 4686 :                 }
; 4687 :             }
; 4688 :             break;

  0084e	e9 3b 06 00 00	 jmp	 $LN5@stbi__pars
$LN61@stbi__pars:

; 4689 :         }
; 4690 : 
; 4691 :         case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
; 4692 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00853	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  0085a	74 11		 je	 SHORT $LN62@stbi__pars
  0085c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  00863	e8 00 00 00 00	 call	 stbi__err
  00868	e9 32 06 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 4693 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");

  0086d	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00874	85 c0		 test	 eax, eax
  00876	74 1a		 je	 SHORT $LN63@stbi__pars
  00878	83 bd 04 05 00
	00 00		 cmp	 DWORD PTR pal_len$[rbp], 0
  0087f	75 11		 jne	 SHORT $LN63@stbi__pars
  00881	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CKIELOEH@no?5PLTE@
  00888	e8 00 00 00 00	 call	 stbi__err
  0088d	e9 0d 06 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:

; 4694 :             if (scan == STBI__SCAN_header) {

  00892	83 bd f8 09 00
	00 02		 cmp	 DWORD PTR scan$[rbp], 2
  00899	75 26		 jne	 SHORT $LN64@stbi__pars

; 4695 :                 // header scan definitely stops at first IDAT
; 4696 :                 if (pal_img_n)

  0089b	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  008a2	85 c0		 test	 eax, eax
  008a4	74 11		 je	 SHORT $LN65@stbi__pars

; 4697 :                     s->img_n = pal_img_n;

  008a6	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  008ad	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  008b4	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN65@stbi__pars:

; 4698 :                 return 1;

  008b7	b8 01 00 00 00	 mov	 eax, 1
  008bc	e9 de 05 00 00	 jmp	 $LN1@stbi__pars
$LN64@stbi__pars:

; 4699 :             }
; 4700 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");

  008c1	81 bd e8 05 00
	00 00 00 00 40	 cmp	 DWORD PTR c$8[rbp], 1073741824 ; 40000000H
  008cb	76 11		 jbe	 SHORT $LN66@stbi__pars
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@PLHGLONG@IDAT?5size?5limit@
  008d4	e8 00 00 00 00	 call	 stbi__err
  008d9	e9 c1 05 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 4701 :             if ((int)(ioff + c.length) < (int)ioff) return 0;

  008de	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  008e4	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR ioff$[rbp]
  008ea	03 c8		 add	 ecx, eax
  008ec	8b c1		 mov	 eax, ecx
  008ee	3b 85 a4 04 00
	00		 cmp	 eax, DWORD PTR ioff$[rbp]
  008f4	7d 07		 jge	 SHORT $LN67@stbi__pars
  008f6	33 c0		 xor	 eax, eax
  008f8	e9 a2 05 00 00	 jmp	 $LN1@stbi__pars
$LN67@stbi__pars:

; 4702 :             if (ioff + c.length > idata_limit) {

  008fd	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  00903	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR ioff$[rbp]
  00909	03 c8		 add	 ecx, eax
  0090b	8b c1		 mov	 eax, ecx
  0090d	3b 85 c4 04 00
	00		 cmp	 eax, DWORD PTR idata_limit$[rbp]
  00913	0f 86 ba 00 00
	00		 jbe	 $LN68@stbi__pars

; 4703 :                 stbi__uint32 idata_limit_old = idata_limit;

  00919	8b 85 c4 04 00
	00		 mov	 eax, DWORD PTR idata_limit$[rbp]
  0091f	89 85 44 06 00
	00		 mov	 DWORD PTR idata_limit_old$11[rbp], eax

; 4704 :                 stbi_uc* p;
; 4705 :                 if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

  00925	83 bd c4 04 00
	00 00		 cmp	 DWORD PTR idata_limit$[rbp], 0
  0092c	75 30		 jne	 SHORT $LN69@stbi__pars
  0092e	81 bd e8 05 00
	00 00 10 00 00	 cmp	 DWORD PTR c$8[rbp], 4096 ; 00001000H
  00938	76 0e		 jbe	 SHORT $LN101@stbi__pars
  0093a	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  00940	89 85 b4 09 00
	00		 mov	 DWORD PTR tv345[rbp], eax
  00946	eb 0a		 jmp	 SHORT $LN102@stbi__pars
$LN101@stbi__pars:
  00948	c7 85 b4 09 00
	00 00 10 00 00	 mov	 DWORD PTR tv345[rbp], 4096 ; 00001000H
$LN102@stbi__pars:
  00952	8b 85 b4 09 00
	00		 mov	 eax, DWORD PTR tv345[rbp]
  00958	89 85 c4 04 00
	00		 mov	 DWORD PTR idata_limit$[rbp], eax
$LN69@stbi__pars:
$LN19@stbi__pars:

; 4706 :                 while (ioff + c.length > idata_limit)

  0095e	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  00964	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR ioff$[rbp]
  0096a	03 c8		 add	 ecx, eax
  0096c	8b c1		 mov	 eax, ecx
  0096e	3b 85 c4 04 00
	00		 cmp	 eax, DWORD PTR idata_limit$[rbp]
  00974	76 10		 jbe	 SHORT $LN20@stbi__pars

; 4707 :                     idata_limit *= 2;

  00976	8b 85 c4 04 00
	00		 mov	 eax, DWORD PTR idata_limit$[rbp]
  0097c	d1 e0		 shl	 eax, 1
  0097e	89 85 c4 04 00
	00		 mov	 DWORD PTR idata_limit$[rbp], eax
  00984	eb d8		 jmp	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:

; 4708 :                 STBI_NOTUSED(idata_limit_old);
; 4709 :                 p = (stbi_uc*)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00986	8b 85 c4 04 00
	00		 mov	 eax, DWORD PTR idata_limit$[rbp]
  0098c	8b d0		 mov	 edx, eax
  0098e	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00995	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00999	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0099f	48 89 85 68 06
	00 00		 mov	 QWORD PTR p$12[rbp], rax
  009a6	48 83 bd 68 06
	00 00 00	 cmp	 QWORD PTR p$12[rbp], 0
  009ae	75 11		 jne	 SHORT $LN70@stbi__pars
  009b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  009b7	e8 00 00 00 00	 call	 stbi__err
  009bc	e9 de 04 00 00	 jmp	 $LN1@stbi__pars
$LN70@stbi__pars:

; 4710 :                 z->idata = p;

  009c1	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  009c8	48 8b 8d 68 06
	00 00		 mov	 rcx, QWORD PTR p$12[rbp]
  009cf	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN68@stbi__pars:

; 4711 :             }
; 4712 :             if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");

  009d3	8b 85 a4 04 00
	00		 mov	 eax, DWORD PTR ioff$[rbp]
  009d9	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  009e0	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  009e4	44 8b 85 e8 05
	00 00		 mov	 r8d, DWORD PTR c$8[rbp]
  009eb	48 8b d0	 mov	 rdx, rax
  009ee	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  009f5	e8 00 00 00 00	 call	 stbi__getn
  009fa	85 c0		 test	 eax, eax
  009fc	75 11		 jne	 SHORT $LN71@stbi__pars
  009fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MNNCNKEO@outofdata@
  00a05	e8 00 00 00 00	 call	 stbi__err
  00a0a	e9 90 04 00 00	 jmp	 $LN1@stbi__pars
$LN71@stbi__pars:

; 4713 :             ioff += c.length;

  00a0f	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp]
  00a15	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR ioff$[rbp]
  00a1b	03 c8		 add	 ecx, eax
  00a1d	8b c1		 mov	 eax, ecx
  00a1f	89 85 a4 04 00
	00		 mov	 DWORD PTR ioff$[rbp], eax

; 4714 :             break;

  00a25	e9 64 04 00 00	 jmp	 $LN5@stbi__pars
$LN72@stbi__pars:

; 4715 :         }
; 4716 : 
; 4717 :         case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
; 4718 :             stbi__uint32 raw_len, bpl;
; 4719 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00a2a	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  00a31	74 11		 je	 SHORT $LN73@stbi__pars
  00a33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  00a3a	e8 00 00 00 00	 call	 stbi__err
  00a3f	e9 5b 04 00 00	 jmp	 $LN1@stbi__pars
$LN73@stbi__pars:

; 4720 :             if (scan != STBI__SCAN_load) return 1;

  00a44	83 bd f8 09 00
	00 00		 cmp	 DWORD PTR scan$[rbp], 0
  00a4b	74 0a		 je	 SHORT $LN74@stbi__pars
  00a4d	b8 01 00 00 00	 mov	 eax, 1
  00a52	e9 48 04 00 00	 jmp	 $LN1@stbi__pars
$LN74@stbi__pars:

; 4721 :             if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");

  00a57	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00a5e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00a63	75 11		 jne	 SHORT $LN75@stbi__pars
  00a65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MLPECBNA@no?5IDAT@
  00a6c	e8 00 00 00 00	 call	 stbi__err
  00a71	e9 29 04 00 00	 jmp	 $LN1@stbi__pars
$LN75@stbi__pars:

; 4722 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 4723 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

  00a76	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00a7d	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00a84	8b 00		 mov	 eax, DWORD PTR [rax]
  00a86	0f af 41 20	 imul	 eax, DWORD PTR [rcx+32]
  00a8a	83 c0 07	 add	 eax, 7
  00a8d	33 d2		 xor	 edx, edx
  00a8f	b9 08 00 00 00	 mov	 ecx, 8
  00a94	f7 f1		 div	 ecx
  00a96	89 85 a4 06 00
	00		 mov	 DWORD PTR bpl$14[rbp], eax

; 4724 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

  00a9c	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00aa3	8b 8d a4 06 00
	00		 mov	 ecx, DWORD PTR bpl$14[rbp]
  00aa9	0f af 48 04	 imul	 ecx, DWORD PTR [rax+4]
  00aad	8b c1		 mov	 eax, ecx
  00aaf	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00ab6	0f af 41 08	 imul	 eax, DWORD PTR [rcx+8]
  00aba	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00ac1	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00ac4	89 85 84 06 00
	00		 mov	 DWORD PTR raw_len$13[rbp], eax

; 4725 :             z->expanded = (stbi_uc*)stbi_zlib_decode_malloc_guesssize_headerflag((char*)z->idata, ioff, raw_len, (int*)&raw_len, !is_iphone);

  00aca	83 bd a4 05 00
	00 00		 cmp	 DWORD PTR is_iphone$[rbp], 0
  00ad1	75 0c		 jne	 SHORT $LN103@stbi__pars
  00ad3	c7 85 b4 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv394[rbp], 1
  00add	eb 0a		 jmp	 SHORT $LN104@stbi__pars
$LN103@stbi__pars:
  00adf	c7 85 b4 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv394[rbp], 0
$LN104@stbi__pars:
  00ae9	8b 85 b4 09 00
	00		 mov	 eax, DWORD PTR tv394[rbp]
  00aef	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00af3	4c 8d 8d 84 06
	00 00		 lea	 r9, QWORD PTR raw_len$13[rbp]
  00afa	44 8b 85 84 06
	00 00		 mov	 r8d, DWORD PTR raw_len$13[rbp]
  00b01	8b 95 a4 04 00
	00		 mov	 edx, DWORD PTR ioff$[rbp]
  00b07	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00b0e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b12	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize_headerflag
  00b17	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00b1e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 4726 :             if (z->expanded == NULL) return 0; // zlib should set error

  00b22	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00b29	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00b2e	75 07		 jne	 SHORT $LN76@stbi__pars
  00b30	33 c0		 xor	 eax, eax
  00b32	e9 68 03 00 00	 jmp	 $LN1@stbi__pars
$LN76@stbi__pars:

; 4727 :             STBI_FREE(z->idata); z->idata = NULL;

  00b37	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00b3e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00b48	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00b4f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 4728 :             if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)

  00b57	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00b5e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00b61	ff c0		 inc	 eax
  00b63	39 85 00 0a 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  00b69	75 14		 jne	 SHORT $LN80@stbi__pars
  00b6b	83 bd 00 0a 00
	00 03		 cmp	 DWORD PTR req_comp$[rbp], 3
  00b72	74 0b		 je	 SHORT $LN80@stbi__pars
  00b74	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00b7b	85 c0		 test	 eax, eax
  00b7d	74 0b		 je	 SHORT $LN79@stbi__pars
$LN80@stbi__pars:
  00b7f	0f b6 85 44 04
	00 00		 movzx	 eax, BYTE PTR has_trans$[rbp]
  00b86	85 c0		 test	 eax, eax
  00b88	74 18		 je	 SHORT $LN77@stbi__pars
$LN79@stbi__pars:

; 4729 :                 s->img_out_n = s->img_n + 1;

  00b8a	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00b91	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00b94	ff c0		 inc	 eax
  00b96	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00b9d	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00ba0	eb 14		 jmp	 SHORT $LN78@stbi__pars
$LN77@stbi__pars:

; 4730 :             else
; 4731 :                 s->img_out_n = s->img_n;

  00ba2	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00ba9	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00bb0	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00bb3	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN78@stbi__pars:

; 4732 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

  00bb6	8b 85 64 05 00
	00		 mov	 eax, DWORD PTR interlace$[rbp]
  00bbc	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00bc0	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR color$[rbp]
  00bc6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00bca	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00bd1	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00bd4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bd8	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00bdf	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00be3	44 8b 85 84 06
	00 00		 mov	 r8d, DWORD PTR raw_len$13[rbp]
  00bea	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00bf1	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00bf5	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00bfc	e8 00 00 00 00	 call	 stbi__create_png_image
  00c01	85 c0		 test	 eax, eax
  00c03	75 07		 jne	 SHORT $LN81@stbi__pars
  00c05	33 c0		 xor	 eax, eax
  00c07	e9 93 02 00 00	 jmp	 $LN1@stbi__pars
$LN81@stbi__pars:

; 4733 :             if (has_trans) {

  00c0c	0f b6 85 44 04
	00 00		 movzx	 eax, BYTE PTR has_trans$[rbp]
  00c13	85 c0		 test	 eax, eax
  00c15	74 61		 je	 SHORT $LN82@stbi__pars

; 4734 :                 if (z->depth == 16) {

  00c17	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c1e	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00c22	75 2b		 jne	 SHORT $LN83@stbi__pars

; 4735 :                     if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

  00c24	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00c2b	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00c2f	48 8d 95 84 04
	00 00		 lea	 rdx, QWORD PTR tc16$[rbp]
  00c36	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00c3d	e8 00 00 00 00	 call	 stbi__compute_transparency16
  00c42	85 c0		 test	 eax, eax
  00c44	75 07		 jne	 SHORT $LN85@stbi__pars
  00c46	33 c0		 xor	 eax, eax
  00c48	e9 52 02 00 00	 jmp	 $LN1@stbi__pars
$LN85@stbi__pars:

; 4736 :                 }

  00c4d	eb 29		 jmp	 SHORT $LN84@stbi__pars
$LN83@stbi__pars:

; 4737 :                 else {
; 4738 :                     if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

  00c4f	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00c56	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00c5a	48 8d 95 64 04
	00 00		 lea	 rdx, QWORD PTR tc$[rbp]
  00c61	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00c68	e8 00 00 00 00	 call	 stbi__compute_transparency
  00c6d	85 c0		 test	 eax, eax
  00c6f	75 07		 jne	 SHORT $LN86@stbi__pars
  00c71	33 c0		 xor	 eax, eax
  00c73	e9 27 02 00 00	 jmp	 $LN1@stbi__pars
$LN86@stbi__pars:
$LN84@stbi__pars:
$LN82@stbi__pars:

; 4739 :                 }
; 4740 :             }
; 4741 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

  00c78	83 bd a4 05 00
	00 00		 cmp	 DWORD PTR is_iphone$[rbp], 0
  00c7f	74 73		 je	 SHORT $LN87@stbi__pars
  00c81	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_set
  00c86	8b c0		 mov	 eax, eax
  00c88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00c8e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00c97	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00c9b	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00c9f	74 25		 je	 SHORT $LN105@stbi__pars
  00ca1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_local
  00ca6	8b c0		 mov	 eax, eax
  00ca8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00cae	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00cb7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00cbb	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00cbe	89 85 b4 09 00
	00		 mov	 DWORD PTR tv461[rbp], eax
  00cc4	eb 0c		 jmp	 SHORT $LN106@stbi__pars
$LN105@stbi__pars:
  00cc6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__de_iphone_flag_global
  00ccc	89 85 b4 09 00
	00		 mov	 DWORD PTR tv461[rbp], eax
$LN106@stbi__pars:
  00cd2	83 bd b4 09 00
	00 00		 cmp	 DWORD PTR tv461[rbp], 0
  00cd9	74 19		 je	 SHORT $LN87@stbi__pars
  00cdb	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00ce2	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  00ce6	7e 0c		 jle	 SHORT $LN87@stbi__pars

; 4742 :                 stbi__de_iphone(z);

  00ce8	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00cef	e8 00 00 00 00	 call	 stbi__de_iphone
$LN87@stbi__pars:

; 4743 :             if (pal_img_n) {

  00cf4	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00cfb	85 c0		 test	 eax, eax
  00cfd	74 6a		 je	 SHORT $LN88@stbi__pars

; 4744 :                 // pal_img_n == 3 or 4
; 4745 :                 s->img_n = pal_img_n; // record the actual colors we had

  00cff	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00d06	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00d0d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4746 :                 s->img_out_n = pal_img_n;

  00d10	0f b6 85 24 04
	00 00		 movzx	 eax, BYTE PTR pal_img_n$[rbp]
  00d17	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00d1e	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 4747 :                 if (req_comp >= 3) s->img_out_n = req_comp;

  00d21	83 bd 00 0a 00
	00 03		 cmp	 DWORD PTR req_comp$[rbp], 3
  00d28	7c 10		 jl	 SHORT $LN90@stbi__pars
  00d2a	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00d31	8b 8d 00 0a 00
	00		 mov	 ecx, DWORD PTR req_comp$[rbp]
  00d37	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN90@stbi__pars:

; 4748 :                 if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

  00d3a	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00d41	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00d45	44 8b 85 04 05
	00 00		 mov	 r8d, DWORD PTR pal_len$[rbp]
  00d4c	48 8d 55 10	 lea	 rdx, QWORD PTR palette$[rbp]
  00d50	48 8b 8d f0 09
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00d57	e8 00 00 00 00	 call	 stbi__expand_png_palette
  00d5c	85 c0		 test	 eax, eax
  00d5e	75 07		 jne	 SHORT $LN91@stbi__pars

; 4749 :                     return 0;

  00d60	33 c0		 xor	 eax, eax
  00d62	e9 38 01 00 00	 jmp	 $LN1@stbi__pars
$LN91@stbi__pars:

; 4750 :             }

  00d67	eb 21		 jmp	 SHORT $LN89@stbi__pars
$LN88@stbi__pars:

; 4751 :             else if (has_trans) {

  00d69	0f b6 85 44 04
	00 00		 movzx	 eax, BYTE PTR has_trans$[rbp]
  00d70	85 c0		 test	 eax, eax
  00d72	74 16		 je	 SHORT $LN92@stbi__pars

; 4752 :                 // non-paletted image with tRNS -> source image has (constant) alpha
; 4753 :                 ++s->img_n;

  00d74	48 8b 85 c8 05
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00d7b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00d7e	ff c0		 inc	 eax
  00d80	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00d87	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN92@stbi__pars:
$LN89@stbi__pars:

; 4754 :             }
; 4755 :             STBI_FREE(z->expanded); z->expanded = NULL;

  00d8a	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00d91	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00d95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00d9b	48 8b 85 f0 09
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00da2	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4756 :             // end of PNG chunk, read and skip CRC
; 4757 :             stbi__get32be(s);

  00daa	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00db1	e8 00 00 00 00	 call	 stbi__get32be

; 4758 :             return 1;

  00db6	b8 01 00 00 00	 mov	 eax, 1
  00dbb	e9 df 00 00 00	 jmp	 $LN1@stbi__pars
$LN93@stbi__pars:

; 4759 :         }
; 4760 : 
; 4761 :         default:
; 4762 :             // if critical, fail
; 4763 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00dc0	83 bd 24 05 00
	00 00		 cmp	 DWORD PTR first$[rbp], 0
  00dc7	74 11		 je	 SHORT $LN94@stbi__pars
  00dc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  00dd0	e8 00 00 00 00	 call	 stbi__err
  00dd5	e9 c5 00 00 00	 jmp	 $LN1@stbi__pars
$LN94@stbi__pars:

; 4764 :             if ((c.type & (1 << 29)) == 0) {

  00dda	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  00de0	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00de5	85 c0		 test	 eax, eax
  00de7	0f 85 8f 00 00
	00		 jne	 $LN95@stbi__pars

; 4765 : #ifndef STBI_NO_FAILURE_STRINGS
; 4766 :                 // not threadsafe
; 4767 :                 static char invalid_chunk[] = "XXXX PNG chunk not known";
; 4768 :                 invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

  00ded	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  00df3	c1 e8 18	 shr	 eax, 24
  00df6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00dfb	b9 01 00 00 00	 mov	 ecx, 1
  00e00	48 6b c9 00	 imul	 rcx, rcx, 0
  00e04	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  00e0b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4769 :                 invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

  00e0e	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  00e14	c1 e8 10	 shr	 eax, 16
  00e17	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e1c	b9 01 00 00 00	 mov	 ecx, 1
  00e21	48 6b c9 01	 imul	 rcx, rcx, 1
  00e25	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  00e2c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4770 :                 invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);

  00e2f	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  00e35	c1 e8 08	 shr	 eax, 8
  00e38	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e3d	b9 01 00 00 00	 mov	 ecx, 1
  00e42	48 6b c9 02	 imul	 rcx, rcx, 2
  00e46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  00e4d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4771 :                 invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);

  00e50	8b 85 ec 05 00
	00		 mov	 eax, DWORD PTR c$8[rbp+4]
  00e56	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e5b	b9 01 00 00 00	 mov	 ecx, 1
  00e60	48 6b c9 03	 imul	 rcx, rcx, 3
  00e64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  00e6b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4772 : #endif
; 4773 :                 return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

  00e6e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  00e75	e8 00 00 00 00	 call	 stbi__err
  00e7a	eb 23		 jmp	 SHORT $LN1@stbi__pars
$LN95@stbi__pars:

; 4774 :             }
; 4775 :             stbi__skip(s, c.length);

  00e7c	8b 95 e8 05 00
	00		 mov	 edx, DWORD PTR c$8[rbp]
  00e82	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e89	e8 00 00 00 00	 call	 stbi__skip
$LN5@stbi__pars:

; 4776 :             break;
; 4777 :         }
; 4778 :         // end of PNG chunk, read and skip CRC
; 4779 :         stbi__get32be(s);

  00e8e	48 8b 8d c8 05
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e95	e8 00 00 00 00	 call	 stbi__get32be

; 4780 :     }

  00e9a	e9 82 f2 ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 4781 : }

  00e9f	48 8b f8	 mov	 rdi, rax
  00ea2	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  00ea6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_png_file$rtcFrameData
  00ead	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00eb2	48 8b c7	 mov	 rax, rdi
  00eb5	48 8b 8d c0 09
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00ebc	48 33 cd	 xor	 rcx, rbp
  00ebf	e8 00 00 00 00	 call	 __security_check_cookie
  00ec4	48 8d a5 d8 09
	00 00		 lea	 rsp, QWORD PTR [rbp+2520]
  00ecb	5f		 pop	 rdi
  00ecc	5d		 pop	 rbp
  00ecd	c3		 ret	 0
stbi__parse_png_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__de_iphone
_TEXT	SEGMENT
s$ = 8
i$ = 36
pixel_count$ = 68
p$ = 104
t$1 = 132
a$2 = 164
t$3 = 196
half$4 = 228
t$5 = 260
tv133 = 468
z$ = 512
stbi__de_iphone PROC					; COMDAT

; 4548 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4549 :     stbi__context* s = z->s;

  0001f	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 45 08	 mov	 QWORD PTR s$[rbp], rax

; 4550 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  0002d	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00031	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00035	8b 00		 mov	 eax, DWORD PTR [rax]
  00037	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0003b	89 45 44	 mov	 DWORD PTR pixel_count$[rbp], eax

; 4551 :     stbi_uc* p = z->out;

  0003e	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00045	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00049	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4552 : 
; 4553 :     if (s->img_out_n == 3) {  // convert bgr to rgb

  0004d	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00051	83 78 0c 03	 cmp	 DWORD PTR [rax+12], 3
  00055	75 7c		 jne	 SHORT $LN11@stbi__de_i

; 4554 :         for (i = 0; i < pixel_count; ++i) {

  00057	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0005e	eb 08		 jmp	 SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
  00060	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00063	ff c0		 inc	 eax
  00065	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__de_i:
  00068	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  0006b	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  0006e	73 5e		 jae	 SHORT $LN3@stbi__de_i

; 4555 :             stbi_uc t = p[0];

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	48 6b c0 00	 imul	 rax, rax, 0
  00079	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  0007d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00081	88 85 84 00 00
	00		 mov	 BYTE PTR t$1[rbp], al

; 4556 :             p[0] = p[2];

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 6b c0 02	 imul	 rax, rax, 2
  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	48 6b c9 00	 imul	 rcx, rcx, 0
  00099	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  0009d	4c 8b 45 68	 mov	 r8, QWORD PTR p$[rbp]
  000a1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000a6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4557 :             p[2] = t;

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	48 6b c0 02	 imul	 rax, rax, 2
  000b2	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  000b6	0f b6 95 84 00
	00 00		 movzx	 edx, BYTE PTR t$1[rbp]
  000bd	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4558 :             p += 3;

  000c0	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  000c4	48 83 c0 03	 add	 rax, 3
  000c8	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4559 :         }

  000cc	eb 92		 jmp	 SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 4560 :     }

  000ce	e9 59 02 00 00	 jmp	 $LN12@stbi__de_i
$LN11@stbi__de_i:

; 4561 :     else {
; 4562 :         STBI_ASSERT(s->img_out_n == 4);

  000d3	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  000d7	83 78 0c 04	 cmp	 DWORD PTR [rax+12], 4
  000db	74 1c		 je	 SHORT $LN18@stbi__de_i
  000dd	41 b8 d2 11 00
	00		 mov	 r8d, 4562		; 000011d2H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f7	33 c0		 xor	 eax, eax
$LN18@stbi__de_i:

; 4563 :         if (stbi__unpremultiply_on_load) {

  000f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_set
  000fe	8b c0		 mov	 eax, eax
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00106	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00113	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00117	74 25		 je	 SHORT $LN19@stbi__de_i
  00119	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_local
  0011e	8b c0		 mov	 eax, eax
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00126	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0012f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00133	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00136	89 85 d4 01 00
	00		 mov	 DWORD PTR tv133[rbp], eax
  0013c	eb 0c		 jmp	 SHORT $LN20@stbi__de_i
$LN19@stbi__de_i:
  0013e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__unpremultiply_on_load_global
  00144	89 85 d4 01 00
	00		 mov	 DWORD PTR tv133[rbp], eax
$LN20@stbi__de_i:
  0014a	83 bd d4 01 00
	00 00		 cmp	 DWORD PTR tv133[rbp], 0
  00151	0f 84 5e 01 00
	00		 je	 $LN13@stbi__de_i

; 4564 :             // convert bgr to rgb and unpremultiply
; 4565 :             for (i = 0; i < pixel_count; ++i) {

  00157	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0015e	eb 08		 jmp	 SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
  00160	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00163	ff c0		 inc	 eax
  00165	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__de_i:
  00168	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  0016b	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  0016e	0f 83 3f 01 00
	00		 jae	 $LN6@stbi__de_i

; 4566 :                 stbi_uc a = p[3];

  00174	b8 01 00 00 00	 mov	 eax, 1
  00179	48 6b c0 03	 imul	 rax, rax, 3
  0017d	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00181	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00185	88 85 a4 00 00
	00		 mov	 BYTE PTR a$2[rbp], al

; 4567 :                 stbi_uc t = p[0];

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	48 6b c0 00	 imul	 rax, rax, 0
  00194	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00198	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019c	88 85 c4 00 00
	00		 mov	 BYTE PTR t$3[rbp], al

; 4568 :                 if (a) {

  001a2	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR a$2[rbp]
  001a9	85 c0		 test	 eax, eax
  001ab	0f 84 b8 00 00
	00		 je	 $LN15@stbi__de_i

; 4569 :                     stbi_uc half = a / 2;

  001b1	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR a$2[rbp]
  001b8	99		 cdq
  001b9	2b c2		 sub	 eax, edx
  001bb	d1 f8		 sar	 eax, 1
  001bd	88 85 e4 00 00
	00		 mov	 BYTE PTR half$4[rbp], al

; 4570 :                     p[0] = (p[2] * 255 + half) / a;

  001c3	b8 01 00 00 00	 mov	 eax, 1
  001c8	48 6b c0 02	 imul	 rax, rax, 2
  001cc	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  001d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d4	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  001da	0f b6 8d e4 00
	00 00		 movzx	 ecx, BYTE PTR half$4[rbp]
  001e1	03 c1		 add	 eax, ecx
  001e3	0f b6 8d a4 00
	00 00		 movzx	 ecx, BYTE PTR a$2[rbp]
  001ea	99		 cdq
  001eb	f7 f9		 idiv	 ecx
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	48 6b c9 00	 imul	 rcx, rcx, 0
  001f6	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  001fa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4571 :                     p[1] = (p[1] * 255 + half) / a;

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	48 6b c0 01	 imul	 rax, rax, 1
  00206	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  0020a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020e	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  00214	0f b6 8d e4 00
	00 00		 movzx	 ecx, BYTE PTR half$4[rbp]
  0021b	03 c1		 add	 eax, ecx
  0021d	0f b6 8d a4 00
	00 00		 movzx	 ecx, BYTE PTR a$2[rbp]
  00224	99		 cdq
  00225	f7 f9		 idiv	 ecx
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	48 6b c9 01	 imul	 rcx, rcx, 1
  00230	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  00234	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4572 :                     p[2] = (t * 255 + half) / a;

  00237	0f b6 85 c4 00
	00 00		 movzx	 eax, BYTE PTR t$3[rbp]
  0023e	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  00244	0f b6 8d e4 00
	00 00		 movzx	 ecx, BYTE PTR half$4[rbp]
  0024b	03 c1		 add	 eax, ecx
  0024d	0f b6 8d a4 00
	00 00		 movzx	 ecx, BYTE PTR a$2[rbp]
  00254	99		 cdq
  00255	f7 f9		 idiv	 ecx
  00257	b9 01 00 00 00	 mov	 ecx, 1
  0025c	48 6b c9 02	 imul	 rcx, rcx, 2
  00260	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  00264	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4573 :                 }

  00267	eb 39		 jmp	 SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 4574 :                 else {
; 4575 :                     p[0] = p[2];

  00269	b8 01 00 00 00	 mov	 eax, 1
  0026e	48 6b c0 02	 imul	 rax, rax, 2
  00272	b9 01 00 00 00	 mov	 ecx, 1
  00277	48 6b c9 00	 imul	 rcx, rcx, 0
  0027b	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  0027f	4c 8b 45 68	 mov	 r8, QWORD PTR p$[rbp]
  00283	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00288	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4576 :                     p[2] = t;

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 02	 imul	 rax, rax, 2
  00294	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00298	0f b6 95 c4 00
	00 00		 movzx	 edx, BYTE PTR t$3[rbp]
  0029f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN16@stbi__de_i:

; 4577 :                 }
; 4578 :                 p += 4;

  002a2	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  002a6	48 83 c0 04	 add	 rax, 4
  002aa	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4579 :             }

  002ae	e9 ad fe ff ff	 jmp	 $LN5@stbi__de_i
$LN6@stbi__de_i:

; 4580 :         }

  002b3	eb 77		 jmp	 SHORT $LN14@stbi__de_i
$LN13@stbi__de_i:

; 4581 :         else {
; 4582 :             // convert bgr to rgb
; 4583 :             for (i = 0; i < pixel_count; ++i) {

  002b5	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  002bc	eb 08		 jmp	 SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
  002be	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  002c1	ff c0		 inc	 eax
  002c3	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__de_i:
  002c6	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  002c9	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  002cc	73 5e		 jae	 SHORT $LN9@stbi__de_i

; 4584 :                 stbi_uc t = p[0];

  002ce	b8 01 00 00 00	 mov	 eax, 1
  002d3	48 6b c0 00	 imul	 rax, rax, 0
  002d7	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  002db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002df	88 85 04 01 00
	00		 mov	 BYTE PTR t$5[rbp], al

; 4585 :                 p[0] = p[2];

  002e5	b8 01 00 00 00	 mov	 eax, 1
  002ea	48 6b c0 02	 imul	 rax, rax, 2
  002ee	b9 01 00 00 00	 mov	 ecx, 1
  002f3	48 6b c9 00	 imul	 rcx, rcx, 0
  002f7	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  002fb	4c 8b 45 68	 mov	 r8, QWORD PTR p$[rbp]
  002ff	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00304	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4586 :                 p[2] = t;

  00307	b8 01 00 00 00	 mov	 eax, 1
  0030c	48 6b c0 02	 imul	 rax, rax, 2
  00310	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00314	0f b6 95 04 01
	00 00		 movzx	 edx, BYTE PTR t$5[rbp]
  0031b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4587 :                 p += 4;

  0031e	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  00322	48 83 c0 04	 add	 rax, 4
  00326	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4588 :             }

  0032a	eb 92		 jmp	 SHORT $LN8@stbi__de_i
$LN9@stbi__de_i:
$LN14@stbi__de_i:
$LN12@stbi__de_i:

; 4589 :         }
; 4590 :     }
; 4591 : }

  0032c	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  00333	5f		 pop	 rdi
  00334	5d		 pop	 rbp
  00335	c3		 ret	 0
stbi__de_iphone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__expand_png_palette
_TEXT	SEGMENT
i$ = 4
pixel_count$ = 36
p$ = 72
temp_out$ = 104
orig$ = 136
n$1 = 164
n$2 = 196
a$ = 448
palette$ = 456
len$ = 464
pal_img_n$ = 472
stbi__expand_png_palette PROC				; COMDAT

; 4470 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4471 :     stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

  0002e	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	8b 00		 mov	 eax, DWORD PTR [rax]
  00044	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00048	89 45 24	 mov	 DWORD PTR pixel_count$[rbp], eax

; 4472 :     stbi_uc* p, * temp_out, * orig = a->out;

  0004b	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00052	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00056	48 89 85 88 00
	00 00		 mov	 QWORD PTR orig$[rbp], rax

; 4473 : 
; 4474 :     p = (stbi_uc*)stbi__malloc_mad2(pixel_count, pal_img_n, 0);

  0005d	45 33 c0	 xor	 r8d, r8d
  00060	8b 95 d8 01 00
	00		 mov	 edx, DWORD PTR pal_img_n$[rbp]
  00066	8b 4d 24	 mov	 ecx, DWORD PTR pixel_count$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__malloc_mad2
  0006e	48 89 45 48	 mov	 QWORD PTR p$[rbp], rax

; 4475 :     if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00072	48 83 7d 48 00	 cmp	 QWORD PTR p$[rbp], 0
  00077	75 11		 jne	 SHORT $LN8@stbi__expa
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00080	e8 00 00 00 00	 call	 stbi__err
  00085	e9 d0 01 00 00	 jmp	 $LN1@stbi__expa
$LN8@stbi__expa:

; 4476 : 
; 4477 :     // between here and free(out) below, exitting would leak
; 4478 :     temp_out = p;

  0008a	48 8b 45 48	 mov	 rax, QWORD PTR p$[rbp]
  0008e	48 89 45 68	 mov	 QWORD PTR temp_out$[rbp], rax

; 4479 : 
; 4480 :     if (pal_img_n == 3) {

  00092	83 bd d8 01 00
	00 03		 cmp	 DWORD PTR pal_img_n$[rbp], 3
  00099	0f 85 ba 00 00
	00		 jne	 $LN9@stbi__expa

; 4481 :         for (i = 0; i < pixel_count; ++i) {

  0009f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  000a6	eb 08		 jmp	 SHORT $LN4@stbi__expa
$LN2@stbi__expa:
  000a8	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000ab	ff c0		 inc	 eax
  000ad	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__expa:
  000b0	8b 45 24	 mov	 eax, DWORD PTR pixel_count$[rbp]
  000b3	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000b6	0f 83 98 00 00
	00		 jae	 $LN3@stbi__expa

; 4482 :             int n = orig[i] * 4;

  000bc	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000bf	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  000c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ca	c1 e0 02	 shl	 eax, 2
  000cd	89 85 a4 00 00
	00		 mov	 DWORD PTR n$1[rbp], eax

; 4483 :             p[0] = palette[n];

  000d3	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR n$1[rbp]
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	48 6b c9 00	 imul	 rcx, rcx, 0
  000e3	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  000e7	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  000ee	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000f3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4484 :             p[1] = palette[n + 1];

  000f6	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR n$1[rbp]
  000fc	ff c0		 inc	 eax
  000fe	48 98		 cdqe
  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	48 6b c9 01	 imul	 rcx, rcx, 1
  00109	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  0010d	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  00114	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00119	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4485 :             p[2] = palette[n + 2];

  0011c	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR n$1[rbp]
  00122	83 c0 02	 add	 eax, 2
  00125	48 98		 cdqe
  00127	b9 01 00 00 00	 mov	 ecx, 1
  0012c	48 6b c9 02	 imul	 rcx, rcx, 2
  00130	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  00134	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  0013b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00140	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4486 :             p += 3;

  00143	48 8b 45 48	 mov	 rax, QWORD PTR p$[rbp]
  00147	48 83 c0 03	 add	 rax, 3
  0014b	48 89 45 48	 mov	 QWORD PTR p$[rbp], rax

; 4487 :         }

  0014f	e9 54 ff ff ff	 jmp	 $LN2@stbi__expa
$LN3@stbi__expa:

; 4488 :     }

  00154	e9 dc 00 00 00	 jmp	 $LN10@stbi__expa
$LN9@stbi__expa:

; 4489 :     else {
; 4490 :         for (i = 0; i < pixel_count; ++i) {

  00159	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00160	eb 08		 jmp	 SHORT $LN7@stbi__expa
$LN5@stbi__expa:
  00162	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00165	ff c0		 inc	 eax
  00167	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__expa:
  0016a	8b 45 24	 mov	 eax, DWORD PTR pixel_count$[rbp]
  0016d	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00170	0f 83 bf 00 00
	00		 jae	 $LN6@stbi__expa

; 4491 :             int n = orig[i] * 4;

  00176	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00179	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  00180	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00184	c1 e0 02	 shl	 eax, 2
  00187	89 85 c4 00 00
	00		 mov	 DWORD PTR n$2[rbp], eax

; 4492 :             p[0] = palette[n];

  0018d	48 63 85 c4 00
	00 00		 movsxd	 rax, DWORD PTR n$2[rbp]
  00194	b9 01 00 00 00	 mov	 ecx, 1
  00199	48 6b c9 00	 imul	 rcx, rcx, 0
  0019d	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  001a1	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  001a8	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001ad	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4493 :             p[1] = palette[n + 1];

  001b0	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR n$2[rbp]
  001b6	ff c0		 inc	 eax
  001b8	48 98		 cdqe
  001ba	b9 01 00 00 00	 mov	 ecx, 1
  001bf	48 6b c9 01	 imul	 rcx, rcx, 1
  001c3	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  001c7	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  001ce	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4494 :             p[2] = palette[n + 2];

  001d6	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR n$2[rbp]
  001dc	83 c0 02	 add	 eax, 2
  001df	48 98		 cdqe
  001e1	b9 01 00 00 00	 mov	 ecx, 1
  001e6	48 6b c9 02	 imul	 rcx, rcx, 2
  001ea	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  001ee	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  001f5	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001fa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4495 :             p[3] = palette[n + 3];

  001fd	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR n$2[rbp]
  00203	83 c0 03	 add	 eax, 3
  00206	48 98		 cdqe
  00208	b9 01 00 00 00	 mov	 ecx, 1
  0020d	48 6b c9 03	 imul	 rcx, rcx, 3
  00211	48 8b 55 48	 mov	 rdx, QWORD PTR p$[rbp]
  00215	4c 8b 85 c8 01
	00 00		 mov	 r8, QWORD PTR palette$[rbp]
  0021c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00221	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4496 :             p += 4;

  00224	48 8b 45 48	 mov	 rax, QWORD PTR p$[rbp]
  00228	48 83 c0 04	 add	 rax, 4
  0022c	48 89 45 48	 mov	 QWORD PTR p$[rbp], rax

; 4497 :         }

  00230	e9 2d ff ff ff	 jmp	 $LN5@stbi__expa
$LN6@stbi__expa:
$LN10@stbi__expa:

; 4498 :     }
; 4499 :     STBI_FREE(a->out);

  00235	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0023c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4500 :     a->out = temp_out;

  00246	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0024d	48 8b 4d 68	 mov	 rcx, QWORD PTR temp_out$[rbp]
  00251	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4501 : 
; 4502 :     STBI_NOTUSED(len);
; 4503 : 
; 4504 :     return 1;

  00255	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__expa:

; 4505 : }

  0025a	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  00261	5f		 pop	 rdi
  00262	5d		 pop	 rbp
  00263	c3		 ret	 0
stbi__expand_png_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__compute_transparency16
_TEXT	SEGMENT
s$ = 8
i$ = 36
pixel_count$ = 68
p$ = 104
tv87 = 308
z$ = 352
tc$ = 360
out_n$ = 368
stbi__compute_transparency16 PROC			; COMDAT

; 4444 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4445 :     stbi__context* s = z->s;

  00029	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 45 08	 mov	 QWORD PTR s$[rbp], rax

; 4446 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00037	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  0003b	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  0003f	8b 00		 mov	 eax, DWORD PTR [rax]
  00041	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00045	89 45 44	 mov	 DWORD PTR pixel_count$[rbp], eax

; 4447 :     stbi__uint16* p = (stbi__uint16*)z->out;

  00048	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0004f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00053	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4448 : 
; 4449 :     // compute color-based transparency, assuming we've
; 4450 :     // already got 65535 as the alpha value in the output
; 4451 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00057	83 bd 70 01 00
	00 02		 cmp	 DWORD PTR out_n$[rbp], 2
  0005e	74 25		 je	 SHORT $LN12@stbi__comp
  00060	83 bd 70 01 00
	00 04		 cmp	 DWORD PTR out_n$[rbp], 4
  00067	74 1c		 je	 SHORT $LN12@stbi__comp
  00069	41 b8 63 11 00
	00		 mov	 r8d, 4451		; 00001163H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4452 : 
; 4453 :     if (out_n == 2) {

  00085	83 bd 70 01 00
	00 02		 cmp	 DWORD PTR out_n$[rbp], 2
  0008c	0f 85 83 00 00
	00		 jne	 $LN8@stbi__comp

; 4454 :         for (i = 0; i < pixel_count; ++i) {

  00092	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00099	eb 08		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0009b	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0009e	ff c0		 inc	 eax
  000a0	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__comp:
  000a3	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  000a6	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  000a9	73 65		 jae	 SHORT $LN3@stbi__comp

; 4455 :             p[1] = (p[0] == tc[0] ? 0 : 65535);

  000ab	b8 02 00 00 00	 mov	 eax, 2
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  000b8	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000bc	b9 02 00 00 00	 mov	 ecx, 2
  000c1	48 6b c9 00	 imul	 rcx, rcx, 0
  000c5	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  000cc	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  000d0	3b c1		 cmp	 eax, ecx
  000d2	75 0c		 jne	 SHORT $LN13@stbi__comp
  000d4	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv87[rbp], 0
  000de	eb 0a		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000e0	c7 85 34 01 00
	00 ff ff 00 00	 mov	 DWORD PTR tv87[rbp], 65535 ; 0000ffffH
$LN14@stbi__comp:
  000ea	b8 02 00 00 00	 mov	 eax, 2
  000ef	48 6b c0 01	 imul	 rax, rax, 1
  000f3	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  000f7	0f b7 95 34 01
	00 00		 movzx	 edx, WORD PTR tv87[rbp]
  000fe	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 4456 :             p += 2;

  00102	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  00106	48 83 c0 04	 add	 rax, 4
  0010a	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4457 :         }

  0010e	eb 8b		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4458 :     }

  00110	e9 bc 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4459 :     else {
; 4460 :         for (i = 0; i < pixel_count; ++i) {

  00115	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0011c	eb 08		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  0011e	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00121	ff c0		 inc	 eax
  00123	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__comp:
  00126	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  00129	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  0012c	0f 83 9f 00 00
	00		 jae	 $LN6@stbi__comp

; 4461 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	48 6b c0 00	 imul	 rax, rax, 0
  0013b	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  0013f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00143	b9 02 00 00 00	 mov	 ecx, 2
  00148	48 6b c9 00	 imul	 rcx, rcx, 0
  0014c	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  00153	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00157	3b c1		 cmp	 eax, ecx
  00159	75 65		 jne	 SHORT $LN10@stbi__comp
  0015b	b8 02 00 00 00	 mov	 eax, 2
  00160	48 6b c0 01	 imul	 rax, rax, 1
  00164	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00168	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0016c	b9 02 00 00 00	 mov	 ecx, 2
  00171	48 6b c9 01	 imul	 rcx, rcx, 1
  00175	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  0017c	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00180	3b c1		 cmp	 eax, ecx
  00182	75 3c		 jne	 SHORT $LN10@stbi__comp
  00184	b8 02 00 00 00	 mov	 eax, 2
  00189	48 6b c0 02	 imul	 rax, rax, 2
  0018d	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00191	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00195	b9 02 00 00 00	 mov	 ecx, 2
  0019a	48 6b c9 02	 imul	 rcx, rcx, 2
  0019e	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  001a5	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  001a9	3b c1		 cmp	 eax, ecx
  001ab	75 13		 jne	 SHORT $LN10@stbi__comp

; 4462 :                 p[3] = 0;

  001ad	b8 02 00 00 00	 mov	 eax, 2
  001b2	48 6b c0 03	 imul	 rax, rax, 3
  001b6	33 c9		 xor	 ecx, ecx
  001b8	48 8b 55 68	 mov	 rdx, QWORD PTR p$[rbp]
  001bc	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
$LN10@stbi__comp:

; 4463 :             p += 4;

  001c0	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  001c4	48 83 c0 08	 add	 rax, 8
  001c8	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4464 :         }

  001cc	e9 4d ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4465 :     }
; 4466 :     return 1;

  001d1	b8 01 00 00 00	 mov	 eax, 1

; 4467 : }

  001d6	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  001dd	5f		 pop	 rdi
  001de	5d		 pop	 rbp
  001df	c3		 ret	 0
stbi__compute_transparency16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__compute_transparency
_TEXT	SEGMENT
s$ = 8
i$ = 36
pixel_count$ = 68
p$ = 104
tv87 = 308
z$ = 352
tc$ = 360
out_n$ = 368
stbi__compute_transparency PROC				; COMDAT

; 4418 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4419 :     stbi__context* s = z->s;

  00029	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 45 08	 mov	 QWORD PTR s$[rbp], rax

; 4420 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00037	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  0003b	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  0003f	8b 00		 mov	 eax, DWORD PTR [rax]
  00041	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00045	89 45 44	 mov	 DWORD PTR pixel_count$[rbp], eax

; 4421 :     stbi_uc* p = z->out;

  00048	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0004f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00053	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4422 : 
; 4423 :     // compute color-based transparency, assuming we've
; 4424 :     // already got 255 as the alpha value in the output
; 4425 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00057	83 bd 70 01 00
	00 02		 cmp	 DWORD PTR out_n$[rbp], 2
  0005e	74 25		 je	 SHORT $LN12@stbi__comp
  00060	83 bd 70 01 00
	00 04		 cmp	 DWORD PTR out_n$[rbp], 4
  00067	74 1c		 je	 SHORT $LN12@stbi__comp
  00069	41 b8 49 11 00
	00		 mov	 r8d, 4425		; 00001149H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4426 : 
; 4427 :     if (out_n == 2) {

  00085	83 bd 70 01 00
	00 02		 cmp	 DWORD PTR out_n$[rbp], 2
  0008c	0f 85 82 00 00
	00		 jne	 $LN8@stbi__comp

; 4428 :         for (i = 0; i < pixel_count; ++i) {

  00092	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00099	eb 08		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0009b	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0009e	ff c0		 inc	 eax
  000a0	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__comp:
  000a3	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  000a6	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  000a9	73 64		 jae	 SHORT $LN3@stbi__comp

; 4429 :             p[1] = (p[0] == tc[0] ? 0 : 255);

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	b9 01 00 00 00	 mov	 ecx, 1
  000c1	48 6b c9 00	 imul	 rcx, rcx, 0
  000c5	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  000cc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d0	3b c1		 cmp	 eax, ecx
  000d2	75 0c		 jne	 SHORT $LN13@stbi__comp
  000d4	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv87[rbp], 0
  000de	eb 0a		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000e0	c7 85 34 01 00
	00 ff 00 00 00	 mov	 DWORD PTR tv87[rbp], 255 ; 000000ffH
$LN14@stbi__comp:
  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	48 6b c0 01	 imul	 rax, rax, 1
  000f3	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  000f7	0f b6 95 34 01
	00 00		 movzx	 edx, BYTE PTR tv87[rbp]
  000fe	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4430 :             p += 2;

  00101	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  00105	48 83 c0 02	 add	 rax, 2
  00109	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4431 :         }

  0010d	eb 8c		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4432 :     }

  0010f	e9 ba 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4433 :     else {
; 4434 :         for (i = 0; i < pixel_count; ++i) {

  00114	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0011b	eb 08		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  0011d	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00120	ff c0		 inc	 eax
  00122	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__comp:
  00125	8b 45 44	 mov	 eax, DWORD PTR pixel_count$[rbp]
  00128	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  0012b	0f 83 9d 00 00
	00		 jae	 $LN6@stbi__comp

; 4435 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	48 6b c0 00	 imul	 rax, rax, 0
  0013a	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  0013e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00142	b9 01 00 00 00	 mov	 ecx, 1
  00147	48 6b c9 00	 imul	 rcx, rcx, 0
  0014b	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  00152	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00156	3b c1		 cmp	 eax, ecx
  00158	75 63		 jne	 SHORT $LN10@stbi__comp
  0015a	b8 01 00 00 00	 mov	 eax, 1
  0015f	48 6b c0 01	 imul	 rax, rax, 1
  00163	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00167	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016b	b9 01 00 00 00	 mov	 ecx, 1
  00170	48 6b c9 01	 imul	 rcx, rcx, 1
  00174	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  0017b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0017f	3b c1		 cmp	 eax, ecx
  00181	75 3a		 jne	 SHORT $LN10@stbi__comp
  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	48 6b c0 02	 imul	 rax, rax, 2
  0018c	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	b9 01 00 00 00	 mov	 ecx, 1
  00199	48 6b c9 02	 imul	 rcx, rcx, 2
  0019d	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR tc$[rbp]
  001a4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001a8	3b c1		 cmp	 eax, ecx
  001aa	75 11		 jne	 SHORT $LN10@stbi__comp

; 4436 :                 p[3] = 0;

  001ac	b8 01 00 00 00	 mov	 eax, 1
  001b1	48 6b c0 03	 imul	 rax, rax, 3
  001b5	48 8b 4d 68	 mov	 rcx, QWORD PTR p$[rbp]
  001b9	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN10@stbi__comp:

; 4437 :             p += 4;

  001bd	48 8b 45 68	 mov	 rax, QWORD PTR p$[rbp]
  001c1	48 83 c0 04	 add	 rax, 4
  001c5	48 89 45 68	 mov	 QWORD PTR p$[rbp], rax

; 4438 :         }

  001c9	e9 4f ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4439 :     }
; 4440 :     return 1;

  001ce	b8 01 00 00 00	 mov	 eax, 1

; 4441 : }

  001d3	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  001da	5f		 pop	 rdi
  001db	5d		 pop	 rbp
  001dc	c3		 ret	 0
stbi__compute_transparency ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__create_png_image
_TEXT	SEGMENT
bytes$ = 4
out_bytes$ = 36
final$ = 72
p$ = 100
xorig$7 = 136
yorig$8 = 200
xspc$9 = 264
yspc$10 = 328
i$11 = 388
j$12 = 420
x$13 = 452
y$14 = 484
img_len$15 = 516
out_y$16 = 548
out_x$17 = 580
tv65 = 980
tv280 = 984
a$ = 1024
image_data$ = 1032
image_data_len$ = 1040
out_n$ = 1048
depth$ = 1056
color$ = 1064
interlaced$ = 1072
stbi__create_png_image PROC				; COMDAT

; 4373 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 04
	00 00		 sub	 rsp, 1064		; 00000428H
  0001d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00022	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00027	b9 9a 00 00 00	 mov	 ecx, 154		; 0000009aH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR [rsp+1096]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00042	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4374 :     int bytes = (depth == 16 ? 2 : 1);

  00047	83 bd 20 04 00
	00 10		 cmp	 DWORD PTR depth$[rbp], 16
  0004e	75 0c		 jne	 SHORT $LN16@stbi__crea
  00050	c7 85 d4 03 00
	00 02 00 00 00	 mov	 DWORD PTR tv65[rbp], 2
  0005a	eb 0a		 jmp	 SHORT $LN17@stbi__crea
$LN16@stbi__crea:
  0005c	c7 85 d4 03 00
	00 01 00 00 00	 mov	 DWORD PTR tv65[rbp], 1
$LN17@stbi__crea:
  00066	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR tv65[rbp]
  0006c	89 45 04	 mov	 DWORD PTR bytes$[rbp], eax

; 4375 :     int out_bytes = out_n * bytes;

  0006f	8b 85 18 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  00075	0f af 45 04	 imul	 eax, DWORD PTR bytes$[rbp]
  00079	89 45 24	 mov	 DWORD PTR out_bytes$[rbp], eax

; 4376 :     stbi_uc* final;
; 4377 :     int p;
; 4378 :     if (!interlaced)

  0007c	83 bd 30 04 00
	00 00		 cmp	 DWORD PTR interlaced$[rbp], 0
  00083	75 5b		 jne	 SHORT $LN11@stbi__crea

; 4379 :         return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

  00085	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00096	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00099	8b 95 28 04 00
	00		 mov	 edx, DWORD PTR color$[rbp]
  0009f	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000a3	8b 95 20 04 00
	00		 mov	 edx, DWORD PTR depth$[rbp]
  000a9	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  000ad	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b4	8b 01		 mov	 eax, DWORD PTR [rcx]
  000b6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ba	44 8b 8d 18 04
	00 00		 mov	 r9d, DWORD PTR out_n$[rbp]
  000c1	44 8b 85 10 04
	00 00		 mov	 r8d, DWORD PTR image_data_len$[rbp]
  000c8	48 8b 95 08 04
	00 00		 mov	 rdx, QWORD PTR image_data$[rbp]
  000cf	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000d6	e8 00 00 00 00	 call	 stbi__create_png_image_raw
  000db	e9 18 04 00 00	 jmp	 $LN1@stbi__crea
$LN11@stbi__crea:

; 4380 : 
; 4381 :     // de-interlacing
; 4382 :     final = (stbi_uc*)stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

  000e0	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ea	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000f1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f4	45 33 c9	 xor	 r9d, r9d
  000f7	44 8b 45 24	 mov	 r8d, DWORD PTR out_bytes$[rbp]
  000fb	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  000fe	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00100	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00105	48 89 45 48	 mov	 QWORD PTR final$[rbp], rax

; 4383 :     if (!final) return stbi__err("outofmem", "Out of memory");

  00109	48 83 7d 48 00	 cmp	 QWORD PTR final$[rbp], 0
  0010e	75 11		 jne	 SHORT $LN12@stbi__crea
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00117	e8 00 00 00 00	 call	 stbi__err
  0011c	e9 d7 03 00 00	 jmp	 $LN1@stbi__crea
$LN12@stbi__crea:

; 4384 :     for (p = 0; p < 7; ++p) {

  00121	c7 45 64 00 00
	00 00		 mov	 DWORD PTR p$[rbp], 0
  00128	eb 08		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  0012a	8b 45 64	 mov	 eax, DWORD PTR p$[rbp]
  0012d	ff c0		 inc	 eax
  0012f	89 45 64	 mov	 DWORD PTR p$[rbp], eax
$LN4@stbi__crea:
  00132	83 7d 64 07	 cmp	 DWORD PTR p$[rbp], 7
  00136	0f 8d a8 03 00
	00		 jge	 $LN3@stbi__crea

; 4385 :         int xorig[] = { 0,4,0,2,0,1,0 };

  0013c	c7 85 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR xorig$7[rbp], 0
  00146	c7 85 8c 00 00
	00 04 00 00 00	 mov	 DWORD PTR xorig$7[rbp+4], 4
  00150	c7 85 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR xorig$7[rbp+8], 0
  0015a	c7 85 94 00 00
	00 02 00 00 00	 mov	 DWORD PTR xorig$7[rbp+12], 2
  00164	c7 85 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR xorig$7[rbp+16], 0
  0016e	c7 85 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR xorig$7[rbp+20], 1
  00178	c7 85 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR xorig$7[rbp+24], 0

; 4386 :         int yorig[] = { 0,0,4,0,2,0,1 };

  00182	c7 85 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR yorig$8[rbp], 0
  0018c	c7 85 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR yorig$8[rbp+4], 0
  00196	c7 85 d0 00 00
	00 04 00 00 00	 mov	 DWORD PTR yorig$8[rbp+8], 4
  001a0	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR yorig$8[rbp+12], 0
  001aa	c7 85 d8 00 00
	00 02 00 00 00	 mov	 DWORD PTR yorig$8[rbp+16], 2
  001b4	c7 85 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR yorig$8[rbp+20], 0
  001be	c7 85 e0 00 00
	00 01 00 00 00	 mov	 DWORD PTR yorig$8[rbp+24], 1

; 4387 :         int xspc[] = { 8,8,4,4,2,2,1 };

  001c8	c7 85 08 01 00
	00 08 00 00 00	 mov	 DWORD PTR xspc$9[rbp], 8
  001d2	c7 85 0c 01 00
	00 08 00 00 00	 mov	 DWORD PTR xspc$9[rbp+4], 8
  001dc	c7 85 10 01 00
	00 04 00 00 00	 mov	 DWORD PTR xspc$9[rbp+8], 4
  001e6	c7 85 14 01 00
	00 04 00 00 00	 mov	 DWORD PTR xspc$9[rbp+12], 4
  001f0	c7 85 18 01 00
	00 02 00 00 00	 mov	 DWORD PTR xspc$9[rbp+16], 2
  001fa	c7 85 1c 01 00
	00 02 00 00 00	 mov	 DWORD PTR xspc$9[rbp+20], 2
  00204	c7 85 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR xspc$9[rbp+24], 1

; 4388 :         int yspc[] = { 8,8,8,4,4,2,2 };

  0020e	c7 85 48 01 00
	00 08 00 00 00	 mov	 DWORD PTR yspc$10[rbp], 8
  00218	c7 85 4c 01 00
	00 08 00 00 00	 mov	 DWORD PTR yspc$10[rbp+4], 8
  00222	c7 85 50 01 00
	00 08 00 00 00	 mov	 DWORD PTR yspc$10[rbp+8], 8
  0022c	c7 85 54 01 00
	00 04 00 00 00	 mov	 DWORD PTR yspc$10[rbp+12], 4
  00236	c7 85 58 01 00
	00 04 00 00 00	 mov	 DWORD PTR yspc$10[rbp+16], 4
  00240	c7 85 5c 01 00
	00 02 00 00 00	 mov	 DWORD PTR yspc$10[rbp+20], 2
  0024a	c7 85 60 01 00
	00 02 00 00 00	 mov	 DWORD PTR yspc$10[rbp+24], 2

; 4389 :         int i, j, x, y;
; 4390 :         // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4391 :         x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];

  00254	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0025b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025e	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  00262	8b 8c 8d 88 00
	00 00		 mov	 ecx, DWORD PTR xorig$7[rbp+rcx*4]
  00269	8b 00		 mov	 eax, DWORD PTR [rax]
  0026b	2b c1		 sub	 eax, ecx
  0026d	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  00271	8b 8c 8d 08 01
	00 00		 mov	 ecx, DWORD PTR xspc$9[rbp+rcx*4]
  00278	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0027c	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  00280	33 d2		 xor	 edx, edx
  00282	f7 b4 8d 08 01
	00 00		 div	 DWORD PTR xspc$9[rbp+rcx*4]
  00289	89 85 c4 01 00
	00		 mov	 DWORD PTR x$13[rbp], eax

; 4392 :         y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];

  0028f	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00296	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00299	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  0029d	8b 8c 8d c8 00
	00 00		 mov	 ecx, DWORD PTR yorig$8[rbp+rcx*4]
  002a4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002a7	2b c1		 sub	 eax, ecx
  002a9	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  002ad	8b 8c 8d 48 01
	00 00		 mov	 ecx, DWORD PTR yspc$10[rbp+rcx*4]
  002b4	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002b8	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  002bc	33 d2		 xor	 edx, edx
  002be	f7 b4 8d 48 01
	00 00		 div	 DWORD PTR yspc$10[rbp+rcx*4]
  002c5	89 85 e4 01 00
	00		 mov	 DWORD PTR y$14[rbp], eax

; 4393 :         if (x && y) {

  002cb	83 bd c4 01 00
	00 00		 cmp	 DWORD PTR x$13[rbp], 0
  002d2	0f 84 07 02 00
	00		 je	 $LN13@stbi__crea
  002d8	83 bd e4 01 00
	00 00		 cmp	 DWORD PTR y$14[rbp], 0
  002df	0f 84 fa 01 00
	00		 je	 $LN13@stbi__crea

; 4394 :             stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

  002e5	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  002ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ef	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002f2	0f af 85 c4 01
	00 00		 imul	 eax, DWORD PTR x$13[rbp]
  002f9	0f af 85 20 04
	00 00		 imul	 eax, DWORD PTR depth$[rbp]
  00300	83 c0 07	 add	 eax, 7
  00303	c1 f8 03	 sar	 eax, 3
  00306	ff c0		 inc	 eax
  00308	0f af 85 e4 01
	00 00		 imul	 eax, DWORD PTR y$14[rbp]
  0030f	89 85 04 02 00
	00		 mov	 DWORD PTR img_len$15[rbp], eax

; 4395 :             if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

  00315	8b 85 28 04 00
	00		 mov	 eax, DWORD PTR color$[rbp]
  0031b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0031f	8b 85 20 04 00
	00		 mov	 eax, DWORD PTR depth$[rbp]
  00325	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00329	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR y$14[rbp]
  0032f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00333	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR x$13[rbp]
  00339	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0033d	44 8b 8d 18 04
	00 00		 mov	 r9d, DWORD PTR out_n$[rbp]
  00344	44 8b 85 10 04
	00 00		 mov	 r8d, DWORD PTR image_data_len$[rbp]
  0034b	48 8b 95 08 04
	00 00		 mov	 rdx, QWORD PTR image_data$[rbp]
  00352	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00359	e8 00 00 00 00	 call	 stbi__create_png_image_raw
  0035e	85 c0		 test	 eax, eax
  00360	75 11		 jne	 SHORT $LN14@stbi__crea

; 4396 :                 STBI_FREE(final);

  00362	48 8b 4d 48	 mov	 rcx, QWORD PTR final$[rbp]
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4397 :                 return 0;

  0036c	33 c0		 xor	 eax, eax
  0036e	e9 85 01 00 00	 jmp	 $LN1@stbi__crea
$LN14@stbi__crea:

; 4398 :             }
; 4399 :             for (j = 0; j < y; ++j) {

  00373	c7 85 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR j$12[rbp], 0
  0037d	eb 0e		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  0037f	8b 85 a4 01 00
	00		 mov	 eax, DWORD PTR j$12[rbp]
  00385	ff c0		 inc	 eax
  00387	89 85 a4 01 00
	00		 mov	 DWORD PTR j$12[rbp], eax
$LN7@stbi__crea:
  0038d	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR y$14[rbp]
  00393	39 85 a4 01 00
	00		 cmp	 DWORD PTR j$12[rbp], eax
  00399	0f 8d ff 00 00
	00		 jge	 $LN6@stbi__crea

; 4400 :                 for (i = 0; i < x; ++i) {

  0039f	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR i$11[rbp], 0
  003a9	eb 0e		 jmp	 SHORT $LN10@stbi__crea
$LN8@stbi__crea:
  003ab	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR i$11[rbp]
  003b1	ff c0		 inc	 eax
  003b3	89 85 84 01 00
	00		 mov	 DWORD PTR i$11[rbp], eax
$LN10@stbi__crea:
  003b9	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR x$13[rbp]
  003bf	39 85 84 01 00
	00		 cmp	 DWORD PTR i$11[rbp], eax
  003c5	0f 8d ce 00 00
	00		 jge	 $LN9@stbi__crea

; 4401 :                     int out_y = j * yspc[p] + yorig[p];

  003cb	48 63 45 64	 movsxd	 rax, DWORD PTR p$[rbp]
  003cf	8b 8d a4 01 00
	00		 mov	 ecx, DWORD PTR j$12[rbp]
  003d5	0f af 8c 85 48
	01 00 00	 imul	 ecx, DWORD PTR yspc$10[rbp+rax*4]
  003dd	8b c1		 mov	 eax, ecx
  003df	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  003e3	03 84 8d c8 00
	00 00		 add	 eax, DWORD PTR yorig$8[rbp+rcx*4]
  003ea	89 85 24 02 00
	00		 mov	 DWORD PTR out_y$16[rbp], eax

; 4402 :                     int out_x = i * xspc[p] + xorig[p];

  003f0	48 63 45 64	 movsxd	 rax, DWORD PTR p$[rbp]
  003f4	8b 8d 84 01 00
	00		 mov	 ecx, DWORD PTR i$11[rbp]
  003fa	0f af 8c 85 08
	01 00 00	 imul	 ecx, DWORD PTR xspc$9[rbp+rax*4]
  00402	8b c1		 mov	 eax, ecx
  00404	48 63 4d 64	 movsxd	 rcx, DWORD PTR p$[rbp]
  00408	03 84 8d 88 00
	00 00		 add	 eax, DWORD PTR xorig$7[rbp+rcx*4]
  0040f	89 85 44 02 00
	00		 mov	 DWORD PTR out_x$17[rbp], eax

; 4403 :                     memcpy(final + out_y * a->s->img_x * out_bytes + out_x * out_bytes,

  00415	48 63 45 24	 movsxd	 rax, DWORD PTR out_bytes$[rbp]
  00419	8b 8d a4 01 00
	00		 mov	 ecx, DWORD PTR j$12[rbp]
  0041f	0f af 8d c4 01
	00 00		 imul	 ecx, DWORD PTR x$13[rbp]
  00426	03 8d 84 01 00
	00		 add	 ecx, DWORD PTR i$11[rbp]
  0042c	0f af 4d 24	 imul	 ecx, DWORD PTR out_bytes$[rbp]
  00430	48 63 c9	 movsxd	 rcx, ecx
  00433	48 8b 95 00 04
	00 00		 mov	 rdx, QWORD PTR a$[rbp]
  0043a	48 03 4a 18	 add	 rcx, QWORD PTR [rdx+24]
  0043e	48 8b 95 00 04
	00 00		 mov	 rdx, QWORD PTR a$[rbp]
  00445	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00448	44 8b 85 24 02
	00 00		 mov	 r8d, DWORD PTR out_y$16[rbp]
  0044f	44 0f af 02	 imul	 r8d, DWORD PTR [rdx]
  00453	41 8b d0	 mov	 edx, r8d
  00456	0f af 55 24	 imul	 edx, DWORD PTR out_bytes$[rbp]
  0045a	8b d2		 mov	 edx, edx
  0045c	4c 8b 45 48	 mov	 r8, QWORD PTR final$[rbp]
  00460	4c 03 c2	 add	 r8, rdx
  00463	49 8b d0	 mov	 rdx, r8
  00466	44 8b 85 44 02
	00 00		 mov	 r8d, DWORD PTR out_x$17[rbp]
  0046d	44 0f af 45 24	 imul	 r8d, DWORD PTR out_bytes$[rbp]
  00472	4d 63 c0	 movsxd	 r8, r8d
  00475	49 03 d0	 add	 rdx, r8
  00478	48 89 95 d8 03
	00 00		 mov	 QWORD PTR tv280[rbp], rdx
  0047f	4c 8b c0	 mov	 r8, rax
  00482	48 8b d1	 mov	 rdx, rcx
  00485	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR tv280[rbp]
  0048c	48 8b c8	 mov	 rcx, rax
  0048f	e8 00 00 00 00	 call	 memcpy

; 4404 :                         a->out + (j * x + i) * out_bytes, out_bytes);
; 4405 :                 }

  00494	e9 12 ff ff ff	 jmp	 $LN8@stbi__crea
$LN9@stbi__crea:

; 4406 :             }

  00499	e9 e1 fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4407 :             STBI_FREE(a->out);

  0049e	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  004a5	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4408 :             image_data += img_len;

  004af	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR img_len$15[rbp]
  004b5	48 8b 8d 08 04
	00 00		 mov	 rcx, QWORD PTR image_data$[rbp]
  004bc	48 03 c8	 add	 rcx, rax
  004bf	48 8b c1	 mov	 rax, rcx
  004c2	48 89 85 08 04
	00 00		 mov	 QWORD PTR image_data$[rbp], rax

; 4409 :             image_data_len -= img_len;

  004c9	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR img_len$15[rbp]
  004cf	8b 8d 10 04 00
	00		 mov	 ecx, DWORD PTR image_data_len$[rbp]
  004d5	2b c8		 sub	 ecx, eax
  004d7	8b c1		 mov	 eax, ecx
  004d9	89 85 10 04 00
	00		 mov	 DWORD PTR image_data_len$[rbp], eax
$LN13@stbi__crea:

; 4410 :         }
; 4411 :     }

  004df	e9 46 fc ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4412 :     a->out = final;

  004e4	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  004eb	48 8b 4d 48	 mov	 rcx, QWORD PTR final$[rbp]
  004ef	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4413 : 
; 4414 :     return 1;

  004f3	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4415 : }

  004f8	48 8b f8	 mov	 rdi, rax
  004fb	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  004ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__create_png_image$rtcFrameData
  00506	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0050b	48 8b c7	 mov	 rax, rdi
  0050e	48 8d a5 e8 03
	00 00		 lea	 rsp, QWORD PTR [rbp+1000]
  00515	5f		 pop	 rdi
  00516	5d		 pop	 rbp
  00517	c3		 ret	 0
stbi__create_png_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__create_png_image_raw
_TEXT	SEGMENT
bytes$ = 4
s$ = 40
i$ = 68
j$ = 100
stride$ = 132
img_len$ = 164
img_width_bytes$ = 196
k$ = 228
img_n$ = 260
output_bytes$ = 292
filter_bytes$ = 324
width$ = 356
cur$1 = 392
prior$2 = 424
filter$3 = 452
nk$4 = 484
cur$5 = 520
in$6 = 552
scale$7 = 580
q$8 = 612
cur$9 = 648
cur16$10 = 680
tv666 = 1076
tv618 = 1076
tv546 = 1076
tv413 = 1076
tv391 = 1076
tv343 = 1076
tv274 = 1076
tv216 = 1076
tv168 = 1076
tv65 = 1076
tv563 = 1080
tv360 = 1080
a$ = 1120
raw$ = 1128
raw_len$ = 1136
out_n$ = 1144
x$ = 1152
y$ = 1160
depth$ = 1168
color$ = 1176
stbi__create_png_image_raw PROC				; COMDAT

; 4154 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 68 04
	00 00		 sub	 rsp, 1128		; 00000468H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4155 :     int bytes = (depth == 16 ? 2 : 1);

  0002e	83 bd 90 04 00
	00 10		 cmp	 DWORD PTR depth$[rbp], 16
  00035	75 0c		 jne	 SHORT $LN159@stbi__crea
  00037	c7 85 34 04 00
	00 02 00 00 00	 mov	 DWORD PTR tv65[rbp], 2
  00041	eb 0a		 jmp	 SHORT $LN160@stbi__crea
$LN159@stbi__crea:
  00043	c7 85 34 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv65[rbp], 1
$LN160@stbi__crea:
  0004d	8b 85 34 04 00
	00		 mov	 eax, DWORD PTR tv65[rbp]
  00053	89 45 04	 mov	 DWORD PTR bytes$[rbp], eax

; 4156 :     stbi__context* s = a->s;

  00056	48 8b 85 60 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	48 89 45 28	 mov	 QWORD PTR s$[rbp], rax

; 4157 :     stbi__uint32 i, j, stride = x * out_n * bytes;

  00064	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0006a	0f af 85 78 04
	00 00		 imul	 eax, DWORD PTR out_n$[rbp]
  00071	0f af 45 04	 imul	 eax, DWORD PTR bytes$[rbp]
  00075	89 85 84 00 00
	00		 mov	 DWORD PTR stride$[rbp], eax

; 4158 :     stbi__uint32 img_len, img_width_bytes;
; 4159 :     int k;
; 4160 :     int img_n = s->img_n; // copy it into a local for later

  0007b	48 8b 45 28	 mov	 rax, QWORD PTR s$[rbp]
  0007f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00082	89 85 04 01 00
	00		 mov	 DWORD PTR img_n$[rbp], eax

; 4161 : 
; 4162 :     int output_bytes = out_n * bytes;

  00088	8b 85 78 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  0008e	0f af 45 04	 imul	 eax, DWORD PTR bytes$[rbp]
  00092	89 85 24 01 00
	00		 mov	 DWORD PTR output_bytes$[rbp], eax

; 4163 :     int filter_bytes = img_n * bytes;

  00098	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR img_n$[rbp]
  0009e	0f af 45 04	 imul	 eax, DWORD PTR bytes$[rbp]
  000a2	89 85 44 01 00
	00		 mov	 DWORD PTR filter_bytes$[rbp], eax

; 4164 :     int width = x;

  000a8	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  000ae	89 85 64 01 00
	00		 mov	 DWORD PTR width$[rbp], eax

; 4165 : 
; 4166 :     STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);

  000b4	48 8b 45 28	 mov	 rax, QWORD PTR s$[rbp]
  000b8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000bb	39 85 78 04 00
	00		 cmp	 DWORD PTR out_n$[rbp], eax
  000c1	74 2d		 je	 SHORT $LN161@stbi__crea
  000c3	48 8b 45 28	 mov	 rax, QWORD PTR s$[rbp]
  000c7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ca	ff c0		 inc	 eax
  000cc	39 85 78 04 00
	00		 cmp	 DWORD PTR out_n$[rbp], eax
  000d2	74 1c		 je	 SHORT $LN161@stbi__crea
  000d4	41 b8 46 10 00
	00		 mov	 r8d, 4166		; 00001046H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ee	33 c0		 xor	 eax, eax
$LN161@stbi__crea:

; 4167 :     a->out = (stbi_uc*)stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

  000f0	45 33 c9	 xor	 r9d, r9d
  000f3	44 8b 85 24 01
	00 00		 mov	 r8d, DWORD PTR output_bytes$[rbp]
  000fa	8b 95 88 04 00
	00		 mov	 edx, DWORD PTR y$[rbp]
  00100	8b 8d 80 04 00
	00		 mov	 ecx, DWORD PTR x$[rbp]
  00106	e8 00 00 00 00	 call	 stbi__malloc_mad3
  0010b	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00112	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4168 :     if (!a->out) return stbi__err("outofmem", "Out of memory");

  00116	48 8b 85 60 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0011d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00122	75 11		 jne	 SHORT $LN98@stbi__crea
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0012b	e8 00 00 00 00	 call	 stbi__err
  00130	e9 54 1a 00 00	 jmp	 $LN1@stbi__crea
$LN98@stbi__crea:

; 4169 : 
; 4170 :     if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

  00135	41 b9 07 00 00
	00		 mov	 r9d, 7
  0013b	44 8b 85 90 04
	00 00		 mov	 r8d, DWORD PTR depth$[rbp]
  00142	8b 95 80 04 00
	00		 mov	 edx, DWORD PTR x$[rbp]
  00148	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR img_n$[rbp]
  0014e	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00153	85 c0		 test	 eax, eax
  00155	75 11		 jne	 SHORT $LN99@stbi__crea
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0015e	e8 00 00 00 00	 call	 stbi__err
  00163	e9 21 1a 00 00	 jmp	 $LN1@stbi__crea
$LN99@stbi__crea:

; 4171 :     img_width_bytes = (((img_n * x * depth) + 7) >> 3);

  00168	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR img_n$[rbp]
  0016e	0f af 85 80 04
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  00175	0f af 85 90 04
	00 00		 imul	 eax, DWORD PTR depth$[rbp]
  0017c	83 c0 07	 add	 eax, 7
  0017f	c1 e8 03	 shr	 eax, 3
  00182	89 85 c4 00 00
	00		 mov	 DWORD PTR img_width_bytes$[rbp], eax

; 4172 :     img_len = (img_width_bytes + 1) * y;

  00188	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR img_width_bytes$[rbp]
  0018e	ff c0		 inc	 eax
  00190	0f af 85 88 04
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  00197	89 85 a4 00 00
	00		 mov	 DWORD PTR img_len$[rbp], eax

; 4173 : 
; 4174 :     // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4175 :     // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4176 :     // so just check for raw_len < img_len always.
; 4177 :     if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");

  0019d	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR img_len$[rbp]
  001a3	39 85 70 04 00
	00		 cmp	 DWORD PTR raw_len$[rbp], eax
  001a9	73 11		 jae	 SHORT $LN100@stbi__crea
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
  001b2	e8 00 00 00 00	 call	 stbi__err
  001b7	e9 cd 19 00 00	 jmp	 $LN1@stbi__crea
$LN100@stbi__crea:

; 4178 : 
; 4179 :     for (j = 0; j < y; ++j) {

  001bc	c7 45 64 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  001c3	eb 08		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  001c5	8b 45 64	 mov	 eax, DWORD PTR j$[rbp]
  001c8	ff c0		 inc	 eax
  001ca	89 45 64	 mov	 DWORD PTR j$[rbp], eax
$LN4@stbi__crea:
  001cd	8b 85 88 04 00
	00		 mov	 eax, DWORD PTR y$[rbp]
  001d3	39 45 64	 cmp	 DWORD PTR j$[rbp], eax
  001d6	0f 83 27 10 00
	00		 jae	 $LN3@stbi__crea

; 4180 :         stbi_uc* cur = a->out + stride * j;

  001dc	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  001e2	0f af 45 64	 imul	 eax, DWORD PTR j$[rbp]
  001e6	8b c0		 mov	 eax, eax
  001e8	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001ef	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  001f3	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4181 :         stbi_uc* prior;
; 4182 :         int filter = *raw++;

  001fa	48 8b 85 68 04
	00 00		 mov	 rax, QWORD PTR raw$[rbp]
  00201	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00204	89 85 c4 01 00
	00		 mov	 DWORD PTR filter$3[rbp], eax
  0020a	48 8b 85 68 04
	00 00		 mov	 rax, QWORD PTR raw$[rbp]
  00211	48 ff c0	 inc	 rax
  00214	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax

; 4183 : 
; 4184 :         if (filter > 4)

  0021b	83 bd c4 01 00
	00 04		 cmp	 DWORD PTR filter$3[rbp], 4
  00222	7e 11		 jle	 SHORT $LN101@stbi__crea

; 4185 :             return stbi__err("invalid filter", "Corrupt PNG");

  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FBBCPGMN@invalid?5filter@
  0022b	e8 00 00 00 00	 call	 stbi__err
  00230	e9 54 19 00 00	 jmp	 $LN1@stbi__crea
$LN101@stbi__crea:

; 4186 : 
; 4187 :         if (depth < 8) {

  00235	83 bd 90 04 00
	00 08		 cmp	 DWORD PTR depth$[rbp], 8
  0023c	7d 5e		 jge	 SHORT $LN102@stbi__crea

; 4188 :             if (img_width_bytes > x) return stbi__err("invalid width", "Corrupt PNG");

  0023e	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00244	39 85 c4 00 00
	00		 cmp	 DWORD PTR img_width_bytes$[rbp], eax
  0024a	76 11		 jbe	 SHORT $LN103@stbi__crea
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  00253	e8 00 00 00 00	 call	 stbi__err
  00258	e9 2c 19 00 00	 jmp	 $LN1@stbi__crea
$LN103@stbi__crea:

; 4189 :             cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

  0025d	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00263	0f af 85 78 04
	00 00		 imul	 eax, DWORD PTR out_n$[rbp]
  0026a	2b 85 c4 00 00
	00		 sub	 eax, DWORD PTR img_width_bytes$[rbp]
  00270	8b c0		 mov	 eax, eax
  00272	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00279	48 03 c8	 add	 rcx, rax
  0027c	48 8b c1	 mov	 rax, rcx
  0027f	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4190 :             filter_bytes = 1;

  00286	c7 85 44 01 00
	00 01 00 00 00	 mov	 DWORD PTR filter_bytes$[rbp], 1

; 4191 :             width = img_width_bytes;

  00290	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR img_width_bytes$[rbp]
  00296	89 85 64 01 00
	00		 mov	 DWORD PTR width$[rbp], eax
$LN102@stbi__crea:

; 4192 :         }
; 4193 :         prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

  0029c	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  002a2	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  002a9	48 2b c8	 sub	 rcx, rax
  002ac	48 8b c1	 mov	 rax, rcx
  002af	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax

; 4194 : 
; 4195 :         // if first row, use special filter that doesn't sample previous row
; 4196 :         if (j == 0) filter = first_row_filter[filter];

  002b6	83 7d 64 00	 cmp	 DWORD PTR j$[rbp], 0
  002ba	75 18		 jne	 SHORT $LN104@stbi__crea
  002bc	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR filter$3[rbp]
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:first_row_filter
  002ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ce	89 85 c4 01 00
	00		 mov	 DWORD PTR filter$3[rbp], eax
$LN104@stbi__crea:

; 4197 : 
; 4198 :         // handle first byte explicitly
; 4199 :         for (k = 0; k < filter_bytes; ++k) {

  002d4	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  002de	eb 0e		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  002e0	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  002e6	ff c0		 inc	 eax
  002e8	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN7@stbi__crea:
  002ee	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  002f4	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  002fa	0f 8d b0 01 00
	00		 jge	 $LN6@stbi__crea

; 4200 :             switch (filter) {

  00300	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR filter$3[rbp]
  00306	89 85 34 04 00
	00		 mov	 DWORD PTR tv168[rbp], eax
  0030c	83 bd 34 04 00
	00 06		 cmp	 DWORD PTR tv168[rbp], 6
  00313	0f 87 92 01 00
	00		 ja	 $LN8@stbi__crea
  00319	48 63 85 34 04
	00 00		 movsxd	 rax, DWORD PTR tv168[rbp]
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00327	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN168@stbi__crea[rcx+rax*4]
  0032e	48 03 c1	 add	 rax, rcx
  00331	ff e0		 jmp	 rax
$LN105@stbi__crea:

; 4201 :             case STBI__F_none: cur[k] = raw[k]; break;

  00333	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  0033a	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00341	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00348	4c 8b 85 68 04
	00 00		 mov	 r8, QWORD PTR raw$[rbp]
  0034f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00354	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00357	e9 4f 01 00 00	 jmp	 $LN8@stbi__crea
$LN106@stbi__crea:

; 4202 :             case STBI__F_sub: cur[k] = raw[k]; break;

  0035c	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00363	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0036a	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00371	4c 8b 85 68 04
	00 00		 mov	 r8, QWORD PTR raw$[rbp]
  00378	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0037d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00380	e9 26 01 00 00	 jmp	 $LN8@stbi__crea
$LN107@stbi__crea:

; 4203 :             case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

  00385	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  0038c	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0039e	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  003a5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003a9	03 c1		 add	 eax, ecx
  003ab	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003b0	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  003b7	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  003be	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003c1	e9 e5 00 00 00	 jmp	 $LN8@stbi__crea
$LN108@stbi__crea:

; 4204 :             case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;

  003c6	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  003cd	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  003d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d8	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  003df	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  003e6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003ea	d1 f9		 sar	 ecx, 1
  003ec	03 c1		 add	 eax, ecx
  003ee	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003f3	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  003fa	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00401	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00404	e9 a2 00 00 00	 jmp	 $LN8@stbi__crea
$LN109@stbi__crea:

; 4205 :             case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;

  00409	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00410	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00417	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0041b	89 85 34 04 00
	00		 mov	 DWORD PTR tv216[rbp], eax
  00421	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00428	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  0042f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00433	45 33 c0	 xor	 r8d, r8d
  00436	8b d1		 mov	 edx, ecx
  00438	33 c9		 xor	 ecx, ecx
  0043a	e8 00 00 00 00	 call	 stbi__paeth
  0043f	8b 8d 34 04 00
	00		 mov	 ecx, DWORD PTR tv216[rbp]
  00445	03 c8		 add	 ecx, eax
  00447	8b c1		 mov	 eax, ecx
  00449	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0044e	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00455	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  0045c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0045f	eb 4a		 jmp	 SHORT $LN8@stbi__crea
$LN110@stbi__crea:

; 4206 :             case STBI__F_avg_first: cur[k] = raw[k]; break;

  00461	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00468	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0046f	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00476	4c 8b 85 68 04
	00 00		 mov	 r8, QWORD PTR raw$[rbp]
  0047d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00482	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00485	eb 24		 jmp	 SHORT $LN8@stbi__crea
$LN111@stbi__crea:

; 4207 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;

  00487	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  0048e	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00495	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  0049c	4c 8b 85 68 04
	00 00		 mov	 r8, QWORD PTR raw$[rbp]
  004a3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004a8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN8@stbi__crea:

; 4208 :             }
; 4209 :         }

  004ab	e9 30 fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4210 : 
; 4211 :         if (depth == 8) {

  004b0	83 bd 90 04 00
	00 08		 cmp	 DWORD PTR depth$[rbp], 8
  004b7	75 76		 jne	 SHORT $LN112@stbi__crea

; 4212 :             if (img_n != out_n)

  004b9	8b 85 78 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  004bf	39 85 04 01 00
	00		 cmp	 DWORD PTR img_n$[rbp], eax
  004c5	74 12		 je	 SHORT $LN114@stbi__crea

; 4213 :                 cur[img_n] = 255; // first pixel

  004c7	48 63 85 04 01
	00 00		 movsxd	 rax, DWORD PTR img_n$[rbp]
  004ce	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  004d5	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN114@stbi__crea:

; 4214 :             raw += img_n;

  004d9	48 63 85 04 01
	00 00		 movsxd	 rax, DWORD PTR img_n$[rbp]
  004e0	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  004e7	48 03 c8	 add	 rcx, rax
  004ea	48 8b c1	 mov	 rax, rcx
  004ed	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax

; 4215 :             cur += out_n;

  004f4	48 63 85 78 04
	00 00		 movsxd	 rax, DWORD PTR out_n$[rbp]
  004fb	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00502	48 03 c8	 add	 rcx, rax
  00505	48 8b c1	 mov	 rax, rcx
  00508	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4216 :             prior += out_n;

  0050f	48 63 85 78 04
	00 00		 movsxd	 rax, DWORD PTR out_n$[rbp]
  00516	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  0051d	48 03 c8	 add	 rcx, rax
  00520	48 8b c1	 mov	 rax, rcx
  00523	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax

; 4217 :         }

  0052a	e9 c8 00 00 00	 jmp	 $LN113@stbi__crea
$LN112@stbi__crea:

; 4218 :         else if (depth == 16) {

  0052f	83 bd 90 04 00
	00 10		 cmp	 DWORD PTR depth$[rbp], 16
  00536	0f 85 88 00 00
	00		 jne	 $LN115@stbi__crea

; 4219 :             if (img_n != out_n) {

  0053c	8b 85 78 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  00542	39 85 04 01 00
	00		 cmp	 DWORD PTR img_n$[rbp], eax
  00548	74 27		 je	 SHORT $LN117@stbi__crea

; 4220 :                 cur[filter_bytes] = 255; // first pixel top byte

  0054a	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00551	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00558	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4221 :                 cur[filter_bytes + 1] = 255; // first pixel bottom byte

  0055c	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00562	ff c0		 inc	 eax
  00564	48 98		 cdqe
  00566	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  0056d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN117@stbi__crea:

; 4222 :             }
; 4223 :             raw += filter_bytes;

  00571	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00578	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  0057f	48 03 c8	 add	 rcx, rax
  00582	48 8b c1	 mov	 rax, rcx
  00585	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax

; 4224 :             cur += output_bytes;

  0058c	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00593	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  0059a	48 03 c8	 add	 rcx, rax
  0059d	48 8b c1	 mov	 rax, rcx
  005a0	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4225 :             prior += output_bytes;

  005a7	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  005ae	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  005b5	48 03 c8	 add	 rcx, rax
  005b8	48 8b c1	 mov	 rax, rcx
  005bb	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax

; 4226 :         }

  005c2	eb 33		 jmp	 SHORT $LN116@stbi__crea
$LN115@stbi__crea:

; 4227 :         else {
; 4228 :             raw += 1;

  005c4	48 8b 85 68 04
	00 00		 mov	 rax, QWORD PTR raw$[rbp]
  005cb	48 ff c0	 inc	 rax
  005ce	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax

; 4229 :             cur += 1;

  005d5	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR cur$1[rbp]
  005dc	48 ff c0	 inc	 rax
  005df	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4230 :             prior += 1;

  005e6	48 8b 85 a8 01
	00 00		 mov	 rax, QWORD PTR prior$2[rbp]
  005ed	48 ff c0	 inc	 rax
  005f0	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN116@stbi__crea:
$LN113@stbi__crea:

; 4231 :         }
; 4232 : 
; 4233 :         // this is a little gross, so that we don't switch per-pixel or per-component
; 4234 :         if (depth < 8 || img_n == out_n) {

  005f7	83 bd 90 04 00
	00 08		 cmp	 DWORD PTR depth$[rbp], 8
  005fe	7c 12		 jl	 SHORT $LN120@stbi__crea
  00600	8b 85 78 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  00606	39 85 04 01 00
	00		 cmp	 DWORD PTR img_n$[rbp], eax
  0060c	0f 85 d7 03 00
	00		 jne	 $LN118@stbi__crea
$LN120@stbi__crea:

; 4235 :             int nk = (width - 1) * filter_bytes;

  00612	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  00618	ff c8		 dec	 eax
  0061a	0f af 85 44 01
	00 00		 imul	 eax, DWORD PTR filter_bytes$[rbp]
  00621	89 85 e4 01 00
	00		 mov	 DWORD PTR nk$4[rbp], eax

; 4236 : #define STBI__CASE(f) \
; 4237 :              case f:     \
; 4238 :                 for (k=0; k < nk; ++k)
; 4239 :             switch (filter) {

  00627	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR filter$3[rbp]
  0062d	89 85 34 04 00
	00		 mov	 DWORD PTR tv274[rbp], eax
  00633	83 bd 34 04 00
	00 06		 cmp	 DWORD PTR tv274[rbp], 6
  0063a	0f 87 89 03 00
	00		 ja	 $LN10@stbi__crea
  00640	48 63 85 34 04
	00 00		 movsxd	 rax, DWORD PTR tv274[rbp]
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0064e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN167@stbi__crea[rcx+rax*4]
  00655	48 03 c1	 add	 rax, rcx
  00658	ff e0		 jmp	 rax
$LN121@stbi__crea:

; 4240 :                 // "none" filter turns into a memcpy here; make that explicit.
; 4241 :             case STBI__F_none:         memcpy(cur, raw, nk); break;

  0065a	48 63 85 e4 01
	00 00		 movsxd	 rax, DWORD PTR nk$4[rbp]
  00661	4c 8b c0	 mov	 r8, rax
  00664	48 8b 95 68 04
	00 00		 mov	 rdx, QWORD PTR raw$[rbp]
  0066b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00672	e8 00 00 00 00	 call	 memcpy
  00677	e9 4d 03 00 00	 jmp	 $LN10@stbi__crea
$LN122@stbi__crea:

; 4242 :                 STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); } break;

  0067c	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00686	eb 0e		 jmp	 SHORT $LN14@stbi__crea
$LN12@stbi__crea:
  00688	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  0068e	ff c0		 inc	 eax
  00690	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN14@stbi__crea:
  00696	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  0069c	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  006a2	7d 4a		 jge	 SHORT $LN13@stbi__crea
  006a4	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  006ab	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  006b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006b6	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR filter_bytes$[rbp]
  006bc	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  006c2	2b d1		 sub	 edx, ecx
  006c4	8b ca		 mov	 ecx, edx
  006c6	48 63 c9	 movsxd	 rcx, ecx
  006c9	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  006d0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006d4	03 c1		 add	 eax, ecx
  006d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006db	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  006e2	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  006e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006ec	eb 9a		 jmp	 SHORT $LN12@stbi__crea
$LN13@stbi__crea:
  006ee	e9 d6 02 00 00	 jmp	 $LN10@stbi__crea
$LN123@stbi__crea:

; 4243 :                 STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  006f3	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  006fd	eb 0e		 jmp	 SHORT $LN17@stbi__crea
$LN15@stbi__crea:
  006ff	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00705	ff c0		 inc	 eax
  00707	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN17@stbi__crea:
  0070d	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  00713	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00719	7d 3e		 jge	 SHORT $LN16@stbi__crea
  0071b	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00722	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00729	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0072d	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00734	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  0073b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0073f	03 c1		 add	 eax, ecx
  00741	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00746	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0074d	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00754	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00757	eb a6		 jmp	 SHORT $LN15@stbi__crea
$LN16@stbi__crea:
  00759	e9 6b 02 00 00	 jmp	 $LN10@stbi__crea
$LN124@stbi__crea:

; 4244 :                 STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); } break;

  0075e	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00768	eb 0e		 jmp	 SHORT $LN20@stbi__crea
$LN18@stbi__crea:
  0076a	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00770	ff c0		 inc	 eax
  00772	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN20@stbi__crea:
  00778	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  0077e	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00784	7d 64		 jge	 SHORT $LN19@stbi__crea
  00786	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  0078d	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00794	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00798	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0079f	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  007a6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  007aa	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR filter_bytes$[rbp]
  007b0	44 8b 85 e4 00
	00 00		 mov	 r8d, DWORD PTR k$[rbp]
  007b7	44 2b c2	 sub	 r8d, edx
  007ba	41 8b d0	 mov	 edx, r8d
  007bd	48 63 d2	 movsxd	 rdx, edx
  007c0	4c 8b 85 88 01
	00 00		 mov	 r8, QWORD PTR cur$1[rbp]
  007c7	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  007cc	03 ca		 add	 ecx, edx
  007ce	d1 f9		 sar	 ecx, 1
  007d0	03 c1		 add	 eax, ecx
  007d2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007d7	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  007de	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  007e5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007e8	eb 80		 jmp	 SHORT $LN18@stbi__crea
$LN19@stbi__crea:
  007ea	e9 da 01 00 00	 jmp	 $LN10@stbi__crea
$LN125@stbi__crea:

; 4245 :                 STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); } break;

  007ef	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  007f9	eb 0e		 jmp	 SHORT $LN23@stbi__crea
$LN21@stbi__crea:
  007fb	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00801	ff c0		 inc	 eax
  00803	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN23@stbi__crea:
  00809	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  0080f	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00815	0f 8d a6 00 00
	00		 jge	 $LN22@stbi__crea
  0081b	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00822	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00829	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0082d	89 85 34 04 00
	00		 mov	 DWORD PTR tv343[rbp], eax
  00833	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR filter_bytes$[rbp]
  00839	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  0083f	2b d1		 sub	 edx, ecx
  00841	8b ca		 mov	 ecx, edx
  00843	48 63 c9	 movsxd	 rcx, ecx
  00846	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  0084d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00851	48 63 95 e4 00
	00 00		 movsxd	 rdx, DWORD PTR k$[rbp]
  00858	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR prior$2[rbp]
  0085f	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00864	44 8b 85 44 01
	00 00		 mov	 r8d, DWORD PTR filter_bytes$[rbp]
  0086b	44 8b 8d e4 00
	00 00		 mov	 r9d, DWORD PTR k$[rbp]
  00872	45 2b c8	 sub	 r9d, r8d
  00875	45 8b c1	 mov	 r8d, r9d
  00878	4d 63 c0	 movsxd	 r8, r8d
  0087b	4c 8b 8d 88 01
	00 00		 mov	 r9, QWORD PTR cur$1[rbp]
  00882	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00887	44 89 85 38 04
	00 00		 mov	 DWORD PTR tv360[rbp], r8d
  0088e	44 8b c1	 mov	 r8d, ecx
  00891	8b 8d 38 04 00
	00		 mov	 ecx, DWORD PTR tv360[rbp]
  00897	e8 00 00 00 00	 call	 stbi__paeth
  0089c	8b 8d 34 04 00
	00		 mov	 ecx, DWORD PTR tv343[rbp]
  008a2	03 c8		 add	 ecx, eax
  008a4	8b c1		 mov	 eax, ecx
  008a6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008ab	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  008b2	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  008b9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008bc	e9 3a ff ff ff	 jmp	 $LN21@stbi__crea
$LN22@stbi__crea:
  008c1	e9 03 01 00 00	 jmp	 $LN10@stbi__crea
$LN126@stbi__crea:

; 4246 :                 STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); } break;

  008c6	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  008d0	eb 0e		 jmp	 SHORT $LN26@stbi__crea
$LN24@stbi__crea:
  008d2	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  008d8	ff c0		 inc	 eax
  008da	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN26@stbi__crea:
  008e0	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  008e6	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  008ec	7d 4c		 jge	 SHORT $LN25@stbi__crea
  008ee	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  008f5	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  008fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00900	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR filter_bytes$[rbp]
  00906	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  0090c	2b d1		 sub	 edx, ecx
  0090e	8b ca		 mov	 ecx, edx
  00910	48 63 c9	 movsxd	 rcx, ecx
  00913	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  0091a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0091e	d1 f9		 sar	 ecx, 1
  00920	03 c1		 add	 eax, ecx
  00922	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00927	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  0092e	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00935	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00938	eb 98		 jmp	 SHORT $LN24@stbi__crea
$LN25@stbi__crea:
  0093a	e9 8a 00 00 00	 jmp	 $LN10@stbi__crea
$LN127@stbi__crea:

; 4247 :                 STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); } break;

  0093f	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00949	eb 0e		 jmp	 SHORT $LN29@stbi__crea
$LN27@stbi__crea:
  0094b	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00951	ff c0		 inc	 eax
  00953	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN29@stbi__crea:
  00959	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR nk$4[rbp]
  0095f	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00965	7d 62		 jge	 SHORT $LN28@stbi__crea
  00967	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  0096e	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00975	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00979	89 85 34 04 00
	00		 mov	 DWORD PTR tv391[rbp], eax
  0097f	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR filter_bytes$[rbp]
  00985	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  0098b	2b d1		 sub	 edx, ecx
  0098d	8b ca		 mov	 ecx, edx
  0098f	48 63 c9	 movsxd	 rcx, ecx
  00992	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00999	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0099d	45 33 c0	 xor	 r8d, r8d
  009a0	33 d2		 xor	 edx, edx
  009a2	e8 00 00 00 00	 call	 stbi__paeth
  009a7	8b 8d 34 04 00
	00		 mov	 ecx, DWORD PTR tv391[rbp]
  009ad	03 c8		 add	 ecx, eax
  009af	8b c1		 mov	 eax, ecx
  009b1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009b6	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  009bd	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  009c4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  009c7	eb 82		 jmp	 SHORT $LN27@stbi__crea
$LN28@stbi__crea:
$LN10@stbi__crea:

; 4248 :             }
; 4249 : #undef STBI__CASE
; 4250 :             raw += nk;

  009c9	48 63 85 e4 01
	00 00		 movsxd	 rax, DWORD PTR nk$4[rbp]
  009d0	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  009d7	48 03 c8	 add	 rcx, rax
  009da	48 8b c1	 mov	 rax, rcx
  009dd	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax

; 4251 :         }

  009e4	e9 15 08 00 00	 jmp	 $LN119@stbi__crea
$LN118@stbi__crea:

; 4252 :         else {
; 4253 :             STBI_ASSERT(img_n + 1 == out_n);

  009e9	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR img_n$[rbp]
  009ef	ff c0		 inc	 eax
  009f1	3b 85 78 04 00
	00		 cmp	 eax, DWORD PTR out_n$[rbp]
  009f7	74 1c		 je	 SHORT $LN162@stbi__crea
  009f9	41 b8 9d 10 00
	00		 mov	 r8d, 4253		; 0000109dH
  009ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
  00a0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a13	33 c0		 xor	 eax, eax
$LN162@stbi__crea:

; 4254 : #define STBI__CASE(f) \
; 4255 :              case f:     \
; 4256 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4257 :                    for (k=0; k < filter_bytes; ++k)
; 4258 :             switch (filter) {

  00a15	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR filter$3[rbp]
  00a1b	89 85 34 04 00
	00		 mov	 DWORD PTR tv413[rbp], eax
  00a21	83 bd 34 04 00
	00 06		 cmp	 DWORD PTR tv413[rbp], 6
  00a28	0f 87 5b 07 00
	00		 ja	 $LN30@stbi__crea
  00a2e	48 63 85 34 04
	00 00		 movsxd	 rax, DWORD PTR tv413[rbp]
  00a35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00a3c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN166@stbi__crea[rcx+rax*4]
  00a43	48 03 c1	 add	 rax, rcx
  00a46	ff e0		 jmp	 rax
$LN128@stbi__crea:

; 4259 :                 STBI__CASE(STBI__F_none) { cur[k] = raw[k]; } break;

  00a48	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00a4e	ff c8		 dec	 eax
  00a50	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00a53	eb 6b		 jmp	 SHORT $LN34@stbi__crea
$LN32@stbi__crea:
  00a55	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00a58	ff c8		 dec	 eax
  00a5a	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00a5d	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00a64	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00a6b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00a6f	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00a76	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00a7d	48 03 c8	 add	 rcx, rax
  00a80	48 8b c1	 mov	 rax, rcx
  00a83	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00a8a	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00a91	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00a98	48 03 c8	 add	 rcx, rax
  00a9b	48 8b c1	 mov	 rax, rcx
  00a9e	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00aa5	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00aac	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00ab3	48 03 c8	 add	 rcx, rax
  00ab6	48 8b c1	 mov	 rax, rcx
  00ab9	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN34@stbi__crea:
  00ac0	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00ac4	72 53		 jb	 SHORT $LN33@stbi__crea
  00ac6	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00ad0	eb 0e		 jmp	 SHORT $LN37@stbi__crea
$LN35@stbi__crea:
  00ad2	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00ad8	ff c0		 inc	 eax
  00ada	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN37@stbi__crea:
  00ae0	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00ae6	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00aec	7d 26		 jge	 SHORT $LN36@stbi__crea
  00aee	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00af5	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00afc	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00b03	4c 8b 85 68 04
	00 00		 mov	 r8, QWORD PTR raw$[rbp]
  00b0a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00b0f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00b12	eb be		 jmp	 SHORT $LN35@stbi__crea
$LN36@stbi__crea:
  00b14	e9 3c ff ff ff	 jmp	 $LN32@stbi__crea
$LN33@stbi__crea:
  00b19	e9 6b 06 00 00	 jmp	 $LN30@stbi__crea
$LN129@stbi__crea:

; 4260 :                 STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); } break;

  00b1e	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00b24	ff c8		 dec	 eax
  00b26	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00b29	eb 6b		 jmp	 SHORT $LN40@stbi__crea
$LN38@stbi__crea:
  00b2b	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00b2e	ff c8		 dec	 eax
  00b30	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00b33	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00b3a	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00b41	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00b45	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00b4c	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00b53	48 03 c8	 add	 rcx, rax
  00b56	48 8b c1	 mov	 rax, rcx
  00b59	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00b60	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00b67	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00b6e	48 03 c8	 add	 rcx, rax
  00b71	48 8b c1	 mov	 rax, rcx
  00b74	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00b7b	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00b82	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00b89	48 03 c8	 add	 rcx, rax
  00b8c	48 8b c1	 mov	 rax, rcx
  00b8f	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN40@stbi__crea:
  00b96	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00b9a	72 77		 jb	 SHORT $LN39@stbi__crea
  00b9c	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00ba6	eb 0e		 jmp	 SHORT $LN43@stbi__crea
$LN41@stbi__crea:
  00ba8	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00bae	ff c0		 inc	 eax
  00bb0	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN43@stbi__crea:
  00bb6	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00bbc	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00bc2	7d 4a		 jge	 SHORT $LN42@stbi__crea
  00bc4	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00bcb	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00bd2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00bd6	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR output_bytes$[rbp]
  00bdc	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  00be2	2b d1		 sub	 edx, ecx
  00be4	8b ca		 mov	 ecx, edx
  00be6	48 63 c9	 movsxd	 rcx, ecx
  00be9	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00bf0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00bf4	03 c1		 add	 eax, ecx
  00bf6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00bfb	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00c02	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00c09	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c0c	eb 9a		 jmp	 SHORT $LN41@stbi__crea
$LN42@stbi__crea:
  00c0e	e9 18 ff ff ff	 jmp	 $LN38@stbi__crea
$LN39@stbi__crea:
  00c13	e9 71 05 00 00	 jmp	 $LN30@stbi__crea
$LN130@stbi__crea:

; 4261 :                 STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  00c18	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00c1e	ff c8		 dec	 eax
  00c20	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00c23	eb 6b		 jmp	 SHORT $LN46@stbi__crea
$LN44@stbi__crea:
  00c25	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00c28	ff c8		 dec	 eax
  00c2a	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00c2d	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00c34	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00c3b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00c3f	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00c46	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00c4d	48 03 c8	 add	 rcx, rax
  00c50	48 8b c1	 mov	 rax, rcx
  00c53	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00c5a	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00c61	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00c68	48 03 c8	 add	 rcx, rax
  00c6b	48 8b c1	 mov	 rax, rcx
  00c6e	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00c75	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00c7c	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00c83	48 03 c8	 add	 rcx, rax
  00c86	48 8b c1	 mov	 rax, rcx
  00c89	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN46@stbi__crea:
  00c90	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00c94	72 6b		 jb	 SHORT $LN45@stbi__crea
  00c96	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00ca0	eb 0e		 jmp	 SHORT $LN49@stbi__crea
$LN47@stbi__crea:
  00ca2	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00ca8	ff c0		 inc	 eax
  00caa	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN49@stbi__crea:
  00cb0	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00cb6	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00cbc	7d 3e		 jge	 SHORT $LN48@stbi__crea
  00cbe	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00cc5	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00ccc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00cd0	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00cd7	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  00cde	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00ce2	03 c1		 add	 eax, ecx
  00ce4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ce9	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00cf0	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00cf7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00cfa	eb a6		 jmp	 SHORT $LN47@stbi__crea
$LN48@stbi__crea:
  00cfc	e9 24 ff ff ff	 jmp	 $LN44@stbi__crea
$LN45@stbi__crea:
  00d01	e9 83 04 00 00	 jmp	 $LN30@stbi__crea
$LN131@stbi__crea:

; 4262 :                 STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); } break;

  00d06	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00d0c	ff c8		 dec	 eax
  00d0e	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00d11	eb 6b		 jmp	 SHORT $LN52@stbi__crea
$LN50@stbi__crea:
  00d13	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00d16	ff c8		 dec	 eax
  00d18	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00d1b	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00d22	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00d29	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00d2d	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00d34	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00d3b	48 03 c8	 add	 rcx, rax
  00d3e	48 8b c1	 mov	 rax, rcx
  00d41	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00d48	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00d4f	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00d56	48 03 c8	 add	 rcx, rax
  00d59	48 8b c1	 mov	 rax, rcx
  00d5c	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00d63	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00d6a	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00d71	48 03 c8	 add	 rcx, rax
  00d74	48 8b c1	 mov	 rax, rcx
  00d77	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN52@stbi__crea:
  00d7e	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00d82	0f 82 91 00 00
	00		 jb	 $LN51@stbi__crea
  00d88	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00d92	eb 0e		 jmp	 SHORT $LN55@stbi__crea
$LN53@stbi__crea:
  00d94	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00d9a	ff c0		 inc	 eax
  00d9c	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN55@stbi__crea:
  00da2	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00da8	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00dae	7d 64		 jge	 SHORT $LN54@stbi__crea
  00db0	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00db7	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00dbe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00dc2	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00dc9	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  00dd0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00dd4	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR output_bytes$[rbp]
  00dda	44 8b 85 e4 00
	00 00		 mov	 r8d, DWORD PTR k$[rbp]
  00de1	44 2b c2	 sub	 r8d, edx
  00de4	41 8b d0	 mov	 edx, r8d
  00de7	48 63 d2	 movsxd	 rdx, edx
  00dea	4c 8b 85 88 01
	00 00		 mov	 r8, QWORD PTR cur$1[rbp]
  00df1	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00df6	03 ca		 add	 ecx, edx
  00df8	d1 f9		 sar	 ecx, 1
  00dfa	03 c1		 add	 eax, ecx
  00dfc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e01	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00e08	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00e0f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e12	eb 80		 jmp	 SHORT $LN53@stbi__crea
$LN54@stbi__crea:
  00e14	e9 fa fe ff ff	 jmp	 $LN50@stbi__crea
$LN51@stbi__crea:
  00e19	e9 6b 03 00 00	 jmp	 $LN30@stbi__crea
$LN132@stbi__crea:

; 4263 :                 STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); } break;

  00e1e	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00e24	ff c8		 dec	 eax
  00e26	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00e29	eb 6b		 jmp	 SHORT $LN58@stbi__crea
$LN56@stbi__crea:
  00e2b	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00e2e	ff c8		 dec	 eax
  00e30	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00e33	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00e3a	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00e41	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00e45	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00e4c	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00e53	48 03 c8	 add	 rcx, rax
  00e56	48 8b c1	 mov	 rax, rcx
  00e59	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00e60	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00e67	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00e6e	48 03 c8	 add	 rcx, rax
  00e71	48 8b c1	 mov	 rax, rcx
  00e74	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00e7b	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00e82	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00e89	48 03 c8	 add	 rcx, rax
  00e8c	48 8b c1	 mov	 rax, rcx
  00e8f	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN58@stbi__crea:
  00e96	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00e9a	0f 82 d7 00 00
	00		 jb	 $LN57@stbi__crea
  00ea0	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00eaa	eb 0e		 jmp	 SHORT $LN61@stbi__crea
$LN59@stbi__crea:
  00eac	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00eb2	ff c0		 inc	 eax
  00eb4	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN61@stbi__crea:
  00eba	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  00ec0	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  00ec6	0f 8d a6 00 00
	00		 jge	 $LN60@stbi__crea
  00ecc	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  00ed3	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00eda	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ede	89 85 34 04 00
	00		 mov	 DWORD PTR tv546[rbp], eax
  00ee4	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR output_bytes$[rbp]
  00eea	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  00ef0	2b d1		 sub	 edx, ecx
  00ef2	8b ca		 mov	 ecx, edx
  00ef4	48 63 c9	 movsxd	 rcx, ecx
  00ef7	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR prior$2[rbp]
  00efe	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00f02	48 63 95 e4 00
	00 00		 movsxd	 rdx, DWORD PTR k$[rbp]
  00f09	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR prior$2[rbp]
  00f10	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00f15	44 8b 85 24 01
	00 00		 mov	 r8d, DWORD PTR output_bytes$[rbp]
  00f1c	44 8b 8d e4 00
	00 00		 mov	 r9d, DWORD PTR k$[rbp]
  00f23	45 2b c8	 sub	 r9d, r8d
  00f26	45 8b c1	 mov	 r8d, r9d
  00f29	4d 63 c0	 movsxd	 r8, r8d
  00f2c	4c 8b 8d 88 01
	00 00		 mov	 r9, QWORD PTR cur$1[rbp]
  00f33	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00f38	44 89 85 38 04
	00 00		 mov	 DWORD PTR tv563[rbp], r8d
  00f3f	44 8b c1	 mov	 r8d, ecx
  00f42	8b 8d 38 04 00
	00		 mov	 ecx, DWORD PTR tv563[rbp]
  00f48	e8 00 00 00 00	 call	 stbi__paeth
  00f4d	8b 8d 34 04 00
	00		 mov	 ecx, DWORD PTR tv546[rbp]
  00f53	03 c8		 add	 ecx, eax
  00f55	8b c1		 mov	 eax, ecx
  00f57	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f5c	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  00f63	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  00f6a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f6d	e9 3a ff ff ff	 jmp	 $LN59@stbi__crea
$LN60@stbi__crea:
  00f72	e9 b4 fe ff ff	 jmp	 $LN56@stbi__crea
$LN57@stbi__crea:
  00f77	e9 0d 02 00 00	 jmp	 $LN30@stbi__crea
$LN133@stbi__crea:

; 4264 :                 STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); } break;

  00f7c	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00f82	ff c8		 dec	 eax
  00f84	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00f87	eb 6b		 jmp	 SHORT $LN64@stbi__crea
$LN62@stbi__crea:
  00f89	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  00f8c	ff c8		 dec	 eax
  00f8e	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  00f91	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00f98	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00f9f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00fa3	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  00faa	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  00fb1	48 03 c8	 add	 rcx, rax
  00fb4	48 8b c1	 mov	 rax, rcx
  00fb7	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  00fbe	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00fc5	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  00fcc	48 03 c8	 add	 rcx, rax
  00fcf	48 8b c1	 mov	 rax, rcx
  00fd2	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  00fd9	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  00fe0	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  00fe7	48 03 c8	 add	 rcx, rax
  00fea	48 8b c1	 mov	 rax, rcx
  00fed	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN64@stbi__crea:
  00ff4	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  00ff8	72 79		 jb	 SHORT $LN63@stbi__crea
  00ffa	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  01004	eb 0e		 jmp	 SHORT $LN67@stbi__crea
$LN65@stbi__crea:
  01006	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  0100c	ff c0		 inc	 eax
  0100e	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN67@stbi__crea:
  01014	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  0101a	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  01020	7d 4c		 jge	 SHORT $LN66@stbi__crea
  01022	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  01029	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  01030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01034	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR output_bytes$[rbp]
  0103a	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  01040	2b d1		 sub	 edx, ecx
  01042	8b ca		 mov	 ecx, edx
  01044	48 63 c9	 movsxd	 rcx, ecx
  01047	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  0104e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01052	d1 f9		 sar	 ecx, 1
  01054	03 c1		 add	 eax, ecx
  01056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0105b	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  01062	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  01069	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0106c	eb 98		 jmp	 SHORT $LN65@stbi__crea
$LN66@stbi__crea:
  0106e	e9 16 ff ff ff	 jmp	 $LN62@stbi__crea
$LN63@stbi__crea:
  01073	e9 11 01 00 00	 jmp	 $LN30@stbi__crea
$LN134@stbi__crea:

; 4265 :                 STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); } break;

  01078	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0107e	ff c8		 dec	 eax
  01080	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  01083	eb 6b		 jmp	 SHORT $LN70@stbi__crea
$LN68@stbi__crea:
  01085	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  01088	ff c8		 dec	 eax
  0108a	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  0108d	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  01094	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  0109b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0109f	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR filter_bytes$[rbp]
  010a6	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  010ad	48 03 c8	 add	 rcx, rax
  010b0	48 8b c1	 mov	 rax, rcx
  010b3	48 89 85 68 04
	00 00		 mov	 QWORD PTR raw$[rbp], rax
  010ba	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  010c1	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  010c8	48 03 c8	 add	 rcx, rax
  010cb	48 8b c1	 mov	 rax, rcx
  010ce	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
  010d5	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  010dc	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR prior$2[rbp]
  010e3	48 03 c8	 add	 rcx, rax
  010e6	48 8b c1	 mov	 rax, rcx
  010e9	48 89 85 a8 01
	00 00		 mov	 QWORD PTR prior$2[rbp], rax
$LN70@stbi__crea:
  010f0	83 7d 44 01	 cmp	 DWORD PTR i$[rbp], 1
  010f4	0f 82 8f 00 00
	00		 jb	 $LN69@stbi__crea
  010fa	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  01104	eb 0e		 jmp	 SHORT $LN73@stbi__crea
$LN71@stbi__crea:
  01106	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  0110c	ff c0		 inc	 eax
  0110e	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN73@stbi__crea:
  01114	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  0111a	39 85 e4 00 00
	00		 cmp	 DWORD PTR k$[rbp], eax
  01120	7d 62		 jge	 SHORT $LN72@stbi__crea
  01122	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR k$[rbp]
  01129	48 8b 8d 68 04
	00 00		 mov	 rcx, QWORD PTR raw$[rbp]
  01130	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01134	89 85 34 04 00
	00		 mov	 DWORD PTR tv618[rbp], eax
  0113a	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR output_bytes$[rbp]
  01140	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR k$[rbp]
  01146	2b d1		 sub	 edx, ecx
  01148	8b ca		 mov	 ecx, edx
  0114a	48 63 c9	 movsxd	 rcx, ecx
  0114d	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  01154	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01158	45 33 c0	 xor	 r8d, r8d
  0115b	33 d2		 xor	 edx, edx
  0115d	e8 00 00 00 00	 call	 stbi__paeth
  01162	8b 8d 34 04 00
	00		 mov	 ecx, DWORD PTR tv618[rbp]
  01168	03 c8		 add	 ecx, eax
  0116a	8b c1		 mov	 eax, ecx
  0116c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01171	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR k$[rbp]
  01178	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR cur$1[rbp]
  0117f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01182	eb 82		 jmp	 SHORT $LN71@stbi__crea
$LN72@stbi__crea:
  01184	e9 fc fe ff ff	 jmp	 $LN68@stbi__crea
$LN69@stbi__crea:
$LN30@stbi__crea:

; 4266 :             }
; 4267 : #undef STBI__CASE
; 4268 : 
; 4269 :             // the loop above sets the high byte of the pixels' alpha, but for
; 4270 :             // 16 bit png files we also need the low byte set. we'll do that here.
; 4271 :             if (depth == 16) {

  01189	83 bd 90 04 00
	00 10		 cmp	 DWORD PTR depth$[rbp], 16
  01190	75 6c		 jne	 SHORT $LN135@stbi__crea

; 4272 :                 cur = a->out + stride * j; // start at the beginning of the row again

  01192	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  01198	0f af 45 64	 imul	 eax, DWORD PTR j$[rbp]
  0119c	8b c0		 mov	 eax, eax
  0119e	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  011a5	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  011a9	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax

; 4273 :                 for (i = 0; i < x; ++i, cur += output_bytes) {

  011b0	c7 45 44 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  011b7	eb 23		 jmp	 SHORT $LN76@stbi__crea
$LN74@stbi__crea:
  011b9	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  011bc	ff c0		 inc	 eax
  011be	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  011c1	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR output_bytes$[rbp]
  011c8	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  011cf	48 03 c8	 add	 rcx, rax
  011d2	48 8b c1	 mov	 rax, rcx
  011d5	48 89 85 88 01
	00 00		 mov	 QWORD PTR cur$1[rbp], rax
$LN76@stbi__crea:
  011dc	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  011e2	39 45 44	 cmp	 DWORD PTR i$[rbp], eax
  011e5	73 17		 jae	 SHORT $LN75@stbi__crea

; 4274 :                     cur[filter_bytes + 1] = 255;

  011e7	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR filter_bytes$[rbp]
  011ed	ff c0		 inc	 eax
  011ef	48 98		 cdqe
  011f1	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR cur$1[rbp]
  011f8	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4275 :                 }

  011fc	eb bb		 jmp	 SHORT $LN74@stbi__crea
$LN75@stbi__crea:
$LN135@stbi__crea:
$LN119@stbi__crea:

; 4276 :             }
; 4277 :         }
; 4278 :     }

  011fe	e9 c2 ef ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4279 : 
; 4280 :     // we make a separate pass to expand bits to pixels; for performance,
; 4281 :     // this could run two scanlines behind the above code, so it won't
; 4282 :     // intefere with filtering but will still be in the cache.
; 4283 :     if (depth < 8) {

  01203	83 bd 90 04 00
	00 08		 cmp	 DWORD PTR depth$[rbp], 8
  0120a	0f 8d c0 08 00
	00		 jge	 $LN136@stbi__crea

; 4284 :         for (j = 0; j < y; ++j) {

  01210	c7 45 64 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  01217	eb 08		 jmp	 SHORT $LN79@stbi__crea
$LN77@stbi__crea:
  01219	8b 45 64	 mov	 eax, DWORD PTR j$[rbp]
  0121c	ff c0		 inc	 eax
  0121e	89 45 64	 mov	 DWORD PTR j$[rbp], eax
$LN79@stbi__crea:
  01221	8b 85 88 04 00
	00		 mov	 eax, DWORD PTR y$[rbp]
  01227	39 45 64	 cmp	 DWORD PTR j$[rbp], eax
  0122a	0f 83 9b 08 00
	00		 jae	 $LN78@stbi__crea

; 4285 :             stbi_uc* cur = a->out + stride * j;

  01230	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  01236	0f af 45 64	 imul	 eax, DWORD PTR j$[rbp]
  0123a	8b c0		 mov	 eax, eax
  0123c	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  01243	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01247	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4286 :             stbi_uc* in = a->out + stride * j + x * out_n - img_width_bytes;

  0124e	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  01254	0f af 45 64	 imul	 eax, DWORD PTR j$[rbp]
  01258	8b c0		 mov	 eax, eax
  0125a	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  01261	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01265	48 03 c8	 add	 rcx, rax
  01268	48 8b c1	 mov	 rax, rcx
  0126b	8b 8d 80 04 00
	00		 mov	 ecx, DWORD PTR x$[rbp]
  01271	0f af 8d 78 04
	00 00		 imul	 ecx, DWORD PTR out_n$[rbp]
  01278	8b c9		 mov	 ecx, ecx
  0127a	48 03 c1	 add	 rax, rcx
  0127d	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR img_width_bytes$[rbp]
  01283	48 2b c1	 sub	 rax, rcx
  01286	48 89 85 28 02
	00 00		 mov	 QWORD PTR in$6[rbp], rax

; 4287 :             // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4288 :             // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4289 :             stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

  0128d	83 bd 98 04 00
	00 00		 cmp	 DWORD PTR color$[rbp], 0
  01294	75 1a		 jne	 SHORT $LN163@stbi__crea
  01296	48 63 85 90 04
	00 00		 movsxd	 rax, DWORD PTR depth$[rbp]
  0129d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__depth_scale_table
  012a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  012a8	89 85 34 04 00
	00		 mov	 DWORD PTR tv666[rbp], eax
  012ae	eb 0a		 jmp	 SHORT $LN164@stbi__crea
$LN163@stbi__crea:
  012b0	c7 85 34 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv666[rbp], 1
$LN164@stbi__crea:
  012ba	0f b6 85 34 04
	00 00		 movzx	 eax, BYTE PTR tv666[rbp]
  012c1	88 85 44 02 00
	00		 mov	 BYTE PTR scale$7[rbp], al

; 4290 : 
; 4291 :             // note that the final byte might overshoot and write more data than desired.
; 4292 :             // we can allocate enough data that this never writes out of memory, but it
; 4293 :             // could also overwrite the next scanline. can it overwrite non-empty data
; 4294 :             // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4295 :             // so we need to explicitly clamp the final ones
; 4296 : 
; 4297 :             if (depth == 4) {

  012c7	83 bd 90 04 00
	00 04		 cmp	 DWORD PTR depth$[rbp], 4
  012ce	0f 85 e4 00 00
	00		 jne	 $LN138@stbi__crea

; 4298 :                 for (k = x * img_n; k >= 2; k -= 2, ++in) {

  012d4	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  012da	0f af 85 04 01
	00 00		 imul	 eax, DWORD PTR img_n$[rbp]
  012e1	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  012e7	eb 20		 jmp	 SHORT $LN82@stbi__crea
$LN80@stbi__crea:
  012e9	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  012ef	83 e8 02	 sub	 eax, 2
  012f2	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  012f8	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR in$6[rbp]
  012ff	48 ff c0	 inc	 rax
  01302	48 89 85 28 02
	00 00		 mov	 QWORD PTR in$6[rbp], rax
$LN82@stbi__crea:
  01309	83 bd e4 00 00
	00 02		 cmp	 DWORD PTR k$[rbp], 2
  01310	7c 67		 jl	 SHORT $LN81@stbi__crea

; 4299 :                     *cur++ = scale * ((*in >> 4));

  01312	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01319	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01320	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01323	c1 f9 04	 sar	 ecx, 4
  01326	0f af c1	 imul	 eax, ecx
  01329	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01330	88 01		 mov	 BYTE PTR [rcx], al
  01332	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01339	48 ff c0	 inc	 rax
  0133c	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4300 :                     *cur++ = scale * ((*in) & 0x0f);

  01343	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0134a	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01351	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01354	83 e1 0f	 and	 ecx, 15
  01357	0f af c1	 imul	 eax, ecx
  0135a	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01361	88 01		 mov	 BYTE PTR [rcx], al
  01363	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  0136a	48 ff c0	 inc	 rax
  0136d	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4301 :                 }

  01374	e9 70 ff ff ff	 jmp	 $LN80@stbi__crea
$LN81@stbi__crea:

; 4302 :                 if (k > 0) *cur++ = scale * ((*in >> 4));

  01379	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR k$[rbp], 0
  01380	7e 31		 jle	 SHORT $LN140@stbi__crea
  01382	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01389	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01390	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01393	c1 f9 04	 sar	 ecx, 4
  01396	0f af c1	 imul	 eax, ecx
  01399	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  013a0	88 01		 mov	 BYTE PTR [rcx], al
  013a2	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  013a9	48 ff c0	 inc	 rax
  013ac	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN140@stbi__crea:

; 4303 :             }

  013b3	e9 6b 05 00 00	 jmp	 $LN139@stbi__crea
$LN138@stbi__crea:

; 4304 :             else if (depth == 2) {

  013b8	83 bd 90 04 00
	00 02		 cmp	 DWORD PTR depth$[rbp], 2
  013bf	0f 85 ca 01 00
	00		 jne	 $LN141@stbi__crea

; 4305 :                 for (k = x * img_n; k >= 4; k -= 4, ++in) {

  013c5	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  013cb	0f af 85 04 01
	00 00		 imul	 eax, DWORD PTR img_n$[rbp]
  013d2	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  013d8	eb 20		 jmp	 SHORT $LN85@stbi__crea
$LN83@stbi__crea:
  013da	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  013e0	83 e8 04	 sub	 eax, 4
  013e3	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  013e9	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR in$6[rbp]
  013f0	48 ff c0	 inc	 rax
  013f3	48 89 85 28 02
	00 00		 mov	 QWORD PTR in$6[rbp], rax
$LN85@stbi__crea:
  013fa	83 bd e4 00 00
	00 04		 cmp	 DWORD PTR k$[rbp], 4
  01401	0f 8c cf 00 00
	00		 jl	 $LN84@stbi__crea

; 4306 :                     *cur++ = scale * ((*in >> 6));

  01407	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0140e	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01415	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01418	c1 f9 06	 sar	 ecx, 6
  0141b	0f af c1	 imul	 eax, ecx
  0141e	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01425	88 01		 mov	 BYTE PTR [rcx], al
  01427	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  0142e	48 ff c0	 inc	 rax
  01431	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4307 :                     *cur++ = scale * ((*in >> 4) & 0x03);

  01438	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0143f	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01446	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01449	c1 f9 04	 sar	 ecx, 4
  0144c	83 e1 03	 and	 ecx, 3
  0144f	0f af c1	 imul	 eax, ecx
  01452	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01459	88 01		 mov	 BYTE PTR [rcx], al
  0145b	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01462	48 ff c0	 inc	 rax
  01465	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4308 :                     *cur++ = scale * ((*in >> 2) & 0x03);

  0146c	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01473	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  0147a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0147d	c1 f9 02	 sar	 ecx, 2
  01480	83 e1 03	 and	 ecx, 3
  01483	0f af c1	 imul	 eax, ecx
  01486	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  0148d	88 01		 mov	 BYTE PTR [rcx], al
  0148f	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01496	48 ff c0	 inc	 rax
  01499	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4309 :                     *cur++ = scale * ((*in) & 0x03);

  014a0	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  014a7	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  014ae	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014b1	83 e1 03	 and	 ecx, 3
  014b4	0f af c1	 imul	 eax, ecx
  014b7	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  014be	88 01		 mov	 BYTE PTR [rcx], al
  014c0	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  014c7	48 ff c0	 inc	 rax
  014ca	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4310 :                 }

  014d1	e9 04 ff ff ff	 jmp	 $LN83@stbi__crea
$LN84@stbi__crea:

; 4311 :                 if (k > 0) *cur++ = scale * ((*in >> 6));

  014d6	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR k$[rbp], 0
  014dd	7e 31		 jle	 SHORT $LN143@stbi__crea
  014df	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  014e6	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  014ed	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014f0	c1 f9 06	 sar	 ecx, 6
  014f3	0f af c1	 imul	 eax, ecx
  014f6	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  014fd	88 01		 mov	 BYTE PTR [rcx], al
  014ff	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01506	48 ff c0	 inc	 rax
  01509	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN143@stbi__crea:

; 4312 :                 if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

  01510	83 bd e4 00 00
	00 01		 cmp	 DWORD PTR k$[rbp], 1
  01517	7e 34		 jle	 SHORT $LN144@stbi__crea
  01519	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01520	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01527	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0152a	c1 f9 04	 sar	 ecx, 4
  0152d	83 e1 03	 and	 ecx, 3
  01530	0f af c1	 imul	 eax, ecx
  01533	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  0153a	88 01		 mov	 BYTE PTR [rcx], al
  0153c	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01543	48 ff c0	 inc	 rax
  01546	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN144@stbi__crea:

; 4313 :                 if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

  0154d	83 bd e4 00 00
	00 02		 cmp	 DWORD PTR k$[rbp], 2
  01554	7e 34		 jle	 SHORT $LN145@stbi__crea
  01556	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0155d	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01564	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01567	c1 f9 02	 sar	 ecx, 2
  0156a	83 e1 03	 and	 ecx, 3
  0156d	0f af c1	 imul	 eax, ecx
  01570	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01577	88 01		 mov	 BYTE PTR [rcx], al
  01579	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01580	48 ff c0	 inc	 rax
  01583	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN145@stbi__crea:

; 4314 :             }

  0158a	e9 94 03 00 00	 jmp	 $LN142@stbi__crea
$LN141@stbi__crea:

; 4315 :             else if (depth == 1) {

  0158f	83 bd 90 04 00
	00 01		 cmp	 DWORD PTR depth$[rbp], 1
  01596	0f 85 87 03 00
	00		 jne	 $LN146@stbi__crea

; 4316 :                 for (k = x * img_n; k >= 8; k -= 8, ++in) {

  0159c	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  015a2	0f af 85 04 01
	00 00		 imul	 eax, DWORD PTR img_n$[rbp]
  015a9	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  015af	eb 20		 jmp	 SHORT $LN88@stbi__crea
$LN86@stbi__crea:
  015b1	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  015b7	83 e8 08	 sub	 eax, 8
  015ba	89 85 e4 00 00
	00		 mov	 DWORD PTR k$[rbp], eax
  015c0	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR in$6[rbp]
  015c7	48 ff c0	 inc	 rax
  015ca	48 89 85 28 02
	00 00		 mov	 QWORD PTR in$6[rbp], rax
$LN88@stbi__crea:
  015d1	83 bd e4 00 00
	00 08		 cmp	 DWORD PTR k$[rbp], 8
  015d8	0f 8c 9e 01 00
	00		 jl	 $LN87@stbi__crea

; 4317 :                     *cur++ = scale * ((*in >> 7));

  015de	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  015e5	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  015ec	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  015ef	c1 f9 07	 sar	 ecx, 7
  015f2	0f af c1	 imul	 eax, ecx
  015f5	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  015fc	88 01		 mov	 BYTE PTR [rcx], al
  015fe	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01605	48 ff c0	 inc	 rax
  01608	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4318 :                     *cur++ = scale * ((*in >> 6) & 0x01);

  0160f	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01616	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  0161d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01620	c1 f9 06	 sar	 ecx, 6
  01623	83 e1 01	 and	 ecx, 1
  01626	0f af c1	 imul	 eax, ecx
  01629	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01630	88 01		 mov	 BYTE PTR [rcx], al
  01632	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01639	48 ff c0	 inc	 rax
  0163c	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4319 :                     *cur++ = scale * ((*in >> 5) & 0x01);

  01643	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0164a	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01651	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01654	c1 f9 05	 sar	 ecx, 5
  01657	83 e1 01	 and	 ecx, 1
  0165a	0f af c1	 imul	 eax, ecx
  0165d	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01664	88 01		 mov	 BYTE PTR [rcx], al
  01666	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  0166d	48 ff c0	 inc	 rax
  01670	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4320 :                     *cur++ = scale * ((*in >> 4) & 0x01);

  01677	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0167e	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01685	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01688	c1 f9 04	 sar	 ecx, 4
  0168b	83 e1 01	 and	 ecx, 1
  0168e	0f af c1	 imul	 eax, ecx
  01691	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01698	88 01		 mov	 BYTE PTR [rcx], al
  0169a	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  016a1	48 ff c0	 inc	 rax
  016a4	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4321 :                     *cur++ = scale * ((*in >> 3) & 0x01);

  016ab	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  016b2	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  016b9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  016bc	c1 f9 03	 sar	 ecx, 3
  016bf	83 e1 01	 and	 ecx, 1
  016c2	0f af c1	 imul	 eax, ecx
  016c5	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  016cc	88 01		 mov	 BYTE PTR [rcx], al
  016ce	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  016d5	48 ff c0	 inc	 rax
  016d8	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4322 :                     *cur++ = scale * ((*in >> 2) & 0x01);

  016df	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  016e6	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  016ed	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  016f0	c1 f9 02	 sar	 ecx, 2
  016f3	83 e1 01	 and	 ecx, 1
  016f6	0f af c1	 imul	 eax, ecx
  016f9	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01700	88 01		 mov	 BYTE PTR [rcx], al
  01702	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01709	48 ff c0	 inc	 rax
  0170c	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4323 :                     *cur++ = scale * ((*in >> 1) & 0x01);

  01713	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0171a	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01721	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01724	d1 f9		 sar	 ecx, 1
  01726	83 e1 01	 and	 ecx, 1
  01729	0f af c1	 imul	 eax, ecx
  0172c	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01733	88 01		 mov	 BYTE PTR [rcx], al
  01735	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  0173c	48 ff c0	 inc	 rax
  0173f	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4324 :                     *cur++ = scale * ((*in) & 0x01);

  01746	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0174d	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01754	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01757	83 e1 01	 and	 ecx, 1
  0175a	0f af c1	 imul	 eax, ecx
  0175d	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01764	88 01		 mov	 BYTE PTR [rcx], al
  01766	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  0176d	48 ff c0	 inc	 rax
  01770	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4325 :                 }

  01777	e9 35 fe ff ff	 jmp	 $LN86@stbi__crea
$LN87@stbi__crea:

; 4326 :                 if (k > 0) *cur++ = scale * ((*in >> 7));

  0177c	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR k$[rbp], 0
  01783	7e 31		 jle	 SHORT $LN147@stbi__crea
  01785	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0178c	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01793	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01796	c1 f9 07	 sar	 ecx, 7
  01799	0f af c1	 imul	 eax, ecx
  0179c	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  017a3	88 01		 mov	 BYTE PTR [rcx], al
  017a5	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  017ac	48 ff c0	 inc	 rax
  017af	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN147@stbi__crea:

; 4327 :                 if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

  017b6	83 bd e4 00 00
	00 01		 cmp	 DWORD PTR k$[rbp], 1
  017bd	7e 34		 jle	 SHORT $LN148@stbi__crea
  017bf	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  017c6	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  017cd	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  017d0	c1 f9 06	 sar	 ecx, 6
  017d3	83 e1 01	 and	 ecx, 1
  017d6	0f af c1	 imul	 eax, ecx
  017d9	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  017e0	88 01		 mov	 BYTE PTR [rcx], al
  017e2	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  017e9	48 ff c0	 inc	 rax
  017ec	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN148@stbi__crea:

; 4328 :                 if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

  017f3	83 bd e4 00 00
	00 02		 cmp	 DWORD PTR k$[rbp], 2
  017fa	7e 34		 jle	 SHORT $LN149@stbi__crea
  017fc	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01803	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  0180a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0180d	c1 f9 05	 sar	 ecx, 5
  01810	83 e1 01	 and	 ecx, 1
  01813	0f af c1	 imul	 eax, ecx
  01816	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  0181d	88 01		 mov	 BYTE PTR [rcx], al
  0181f	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01826	48 ff c0	 inc	 rax
  01829	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN149@stbi__crea:

; 4329 :                 if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

  01830	83 bd e4 00 00
	00 03		 cmp	 DWORD PTR k$[rbp], 3
  01837	7e 34		 jle	 SHORT $LN150@stbi__crea
  01839	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  01840	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01847	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0184a	c1 f9 04	 sar	 ecx, 4
  0184d	83 e1 01	 and	 ecx, 1
  01850	0f af c1	 imul	 eax, ecx
  01853	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  0185a	88 01		 mov	 BYTE PTR [rcx], al
  0185c	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01863	48 ff c0	 inc	 rax
  01866	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN150@stbi__crea:

; 4330 :                 if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

  0186d	83 bd e4 00 00
	00 04		 cmp	 DWORD PTR k$[rbp], 4
  01874	7e 34		 jle	 SHORT $LN151@stbi__crea
  01876	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  0187d	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  01884	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01887	c1 f9 03	 sar	 ecx, 3
  0188a	83 e1 01	 and	 ecx, 1
  0188d	0f af c1	 imul	 eax, ecx
  01890	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01897	88 01		 mov	 BYTE PTR [rcx], al
  01899	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  018a0	48 ff c0	 inc	 rax
  018a3	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN151@stbi__crea:

; 4331 :                 if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

  018aa	83 bd e4 00 00
	00 05		 cmp	 DWORD PTR k$[rbp], 5
  018b1	7e 34		 jle	 SHORT $LN152@stbi__crea
  018b3	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  018ba	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  018c1	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  018c4	c1 f9 02	 sar	 ecx, 2
  018c7	83 e1 01	 and	 ecx, 1
  018ca	0f af c1	 imul	 eax, ecx
  018cd	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  018d4	88 01		 mov	 BYTE PTR [rcx], al
  018d6	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  018dd	48 ff c0	 inc	 rax
  018e0	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN152@stbi__crea:

; 4332 :                 if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

  018e7	83 bd e4 00 00
	00 06		 cmp	 DWORD PTR k$[rbp], 6
  018ee	7e 33		 jle	 SHORT $LN153@stbi__crea
  018f0	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR scale$7[rbp]
  018f7	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR in$6[rbp]
  018fe	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01901	d1 f9		 sar	 ecx, 1
  01903	83 e1 01	 and	 ecx, 1
  01906	0f af c1	 imul	 eax, ecx
  01909	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01910	88 01		 mov	 BYTE PTR [rcx], al
  01912	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR cur$5[rbp]
  01919	48 ff c0	 inc	 rax
  0191c	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax
$LN153@stbi__crea:
$LN146@stbi__crea:
$LN142@stbi__crea:
$LN139@stbi__crea:

; 4333 :             }
; 4334 :             if (img_n != out_n) {

  01923	8b 85 78 04 00
	00		 mov	 eax, DWORD PTR out_n$[rbp]
  01929	39 85 04 01 00
	00		 cmp	 DWORD PTR img_n$[rbp], eax
  0192f	0f 84 91 01 00
	00		 je	 $LN154@stbi__crea

; 4335 :                 int q;
; 4336 :                 // insert alpha = 255
; 4337 :                 cur = a->out + stride * j;

  01935	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR stride$[rbp]
  0193b	0f af 45 64	 imul	 eax, DWORD PTR j$[rbp]
  0193f	8b c0		 mov	 eax, eax
  01941	48 8b 8d 60 04
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  01948	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  0194c	48 89 85 08 02
	00 00		 mov	 QWORD PTR cur$5[rbp], rax

; 4338 :                 if (img_n == 1) {

  01953	83 bd 04 01 00
	00 01		 cmp	 DWORD PTR img_n$[rbp], 1
  0195a	75 6d		 jne	 SHORT $LN155@stbi__crea

; 4339 :                     for (q = x - 1; q >= 0; --q) {

  0195c	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  01962	ff c8		 dec	 eax
  01964	89 85 64 02 00
	00		 mov	 DWORD PTR q$8[rbp], eax
  0196a	eb 0e		 jmp	 SHORT $LN91@stbi__crea
$LN89@stbi__crea:
  0196c	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR q$8[rbp]
  01972	ff c8		 dec	 eax
  01974	89 85 64 02 00
	00		 mov	 DWORD PTR q$8[rbp], eax
$LN91@stbi__crea:
  0197a	83 bd 64 02 00
	00 00		 cmp	 DWORD PTR q$8[rbp], 0
  01981	7c 41		 jl	 SHORT $LN90@stbi__crea

; 4340 :                         cur[q * 2 + 1] = 255;

  01983	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR q$8[rbp]
  01989	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0198d	48 98		 cdqe
  0198f	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01996	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4341 :                         cur[q * 2 + 0] = cur[q];

  0199a	48 63 85 64 02
	00 00		 movsxd	 rax, DWORD PTR q$8[rbp]
  019a1	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR q$8[rbp]
  019a7	03 c9		 add	 ecx, ecx
  019a9	48 63 c9	 movsxd	 rcx, ecx
  019ac	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR cur$5[rbp]
  019b3	4c 8b 85 08 02
	00 00		 mov	 r8, QWORD PTR cur$5[rbp]
  019ba	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  019bf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4342 :                     }

  019c2	eb a8		 jmp	 SHORT $LN89@stbi__crea
$LN90@stbi__crea:

; 4343 :                 }

  019c4	e9 fd 00 00 00	 jmp	 $LN156@stbi__crea
$LN155@stbi__crea:

; 4344 :                 else {
; 4345 :                     STBI_ASSERT(img_n == 3);

  019c9	83 bd 04 01 00
	00 03		 cmp	 DWORD PTR img_n$[rbp], 3
  019d0	74 1c		 je	 SHORT $LN165@stbi__crea
  019d2	41 b8 f9 10 00
	00		 mov	 r8d, 4345		; 000010f9H
  019d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  019df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
  019e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  019ec	33 c0		 xor	 eax, eax
$LN165@stbi__crea:

; 4346 :                     for (q = x - 1; q >= 0; --q) {

  019ee	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  019f4	ff c8		 dec	 eax
  019f6	89 85 64 02 00
	00		 mov	 DWORD PTR q$8[rbp], eax
  019fc	eb 0e		 jmp	 SHORT $LN94@stbi__crea
$LN92@stbi__crea:
  019fe	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR q$8[rbp]
  01a04	ff c8		 dec	 eax
  01a06	89 85 64 02 00
	00		 mov	 DWORD PTR q$8[rbp], eax
$LN94@stbi__crea:
  01a0c	83 bd 64 02 00
	00 00		 cmp	 DWORD PTR q$8[rbp], 0
  01a13	0f 8c ad 00 00
	00		 jl	 $LN93@stbi__crea

; 4347 :                         cur[q * 4 + 3] = 255;

  01a19	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR q$8[rbp]
  01a1f	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  01a26	48 98		 cdqe
  01a28	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR cur$5[rbp]
  01a2f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4348 :                         cur[q * 4 + 2] = cur[q * 3 + 2];

  01a33	6b 85 64 02 00
	00 03		 imul	 eax, DWORD PTR q$8[rbp], 3
  01a3a	83 c0 02	 add	 eax, 2
  01a3d	48 98		 cdqe
  01a3f	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR q$8[rbp]
  01a45	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  01a4c	48 63 c9	 movsxd	 rcx, ecx
  01a4f	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR cur$5[rbp]
  01a56	4c 8b 85 08 02
	00 00		 mov	 r8, QWORD PTR cur$5[rbp]
  01a5d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01a62	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4349 :                         cur[q * 4 + 1] = cur[q * 3 + 1];

  01a65	6b 85 64 02 00
	00 03		 imul	 eax, DWORD PTR q$8[rbp], 3
  01a6c	ff c0		 inc	 eax
  01a6e	48 98		 cdqe
  01a70	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR q$8[rbp]
  01a76	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  01a7d	48 63 c9	 movsxd	 rcx, ecx
  01a80	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR cur$5[rbp]
  01a87	4c 8b 85 08 02
	00 00		 mov	 r8, QWORD PTR cur$5[rbp]
  01a8e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01a93	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4350 :                         cur[q * 4 + 0] = cur[q * 3 + 0];

  01a96	6b 85 64 02 00
	00 03		 imul	 eax, DWORD PTR q$8[rbp], 3
  01a9d	48 98		 cdqe
  01a9f	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR q$8[rbp]
  01aa5	c1 e1 02	 shl	 ecx, 2
  01aa8	48 63 c9	 movsxd	 rcx, ecx
  01aab	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR cur$5[rbp]
  01ab2	4c 8b 85 08 02
	00 00		 mov	 r8, QWORD PTR cur$5[rbp]
  01ab9	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01abe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4351 :                     }

  01ac1	e9 38 ff ff ff	 jmp	 $LN92@stbi__crea
$LN93@stbi__crea:
$LN156@stbi__crea:
$LN154@stbi__crea:

; 4352 :                 }
; 4353 :             }
; 4354 :         }

  01ac6	e9 4e f7 ff ff	 jmp	 $LN77@stbi__crea
$LN78@stbi__crea:

; 4355 :     }

  01acb	e9 b4 00 00 00	 jmp	 $LN137@stbi__crea
$LN136@stbi__crea:

; 4356 :     else if (depth == 16) {

  01ad0	83 bd 90 04 00
	00 10		 cmp	 DWORD PTR depth$[rbp], 16
  01ad7	0f 85 a7 00 00
	00		 jne	 $LN157@stbi__crea

; 4357 :         // force the image data from big-endian to platform-native.
; 4358 :         // this is done in a separate pass due to the decoding relying
; 4359 :         // on the data being untouched, but could probably be done
; 4360 :         // per-line during decode if care is taken.
; 4361 :         stbi_uc* cur = a->out;

  01add	48 8b 85 60 04
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  01ae4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01ae8	48 89 85 88 02
	00 00		 mov	 QWORD PTR cur$9[rbp], rax

; 4362 :         stbi__uint16* cur16 = (stbi__uint16*)cur;

  01aef	48 8b 85 88 02
	00 00		 mov	 rax, QWORD PTR cur$9[rbp]
  01af6	48 89 85 a8 02
	00 00		 mov	 QWORD PTR cur16$10[rbp], rax

; 4363 : 
; 4364 :         for (i = 0; i < x * y * out_n; ++i, cur16++, cur += 2) {

  01afd	c7 45 44 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  01b04	eb 2c		 jmp	 SHORT $LN97@stbi__crea
$LN95@stbi__crea:
  01b06	8b 45 44	 mov	 eax, DWORD PTR i$[rbp]
  01b09	ff c0		 inc	 eax
  01b0b	89 45 44	 mov	 DWORD PTR i$[rbp], eax
  01b0e	48 8b 85 a8 02
	00 00		 mov	 rax, QWORD PTR cur16$10[rbp]
  01b15	48 83 c0 02	 add	 rax, 2
  01b19	48 89 85 a8 02
	00 00		 mov	 QWORD PTR cur16$10[rbp], rax
  01b20	48 8b 85 88 02
	00 00		 mov	 rax, QWORD PTR cur$9[rbp]
  01b27	48 83 c0 02	 add	 rax, 2
  01b2b	48 89 85 88 02
	00 00		 mov	 QWORD PTR cur$9[rbp], rax
$LN97@stbi__crea:
  01b32	8b 85 80 04 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  01b38	0f af 85 88 04
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  01b3f	0f af 85 78 04
	00 00		 imul	 eax, DWORD PTR out_n$[rbp]
  01b46	39 45 44	 cmp	 DWORD PTR i$[rbp], eax
  01b49	73 39		 jae	 SHORT $LN96@stbi__crea

; 4365 :             *cur16 = (cur[0] << 8) | cur[1];

  01b4b	b8 01 00 00 00	 mov	 eax, 1
  01b50	48 6b c0 00	 imul	 rax, rax, 0
  01b54	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR cur$9[rbp]
  01b5b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01b5f	c1 e0 08	 shl	 eax, 8
  01b62	b9 01 00 00 00	 mov	 ecx, 1
  01b67	48 6b c9 01	 imul	 rcx, rcx, 1
  01b6b	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR cur$9[rbp]
  01b72	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01b76	0b c1		 or	 eax, ecx
  01b78	48 8b 8d a8 02
	00 00		 mov	 rcx, QWORD PTR cur16$10[rbp]
  01b7f	66 89 01	 mov	 WORD PTR [rcx], ax

; 4366 :         }

  01b82	eb 82		 jmp	 SHORT $LN95@stbi__crea
$LN96@stbi__crea:
$LN157@stbi__crea:
$LN137@stbi__crea:

; 4367 :     }
; 4368 : 
; 4369 :     return 1;

  01b84	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4370 : }

  01b89	48 8d a5 48 04
	00 00		 lea	 rsp, QWORD PTR [rbp+1096]
  01b90	5f		 pop	 rdi
  01b91	5d		 pop	 rbp
  01b92	c3		 ret	 0
  01b93	90		 npad	 1
$LN168@stbi__crea:
  01b94	00 00 00 00	 DD	 $LN105@stbi__crea
  01b98	00 00 00 00	 DD	 $LN106@stbi__crea
  01b9c	00 00 00 00	 DD	 $LN107@stbi__crea
  01ba0	00 00 00 00	 DD	 $LN108@stbi__crea
  01ba4	00 00 00 00	 DD	 $LN109@stbi__crea
  01ba8	00 00 00 00	 DD	 $LN110@stbi__crea
  01bac	00 00 00 00	 DD	 $LN111@stbi__crea
$LN167@stbi__crea:
  01bb0	00 00 00 00	 DD	 $LN121@stbi__crea
  01bb4	00 00 00 00	 DD	 $LN122@stbi__crea
  01bb8	00 00 00 00	 DD	 $LN123@stbi__crea
  01bbc	00 00 00 00	 DD	 $LN124@stbi__crea
  01bc0	00 00 00 00	 DD	 $LN125@stbi__crea
  01bc4	00 00 00 00	 DD	 $LN126@stbi__crea
  01bc8	00 00 00 00	 DD	 $LN127@stbi__crea
$LN166@stbi__crea:
  01bcc	00 00 00 00	 DD	 $LN128@stbi__crea
  01bd0	00 00 00 00	 DD	 $LN129@stbi__crea
  01bd4	00 00 00 00	 DD	 $LN130@stbi__crea
  01bd8	00 00 00 00	 DD	 $LN131@stbi__crea
  01bdc	00 00 00 00	 DD	 $LN132@stbi__crea
  01be0	00 00 00 00	 DD	 $LN133@stbi__crea
  01be4	00 00 00 00	 DD	 $LN134@stbi__crea
stbi__create_png_image_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__paeth
_TEXT	SEGMENT
p$ = 4
pa$ = 36
pb$ = 68
pc$ = 100
a$ = 352
b$ = 360
c$ = 368
stbi__paeth PROC					; COMDAT

; 4140 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4141 :     int p = a + b - c;

  00027	8b 85 68 01 00
	00		 mov	 eax, DWORD PTR b$[rbp]
  0002d	8b 8d 60 01 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00033	03 c8		 add	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	2b 85 70 01 00
	00		 sub	 eax, DWORD PTR c$[rbp]
  0003d	89 45 04	 mov	 DWORD PTR p$[rbp], eax

; 4142 :     int pa = abs(p - a);

  00040	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00046	8b 4d 04	 mov	 ecx, DWORD PTR p$[rbp]
  00049	2b c8		 sub	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	8b c8		 mov	 ecx, eax
  0004f	e8 00 00 00 00	 call	 abs
  00054	89 45 24	 mov	 DWORD PTR pa$[rbp], eax

; 4143 :     int pb = abs(p - b);

  00057	8b 85 68 01 00
	00		 mov	 eax, DWORD PTR b$[rbp]
  0005d	8b 4d 04	 mov	 ecx, DWORD PTR p$[rbp]
  00060	2b c8		 sub	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 abs
  0006b	89 45 44	 mov	 DWORD PTR pb$[rbp], eax

; 4144 :     int pc = abs(p - c);

  0006e	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR c$[rbp]
  00074	8b 4d 04	 mov	 ecx, DWORD PTR p$[rbp]
  00077	2b c8		 sub	 ecx, eax
  00079	8b c1		 mov	 eax, ecx
  0007b	8b c8		 mov	 ecx, eax
  0007d	e8 00 00 00 00	 call	 abs
  00082	89 45 64	 mov	 DWORD PTR pc$[rbp], eax

; 4145 :     if (pa <= pb && pa <= pc) return a;

  00085	8b 45 44	 mov	 eax, DWORD PTR pb$[rbp]
  00088	39 45 24	 cmp	 DWORD PTR pa$[rbp], eax
  0008b	7f 10		 jg	 SHORT $LN2@stbi__paet
  0008d	8b 45 64	 mov	 eax, DWORD PTR pc$[rbp]
  00090	39 45 24	 cmp	 DWORD PTR pa$[rbp], eax
  00093	7f 08		 jg	 SHORT $LN2@stbi__paet
  00095	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0009b	eb 16		 jmp	 SHORT $LN1@stbi__paet
$LN2@stbi__paet:

; 4146 :     if (pb <= pc) return b;

  0009d	8b 45 64	 mov	 eax, DWORD PTR pc$[rbp]
  000a0	39 45 44	 cmp	 DWORD PTR pb$[rbp], eax
  000a3	7f 08		 jg	 SHORT $LN3@stbi__paet
  000a5	8b 85 68 01 00
	00		 mov	 eax, DWORD PTR b$[rbp]
  000ab	eb 06		 jmp	 SHORT $LN1@stbi__paet
$LN3@stbi__paet:

; 4147 :     return c;

  000ad	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR c$[rbp]
$LN1@stbi__paet:

; 4148 : }

  000b3	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000ba	5f		 pop	 rdi
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
stbi__paeth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__check_png_header
_TEXT	SEGMENT
i$ = 4
s$ = 256
stbi__check_png_header PROC				; COMDAT

; 4104 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4105 :     static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4106 :     int i;
; 4107 :     for (i = 0; i < 8; ++i)

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00026	eb 08		 jmp	 SHORT $LN4@stbi__chec
$LN2@stbi__chec:
  00028	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0002b	ff c0		 inc	 eax
  0002d	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__chec:
  00030	83 7d 04 08	 cmp	 DWORD PTR i$[rbp], 8
  00034	7d 32		 jge	 SHORT $LN3@stbi__chec

; 4108 :         if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");

  00036	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003d	e8 00 00 00 00	 call	 stbi__get8
  00042	0f b6 c0	 movzx	 eax, al
  00045	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@9@9
  00050	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00054	3b c1		 cmp	 eax, ecx
  00056	74 0e		 je	 SHORT $LN5@stbi__chec
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DMDNBACF@bad?5png?5sig@
  0005f	e8 00 00 00 00	 call	 stbi__err
  00064	eb 07		 jmp	 SHORT $LN1@stbi__chec
$LN5@stbi__chec:
  00066	eb c0		 jmp	 SHORT $LN2@stbi__chec
$LN3@stbi__chec:

; 4109 :     return 1;

  00068	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__chec:

; 4110 : }

  0006d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00074	5f		 pop	 rdi
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
stbi__check_png_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get_chunk_header
_TEXT	SEGMENT
c$ = 8
s$ = 256
stbi__get_chunk_header PROC				; COMDAT

; 4096 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 0a 00 00 00	 mov	 ecx, 10
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4097 :     stbi__pngchunk c;
; 4098 :     c.length = stbi__get32be(s);

  00038	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003f	e8 00 00 00 00	 call	 stbi__get32be
  00044	89 45 08	 mov	 DWORD PTR c$[rbp], eax

; 4099 :     c.type = stbi__get32be(s);

  00047	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004e	e8 00 00 00 00	 call	 stbi__get32be
  00053	89 45 0c	 mov	 DWORD PTR c$[rbp+4], eax

; 4100 :     return c;

  00056	48 8b 45 08	 mov	 rax, QWORD PTR c$[rbp]

; 4101 : }

  0005a	48 8b f8	 mov	 rdi, rax
  0005d	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__get_chunk_header$rtcFrameData
  00068	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0006d	48 8b c7	 mov	 rax, rdi
  00070	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00077	5f		 pop	 rdi
  00078	5d		 pop	 rbp
  00079	c3		 ret	 0
stbi__get_chunk_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__do_zlib
_TEXT	SEGMENT
a$ = 224
obuf$ = 232
olen$ = 240
exp$ = 248
parse_header$ = 256
stbi__do_zlib PROC					; COMDAT

; 3990 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3991 :     a->zout_start = obuf;

  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00035	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR obuf$[rbp]
  0003c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 3992 :     a->zout = obuf;

  00040	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00047	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR obuf$[rbp]
  0004e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3993 :     a->zout_end = obuf + olen;

  00052	48 63 85 f0 00
	00 00		 movsxd	 rax, DWORD PTR olen$[rbp]
  00059	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR obuf$[rbp]
  00060	48 03 c8	 add	 rcx, rax
  00063	48 8b c1	 mov	 rax, rcx
  00066	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0006d	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 3994 :     a->z_expandable = exp;

  00071	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00078	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR exp$[rbp]
  0007e	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 3995 : 
; 3996 :     return stbi__parse_zlib(a, parse_header);

  00081	8b 95 00 01 00
	00		 mov	 edx, DWORD PTR parse_header$[rbp]
  00087	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0008e	e8 00 00 00 00	 call	 stbi__parse_zlib

; 3997 : }

  00093	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0009a	5f		 pop	 rdi
  0009b	5d		 pop	 rbp
  0009c	c3		 ret	 0
stbi__do_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_zlib
_TEXT	SEGMENT
final$ = 4
type$ = 36
a$ = 288
parse_header$ = 296
stbi__parse_zlib PROC					; COMDAT

; 3959 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3960 :     int final, type;
; 3961 :     if (parse_header)

  00023	83 bd 28 01 00
	00 00		 cmp	 DWORD PTR parse_header$[rbp], 0
  0002a	74 17		 je	 SHORT $LN5@stbi__pars

; 3962 :         if (!stbi__parse_zlib_header(a)) return 0;

  0002c	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00033	e8 00 00 00 00	 call	 stbi__parse_zlib_header
  00038	85 c0		 test	 eax, eax
  0003a	75 07		 jne	 SHORT $LN6@stbi__pars
  0003c	33 c0		 xor	 eax, eax
  0003e	e9 09 01 00 00	 jmp	 $LN1@stbi__pars
$LN6@stbi__pars:
$LN5@stbi__pars:

; 3963 :     a->num_bits = 0;

  00043	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0004a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 3964 :     a->code_buffer = 0;

  00051	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00058	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN4@stbi__pars:

; 3965 :     do {
; 3966 :         final = stbi__zreceive(a, 1);

  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0006b	e8 00 00 00 00	 call	 stbi__zreceive
  00070	89 45 04	 mov	 DWORD PTR final$[rbp], eax

; 3967 :         type = stbi__zreceive(a, 2);

  00073	ba 02 00 00 00	 mov	 edx, 2
  00078	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0007f	e8 00 00 00 00	 call	 stbi__zreceive
  00084	89 45 24	 mov	 DWORD PTR type$[rbp], eax

; 3968 :         if (type == 0) {

  00087	83 7d 24 00	 cmp	 DWORD PTR type$[rbp], 0
  0008b	75 1c		 jne	 SHORT $LN7@stbi__pars

; 3969 :             if (!stbi__parse_uncompressed_block(a)) return 0;

  0008d	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00094	e8 00 00 00 00	 call	 stbi__parse_uncompressed_block
  00099	85 c0		 test	 eax, eax
  0009b	75 07		 jne	 SHORT $LN9@stbi__pars
  0009d	33 c0		 xor	 eax, eax
  0009f	e9 a8 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 3970 :         }

  000a4	e9 94 00 00 00	 jmp	 $LN8@stbi__pars
$LN7@stbi__pars:

; 3971 :         else if (type == 3) {

  000a9	83 7d 24 03	 cmp	 DWORD PTR type$[rbp], 3
  000ad	75 0c		 jne	 SHORT $LN10@stbi__pars

; 3972 :             return 0;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 96 00 00 00	 jmp	 $LN1@stbi__pars

; 3973 :         }

  000b6	e9 82 00 00 00	 jmp	 $LN11@stbi__pars
$LN10@stbi__pars:

; 3974 :         else {
; 3975 :             if (type == 1) {

  000bb	83 7d 24 01	 cmp	 DWORD PTR type$[rbp], 1
  000bf	75 54		 jne	 SHORT $LN12@stbi__pars

; 3976 :                 // use fixed code lengths
; 3977 :                 if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, STBI__ZNSYMS)) return 0;

  000c1	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000c8	48 83 c0 34	 add	 rax, 52			; 00000034H
  000cc	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zdefault_length
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  000e1	85 c0		 test	 eax, eax
  000e3	75 04		 jne	 SHORT $LN14@stbi__pars
  000e5	33 c0		 xor	 eax, eax
  000e7	eb 63		 jmp	 SHORT $LN1@stbi__pars
$LN14@stbi__pars:

; 3978 :                 if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;

  000e9	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000f0	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  000f6	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zdefault_distance
  00103	48 8b c8	 mov	 rcx, rax
  00106	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  0010b	85 c0		 test	 eax, eax
  0010d	75 04		 jne	 SHORT $LN15@stbi__pars
  0010f	33 c0		 xor	 eax, eax
  00111	eb 39		 jmp	 SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 3979 :             }

  00113	eb 14		 jmp	 SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 3980 :             else {
; 3981 :                 if (!stbi__compute_huffman_codes(a)) return 0;

  00115	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0011c	e8 00 00 00 00	 call	 stbi__compute_huffman_codes
  00121	85 c0		 test	 eax, eax
  00123	75 04		 jne	 SHORT $LN16@stbi__pars
  00125	33 c0		 xor	 eax, eax
  00127	eb 23		 jmp	 SHORT $LN1@stbi__pars
$LN16@stbi__pars:
$LN13@stbi__pars:

; 3982 :             }
; 3983 :             if (!stbi__parse_huffman_block(a)) return 0;

  00129	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00130	e8 00 00 00 00	 call	 stbi__parse_huffman_block
  00135	85 c0		 test	 eax, eax
  00137	75 04		 jne	 SHORT $LN17@stbi__pars
  00139	33 c0		 xor	 eax, eax
  0013b	eb 0f		 jmp	 SHORT $LN1@stbi__pars
$LN17@stbi__pars:
$LN11@stbi__pars:
$LN8@stbi__pars:

; 3984 :         }
; 3985 :     } while (!final);

  0013d	83 7d 04 00	 cmp	 DWORD PTR final$[rbp], 0
  00141	0f 84 18 ff ff
	ff		 je	 $LN4@stbi__pars

; 3986 :     return 1;

  00147	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 3987 : }

  0014c	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00153	5f		 pop	 rdi
  00154	5d		 pop	 rbp
  00155	c3		 ret	 0
stbi__parse_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_zlib_header
_TEXT	SEGMENT
cmf$ = 4
cm$ = 36
flg$ = 68
a$ = 320
stbi__parse_zlib_header PROC				; COMDAT

; 3916 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3917 :     int cmf = stbi__zget8(a);

  0001f	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__zget8
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	89 45 04	 mov	 DWORD PTR cmf$[rbp], eax

; 3918 :     int cm = cmf & 15;

  00031	8b 45 04	 mov	 eax, DWORD PTR cmf$[rbp]
  00034	83 e0 0f	 and	 eax, 15
  00037	89 45 24	 mov	 DWORD PTR cm$[rbp], eax

; 3919 :     /* int cinfo = cmf >> 4; */
; 3920 :     int flg = stbi__zget8(a);

  0003a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00041	e8 00 00 00 00	 call	 stbi__zget8
  00046	0f b6 c0	 movzx	 eax, al
  00049	89 45 44	 mov	 DWORD PTR flg$[rbp], eax

; 3921 :     if (stbi__zeof(a)) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec

  0004c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00053	e8 00 00 00 00	 call	 stbi__zeof
  00058	85 c0		 test	 eax, eax
  0005a	74 0e		 je	 SHORT $LN2@stbi__pars
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
  00063	e8 00 00 00 00	 call	 stbi__err
  00068	eb 57		 jmp	 SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 3922 :     if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec

  0006a	69 45 04 00 01
	00 00		 imul	 eax, DWORD PTR cmf$[rbp], 256 ; 00000100H
  00071	03 45 44	 add	 eax, DWORD PTR flg$[rbp]
  00074	99		 cdq
  00075	b9 1f 00 00 00	 mov	 ecx, 31
  0007a	f7 f9		 idiv	 ecx
  0007c	8b c2		 mov	 eax, edx
  0007e	85 c0		 test	 eax, eax
  00080	74 0e		 je	 SHORT $LN3@stbi__pars
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
  00089	e8 00 00 00 00	 call	 stbi__err
  0008e	eb 31		 jmp	 SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 3923 :     if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png

  00090	8b 45 44	 mov	 eax, DWORD PTR flg$[rbp]
  00093	83 e0 20	 and	 eax, 32			; 00000020H
  00096	85 c0		 test	 eax, eax
  00098	74 0e		 je	 SHORT $LN4@stbi__pars
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@DOGMHEBI@no?5preset?5dict@
  000a1	e8 00 00 00 00	 call	 stbi__err
  000a6	eb 19		 jmp	 SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 3924 :     if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png

  000a8	83 7d 24 08	 cmp	 DWORD PTR cm$[rbp], 8
  000ac	74 0e		 je	 SHORT $LN5@stbi__pars
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@
  000b5	e8 00 00 00 00	 call	 stbi__err
  000ba	eb 05		 jmp	 SHORT $LN1@stbi__pars
$LN5@stbi__pars:

; 3925 :     // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 3926 :     return 1;

  000bc	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 3927 : }

  000c1	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000c8	5f		 pop	 rdi
  000c9	5d		 pop	 rbp
  000ca	c3		 ret	 0
stbi__parse_zlib_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_uncompressed_block
_TEXT	SEGMENT
header$ = 4
len$ = 36
nlen$ = 68
k$ = 100
a$ = 352
stbi__parse_uncompressed_block PROC			; COMDAT

; 3887 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR [rsp+392]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3888 :     stbi_uc header[4];
; 3889 :     int len, nlen, k;
; 3890 :     if (a->num_bits & 7)

  00038	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0003f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00042	83 e0 07	 and	 eax, 7
  00045	85 c0		 test	 eax, eax
  00047	74 1b		 je	 SHORT $LN6@stbi__pars

; 3891 :         stbi__zreceive(a, a->num_bits & 7); // discard

  00049	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00050	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00053	83 e0 07	 and	 eax, 7
  00056	8b d0		 mov	 edx, eax
  00058	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__zreceive
$LN6@stbi__pars:

; 3892 :     // drain the bit-packed data into header
; 3893 :     k = 0;

  00064	c7 45 64 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0
$LN2@stbi__pars:

; 3894 :     while (a->num_bits > 0) {

  0006b	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00072	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00076	7e 4f		 jle	 SHORT $LN3@stbi__pars

; 3895 :         header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check

  00078	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0007f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00082	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00087	48 63 4d 64	 movsxd	 rcx, DWORD PTR k$[rbp]
  0008b	88 44 0d 04	 mov	 BYTE PTR header$[rbp+rcx], al
  0008f	8b 45 64	 mov	 eax, DWORD PTR k$[rbp]
  00092	ff c0		 inc	 eax
  00094	89 45 64	 mov	 DWORD PTR k$[rbp], eax

; 3896 :         a->code_buffer >>= 8;

  00097	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0009e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000a1	c1 e8 08	 shr	 eax, 8
  000a4	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000ab	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 3897 :         a->num_bits -= 8;

  000ae	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000b5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b8	83 e8 08	 sub	 eax, 8
  000bb	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000c2	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3898 :     }

  000c5	eb a4		 jmp	 SHORT $LN2@stbi__pars
$LN3@stbi__pars:

; 3899 :     if (a->num_bits < 0) return stbi__err("zlib corrupt", "Corrupt PNG");

  000c7	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000ce	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  000d2	7d 11		 jge	 SHORT $LN7@stbi__pars
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IECDHMDI@zlib?5corrupt@
  000db	e8 00 00 00 00	 call	 stbi__err
  000e0	e9 53 01 00 00	 jmp	 $LN1@stbi__pars
$LN7@stbi__pars:
$LN4@stbi__pars:

; 3900 :     // now fill header the normal way
; 3901 :     while (k < 4)

  000e5	83 7d 64 04	 cmp	 DWORD PTR k$[rbp], 4
  000e9	7d 1e		 jge	 SHORT $LN5@stbi__pars

; 3902 :         header[k++] = stbi__zget8(a);

  000eb	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000f2	e8 00 00 00 00	 call	 stbi__zget8
  000f7	48 63 4d 64	 movsxd	 rcx, DWORD PTR k$[rbp]
  000fb	88 44 0d 04	 mov	 BYTE PTR header$[rbp+rcx], al
  000ff	8b 45 64	 mov	 eax, DWORD PTR k$[rbp]
  00102	ff c0		 inc	 eax
  00104	89 45 64	 mov	 DWORD PTR k$[rbp], eax
  00107	eb dc		 jmp	 SHORT $LN4@stbi__pars
$LN5@stbi__pars:

; 3903 :     len = header[1] * 256 + header[0];

  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	0f b6 44 05 04	 movzx	 eax, BYTE PTR header$[rbp+rax]
  00117	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0011d	b9 01 00 00 00	 mov	 ecx, 1
  00122	48 6b c9 00	 imul	 rcx, rcx, 0
  00126	0f b6 4c 0d 04	 movzx	 ecx, BYTE PTR header$[rbp+rcx]
  0012b	03 c1		 add	 eax, ecx
  0012d	89 45 24	 mov	 DWORD PTR len$[rbp], eax

; 3904 :     nlen = header[3] * 256 + header[2];

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	48 6b c0 03	 imul	 rax, rax, 3
  00139	0f b6 44 05 04	 movzx	 eax, BYTE PTR header$[rbp+rax]
  0013e	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	48 6b c9 02	 imul	 rcx, rcx, 2
  0014d	0f b6 4c 0d 04	 movzx	 ecx, BYTE PTR header$[rbp+rcx]
  00152	03 c1		 add	 eax, ecx
  00154	89 45 44	 mov	 DWORD PTR nlen$[rbp], eax

; 3905 :     if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");

  00157	8b 45 24	 mov	 eax, DWORD PTR len$[rbp]
  0015a	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  0015f	39 45 44	 cmp	 DWORD PTR nlen$[rbp], eax
  00162	74 11		 je	 SHORT $LN8@stbi__pars
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IECDHMDI@zlib?5corrupt@
  0016b	e8 00 00 00 00	 call	 stbi__err
  00170	e9 c3 00 00 00	 jmp	 $LN1@stbi__pars
$LN8@stbi__pars:

; 3906 :     if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");

  00175	48 63 45 24	 movsxd	 rax, DWORD PTR len$[rbp]
  00179	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00180	48 03 01	 add	 rax, QWORD PTR [rcx]
  00183	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0018a	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  0018e	76 11		 jbe	 SHORT $LN9@stbi__pars
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@PIPBCKIA@read?5past?5buffer@
  00197	e8 00 00 00 00	 call	 stbi__err
  0019c	e9 97 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 3907 :     if (a->zout + len > a->zout_end)

  001a1	48 63 45 24	 movsxd	 rax, DWORD PTR len$[rbp]
  001a5	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001ac	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  001b0	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001b7	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  001bb	76 23		 jbe	 SHORT $LN10@stbi__pars

; 3908 :         if (!stbi__zexpand(a, a->zout, len)) return 0;

  001bd	44 8b 45 24	 mov	 r8d, DWORD PTR len$[rbp]
  001c1	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  001c8	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  001cc	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001d3	e8 00 00 00 00	 call	 stbi__zexpand
  001d8	85 c0		 test	 eax, eax
  001da	75 04		 jne	 SHORT $LN11@stbi__pars
  001dc	33 c0		 xor	 eax, eax
  001de	eb 58		 jmp	 SHORT $LN1@stbi__pars
$LN11@stbi__pars:
$LN10@stbi__pars:

; 3909 :     memcpy(a->zout, a->zbuffer, len);

  001e0	48 63 45 24	 movsxd	 rax, DWORD PTR len$[rbp]
  001e4	4c 8b c0	 mov	 r8, rax
  001e7	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  001ee	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001f1	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  001f8	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001fc	e8 00 00 00 00	 call	 memcpy

; 3910 :     a->zbuffer += len;

  00201	48 63 45 24	 movsxd	 rax, DWORD PTR len$[rbp]
  00205	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0020c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0020f	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00216	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3911 :     a->zout += len;

  00219	48 63 45 24	 movsxd	 rax, DWORD PTR len$[rbp]
  0021d	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00224	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00228	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0022f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3912 :     return 1;

  00233	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 3913 : }

  00238	48 8b f8	 mov	 rdi, rax
  0023b	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_uncompressed_block$rtcFrameData
  00246	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0024b	48 8b c7	 mov	 rax, rdi
  0024e	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  00255	5f		 pop	 rdi
  00256	5d		 pop	 rbp
  00257	c3		 ret	 0
stbi__parse_uncompressed_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__compute_huffman_codes
_TEXT	SEGMENT
z_codelength$ = 16
lencodes$ = 2080
codelength_sizes$ = 2568
i$ = 2612
n$ = 2644
hlit$ = 2676
hdist$ = 2708
hclen$ = 2740
ntot$ = 2772
s$6 = 2804
c$7 = 2836
fill$8 = 2868
tv175 = 4040
__$ArrayPad$ = 4048
a$ = 4096
stbi__compute_huffman_codes PROC			; COMDAT

; 3834 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 da 02 00 00	 mov	 ecx, 730		; 000002daH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 28
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4136]
  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00039	48 33 c5	 xor	 rax, rbp
  0003c	48 89 85 d0 0f
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0004a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3835 :     static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 3836 :     stbi__zhuffman z_codelength;
; 3837 :     stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
; 3838 :     stbi_uc codelength_sizes[19];
; 3839 :     int i, n;
; 3840 : 
; 3841 :     int hlit = stbi__zreceive(a, 5) + 257;

  0004f	ba 05 00 00 00	 mov	 edx, 5
  00054	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0005b	e8 00 00 00 00	 call	 stbi__zreceive
  00060	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00065	89 85 74 0a 00
	00		 mov	 DWORD PTR hlit$[rbp], eax

; 3842 :     int hdist = stbi__zreceive(a, 5) + 1;

  0006b	ba 05 00 00 00	 mov	 edx, 5
  00070	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00077	e8 00 00 00 00	 call	 stbi__zreceive
  0007c	ff c0		 inc	 eax
  0007e	89 85 94 0a 00
	00		 mov	 DWORD PTR hdist$[rbp], eax

; 3843 :     int hclen = stbi__zreceive(a, 4) + 4;

  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00090	e8 00 00 00 00	 call	 stbi__zreceive
  00095	83 c0 04	 add	 eax, 4
  00098	89 85 b4 0a 00
	00		 mov	 DWORD PTR hclen$[rbp], eax

; 3844 :     int ntot = hlit + hdist;

  0009e	8b 85 94 0a 00
	00		 mov	 eax, DWORD PTR hdist$[rbp]
  000a4	8b 8d 74 0a 00
	00		 mov	 ecx, DWORD PTR hlit$[rbp]
  000aa	03 c8		 add	 ecx, eax
  000ac	8b c1		 mov	 eax, ecx
  000ae	89 85 d4 0a 00
	00		 mov	 DWORD PTR ntot$[rbp], eax

; 3845 : 
; 3846 :     memset(codelength_sizes, 0, sizeof(codelength_sizes));

  000b4	41 b8 13 00 00
	00		 mov	 r8d, 19
  000ba	33 d2		 xor	 edx, edx
  000bc	48 8d 8d 08 0a
	00 00		 lea	 rcx, QWORD PTR codelength_sizes$[rbp]
  000c3	e8 00 00 00 00	 call	 memset

; 3847 :     for (i = 0; i < hclen; ++i) {

  000c8	c7 85 34 0a 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  000d2	eb 0e		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  000d4	8b 85 34 0a 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  000da	ff c0		 inc	 eax
  000dc	89 85 34 0a 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__comp:
  000e2	8b 85 b4 0a 00
	00		 mov	 eax, DWORD PTR hclen$[rbp]
  000e8	39 85 34 0a 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  000ee	7d 39		 jge	 SHORT $LN3@stbi__comp

; 3848 :         int s = stbi__zreceive(a, 3);

  000f0	ba 03 00 00 00	 mov	 edx, 3
  000f5	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000fc	e8 00 00 00 00	 call	 stbi__zreceive
  00101	89 85 f4 0a 00
	00		 mov	 DWORD PTR s$6[rbp], eax

; 3849 :         codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;

  00107	48 63 85 34 0a
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9
  00115	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00119	0f b6 8d f4 0a
	00 00		 movzx	 ecx, BYTE PTR s$6[rbp]
  00120	88 8c 05 08 0a
	00 00		 mov	 BYTE PTR codelength_sizes$[rbp+rax], cl

; 3850 :     }

  00127	eb ab		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 3851 :     if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

  00129	41 b8 13 00 00
	00		 mov	 r8d, 19
  0012f	48 8d 95 08 0a
	00 00		 lea	 rdx, QWORD PTR codelength_sizes$[rbp]
  00136	48 8d 4d 10	 lea	 rcx, QWORD PTR z_codelength$[rbp]
  0013a	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  0013f	85 c0		 test	 eax, eax
  00141	75 07		 jne	 SHORT $LN7@stbi__comp
  00143	33 c0		 xor	 eax, eax
  00145	e9 39 02 00 00	 jmp	 $LN1@stbi__comp
$LN7@stbi__comp:

; 3852 : 
; 3853 :     n = 0;

  0014a	c7 85 54 0a 00
	00 00 00 00 00	 mov	 DWORD PTR n$[rbp], 0
$LN5@stbi__comp:

; 3854 :     while (n < ntot) {

  00154	8b 85 d4 0a 00
	00		 mov	 eax, DWORD PTR ntot$[rbp]
  0015a	39 85 54 0a 00
	00		 cmp	 DWORD PTR n$[rbp], eax
  00160	0f 8d 9f 01 00
	00		 jge	 $LN6@stbi__comp

; 3855 :         int c = stbi__zhuffman_decode(a, &z_codelength);

  00166	48 8d 55 10	 lea	 rdx, QWORD PTR z_codelength$[rbp]
  0016a	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00171	e8 00 00 00 00	 call	 stbi__zhuffman_decode
  00176	89 85 14 0b 00
	00		 mov	 DWORD PTR c$7[rbp], eax

; 3856 :         if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

  0017c	83 bd 14 0b 00
	00 00		 cmp	 DWORD PTR c$7[rbp], 0
  00183	7c 09		 jl	 SHORT $LN9@stbi__comp
  00185	83 bd 14 0b 00
	00 13		 cmp	 DWORD PTR c$7[rbp], 19
  0018c	7c 11		 jl	 SHORT $LN8@stbi__comp
$LN9@stbi__comp:
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  00195	e8 00 00 00 00	 call	 stbi__err
  0019a	e9 e4 01 00 00	 jmp	 $LN1@stbi__comp
$LN8@stbi__comp:

; 3857 :         if (c < 16)

  0019f	83 bd 14 0b 00
	00 10		 cmp	 DWORD PTR c$7[rbp], 16
  001a6	7d 28		 jge	 SHORT $LN10@stbi__comp

; 3858 :             lencodes[n++] = (stbi_uc)c;

  001a8	48 63 85 54 0a
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  001af	0f b6 8d 14 0b
	00 00		 movzx	 ecx, BYTE PTR c$7[rbp]
  001b6	88 8c 05 20 08
	00 00		 mov	 BYTE PTR lencodes$[rbp+rax], cl
  001bd	8b 85 54 0a 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  001c3	ff c0		 inc	 eax
  001c5	89 85 54 0a 00
	00		 mov	 DWORD PTR n$[rbp], eax
  001cb	e9 30 01 00 00	 jmp	 $LN11@stbi__comp
$LN10@stbi__comp:

; 3859 :         else {
; 3860 :             stbi_uc fill = 0;

  001d0	c6 85 34 0b 00
	00 00		 mov	 BYTE PTR fill$8[rbp], 0

; 3861 :             if (c == 16) {

  001d7	83 bd 14 0b 00
	00 10		 cmp	 DWORD PTR c$7[rbp], 16
  001de	75 4e		 jne	 SHORT $LN12@stbi__comp

; 3862 :                 c = stbi__zreceive(a, 2) + 3;

  001e0	ba 02 00 00 00	 mov	 edx, 2
  001e5	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001ec	e8 00 00 00 00	 call	 stbi__zreceive
  001f1	83 c0 03	 add	 eax, 3
  001f4	89 85 14 0b 00
	00		 mov	 DWORD PTR c$7[rbp], eax

; 3863 :                 if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

  001fa	83 bd 54 0a 00
	00 00		 cmp	 DWORD PTR n$[rbp], 0
  00201	75 11		 jne	 SHORT $LN14@stbi__comp
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  0020a	e8 00 00 00 00	 call	 stbi__err
  0020f	e9 6f 01 00 00	 jmp	 $LN1@stbi__comp
$LN14@stbi__comp:

; 3864 :                 fill = lencodes[n - 1];

  00214	8b 85 54 0a 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0021a	ff c8		 dec	 eax
  0021c	48 98		 cdqe
  0021e	0f b6 84 05 20
	08 00 00	 movzx	 eax, BYTE PTR lencodes$[rbp+rax]
  00226	88 85 34 0b 00
	00		 mov	 BYTE PTR fill$8[rbp], al

; 3865 :             }

  0022c	eb 5b		 jmp	 SHORT $LN13@stbi__comp
$LN12@stbi__comp:

; 3866 :             else if (c == 17) {

  0022e	83 bd 14 0b 00
	00 11		 cmp	 DWORD PTR c$7[rbp], 17
  00235	75 1c		 jne	 SHORT $LN15@stbi__comp

; 3867 :                 c = stbi__zreceive(a, 3) + 3;

  00237	ba 03 00 00 00	 mov	 edx, 3
  0023c	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00243	e8 00 00 00 00	 call	 stbi__zreceive
  00248	83 c0 03	 add	 eax, 3
  0024b	89 85 14 0b 00
	00		 mov	 DWORD PTR c$7[rbp], eax

; 3868 :             }

  00251	eb 36		 jmp	 SHORT $LN16@stbi__comp
$LN15@stbi__comp:

; 3869 :             else if (c == 18) {

  00253	83 bd 14 0b 00
	00 12		 cmp	 DWORD PTR c$7[rbp], 18
  0025a	75 1c		 jne	 SHORT $LN17@stbi__comp

; 3870 :                 c = stbi__zreceive(a, 7) + 11;

  0025c	ba 07 00 00 00	 mov	 edx, 7
  00261	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00268	e8 00 00 00 00	 call	 stbi__zreceive
  0026d	83 c0 0b	 add	 eax, 11
  00270	89 85 14 0b 00
	00		 mov	 DWORD PTR c$7[rbp], eax

; 3871 :             }

  00276	eb 11		 jmp	 SHORT $LN18@stbi__comp
$LN17@stbi__comp:

; 3872 :             else {
; 3873 :                 return stbi__err("bad codelengths", "Corrupt PNG");

  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  0027f	e8 00 00 00 00	 call	 stbi__err
  00284	e9 fa 00 00 00	 jmp	 $LN1@stbi__comp
$LN18@stbi__comp:
$LN16@stbi__comp:
$LN13@stbi__comp:

; 3874 :             }
; 3875 :             if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

  00289	8b 85 54 0a 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0028f	8b 8d d4 0a 00
	00		 mov	 ecx, DWORD PTR ntot$[rbp]
  00295	2b c8		 sub	 ecx, eax
  00297	8b c1		 mov	 eax, ecx
  00299	3b 85 14 0b 00
	00		 cmp	 eax, DWORD PTR c$7[rbp]
  0029f	7d 11		 jge	 SHORT $LN19@stbi__comp
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  002a8	e8 00 00 00 00	 call	 stbi__err
  002ad	e9 d1 00 00 00	 jmp	 $LN1@stbi__comp
$LN19@stbi__comp:

; 3876 :             memset(lencodes + n, fill, c);

  002b2	48 63 85 14 0b
	00 00		 movsxd	 rax, DWORD PTR c$7[rbp]
  002b9	0f b6 8d 34 0b
	00 00		 movzx	 ecx, BYTE PTR fill$8[rbp]
  002c0	48 63 95 54 0a
	00 00		 movsxd	 rdx, DWORD PTR n$[rbp]
  002c7	48 8d 94 15 20
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rbp+rdx]
  002cf	48 89 95 c8 0f
	00 00		 mov	 QWORD PTR tv175[rbp], rdx
  002d6	4c 8b c0	 mov	 r8, rax
  002d9	8b d1		 mov	 edx, ecx
  002db	48 8b 85 c8 0f
	00 00		 mov	 rax, QWORD PTR tv175[rbp]
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	e8 00 00 00 00	 call	 memset

; 3877 :             n += c;

  002ea	8b 85 14 0b 00
	00		 mov	 eax, DWORD PTR c$7[rbp]
  002f0	8b 8d 54 0a 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  002f6	03 c8		 add	 ecx, eax
  002f8	8b c1		 mov	 eax, ecx
  002fa	89 85 54 0a 00
	00		 mov	 DWORD PTR n$[rbp], eax
$LN11@stbi__comp:

; 3878 :         }
; 3879 :     }

  00300	e9 4f fe ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:

; 3880 :     if (n != ntot) return stbi__err("bad codelengths", "Corrupt PNG");

  00305	8b 85 d4 0a 00
	00		 mov	 eax, DWORD PTR ntot$[rbp]
  0030b	39 85 54 0a 00
	00		 cmp	 DWORD PTR n$[rbp], eax
  00311	74 0e		 je	 SHORT $LN20@stbi__comp
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  0031a	e8 00 00 00 00	 call	 stbi__err
  0031f	eb 62		 jmp	 SHORT $LN1@stbi__comp
$LN20@stbi__comp:

; 3881 :     if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

  00321	48 8b 85 00 10
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00328	48 83 c0 34	 add	 rax, 52			; 00000034H
  0032c	44 8b 85 74 0a
	00 00		 mov	 r8d, DWORD PTR hlit$[rbp]
  00333	48 8d 95 20 08
	00 00		 lea	 rdx, QWORD PTR lencodes$[rbp]
  0033a	48 8b c8	 mov	 rcx, rax
  0033d	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  00342	85 c0		 test	 eax, eax
  00344	75 04		 jne	 SHORT $LN21@stbi__comp
  00346	33 c0		 xor	 eax, eax
  00348	eb 39		 jmp	 SHORT $LN1@stbi__comp
$LN21@stbi__comp:

; 3882 :     if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;

  0034a	48 63 85 74 0a
	00 00		 movsxd	 rax, DWORD PTR hlit$[rbp]
  00351	48 8d 84 05 20
	08 00 00	 lea	 rax, QWORD PTR lencodes$[rbp+rax]
  00359	48 8b 8d 00 10
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00360	48 81 c1 18 08
	00 00		 add	 rcx, 2072		; 00000818H
  00367	44 8b 85 94 0a
	00 00		 mov	 r8d, DWORD PTR hdist$[rbp]
  0036e	48 8b d0	 mov	 rdx, rax
  00371	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  00376	85 c0		 test	 eax, eax
  00378	75 04		 jne	 SHORT $LN22@stbi__comp
  0037a	33 c0		 xor	 eax, eax
  0037c	eb 05		 jmp	 SHORT $LN1@stbi__comp
$LN22@stbi__comp:

; 3883 :     return 1;

  0037e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__comp:

; 3884 : }

  00383	48 8b f8	 mov	 rdi, rax
  00386	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__compute_huffman_codes$rtcFrameData
  00391	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00396	48 8b c7	 mov	 rax, rdi
  00399	48 8b 8d d0 0f
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  003a0	48 33 cd	 xor	 rcx, rbp
  003a3	e8 00 00 00 00	 call	 __security_check_cookie
  003a8	48 8d a5 e8 0f
	00 00		 lea	 rsp, QWORD PTR [rbp+4072]
  003af	5f		 pop	 rdi
  003b0	5d		 pop	 rbp
  003b1	c3		 ret	 0
stbi__compute_huffman_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_huffman_block
_TEXT	SEGMENT
zout$ = 8
z$1 = 36
p$2 = 72
len$3 = 100
dist$4 = 132
v$5 = 164
a$ = 416
stbi__parse_huffman_block PROC				; COMDAT

; 3789 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3790 :     char* zout = a->zout;

  0001f	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002a	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax
$LN2@stbi__pars:

; 3791 :     for (;;) {
; 3792 :         int z = stbi__zhuffman_decode(a, &a->z_length);

  0002e	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00035	48 83 c0 34	 add	 rax, 52			; 00000034H
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00043	e8 00 00 00 00	 call	 stbi__zhuffman_decode
  00048	89 45 24	 mov	 DWORD PTR z$1[rbp], eax

; 3793 :         if (z < 256) {

  0004b	81 7d 24 00 01
	00 00		 cmp	 DWORD PTR z$1[rbp], 256	; 00000100H
  00052	7d 72		 jge	 SHORT $LN11@stbi__pars

; 3794 :             if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes

  00054	83 7d 24 00	 cmp	 DWORD PTR z$1[rbp], 0
  00058	7d 11		 jge	 SHORT $LN13@stbi__pars
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00061	e8 00 00 00 00	 call	 stbi__err
  00066	e9 83 02 00 00	 jmp	 $LN1@stbi__pars
$LN13@stbi__pars:

; 3795 :             if (zout >= a->zout_end) {

  0006b	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00072	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00076	48 39 45 08	 cmp	 QWORD PTR zout$[rbp], rax
  0007a	72 30		 jb	 SHORT $LN14@stbi__pars

; 3796 :                 if (!stbi__zexpand(a, zout, 1)) return 0;

  0007c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00082	48 8b 55 08	 mov	 rdx, QWORD PTR zout$[rbp]
  00086	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0008d	e8 00 00 00 00	 call	 stbi__zexpand
  00092	85 c0		 test	 eax, eax
  00094	75 07		 jne	 SHORT $LN15@stbi__pars
  00096	33 c0		 xor	 eax, eax
  00098	e9 51 02 00 00	 jmp	 $LN1@stbi__pars
$LN15@stbi__pars:

; 3797 :                 zout = a->zout;

  0009d	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a8	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax
$LN14@stbi__pars:

; 3798 :             }
; 3799 :             *zout++ = (char)z;

  000ac	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  000b0	0f b6 4d 24	 movzx	 ecx, BYTE PTR z$1[rbp]
  000b4	88 08		 mov	 BYTE PTR [rax], cl
  000b6	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  000ba	48 ff c0	 inc	 rax
  000bd	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax

; 3800 :         }

  000c1	e9 23 02 00 00	 jmp	 $LN12@stbi__pars
$LN11@stbi__pars:

; 3801 :         else {
; 3802 :             stbi_uc* p;
; 3803 :             int len, dist;
; 3804 :             if (z == 256) {

  000c6	81 7d 24 00 01
	00 00		 cmp	 DWORD PTR z$1[rbp], 256	; 00000100H
  000cd	75 19		 jne	 SHORT $LN16@stbi__pars

; 3805 :                 a->zout = zout;

  000cf	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000d6	48 8b 4d 08	 mov	 rcx, QWORD PTR zout$[rbp]
  000da	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3806 :                 return 1;

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	e9 06 02 00 00	 jmp	 $LN1@stbi__pars
$LN16@stbi__pars:

; 3807 :             }
; 3808 :             if (z >= 286) return stbi__err("bad huffman code", "Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data

  000e8	81 7d 24 1e 01
	00 00		 cmp	 DWORD PTR z$1[rbp], 286	; 0000011eH
  000ef	7c 11		 jl	 SHORT $LN17@stbi__pars
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  000f8	e8 00 00 00 00	 call	 stbi__err
  000fd	e9 ec 01 00 00	 jmp	 $LN1@stbi__pars
$LN17@stbi__pars:

; 3809 :             z -= 257;

  00102	8b 45 24	 mov	 eax, DWORD PTR z$1[rbp]
  00105	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  0010a	89 45 24	 mov	 DWORD PTR z$1[rbp], eax

; 3810 :             len = stbi__zlength_base[z];

  0010d	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_base
  00118	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0011b	89 45 64	 mov	 DWORD PTR len$3[rbp], eax

; 3811 :             if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

  0011e	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_extra
  00129	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  0012d	74 24		 je	 SHORT $LN18@stbi__pars
  0012f	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_extra
  0013a	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  0013d	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00144	e8 00 00 00 00	 call	 stbi__zreceive
  00149	8b 4d 64	 mov	 ecx, DWORD PTR len$3[rbp]
  0014c	03 c8		 add	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	89 45 64	 mov	 DWORD PTR len$3[rbp], eax
$LN18@stbi__pars:

; 3812 :             z = stbi__zhuffman_decode(a, &a->z_distance);

  00153	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0015a	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  00160	48 8b d0	 mov	 rdx, rax
  00163	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0016a	e8 00 00 00 00	 call	 stbi__zhuffman_decode
  0016f	89 45 24	 mov	 DWORD PTR z$1[rbp], eax

; 3813 :             if (z < 0 || z >= 30) return stbi__err("bad huffman code", "Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data

  00172	83 7d 24 00	 cmp	 DWORD PTR z$1[rbp], 0
  00176	7c 06		 jl	 SHORT $LN20@stbi__pars
  00178	83 7d 24 1e	 cmp	 DWORD PTR z$1[rbp], 30
  0017c	7c 11		 jl	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00185	e8 00 00 00 00	 call	 stbi__err
  0018a	e9 5f 01 00 00	 jmp	 $LN1@stbi__pars
$LN19@stbi__pars:

; 3814 :             dist = stbi__zdist_base[z];

  0018f	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_base
  0019a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0019d	89 85 84 00 00
	00		 mov	 DWORD PTR dist$4[rbp], eax

; 3815 :             if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

  001a3	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_extra
  001ae	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  001b2	74 2a		 je	 SHORT $LN21@stbi__pars
  001b4	48 63 45 24	 movsxd	 rax, DWORD PTR z$1[rbp]
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_extra
  001bf	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  001c2	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  001c9	e8 00 00 00 00	 call	 stbi__zreceive
  001ce	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR dist$4[rbp]
  001d4	03 c8		 add	 ecx, eax
  001d6	8b c1		 mov	 eax, ecx
  001d8	89 85 84 00 00
	00		 mov	 DWORD PTR dist$4[rbp], eax
$LN21@stbi__pars:

; 3816 :             if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");

  001de	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  001e5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e9	48 8b 4d 08	 mov	 rcx, QWORD PTR zout$[rbp]
  001ed	48 2b c8	 sub	 rcx, rax
  001f0	48 8b c1	 mov	 rax, rcx
  001f3	48 63 8d 84 00
	00 00		 movsxd	 rcx, DWORD PTR dist$4[rbp]
  001fa	48 3b c1	 cmp	 rax, rcx
  001fd	7d 11		 jge	 SHORT $LN22@stbi__pars
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DIAPIMGJ@bad?5dist@
  00206	e8 00 00 00 00	 call	 stbi__err
  0020b	e9 de 00 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:

; 3817 :             if (zout + len > a->zout_end) {

  00210	48 63 45 64	 movsxd	 rax, DWORD PTR len$3[rbp]
  00214	48 8b 4d 08	 mov	 rcx, QWORD PTR zout$[rbp]
  00218	48 03 c8	 add	 rcx, rax
  0021b	48 8b c1	 mov	 rax, rcx
  0021e	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00225	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  00229	76 2e		 jbe	 SHORT $LN23@stbi__pars

; 3818 :                 if (!stbi__zexpand(a, zout, len)) return 0;

  0022b	44 8b 45 64	 mov	 r8d, DWORD PTR len$3[rbp]
  0022f	48 8b 55 08	 mov	 rdx, QWORD PTR zout$[rbp]
  00233	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0023a	e8 00 00 00 00	 call	 stbi__zexpand
  0023f	85 c0		 test	 eax, eax
  00241	75 07		 jne	 SHORT $LN24@stbi__pars
  00243	33 c0		 xor	 eax, eax
  00245	e9 a4 00 00 00	 jmp	 $LN1@stbi__pars
$LN24@stbi__pars:

; 3819 :                 zout = a->zout;

  0024a	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00251	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00255	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax
$LN23@stbi__pars:

; 3820 :             }
; 3821 :             p = (stbi_uc*)(zout - dist);

  00259	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR dist$4[rbp]
  00260	48 8b 4d 08	 mov	 rcx, QWORD PTR zout$[rbp]
  00264	48 2b c8	 sub	 rcx, rax
  00267	48 8b c1	 mov	 rax, rcx
  0026a	48 89 45 48	 mov	 QWORD PTR p$2[rbp], rax

; 3822 :             if (dist == 1) { // run of one byte; common in images.

  0026e	83 bd 84 00 00
	00 01		 cmp	 DWORD PTR dist$4[rbp], 1
  00275	75 3b		 jne	 SHORT $LN25@stbi__pars

; 3823 :                 stbi_uc v = *p;

  00277	48 8b 45 48	 mov	 rax, QWORD PTR p$2[rbp]
  0027b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0027e	88 85 a4 00 00
	00		 mov	 BYTE PTR v$5[rbp], al

; 3824 :                 if (len) { do *zout++ = v; while (--len); }

  00284	83 7d 64 00	 cmp	 DWORD PTR len$3[rbp], 0
  00288	74 26		 je	 SHORT $LN27@stbi__pars
$LN7@stbi__pars:
  0028a	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  0028e	0f b6 8d a4 00
	00 00		 movzx	 ecx, BYTE PTR v$5[rbp]
  00295	88 08		 mov	 BYTE PTR [rax], cl
  00297	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  0029b	48 ff c0	 inc	 rax
  0029e	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax
  002a2	8b 45 64	 mov	 eax, DWORD PTR len$3[rbp]
  002a5	ff c8		 dec	 eax
  002a7	89 45 64	 mov	 DWORD PTR len$3[rbp], eax
  002aa	83 7d 64 00	 cmp	 DWORD PTR len$3[rbp], 0
  002ae	75 da		 jne	 SHORT $LN7@stbi__pars
$LN27@stbi__pars:

; 3825 :             }

  002b0	eb 37		 jmp	 SHORT $LN26@stbi__pars
$LN25@stbi__pars:

; 3826 :             else {
; 3827 :                 if (len) { do *zout++ = *p++; while (--len); }

  002b2	83 7d 64 00	 cmp	 DWORD PTR len$3[rbp], 0
  002b6	74 31		 je	 SHORT $LN28@stbi__pars
$LN10@stbi__pars:
  002b8	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  002bc	48 8b 4d 48	 mov	 rcx, QWORD PTR p$2[rbp]
  002c0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002c3	88 08		 mov	 BYTE PTR [rax], cl
  002c5	48 8b 45 08	 mov	 rax, QWORD PTR zout$[rbp]
  002c9	48 ff c0	 inc	 rax
  002cc	48 89 45 08	 mov	 QWORD PTR zout$[rbp], rax
  002d0	48 8b 45 48	 mov	 rax, QWORD PTR p$2[rbp]
  002d4	48 ff c0	 inc	 rax
  002d7	48 89 45 48	 mov	 QWORD PTR p$2[rbp], rax
  002db	8b 45 64	 mov	 eax, DWORD PTR len$3[rbp]
  002de	ff c8		 dec	 eax
  002e0	89 45 64	 mov	 DWORD PTR len$3[rbp], eax
  002e3	83 7d 64 00	 cmp	 DWORD PTR len$3[rbp], 0
  002e7	75 cf		 jne	 SHORT $LN10@stbi__pars
$LN28@stbi__pars:
$LN26@stbi__pars:
$LN12@stbi__pars:

; 3828 :             }
; 3829 :         }
; 3830 :     }

  002e9	e9 40 fd ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 3831 : }

  002ee	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  002f5	5f		 pop	 rdi
  002f6	5d		 pop	 rbp
  002f7	c3		 ret	 0
stbi__parse_huffman_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zexpand
_TEXT	SEGMENT
q$ = 8
cur$ = 36
limit$ = 68
old_limit$ = 100
z$ = 352
zout$ = 360
n$ = 368
stbi__zexpand PROC					; COMDAT

; 3753 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3754 :     char* q;
; 3755 :     unsigned int cur, limit, old_limit;
; 3756 :     z->zout = zout;

  00029	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00030	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR zout$[rbp]
  00037	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3757 :     if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");

  0003b	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00042	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00046	75 11		 jne	 SHORT $LN4@stbi__zexp
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@IBFIPFO@output?5buffer?5limit@
  0004f	e8 00 00 00 00	 call	 stbi__err
  00054	e9 05 01 00 00	 jmp	 $LN1@stbi__zexp
$LN4@stbi__zexp:

; 3758 :     cur = (unsigned int)(z->zout - z->zout_start);

  00059	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00060	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00067	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006f	48 2b c1	 sub	 rax, rcx
  00072	89 45 24	 mov	 DWORD PTR cur$[rbp], eax

; 3759 :     limit = old_limit = (unsigned)(z->zout_end - z->zout_start);

  00075	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0007c	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00083	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00087	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	89 45 64	 mov	 DWORD PTR old_limit$[rbp], eax
  00091	8b 45 64	 mov	 eax, DWORD PTR old_limit$[rbp]
  00094	89 45 44	 mov	 DWORD PTR limit$[rbp], eax

; 3760 :     if (UINT_MAX - cur < (unsigned)n) return stbi__err("outofmem", "Out of memory");

  00097	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0009c	2b 45 24	 sub	 eax, DWORD PTR cur$[rbp]
  0009f	3b 85 70 01 00
	00		 cmp	 eax, DWORD PTR n$[rbp]
  000a5	73 11		 jae	 SHORT $LN5@stbi__zexp
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000ae	e8 00 00 00 00	 call	 stbi__err
  000b3	e9 a6 00 00 00	 jmp	 $LN1@stbi__zexp
$LN5@stbi__zexp:
$LN2@stbi__zexp:

; 3761 :     while (cur + n > limit) {

  000b8	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  000be	8b 4d 24	 mov	 ecx, DWORD PTR cur$[rbp]
  000c1	03 c8		 add	 ecx, eax
  000c3	8b c1		 mov	 eax, ecx
  000c5	3b 45 44	 cmp	 eax, DWORD PTR limit$[rbp]
  000c8	76 21		 jbe	 SHORT $LN3@stbi__zexp

; 3762 :         if (limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");

  000ca	81 7d 44 ff ff
	ff 7f		 cmp	 DWORD PTR limit$[rbp], 2147483647 ; 7fffffffH
  000d1	76 0e		 jbe	 SHORT $LN6@stbi__zexp
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000da	e8 00 00 00 00	 call	 stbi__err
  000df	eb 7d		 jmp	 SHORT $LN1@stbi__zexp
$LN6@stbi__zexp:

; 3763 :         limit *= 2;

  000e1	8b 45 44	 mov	 eax, DWORD PTR limit$[rbp]
  000e4	d1 e0		 shl	 eax, 1
  000e6	89 45 44	 mov	 DWORD PTR limit$[rbp], eax

; 3764 :     }

  000e9	eb cd		 jmp	 SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 3765 :     q = (char*)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

  000eb	8b 45 44	 mov	 eax, DWORD PTR limit$[rbp]
  000ee	8b d0		 mov	 edx, eax
  000f0	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000f7	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00101	48 89 45 08	 mov	 QWORD PTR q$[rbp], rax

; 3766 :     STBI_NOTUSED(old_limit);
; 3767 :     if (q == NULL) return stbi__err("outofmem", "Out of memory");

  00105	48 83 7d 08 00	 cmp	 QWORD PTR q$[rbp], 0
  0010a	75 0e		 jne	 SHORT $LN7@stbi__zexp
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00113	e8 00 00 00 00	 call	 stbi__err
  00118	eb 44		 jmp	 SHORT $LN1@stbi__zexp
$LN7@stbi__zexp:

; 3768 :     z->zout_start = q;

  0011a	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00121	48 8b 4d 08	 mov	 rcx, QWORD PTR q$[rbp]
  00125	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 3769 :     z->zout = q + cur;

  00129	8b 45 24	 mov	 eax, DWORD PTR cur$[rbp]
  0012c	48 8b 4d 08	 mov	 rcx, QWORD PTR q$[rbp]
  00130	48 03 c8	 add	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0013d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3770 :     z->zout_end = q + limit;

  00141	8b 45 44	 mov	 eax, DWORD PTR limit$[rbp]
  00144	48 8b 4d 08	 mov	 rcx, QWORD PTR q$[rbp]
  00148	48 03 c8	 add	 rcx, rax
  0014b	48 8b c1	 mov	 rax, rcx
  0014e	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00155	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 3771 :     return 1;

  00159	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zexp:

; 3772 : }

  0015e	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  00165	5f		 pop	 rdi
  00166	5d		 pop	 rbp
  00167	c3		 ret	 0
stbi__zexpand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zhuffman_decode
_TEXT	SEGMENT
b$ = 4
s$ = 36
tv133 = 248
a$ = 288
z$ = 296
stbi__zhuffman_decode PROC				; COMDAT

; 3734 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3735 :     int b, s;
; 3736 :     if (a->num_bits < 16) {

  00024	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0002b	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  0002f	7d 26		 jge	 SHORT $LN2@stbi__zhuf

; 3737 :         if (stbi__zeof(a)) {

  00031	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00038	e8 00 00 00 00	 call	 stbi__zeof
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN3@stbi__zhuf

; 3738 :             return -1;   /* report error for unexpected end of data. */

  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	e9 9a 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN3@stbi__zhuf:

; 3739 :         }
; 3740 :         stbi__fill_bits(a);

  0004b	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00052	e8 00 00 00 00	 call	 stbi__fill_bits
$LN2@stbi__zhuf:

; 3741 :     }
; 3742 :     b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  00057	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  0005e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00061	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00066	8b c0		 mov	 eax, eax
  00068	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0006f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00073	89 45 04	 mov	 DWORD PTR b$[rbp], eax

; 3743 :     if (b) {

  00076	83 7d 04 00	 cmp	 DWORD PTR b$[rbp], 0
  0007a	74 56		 je	 SHORT $LN4@stbi__zhuf

; 3744 :         s = b >> 9;

  0007c	8b 45 04	 mov	 eax, DWORD PTR b$[rbp]
  0007f	c1 f8 09	 sar	 eax, 9
  00082	89 45 24	 mov	 DWORD PTR s$[rbp], eax

; 3745 :         a->code_buffer >>= s;

  00085	8b 45 24	 mov	 eax, DWORD PTR s$[rbp]
  00088	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0008f	48 89 8d f8 00
	00 00		 mov	 QWORD PTR tv133[rbp], rcx
  00096	0f b6 c8	 movzx	 ecx, al
  00099	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv133[rbp]
  000a0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000a3	d3 e8		 shr	 eax, cl
  000a5	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000ac	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 3746 :         a->num_bits -= s;

  000af	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  000b6	8b 4d 24	 mov	 ecx, DWORD PTR s$[rbp]
  000b9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000bc	2b c1		 sub	 eax, ecx
  000be	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000c5	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3747 :         return b & 511;

  000c8	8b 45 04	 mov	 eax, DWORD PTR b$[rbp]
  000cb	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000d0	eb 13		 jmp	 SHORT $LN1@stbi__zhuf
$LN4@stbi__zhuf:

; 3748 :     }
; 3749 :     return stbi__zhuffman_decode_slowpath(a, z);

  000d2	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  000d9	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000e0	e8 00 00 00 00	 call	 stbi__zhuffman_decode_slowpath
$LN1@stbi__zhuf:

; 3750 : }

  000e5	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000ec	5f		 pop	 rdi
  000ed	5d		 pop	 rbp
  000ee	c3		 ret	 0
stbi__zhuffman_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zhuffman_decode_slowpath
_TEXT	SEGMENT
b$ = 4
s$ = 36
k$ = 68
tv159 = 280
a$ = 320
z$ = 328
stbi__zhuffman_decode_slowpath PROC			; COMDAT

; 3715 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3716 :     int b, s, k;
; 3717 :     // not resolved by fast table, so compute it the slow way
; 3718 :     // use jpeg approach, which requires MSbits at top
; 3719 :     k = stbi__bit_reverse(a->code_buffer, 16);

  00024	ba 10 00 00 00	 mov	 edx, 16
  00029	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00030	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00033	e8 00 00 00 00	 call	 stbi__bit_reverse
  00038	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 3720 :     for (s = STBI__ZFAST_BITS + 1; ; ++s)

  0003b	c7 45 24 0a 00
	00 00		 mov	 DWORD PTR s$[rbp], 10
  00042	eb 08		 jmp	 SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
  00044	8b 45 24	 mov	 eax, DWORD PTR s$[rbp]
  00047	ff c0		 inc	 eax
  00049	89 45 24	 mov	 DWORD PTR s$[rbp], eax
$LN4@stbi__zhuf:

; 3721 :         if (k < z->maxcode[s])

  0004c	48 63 45 24	 movsxd	 rax, DWORD PTR s$[rbp]
  00050	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00057	8b 84 81 20 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1056]
  0005e	39 45 44	 cmp	 DWORD PTR k$[rbp], eax
  00061	7d 02		 jge	 SHORT $LN5@stbi__zhuf

; 3722 :             break;

  00063	eb 02		 jmp	 SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
  00065	eb dd		 jmp	 SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 3723 :     if (s >= 16) return -1; // invalid code!

  00067	83 7d 24 10	 cmp	 DWORD PTR s$[rbp], 16
  0006b	7c 0a		 jl	 SHORT $LN6@stbi__zhuf
  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	e9 c2 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 3724 :     // code size is s, so:
; 3725 :     b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];

  00077	b8 10 00 00 00	 mov	 eax, 16
  0007c	2b 45 24	 sub	 eax, DWORD PTR s$[rbp]
  0007f	0f b6 c8	 movzx	 ecx, al
  00082	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  00085	d3 f8		 sar	 eax, cl
  00087	48 63 4d 24	 movsxd	 rcx, DWORD PTR s$[rbp]
  0008b	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00092	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  0009a	2b c1		 sub	 eax, ecx
  0009c	48 63 4d 24	 movsxd	 rcx, DWORD PTR s$[rbp]
  000a0	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  000a7	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  000af	03 c1		 add	 eax, ecx
  000b1	89 45 04	 mov	 DWORD PTR b$[rbp], eax

; 3726 :     if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!

  000b4	81 7d 04 20 01
	00 00		 cmp	 DWORD PTR b$[rbp], 288	; 00000120H
  000bb	7c 07		 jl	 SHORT $LN7@stbi__zhuf
  000bd	b8 ff ff ff ff	 mov	 eax, -1
  000c2	eb 75		 jmp	 SHORT $LN1@stbi__zhuf
$LN7@stbi__zhuf:

; 3727 :     if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

  000c4	48 63 45 04	 movsxd	 rax, DWORD PTR b$[rbp]
  000c8	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000cf	0f b6 84 01 84
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1156]
  000d7	3b 45 24	 cmp	 eax, DWORD PTR s$[rbp]
  000da	74 07		 je	 SHORT $LN8@stbi__zhuf
  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	eb 56		 jmp	 SHORT $LN1@stbi__zhuf
$LN8@stbi__zhuf:

; 3728 :     a->code_buffer >>= s;

  000e3	8b 45 24	 mov	 eax, DWORD PTR s$[rbp]
  000e6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  000ed	48 89 8d 18 01
	00 00		 mov	 QWORD PTR tv159[rbp], rcx
  000f4	0f b6 c8	 movzx	 ecx, al
  000f7	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv159[rbp]
  000fe	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00101	d3 e8		 shr	 eax, cl
  00103	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  0010a	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 3729 :     a->num_bits -= s;

  0010d	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00114	8b 4d 24	 mov	 ecx, DWORD PTR s$[rbp]
  00117	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0011a	2b c1		 sub	 eax, ecx
  0011c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR a$[rbp]
  00123	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3730 :     return z->value[b];

  00126	48 63 45 04	 movsxd	 rax, DWORD PTR b$[rbp]
  0012a	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00131	0f b7 84 41 a4
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+1444]
$LN1@stbi__zhuf:

; 3731 : }

  00139	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00140	5f		 pop	 rdi
  00141	5d		 pop	 rbp
  00142	c3		 ret	 0
stbi__zhuffman_decode_slowpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zreceive
_TEXT	SEGMENT
k$ = 4
tv84 = 212
tv90 = 216
z$ = 256
n$ = 264
stbi__zreceive PROC					; COMDAT

; 3705 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3706 :     unsigned int k;
; 3707 :     if (z->num_bits < n) stbi__fill_bits(z);

  00023	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0002a	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00030	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00033	7d 0c		 jge	 SHORT $LN2@stbi__zrec
  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fill_bits
$LN2@stbi__zrec:

; 3708 :     k = z->code_buffer & ((1 << n) - 1);

  00041	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	89 8d d4 00 00
	00		 mov	 DWORD PTR tv84[rbp], ecx
  00052	0f b6 c8	 movzx	 ecx, al
  00055	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv84[rbp]
  0005b	d3 e0		 shl	 eax, cl
  0005d	ff c8		 dec	 eax
  0005f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00066	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00069	23 c8		 and	 ecx, eax
  0006b	8b c1		 mov	 eax, ecx
  0006d	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 3709 :     z->code_buffer >>= n;

  00070	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00076	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0007d	48 89 8d d8 00
	00 00		 mov	 QWORD PTR tv90[rbp], rcx
  00084	0f b6 c8	 movzx	 ecx, al
  00087	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv90[rbp]
  0008e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00091	d3 e8		 shr	 eax, cl
  00093	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0009a	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 3710 :     z->num_bits -= n;

  0009d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000a4	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  000aa	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ad	2b c1		 sub	 eax, ecx
  000af	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000b6	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3711 :     return k;

  000b9	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]

; 3712 : }

  000bc	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi__zreceive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__fill_bits
_TEXT	SEGMENT
tv92 = 192
z$ = 240
stbi__fill_bits PROC					; COMDAT

; 3693 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@stbi__fill:

; 3694 :     do {
; 3695 :         if (z->code_buffer >= (1U << z->num_bits)) {

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00026	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	89 8d c0 00 00
	00		 mov	 DWORD PTR tv92[rbp], ecx
  00034	0f b6 c8	 movzx	 ecx, al
  00037	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv92[rbp]
  0003d	d3 e0		 shl	 eax, cl
  0003f	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00046	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00049	72 17		 jb	 SHORT $LN5@stbi__fill

; 3696 :             z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */

  0004b	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00052	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00059	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3697 :             return;

  00060	eb 5b		 jmp	 SHORT $LN1@stbi__fill
$LN5@stbi__fill:

; 3698 :         }
; 3699 :         z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;

  00062	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__zget8
  0006e	0f b6 c0	 movzx	 eax, al
  00071	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00078	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0007b	d3 e0		 shl	 eax, cl
  0007d	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00084	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00087	0b c8		 or	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00092	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 3700 :         z->num_bits += 8;

  00095	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0009c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0009f	83 c0 08	 add	 eax, 8
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000a9	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3701 :     } while (z->num_bits <= 24);

  000ac	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000b3	83 78 10 18	 cmp	 DWORD PTR [rax+16], 24
  000b7	0f 8e 62 ff ff
	ff		 jle	 $LN4@stbi__fill
$LN1@stbi__fill:

; 3702 : }

  000bd	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000c4	5f		 pop	 rdi
  000c5	5d		 pop	 rbp
  000c6	c3		 ret	 0
stbi__fill_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zget8
_TEXT	SEGMENT
tv73 = 192
z$ = 240
stbi__zget8 PROC					; COMDAT

; 3688 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3689 :     return stbi__zeof(z) ? 0 : *z->zbuffer++;

  0001f	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__zeof
  0002b	85 c0		 test	 eax, eax
  0002d	74 0c		 je	 SHORT $LN3@stbi__zget
  0002f	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
  00039	eb 2a		 jmp	 SHORT $LN4@stbi__zget
$LN3@stbi__zget:
  0003b	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00048	89 85 c0 00 00
	00		 mov	 DWORD PTR tv73[rbp], eax
  0004e	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 ff c0	 inc	 rax
  0005b	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00062	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@stbi__zget:
  00065	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv73[rbp]

; 3690 : }

  0006c	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00073	5f		 pop	 rdi
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
stbi__zget8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zeof
_TEXT	SEGMENT
tv67 = 192
z$ = 240
stbi__zeof PROC						; COMDAT

; 3683 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3684 :     return (z->zbuffer >= z->zbuffer_end);

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00026	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0002d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00031	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00034	72 0c		 jb	 SHORT $LN3@stbi__zeof
  00036	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
  00040	eb 0a		 jmp	 SHORT $LN4@stbi__zeof
$LN3@stbi__zeof:
  00042	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN4@stbi__zeof:
  0004c	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv67[rbp]

; 3685 : }

  00052	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
stbi__zeof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__zbuild_huffman
_TEXT	SEGMENT
i$ = 4
k$ = 36
code$ = 68
next_code$ = 112
sizes$ = 208
s$5 = 308
c$6 = 340
fastv$7 = 372
j$8 = 404
tv289 = 612
__$ArrayPad$ = 616
z$ = 656
sizelist$ = 664
num$ = 672
stbi__zbuild_huffman PROC				; COMDAT

; 3616 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00022	b9 6e 00 00 00	 mov	 ecx, 110		; 0000006eH
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR [rsp+696]
  00036	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003d	48 33 c5	 xor	 rax, rbp
  00040	48 89 85 68 02
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3617 :     int i, k = 0;

  00053	c7 45 24 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0

; 3618 :     int code, next_code[16], sizes[17];
; 3619 : 
; 3620 :     // DEFLATE spec for generating codes
; 3621 :     memset(sizes, 0, sizeof(sizes));

  0005a	41 b8 44 00 00
	00		 mov	 r8d, 68			; 00000044H
  00060	33 d2		 xor	 edx, edx
  00062	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR sizes$[rbp]
  00069	e8 00 00 00 00	 call	 memset

; 3622 :     memset(z->fast, 0, sizeof(z->fast));

  0006e	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00075	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  0007b	33 d2		 xor	 edx, edx
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 memset

; 3623 :     for (i = 0; i < num; ++i)

  00085	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0008c	eb 08		 jmp	 SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
  0008e	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00091	ff c0		 inc	 eax
  00093	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__zbui:
  00096	8b 85 a0 02 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  0009c	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  0009f	7d 30		 jge	 SHORT $LN3@stbi__zbui

; 3624 :         ++sizes[sizelist[i]];

  000a1	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000a5	48 8b 8d 98 02
	00 00		 mov	 rcx, QWORD PTR sizelist$[rbp]
  000ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b0	8b 84 85 d0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rbp+rax*4]
  000b7	ff c0		 inc	 eax
  000b9	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  000bd	48 8b 95 98 02
	00 00		 mov	 rdx, QWORD PTR sizelist$[rbp]
  000c4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c8	89 84 8d d0 00
	00 00		 mov	 DWORD PTR sizes$[rbp+rcx*4], eax
  000cf	eb bd		 jmp	 SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 3625 :     sizes[0] = 0;

  000d1	b8 04 00 00 00	 mov	 eax, 4
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	c7 84 05 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sizes$[rbp+rax], 0

; 3626 :     for (i = 1; i < 16; ++i)

  000e5	c7 45 04 01 00
	00 00		 mov	 DWORD PTR i$[rbp], 1
  000ec	eb 08		 jmp	 SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
  000ee	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000f1	ff c0		 inc	 eax
  000f3	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__zbui:
  000f6	83 7d 04 10	 cmp	 DWORD PTR i$[rbp], 16
  000fa	7d 2c		 jge	 SHORT $LN6@stbi__zbui

; 3627 :         if (sizes[i] > (1 << i))

  000fc	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00100	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00103	ba 01 00 00 00	 mov	 edx, 1
  00108	d3 e2		 shl	 edx, cl
  0010a	8b ca		 mov	 ecx, edx
  0010c	39 8c 85 d0 00
	00 00		 cmp	 DWORD PTR sizes$[rbp+rax*4], ecx
  00113	7e 11		 jle	 SHORT $LN16@stbi__zbui

; 3628 :             return stbi__err("bad sizes", "Corrupt PNG");

  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EOHLEIKL@bad?5sizes@
  0011c	e8 00 00 00 00	 call	 stbi__err
  00121	e9 6b 02 00 00	 jmp	 $LN1@stbi__zbui
$LN16@stbi__zbui:
  00126	eb c6		 jmp	 SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 3629 :     code = 0;

  00128	c7 45 44 00 00
	00 00		 mov	 DWORD PTR code$[rbp], 0

; 3630 :     for (i = 1; i < 16; ++i) {

  0012f	c7 45 04 01 00
	00 00		 mov	 DWORD PTR i$[rbp], 1
  00136	eb 08		 jmp	 SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
  00138	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0013b	ff c0		 inc	 eax
  0013d	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__zbui:
  00140	83 7d 04 10	 cmp	 DWORD PTR i$[rbp], 16
  00144	0f 8d c6 00 00
	00		 jge	 $LN9@stbi__zbui

; 3631 :         next_code[i] = code;

  0014a	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0014e	8b 4d 44	 mov	 ecx, DWORD PTR code$[rbp]
  00151	89 4c 85 70	 mov	 DWORD PTR next_code$[rbp+rax*4], ecx

; 3632 :         z->firstcode[i] = (stbi__uint16)code;

  00155	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00159	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00160	0f b7 55 44	 movzx	 edx, WORD PTR code$[rbp]
  00164	66 89 94 41 00
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1024], dx

; 3633 :         z->firstsymbol[i] = (stbi__uint16)k;

  0016c	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00170	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00177	0f b7 55 24	 movzx	 edx, WORD PTR k$[rbp]
  0017b	66 89 94 41 64
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1124], dx

; 3634 :         code = (code + sizes[i]);

  00183	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00187	8b 84 85 d0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rbp+rax*4]
  0018e	8b 4d 44	 mov	 ecx, DWORD PTR code$[rbp]
  00191	03 c8		 add	 ecx, eax
  00193	8b c1		 mov	 eax, ecx
  00195	89 45 44	 mov	 DWORD PTR code$[rbp], eax

; 3635 :         if (sizes[i])

  00198	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0019c	83 bc 85 d0 00
	00 00 00	 cmp	 DWORD PTR sizes$[rbp+rax*4], 0
  001a4	74 26		 je	 SHORT $LN17@stbi__zbui

; 3636 :             if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");

  001a6	8b 45 44	 mov	 eax, DWORD PTR code$[rbp]
  001a9	ff c8		 dec	 eax
  001ab	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  001ae	ba 01 00 00 00	 mov	 edx, 1
  001b3	d3 e2		 shl	 edx, cl
  001b5	8b ca		 mov	 ecx, edx
  001b7	3b c1		 cmp	 eax, ecx
  001b9	7c 11		 jl	 SHORT $LN18@stbi__zbui
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  001c2	e8 00 00 00 00	 call	 stbi__err
  001c7	e9 c5 01 00 00	 jmp	 $LN1@stbi__zbui
$LN18@stbi__zbui:
$LN17@stbi__zbui:

; 3637 :         z->maxcode[i] = code << (16 - i); // preshift for inner loop

  001cc	b8 10 00 00 00	 mov	 eax, 16
  001d1	2b 45 04	 sub	 eax, DWORD PTR i$[rbp]
  001d4	0f b6 c8	 movzx	 ecx, al
  001d7	8b 45 44	 mov	 eax, DWORD PTR code$[rbp]
  001da	d3 e0		 shl	 eax, cl
  001dc	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  001e0	48 8b 95 90 02
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  001e7	89 84 8a 20 04
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1056], eax

; 3638 :         code <<= 1;

  001ee	8b 45 44	 mov	 eax, DWORD PTR code$[rbp]
  001f1	d1 e0		 shl	 eax, 1
  001f3	89 45 44	 mov	 DWORD PTR code$[rbp], eax

; 3639 :         k += sizes[i];

  001f6	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  001fa	8b 84 85 d0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rbp+rax*4]
  00201	8b 4d 24	 mov	 ecx, DWORD PTR k$[rbp]
  00204	03 c8		 add	 ecx, eax
  00206	8b c1		 mov	 eax, ecx
  00208	89 45 24	 mov	 DWORD PTR k$[rbp], eax

; 3640 :     }

  0020b	e9 28 ff ff ff	 jmp	 $LN8@stbi__zbui
$LN9@stbi__zbui:

; 3641 :     z->maxcode[16] = 0x10000; // sentinel

  00210	b8 04 00 00 00	 mov	 eax, 4
  00215	48 6b c0 10	 imul	 rax, rax, 16
  00219	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00220	c7 84 01 20 04
	00 00 00 00 01
	00		 mov	 DWORD PTR [rcx+rax+1056], 65536 ; 00010000H

; 3642 :     for (i = 0; i < num; ++i) {

  0022b	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00232	eb 08		 jmp	 SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
  00234	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00237	ff c0		 inc	 eax
  00239	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN13@stbi__zbui:
  0023c	8b 85 a0 02 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  00242	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00245	0f 8d 41 01 00
	00		 jge	 $LN12@stbi__zbui

; 3643 :         int s = sizelist[i];

  0024b	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0024f	48 8b 8d 98 02
	00 00		 mov	 rcx, QWORD PTR sizelist$[rbp]
  00256	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025a	89 85 34 01 00
	00		 mov	 DWORD PTR s$5[rbp], eax

; 3644 :         if (s) {

  00260	83 bd 34 01 00
	00 00		 cmp	 DWORD PTR s$5[rbp], 0
  00267	0f 84 1a 01 00
	00		 je	 $LN19@stbi__zbui

; 3645 :             int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

  0026d	48 63 85 34 01
	00 00		 movsxd	 rax, DWORD PTR s$5[rbp]
  00274	48 63 8d 34 01
	00 00		 movsxd	 rcx, DWORD PTR s$5[rbp]
  0027b	48 8b 95 90 02
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00282	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  0028a	8b 44 85 70	 mov	 eax, DWORD PTR next_code$[rbp+rax*4]
  0028e	2b c1		 sub	 eax, ecx
  00290	48 63 8d 34 01
	00 00		 movsxd	 rcx, DWORD PTR s$5[rbp]
  00297	48 8b 95 90 02
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0029e	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  002a6	03 c1		 add	 eax, ecx
  002a8	89 85 54 01 00
	00		 mov	 DWORD PTR c$6[rbp], eax

; 3646 :             stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);

  002ae	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR s$5[rbp]
  002b4	c1 e0 09	 shl	 eax, 9
  002b7	0b 45 04	 or	 eax, DWORD PTR i$[rbp]
  002ba	66 89 85 74 01
	00 00		 mov	 WORD PTR fastv$7[rbp], ax

; 3647 :             z->size[c] = (stbi_uc)s;

  002c1	48 63 85 54 01
	00 00		 movsxd	 rax, DWORD PTR c$6[rbp]
  002c8	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002cf	0f b6 95 34 01
	00 00		 movzx	 edx, BYTE PTR s$5[rbp]
  002d6	88 94 01 84 04
	00 00		 mov	 BYTE PTR [rcx+rax+1156], dl

; 3648 :             z->value[c] = (stbi__uint16)i;

  002dd	48 63 85 54 01
	00 00		 movsxd	 rax, DWORD PTR c$6[rbp]
  002e4	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002eb	0f b7 55 04	 movzx	 edx, WORD PTR i$[rbp]
  002ef	66 89 94 41 a4
	05 00 00	 mov	 WORD PTR [rcx+rax*2+1444], dx

; 3649 :             if (s <= STBI__ZFAST_BITS) {

  002f7	83 bd 34 01 00
	00 09		 cmp	 DWORD PTR s$5[rbp], 9
  002fe	7f 6f		 jg	 SHORT $LN20@stbi__zbui

; 3650 :                 int j = stbi__bit_reverse(next_code[s], s);

  00300	48 63 85 34 01
	00 00		 movsxd	 rax, DWORD PTR s$5[rbp]
  00307	8b 95 34 01 00
	00		 mov	 edx, DWORD PTR s$5[rbp]
  0030d	8b 4c 85 70	 mov	 ecx, DWORD PTR next_code$[rbp+rax*4]
  00311	e8 00 00 00 00	 call	 stbi__bit_reverse
  00316	89 85 94 01 00
	00		 mov	 DWORD PTR j$8[rbp], eax
$LN14@stbi__zbui:

; 3651 :                 while (j < (1 << STBI__ZFAST_BITS)) {

  0031c	81 bd 94 01 00
	00 00 02 00 00	 cmp	 DWORD PTR j$8[rbp], 512	; 00000200H
  00326	7d 47		 jge	 SHORT $LN15@stbi__zbui

; 3652 :                     z->fast[j] = fastv;

  00328	48 63 85 94 01
	00 00		 movsxd	 rax, DWORD PTR j$8[rbp]
  0032f	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00336	0f b7 95 74 01
	00 00		 movzx	 edx, WORD PTR fastv$7[rbp]
  0033d	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 3653 :                     j += (1 << s);

  00341	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR s$5[rbp]
  00347	b9 01 00 00 00	 mov	 ecx, 1
  0034c	89 8d 64 02 00
	00		 mov	 DWORD PTR tv289[rbp], ecx
  00352	0f b6 c8	 movzx	 ecx, al
  00355	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR tv289[rbp]
  0035b	d3 e0		 shl	 eax, cl
  0035d	8b 8d 94 01 00
	00		 mov	 ecx, DWORD PTR j$8[rbp]
  00363	03 c8		 add	 ecx, eax
  00365	8b c1		 mov	 eax, ecx
  00367	89 85 94 01 00
	00		 mov	 DWORD PTR j$8[rbp], eax

; 3654 :                 }

  0036d	eb ad		 jmp	 SHORT $LN14@stbi__zbui
$LN15@stbi__zbui:
$LN20@stbi__zbui:

; 3655 :             }
; 3656 :             ++next_code[s];

  0036f	48 63 85 34 01
	00 00		 movsxd	 rax, DWORD PTR s$5[rbp]
  00376	8b 44 85 70	 mov	 eax, DWORD PTR next_code$[rbp+rax*4]
  0037a	ff c0		 inc	 eax
  0037c	48 63 8d 34 01
	00 00		 movsxd	 rcx, DWORD PTR s$5[rbp]
  00383	89 44 8d 70	 mov	 DWORD PTR next_code$[rbp+rcx*4], eax
$LN19@stbi__zbui:

; 3657 :         }
; 3658 :     }

  00387	e9 a8 fe ff ff	 jmp	 $LN11@stbi__zbui
$LN12@stbi__zbui:

; 3659 :     return 1;

  0038c	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zbui:

; 3660 : }

  00391	48 8b f8	 mov	 rdi, rax
  00394	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zbuild_huffman$rtcFrameData
  0039f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003a4	48 8b c7	 mov	 rax, rdi
  003a7	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  003ae	48 33 cd	 xor	 rcx, rbp
  003b1	e8 00 00 00 00	 call	 __security_check_cookie
  003b6	48 8d a5 78 02
	00 00		 lea	 rsp, QWORD PTR [rbp+632]
  003bd	5f		 pop	 rdi
  003be	5d		 pop	 rbp
  003bf	c3		 ret	 0
stbi__zbuild_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bit_reverse
_TEXT	SEGMENT
v$ = 224
bits$ = 232
stbi__bit_reverse PROC					; COMDAT

; 3608 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3609 :     STBI_ASSERT(bits <= 16);

  00022	83 bd e8 00 00
	00 10		 cmp	 DWORD PTR bits$[rbp], 16
  00029	7e 1c		 jle	 SHORT $LN3@stbi__bit_
  0002b	41 b8 19 0e 00
	00		 mov	 r8d, 3609		; 00000e19H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN3@stbi__bit_:

; 3610 :     // to bit reverse n bits, reverse 16 and shift
; 3611 :     // e.g. 11 bits, bit reverse and shift away 5
; 3612 :     return stbi__bitreverse16(v) >> (16 - bits);

  00047	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR v$[rbp]
  0004d	e8 00 00 00 00	 call	 stbi__bitreverse16
  00052	b9 10 00 00 00	 mov	 ecx, 16
  00057	2b 8d e8 00 00
	00		 sub	 ecx, DWORD PTR bits$[rbp]
  0005d	d3 f8		 sar	 eax, cl

; 3613 : }

  0005f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00066	5f		 pop	 rdi
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
stbi__bit_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bitreverse16
_TEXT	SEGMENT
n$ = 224
stbi__bitreverse16 PROC					; COMDAT

; 3599 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3600 :     n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00024	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  00029	d1 f8		 sar	 eax, 1
  0002b	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00031	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  00037	d1 e1		 shl	 ecx, 1
  00039	0b c1		 or	 eax, ecx
  0003b	89 85 e0 00 00
	00		 mov	 DWORD PTR n$[rbp], eax

; 3601 :     n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);

  00041	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00047	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0004c	c1 f8 02	 sar	 eax, 2
  0004f	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00055	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  0005b	c1 e1 02	 shl	 ecx, 2
  0005e	0b c1		 or	 eax, ecx
  00060	89 85 e0 00 00
	00		 mov	 DWORD PTR n$[rbp], eax

; 3602 :     n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);

  00066	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0006c	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  00071	c1 f8 04	 sar	 eax, 4
  00074	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  0007a	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  00080	c1 e1 04	 shl	 ecx, 4
  00083	0b c1		 or	 eax, ecx
  00085	89 85 e0 00 00
	00		 mov	 DWORD PTR n$[rbp], eax

; 3603 :     n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);

  0008b	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00091	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00096	c1 f8 08	 sar	 eax, 8
  00099	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  0009f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a5	c1 e1 08	 shl	 ecx, 8
  000a8	0b c1		 or	 eax, ecx
  000aa	89 85 e0 00 00
	00		 mov	 DWORD PTR n$[rbp], eax

; 3604 :     return n;

  000b0	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR n$[rbp]

; 3605 : }

  000b6	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000bd	5f		 pop	 rdi
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
stbi__bitreverse16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_info_raw
_TEXT	SEGMENT
tv80 = 192
j$ = 240
x$ = 248
y$ = 256
comp$ = 264
stbi__jpeg_info_raw PROC				; COMDAT

; 3548 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3549 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

  0002e	ba 02 00 00 00	 mov	 edx, 2
  00033	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0003a	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  0003f	85 c0		 test	 eax, eax
  00041	75 16		 jne	 SHORT $LN2@stbi__jpeg

; 3550 :         stbi__rewind(j->s);

  00043	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0004a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004d	e8 00 00 00 00	 call	 stbi__rewind

; 3551 :         return 0;

  00052	33 c0		 xor	 eax, eax
  00054	e9 83 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3552 :     }
; 3553 :     if (x) *x = j->s->img_x;

  00059	48 83 bd f8 00
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00061	74 15		 je	 SHORT $LN3@stbi__jpeg
  00063	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00074	8b 00		 mov	 eax, DWORD PTR [rax]
  00076	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__jpeg:

; 3554 :     if (y) *y = j->s->img_y;

  00078	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00080	74 16		 je	 SHORT $LN4@stbi__jpeg
  00082	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  00093	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00096	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__jpeg:

; 3555 :     if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;

  00098	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  000a0	74 35		 je	 SHORT $LN5@stbi__jpeg
  000a2	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  000b0	7c 0c		 jl	 SHORT $LN7@stbi__jpeg
  000b2	c7 85 c0 00 00
	00 03 00 00 00	 mov	 DWORD PTR tv80[rbp], 3
  000bc	eb 0a		 jmp	 SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
  000be	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv80[rbp], 1
$LN8@stbi__jpeg:
  000c8	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  000cf	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv80[rbp]
  000d5	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__jpeg:

; 3556 :     return 1;

  000d7	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 3557 : }

  000dc	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000e3	5f		 pop	 rdi
  000e4	5d		 pop	 rbp
  000e5	c3		 ret	 0
stbi__jpeg_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT load_jpeg_image
_TEXT	SEGMENT
n$ = 4
decode_n$ = 36
is_rgb$ = 68
k$5 = 100
i$6 = 132
j$7 = 164
output$8 = 200
coutput$9 = 232
res_comp$10 = 304
r$11 = 520
out$12 = 552
r$13 = 584
y_bot$14 = 612
y$15 = 648
m$16 = 676
m$17 = 708
m$18 = 740
r$19 = 772
g$20 = 804
b$21 = 836
y$22 = 872
tv694 = 1268
tv656 = 1268
tv626 = 1268
tv545 = 1268
tv516 = 1268
tv288 = 1268
tv280 = 1268
tv252 = 1268
tv91 = 1268
tv81 = 1268
tv265 = 1272
tv232 = 1272
tv172 = 1272
tv164 = 1272
tv159 = 1272
tv79 = 1272
tv71 = 1272
tv270 = 1280
__$ArrayPad$ = 1288
z$ = 1328
out_x$ = 1336
out_y$ = 1344
comp$ = 1352
req_comp$ = 1360
load_jpeg_image PROC					; COMDAT

; 3348 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 05
	00 00		 sub	 rsp, 1352		; 00000548H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 e6 00 00 00	 mov	 ecx, 230		; 000000e6H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 68
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1384]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 08 05
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3349 :     int n, decode_n, is_rgb;
; 3350 :     z->s->img_n = 0; // make stbi__cleanup_jpeg safe

  00058	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3351 : 
; 3352 :     // validate req_comp
; 3353 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  00069	83 bd 50 05 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00070	7c 09		 jl	 SHORT $LN42@load_jpeg_
  00072	83 bd 50 05 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  00079	7e 34		 jle	 SHORT $LN41@load_jpeg_
$LN42@load_jpeg_:
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KBPNPPBJ@bad?5req_comp@
  00082	e8 00 00 00 00	 call	 stbi__err
  00087	85 c0		 test	 eax, eax
  00089	74 0d		 je	 SHORT $LN83@load_jpeg_
  0008b	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
  00096	eb 0b		 jmp	 SHORT $LN84@load_jpeg_
$LN83@load_jpeg_:
  00098	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
$LN84@load_jpeg_:
  000a3	48 8b 85 f8 04
	00 00		 mov	 rax, QWORD PTR tv71[rbp]
  000aa	e9 f2 11 00 00	 jmp	 $LN1@load_jpeg_
$LN41@load_jpeg_:

; 3354 : 
; 3355 :     // load a jpeg image from whichever source, but leave in YCbCr format
; 3356 :     if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

  000af	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000b6	e8 00 00 00 00	 call	 stbi__decode_jpeg_image
  000bb	85 c0		 test	 eax, eax
  000bd	75 13		 jne	 SHORT $LN43@load_jpeg_
  000bf	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000c6	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  000cb	33 c0		 xor	 eax, eax
  000cd	e9 cf 11 00 00	 jmp	 $LN1@load_jpeg_
$LN43@load_jpeg_:

; 3357 : 
; 3358 :     // determine actual number of components to generate
; 3359 :     n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

  000d2	83 bd 50 05 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  000d9	74 0e		 je	 SHORT $LN87@load_jpeg_
  000db	8b 85 50 05 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000e1	89 85 f4 04 00
	00		 mov	 DWORD PTR tv81[rbp], eax
  000e7	eb 32		 jmp	 SHORT $LN88@load_jpeg_
$LN87@load_jpeg_:
  000e9	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f3	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  000f7	7c 0c		 jl	 SHORT $LN85@load_jpeg_
  000f9	c7 85 f8 04 00
	00 03 00 00 00	 mov	 DWORD PTR tv79[rbp], 3
  00103	eb 0a		 jmp	 SHORT $LN86@load_jpeg_
$LN85@load_jpeg_:
  00105	c7 85 f8 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv79[rbp], 1
$LN86@load_jpeg_:
  0010f	8b 85 f8 04 00
	00		 mov	 eax, DWORD PTR tv79[rbp]
  00115	89 85 f4 04 00
	00		 mov	 DWORD PTR tv81[rbp], eax
$LN88@load_jpeg_:
  0011b	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv81[rbp]
  00121	89 45 04	 mov	 DWORD PTR n$[rbp], eax

; 3360 : 
; 3361 :     is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

  00124	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0012b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012e	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00132	75 3c		 jne	 SHORT $LN91@load_jpeg_
  00134	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0013b	83 b8 50 48 00
	00 03		 cmp	 DWORD PTR [rax+18512], 3
  00142	74 20		 je	 SHORT $LN90@load_jpeg_
  00144	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0014b	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00152	75 1c		 jne	 SHORT $LN89@load_jpeg_
  00154	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0015b	83 b8 48 48 00
	00 00		 cmp	 DWORD PTR [rax+18504], 0
  00162	75 0c		 jne	 SHORT $LN91@load_jpeg_
$LN90@load_jpeg_:
  00164	c7 85 f4 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv91[rbp], 1
  0016e	eb 0a		 jmp	 SHORT $LN92@load_jpeg_
$LN91@load_jpeg_:
$LN89@load_jpeg_:
  00170	c7 85 f4 04 00
	00 00 00 00 00	 mov	 DWORD PTR tv91[rbp], 0
$LN92@load_jpeg_:
  0017a	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv91[rbp]
  00180	89 45 44	 mov	 DWORD PTR is_rgb$[rbp], eax

; 3362 : 
; 3363 :     if (z->s->img_n == 3 && n < 3 && !is_rgb)

  00183	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0018a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018d	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00191	75 15		 jne	 SHORT $LN44@load_jpeg_
  00193	83 7d 04 03	 cmp	 DWORD PTR n$[rbp], 3
  00197	7d 0f		 jge	 SHORT $LN44@load_jpeg_
  00199	83 7d 44 00	 cmp	 DWORD PTR is_rgb$[rbp], 0
  0019d	75 09		 jne	 SHORT $LN44@load_jpeg_

; 3364 :         decode_n = 1;

  0019f	c7 45 24 01 00
	00 00		 mov	 DWORD PTR decode_n$[rbp], 1
  001a6	eb 10		 jmp	 SHORT $LN45@load_jpeg_
$LN44@load_jpeg_:

; 3365 :     else
; 3366 :         decode_n = z->s->img_n;

  001a8	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001b5	89 45 24	 mov	 DWORD PTR decode_n$[rbp], eax
$LN45@load_jpeg_:

; 3367 : 
; 3368 :     // nothing to do if no components requested; check this now to avoid
; 3369 :     // accessing uninitialized coutput[0] later
; 3370 :     if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

  001b8	83 7d 24 00	 cmp	 DWORD PTR decode_n$[rbp], 0
  001bc	7f 13		 jg	 SHORT $LN46@load_jpeg_
  001be	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  001c5	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  001ca	33 c0		 xor	 eax, eax
  001cc	e9 d0 10 00 00	 jmp	 $LN1@load_jpeg_
$LN46@load_jpeg_:

; 3371 : 
; 3372 :     // resample and color-convert
; 3373 :     {
; 3374 :         int k;
; 3375 :         unsigned int i, j;
; 3376 :         stbi_uc* output;
; 3377 :         stbi_uc* coutput[4] = { NULL, NULL, NULL, NULL };

  001d1	48 c7 85 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR coutput$9[rbp], 0
  001dc	48 c7 85 f0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR coutput$9[rbp+8], 0
  001e7	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR coutput$9[rbp+16], 0
  001f2	48 c7 85 00 01
	00 00 00 00 00
	00		 mov	 QWORD PTR coutput$9[rbp+24], 0

; 3378 : 
; 3379 :         stbi__resample res_comp[4];
; 3380 : 
; 3381 :         for (k = 0; k < decode_n; ++k) {

  001fd	c7 45 64 00 00
	00 00		 mov	 DWORD PTR k$5[rbp], 0
  00204	eb 08		 jmp	 SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
  00206	8b 45 64	 mov	 eax, DWORD PTR k$5[rbp]
  00209	ff c0		 inc	 eax
  0020b	89 45 64	 mov	 DWORD PTR k$5[rbp], eax
$LN4@load_jpeg_:
  0020e	8b 45 24	 mov	 eax, DWORD PTR decode_n$[rbp]
  00211	39 45 64	 cmp	 DWORD PTR k$5[rbp], eax
  00214	0f 8d 7a 02 00
	00		 jge	 $LN3@load_jpeg_

; 3382 :             stbi__resample* r = &res_comp[k];

  0021a	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  0021e	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00222	48 8d 84 05 30
	01 00 00	 lea	 rax, QWORD PTR res_comp$10[rbp+rax]
  0022a	48 89 85 08 02
	00 00		 mov	 QWORD PTR r$11[rbp], rax

; 3383 : 
; 3384 :             // allocate line buffer big enough for upsampling off the edges
; 3385 :             // with upsample factor of 4
; 3386 :             z->img_comp[k].linebuf = (stbi_uc*)stbi__malloc(z->s->img_x + 3);

  00231	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00238	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023b	8b 00		 mov	 eax, DWORD PTR [rax]
  0023d	83 c0 03	 add	 eax, 3
  00240	8b c0		 mov	 eax, eax
  00242	8b c8		 mov	 ecx, eax
  00244	e8 00 00 00 00	 call	 stbi__malloc
  00249	48 63 4d 64	 movsxd	 rcx, DWORD PTR k$5[rbp]
  0024d	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00251	48 8b 95 30 05
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00258	48 89 84 0a e8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18152], rax

; 3387 :             if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  00260	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  00264	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00268	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0026f	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  00278	75 40		 jne	 SHORT $LN47@load_jpeg_
  0027a	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00281	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0028d	e8 00 00 00 00	 call	 stbi__err
  00292	85 c0		 test	 eax, eax
  00294	74 0d		 je	 SHORT $LN93@load_jpeg_
  00296	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv159[rbp], 0
  002a1	eb 0b		 jmp	 SHORT $LN94@load_jpeg_
$LN93@load_jpeg_:
  002a3	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv159[rbp], 0
$LN94@load_jpeg_:
  002ae	48 8b 85 f8 04
	00 00		 mov	 rax, QWORD PTR tv159[rbp]
  002b5	e9 e7 0f 00 00	 jmp	 $LN1@load_jpeg_
$LN47@load_jpeg_:

; 3388 : 
; 3389 :             r->hs = z->img_h_max / z->img_comp[k].h;

  002ba	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  002be	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002c2	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv164[rbp], rax
  002c9	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002d0	8b 81 88 46 00
	00		 mov	 eax, DWORD PTR [rcx+18056]
  002d6	99		 cdq
  002d7	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002de	4c 8b 85 f8 04
	00 00		 mov	 r8, QWORD PTR tv164[rbp]
  002e5	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  002ed	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  002f4	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 3390 :             r->vs = z->img_v_max / z->img_comp[k].v;

  002f7	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  002fb	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002ff	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv172[rbp], rax
  00306	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0030d	8b 81 8c 46 00
	00		 mov	 eax, DWORD PTR [rcx+18060]
  00313	99		 cdq
  00314	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0031b	4c 8b 85 f8 04
	00 00		 mov	 r8, QWORD PTR tv172[rbp]
  00322	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  0032a	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  00331	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 3391 :             r->ystep = r->vs >> 1;

  00334	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  0033b	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0033e	d1 f8		 sar	 eax, 1
  00340	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  00347	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 3392 :             r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;

  0034a	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00351	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00354	8b 00		 mov	 eax, DWORD PTR [rax]
  00356	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  0035d	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00360	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00364	33 d2		 xor	 edx, edx
  00366	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  0036d	f7 71 18	 div	 DWORD PTR [rcx+24]
  00370	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  00377	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3393 :             r->ypos = 0;

  0037a	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00381	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 3394 :             r->line0 = r->line1 = z->img_comp[k].data;

  00388	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  0038c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00390	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  00397	48 8b 95 30 05
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0039e	48 8b 84 02 d0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18128]
  003a6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  003aa	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  003b1	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR r$11[rbp]
  003b8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003bc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3395 : 
; 3396 :             if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

  003c0	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  003c7	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003cb	75 23		 jne	 SHORT $LN48@load_jpeg_
  003cd	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  003d4	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  003d8	75 16		 jne	 SHORT $LN48@load_jpeg_
  003da	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:resample_row_1
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx
  003eb	e9 9f 00 00 00	 jmp	 $LN49@load_jpeg_
$LN48@load_jpeg_:

; 3397 :             else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

  003f0	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  003f7	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003fb	75 20		 jne	 SHORT $LN50@load_jpeg_
  003fd	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00404	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  00408	75 13		 jne	 SHORT $LN50@load_jpeg_
  0040a	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_v_2
  00418	48 89 08	 mov	 QWORD PTR [rax], rcx
  0041b	eb 72		 jmp	 SHORT $LN51@load_jpeg_
$LN50@load_jpeg_:

; 3398 :             else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

  0041d	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00424	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00428	75 20		 jne	 SHORT $LN52@load_jpeg_
  0042a	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00431	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  00435	75 13		 jne	 SHORT $LN52@load_jpeg_
  00437	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  0043e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_h_2
  00445	48 89 08	 mov	 QWORD PTR [rax], rcx
  00448	eb 45		 jmp	 SHORT $LN53@load_jpeg_
$LN52@load_jpeg_:

; 3399 :             else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

  0044a	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00451	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00455	75 27		 jne	 SHORT $LN54@load_jpeg_
  00457	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  0045e	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  00462	75 1a		 jne	 SHORT $LN54@load_jpeg_
  00464	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  0046b	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00472	48 8b 89 80 48
	00 00		 mov	 rcx, QWORD PTR [rcx+18560]
  00479	48 89 08	 mov	 QWORD PTR [rax], rcx
  0047c	eb 11		 jmp	 SHORT $LN55@load_jpeg_
$LN54@load_jpeg_:

; 3400 :             else                               r->resample = stbi__resample_row_generic;

  0047e	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR r$11[rbp]
  00485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_generic
  0048c	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN55@load_jpeg_:
$LN53@load_jpeg_:
$LN51@load_jpeg_:
$LN49@load_jpeg_:

; 3401 :         }

  0048f	e9 72 fd ff ff	 jmp	 $LN2@load_jpeg_
$LN3@load_jpeg_:

; 3402 : 
; 3403 :         // can't error after this so, this is safe
; 3404 :         output = (stbi_uc*)stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

  00494	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0049b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049e	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004a5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  004ae	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  004b2	8b 11		 mov	 edx, DWORD PTR [rcx]
  004b4	8b 4d 04	 mov	 ecx, DWORD PTR n$[rbp]
  004b7	e8 00 00 00 00	 call	 stbi__malloc_mad3
  004bc	48 89 85 c8 00
	00 00		 mov	 QWORD PTR output$8[rbp], rax

; 3405 :         if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  004c3	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR output$8[rbp], 0
  004cb	75 40		 jne	 SHORT $LN56@load_jpeg_
  004cd	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004d4	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  004e0	e8 00 00 00 00	 call	 stbi__err
  004e5	85 c0		 test	 eax, eax
  004e7	74 0d		 je	 SHORT $LN95@load_jpeg_
  004e9	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv232[rbp], 0
  004f4	eb 0b		 jmp	 SHORT $LN96@load_jpeg_
$LN95@load_jpeg_:
  004f6	48 c7 85 f8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv232[rbp], 0
$LN96@load_jpeg_:
  00501	48 8b 85 f8 04
	00 00		 mov	 rax, QWORD PTR tv232[rbp]
  00508	e9 94 0d 00 00	 jmp	 $LN1@load_jpeg_
$LN56@load_jpeg_:

; 3406 : 
; 3407 :         // now go ahead and resample
; 3408 :         for (j = 0; j < z->s->img_y; ++j) {

  0050d	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR j$7[rbp], 0
  00517	eb 0e		 jmp	 SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
  00519	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR j$7[rbp]
  0051f	ff c0		 inc	 eax
  00521	89 85 a4 00 00
	00		 mov	 DWORD PTR j$7[rbp], eax
$LN7@load_jpeg_:
  00527	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0052e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00531	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00534	39 85 a4 00 00
	00		 cmp	 DWORD PTR j$7[rbp], eax
  0053a	0f 83 e4 0c 00
	00		 jae	 $LN6@load_jpeg_

; 3409 :             stbi_uc* out = output + n * z->s->img_x * j;

  00540	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00547	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0054a	8b 4d 04	 mov	 ecx, DWORD PTR n$[rbp]
  0054d	0f af 08	 imul	 ecx, DWORD PTR [rax]
  00550	8b c1		 mov	 eax, ecx
  00552	0f af 85 a4 00
	00 00		 imul	 eax, DWORD PTR j$7[rbp]
  00559	8b c0		 mov	 eax, eax
  0055b	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR output$8[rbp]
  00562	48 03 c8	 add	 rcx, rax
  00565	48 8b c1	 mov	 rax, rcx
  00568	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3410 :             for (k = 0; k < decode_n; ++k) {

  0056f	c7 45 64 00 00
	00 00		 mov	 DWORD PTR k$5[rbp], 0
  00576	eb 08		 jmp	 SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
  00578	8b 45 64	 mov	 eax, DWORD PTR k$5[rbp]
  0057b	ff c0		 inc	 eax
  0057d	89 45 64	 mov	 DWORD PTR k$5[rbp], eax
$LN10@load_jpeg_:
  00580	8b 45 24	 mov	 eax, DWORD PTR decode_n$[rbp]
  00583	39 45 64	 cmp	 DWORD PTR k$5[rbp], eax
  00586	0f 8d d0 01 00
	00		 jge	 $LN9@load_jpeg_

; 3411 :                 stbi__resample* r = &res_comp[k];

  0058c	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  00590	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00594	48 8d 84 05 30
	01 00 00	 lea	 rax, QWORD PTR res_comp$10[rbp+rax]
  0059c	48 89 85 48 02
	00 00		 mov	 QWORD PTR r$13[rbp], rax

; 3412 :                 int y_bot = r->ystep >= (r->vs >> 1);

  005a3	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  005aa	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  005ad	d1 f8		 sar	 eax, 1
  005af	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  005b6	39 41 24	 cmp	 DWORD PTR [rcx+36], eax
  005b9	7c 0c		 jl	 SHORT $LN97@load_jpeg_
  005bb	c7 85 f4 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv252[rbp], 1
  005c5	eb 0a		 jmp	 SHORT $LN98@load_jpeg_
$LN97@load_jpeg_:
  005c7	c7 85 f4 04 00
	00 00 00 00 00	 mov	 DWORD PTR tv252[rbp], 0
$LN98@load_jpeg_:
  005d1	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv252[rbp]
  005d7	89 85 64 02 00
	00		 mov	 DWORD PTR y_bot$14[rbp], eax

; 3413 :                 coutput[k] = r->resample(z->img_comp[k].linebuf,

  005dd	83 bd 64 02 00
	00 00		 cmp	 DWORD PTR y_bot$14[rbp], 0
  005e4	74 14		 je	 SHORT $LN99@load_jpeg_
  005e6	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  005ed	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005f1	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv265[rbp], rax
  005f8	eb 12		 jmp	 SHORT $LN100@load_jpeg_
$LN99@load_jpeg_:
  005fa	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  00601	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00605	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv265[rbp], rax
$LN100@load_jpeg_:
  0060c	83 bd 64 02 00
	00 00		 cmp	 DWORD PTR y_bot$14[rbp], 0
  00613	74 14		 je	 SHORT $LN101@load_jpeg_
  00615	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  0061c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00620	48 89 85 00 05
	00 00		 mov	 QWORD PTR tv270[rbp], rax
  00627	eb 12		 jmp	 SHORT $LN102@load_jpeg_
$LN101@load_jpeg_:
  00629	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  00630	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00634	48 89 85 00 05
	00 00		 mov	 QWORD PTR tv270[rbp], rax
$LN102@load_jpeg_:
  0063b	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  0063f	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00643	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  0064a	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0064d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00651	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  00658	44 8b 49 20	 mov	 r9d, DWORD PTR [rcx+32]
  0065c	4c 8b 85 f8 04
	00 00		 mov	 r8, QWORD PTR tv265[rbp]
  00663	48 8b 95 00 05
	00 00		 mov	 rdx, QWORD PTR tv270[rbp]
  0066a	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00671	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00679	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  00680	ff 10		 call	 QWORD PTR [rax]
  00682	48 63 4d 64	 movsxd	 rcx, DWORD PTR k$5[rbp]
  00686	48 89 84 cd e8
	00 00 00	 mov	 QWORD PTR coutput$9[rbp+rcx*8], rax

; 3414 :                     y_bot ? r->line1 : r->line0,
; 3415 :                     y_bot ? r->line0 : r->line1,
; 3416 :                     r->w_lores, r->hs);
; 3417 :                 if (++r->ystep >= r->vs) {

  0068e	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  00695	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00698	ff c0		 inc	 eax
  0069a	89 85 f4 04 00
	00		 mov	 DWORD PTR tv280[rbp], eax
  006a0	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  006a7	8b 8d f4 04 00
	00		 mov	 ecx, DWORD PTR tv280[rbp]
  006ad	89 48 24	 mov	 DWORD PTR [rax+36], ecx
  006b0	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  006b7	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  006ba	39 85 f4 04 00
	00		 cmp	 DWORD PTR tv280[rbp], eax
  006c0	0f 8c 91 00 00
	00		 jl	 $LN57@load_jpeg_

; 3418 :                     r->ystep = 0;

  006c6	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  006cd	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 3419 :                     r->line0 = r->line1;

  006d4	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  006db	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  006e2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  006e6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3420 :                     if (++r->ypos < z->img_comp[k].y)

  006ea	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  006f1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  006f4	ff c0		 inc	 eax
  006f6	89 85 f4 04 00
	00		 mov	 DWORD PTR tv288[rbp], eax
  006fc	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR r$13[rbp]
  00703	8b 8d f4 04 00
	00		 mov	 ecx, DWORD PTR tv288[rbp]
  00709	89 48 28	 mov	 DWORD PTR [rax+40], ecx
  0070c	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  00710	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00714	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0071b	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00722	39 85 f4 04 00
	00		 cmp	 DWORD PTR tv288[rbp], eax
  00728	7d 2d		 jge	 SHORT $LN58@load_jpeg_

; 3421 :                         r->line1 += z->img_comp[k].w2;

  0072a	48 63 45 64	 movsxd	 rax, DWORD PTR k$5[rbp]
  0072e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00732	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00739	48 63 84 01 c4
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18116]
  00741	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  00748	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0074c	48 8b 8d 48 02
	00 00		 mov	 rcx, QWORD PTR r$13[rbp]
  00753	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN58@load_jpeg_:
$LN57@load_jpeg_:

; 3422 :                 }
; 3423 :             }

  00757	e9 1c fe ff ff	 jmp	 $LN8@load_jpeg_
$LN9@load_jpeg_:

; 3424 :             if (n >= 3) {

  0075c	83 7d 04 03	 cmp	 DWORD PTR n$[rbp], 3
  00760	0f 8c a9 05 00
	00		 jl	 $LN59@load_jpeg_

; 3425 :                 stbi_uc* y = coutput[0];

  00766	b8 08 00 00 00	 mov	 eax, 8
  0076b	48 6b c0 00	 imul	 rax, rax, 0
  0076f	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00777	48 89 85 88 02
	00 00		 mov	 QWORD PTR y$15[rbp], rax

; 3426 :                 if (z->s->img_n == 3) {

  0077e	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00785	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00788	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  0078c	0f 85 4d 01 00
	00		 jne	 $LN61@load_jpeg_

; 3427 :                     if (is_rgb) {

  00792	83 7d 44 00	 cmp	 DWORD PTR is_rgb$[rbp], 0
  00796	0f 84 e8 00 00
	00		 je	 $LN63@load_jpeg_

; 3428 :                         for (i = 0; i < z->s->img_x; ++i) {

  0079c	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  007a6	eb 0e		 jmp	 SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
  007a8	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  007ae	ff c0		 inc	 eax
  007b0	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN13@load_jpeg_:
  007b6	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  007bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007c0	8b 00		 mov	 eax, DWORD PTR [rax]
  007c2	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  007c8	0f 83 b4 00 00
	00		 jae	 $LN12@load_jpeg_

; 3429 :                             out[0] = y[i];

  007ce	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  007d4	b9 01 00 00 00	 mov	 ecx, 1
  007d9	48 6b c9 00	 imul	 rcx, rcx, 0
  007dd	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  007e4	4c 8b 85 88 02
	00 00		 mov	 r8, QWORD PTR y$15[rbp]
  007eb	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  007f0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3430 :                             out[1] = coutput[1][i];

  007f3	b8 08 00 00 00	 mov	 eax, 8
  007f8	48 6b c0 01	 imul	 rax, rax, 1
  007fc	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00802	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  0080a	ba 01 00 00 00	 mov	 edx, 1
  0080f	48 6b d2 01	 imul	 rdx, rdx, 1
  00813	4c 8b 85 28 02
	00 00		 mov	 r8, QWORD PTR out$12[rbp]
  0081a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0081e	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3431 :                             out[2] = coutput[2][i];

  00822	b8 08 00 00 00	 mov	 eax, 8
  00827	48 6b c0 02	 imul	 rax, rax, 2
  0082b	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00831	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00839	ba 01 00 00 00	 mov	 edx, 1
  0083e	48 6b d2 02	 imul	 rdx, rdx, 2
  00842	4c 8b 85 28 02
	00 00		 mov	 r8, QWORD PTR out$12[rbp]
  00849	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0084d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3432 :                             out[3] = 255;

  00851	b8 01 00 00 00	 mov	 eax, 1
  00856	48 6b c0 03	 imul	 rax, rax, 3
  0085a	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00861	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3433 :                             out += n;

  00865	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  00869	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00870	48 03 c8	 add	 rcx, rax
  00873	48 8b c1	 mov	 rax, rcx
  00876	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3434 :                         }

  0087d	e9 26 ff ff ff	 jmp	 $LN11@load_jpeg_
$LN12@load_jpeg_:

; 3435 :                     }

  00882	eb 56		 jmp	 SHORT $LN64@load_jpeg_
$LN63@load_jpeg_:

; 3436 :                     else {
; 3437 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00884	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0088b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0088e	b9 08 00 00 00	 mov	 ecx, 8
  00893	48 6b c9 02	 imul	 rcx, rcx, 2
  00897	ba 08 00 00 00	 mov	 edx, 8
  0089c	48 6b d2 01	 imul	 rdx, rdx, 1
  008a0	44 8b 45 04	 mov	 r8d, DWORD PTR n$[rbp]
  008a4	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  008a9	8b 00		 mov	 eax, DWORD PTR [rax]
  008ab	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008af	4c 8b 8c 0d e8
	00 00 00	 mov	 r9, QWORD PTR coutput$9[rbp+rcx]
  008b7	4c 8b 84 15 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$9[rbp+rdx]
  008bf	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR y$15[rbp]
  008c6	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  008cd	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  008d4	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN64@load_jpeg_:

; 3438 :                     }
; 3439 :                 }

  008da	e9 2b 04 00 00	 jmp	 $LN62@load_jpeg_
$LN61@load_jpeg_:

; 3440 :                 else if (z->s->img_n == 4) {

  008df	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  008e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008e9	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  008ed	0f 85 3f 03 00
	00		 jne	 $LN65@load_jpeg_

; 3441 :                     if (z->app14_color_transform == 0) { // CMYK

  008f3	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  008fa	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00901	0f 85 37 01 00
	00		 jne	 $LN67@load_jpeg_

; 3442 :                         for (i = 0; i < z->s->img_x; ++i) {

  00907	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00911	eb 0e		 jmp	 SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
  00913	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00919	ff c0		 inc	 eax
  0091b	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN16@load_jpeg_:
  00921	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00928	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0092b	8b 00		 mov	 eax, DWORD PTR [rax]
  0092d	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00933	0f 83 00 01 00
	00		 jae	 $LN15@load_jpeg_

; 3443 :                             stbi_uc m = coutput[3][i];

  00939	b8 08 00 00 00	 mov	 eax, 8
  0093e	48 6b c0 03	 imul	 rax, rax, 3
  00942	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00948	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00950	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00954	88 85 a4 02 00
	00		 mov	 BYTE PTR m$16[rbp], al

; 3444 :                             out[0] = stbi__blinn_8x8(coutput[0][i], m);

  0095a	b8 08 00 00 00	 mov	 eax, 8
  0095f	48 6b c0 00	 imul	 rax, rax, 0
  00963	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00969	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00971	0f b6 95 a4 02
	00 00		 movzx	 edx, BYTE PTR m$16[rbp]
  00978	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0097c	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00981	b9 01 00 00 00	 mov	 ecx, 1
  00986	48 6b c9 00	 imul	 rcx, rcx, 0
  0098a	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00991	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3445 :                             out[1] = stbi__blinn_8x8(coutput[1][i], m);

  00994	b8 08 00 00 00	 mov	 eax, 8
  00999	48 6b c0 01	 imul	 rax, rax, 1
  0099d	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  009a3	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  009ab	0f b6 95 a4 02
	00 00		 movzx	 edx, BYTE PTR m$16[rbp]
  009b2	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  009b6	e8 00 00 00 00	 call	 stbi__blinn_8x8
  009bb	b9 01 00 00 00	 mov	 ecx, 1
  009c0	48 6b c9 01	 imul	 rcx, rcx, 1
  009c4	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  009cb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3446 :                             out[2] = stbi__blinn_8x8(coutput[2][i], m);

  009ce	b8 08 00 00 00	 mov	 eax, 8
  009d3	48 6b c0 02	 imul	 rax, rax, 2
  009d7	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  009dd	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  009e5	0f b6 95 a4 02
	00 00		 movzx	 edx, BYTE PTR m$16[rbp]
  009ec	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  009f0	e8 00 00 00 00	 call	 stbi__blinn_8x8
  009f5	b9 01 00 00 00	 mov	 ecx, 1
  009fa	48 6b c9 02	 imul	 rcx, rcx, 2
  009fe	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00a05	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3447 :                             out[3] = 255;

  00a08	b8 01 00 00 00	 mov	 eax, 1
  00a0d	48 6b c0 03	 imul	 rax, rax, 3
  00a11	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00a18	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3448 :                             out += n;

  00a1c	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  00a20	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00a27	48 03 c8	 add	 rcx, rax
  00a2a	48 8b c1	 mov	 rax, rcx
  00a2d	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3449 :                         }

  00a34	e9 da fe ff ff	 jmp	 $LN14@load_jpeg_
$LN15@load_jpeg_:

; 3450 :                     }

  00a39	e9 ef 01 00 00	 jmp	 $LN68@load_jpeg_
$LN67@load_jpeg_:

; 3451 :                     else if (z->app14_color_transform == 2) { // YCCK

  00a3e	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00a45	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  00a4c	0f 85 85 01 00
	00		 jne	 $LN69@load_jpeg_

; 3452 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00a52	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00a59	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a5c	b9 08 00 00 00	 mov	 ecx, 8
  00a61	48 6b c9 02	 imul	 rcx, rcx, 2
  00a65	ba 08 00 00 00	 mov	 edx, 8
  00a6a	48 6b d2 01	 imul	 rdx, rdx, 1
  00a6e	44 8b 45 04	 mov	 r8d, DWORD PTR n$[rbp]
  00a72	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00a77	8b 00		 mov	 eax, DWORD PTR [rax]
  00a79	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a7d	4c 8b 8c 0d e8
	00 00 00	 mov	 r9, QWORD PTR coutput$9[rbp+rcx]
  00a85	4c 8b 84 15 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$9[rbp+rdx]
  00a8d	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR y$15[rbp]
  00a94	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00a9b	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00aa2	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]

; 3453 :                         for (i = 0; i < z->s->img_x; ++i) {

  00aa8	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00ab2	eb 0e		 jmp	 SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
  00ab4	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00aba	ff c0		 inc	 eax
  00abc	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN19@load_jpeg_:
  00ac2	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00ac9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00acc	8b 00		 mov	 eax, DWORD PTR [rax]
  00ace	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00ad4	0f 83 fb 00 00
	00		 jae	 $LN18@load_jpeg_

; 3454 :                             stbi_uc m = coutput[3][i];

  00ada	b8 08 00 00 00	 mov	 eax, 8
  00adf	48 6b c0 03	 imul	 rax, rax, 3
  00ae3	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00ae9	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00af1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00af5	88 85 c4 02 00
	00		 mov	 BYTE PTR m$17[rbp], al

; 3455 :                             out[0] = stbi__blinn_8x8(255 - out[0], m);

  00afb	b8 01 00 00 00	 mov	 eax, 1
  00b00	48 6b c0 00	 imul	 rax, rax, 0
  00b04	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00b0b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b0f	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00b14	2b c8		 sub	 ecx, eax
  00b16	8b c1		 mov	 eax, ecx
  00b18	0f b6 95 c4 02
	00 00		 movzx	 edx, BYTE PTR m$17[rbp]
  00b1f	0f b6 c8	 movzx	 ecx, al
  00b22	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00b27	b9 01 00 00 00	 mov	 ecx, 1
  00b2c	48 6b c9 00	 imul	 rcx, rcx, 0
  00b30	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00b37	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3456 :                             out[1] = stbi__blinn_8x8(255 - out[1], m);

  00b3a	b8 01 00 00 00	 mov	 eax, 1
  00b3f	48 6b c0 01	 imul	 rax, rax, 1
  00b43	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00b4a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b4e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00b53	2b c8		 sub	 ecx, eax
  00b55	8b c1		 mov	 eax, ecx
  00b57	0f b6 95 c4 02
	00 00		 movzx	 edx, BYTE PTR m$17[rbp]
  00b5e	0f b6 c8	 movzx	 ecx, al
  00b61	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00b66	b9 01 00 00 00	 mov	 ecx, 1
  00b6b	48 6b c9 01	 imul	 rcx, rcx, 1
  00b6f	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00b76	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3457 :                             out[2] = stbi__blinn_8x8(255 - out[2], m);

  00b79	b8 01 00 00 00	 mov	 eax, 1
  00b7e	48 6b c0 02	 imul	 rax, rax, 2
  00b82	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00b89	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b8d	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00b92	2b c8		 sub	 ecx, eax
  00b94	8b c1		 mov	 eax, ecx
  00b96	0f b6 95 c4 02
	00 00		 movzx	 edx, BYTE PTR m$17[rbp]
  00b9d	0f b6 c8	 movzx	 ecx, al
  00ba0	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00ba5	b9 01 00 00 00	 mov	 ecx, 1
  00baa	48 6b c9 02	 imul	 rcx, rcx, 2
  00bae	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00bb5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3458 :                             out += n;

  00bb8	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  00bbc	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00bc3	48 03 c8	 add	 rcx, rax
  00bc6	48 8b c1	 mov	 rax, rcx
  00bc9	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3459 :                         }

  00bd0	e9 df fe ff ff	 jmp	 $LN17@load_jpeg_
$LN18@load_jpeg_:

; 3460 :                     }

  00bd5	eb 56		 jmp	 SHORT $LN70@load_jpeg_
$LN69@load_jpeg_:

; 3461 :                     else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3462 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00bd7	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00bde	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00be1	b9 08 00 00 00	 mov	 ecx, 8
  00be6	48 6b c9 02	 imul	 rcx, rcx, 2
  00bea	ba 08 00 00 00	 mov	 edx, 8
  00bef	48 6b d2 01	 imul	 rdx, rdx, 1
  00bf3	44 8b 45 04	 mov	 r8d, DWORD PTR n$[rbp]
  00bf7	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00bfc	8b 00		 mov	 eax, DWORD PTR [rax]
  00bfe	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c02	4c 8b 8c 0d e8
	00 00 00	 mov	 r9, QWORD PTR coutput$9[rbp+rcx]
  00c0a	4c 8b 84 15 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$9[rbp+rdx]
  00c12	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR y$15[rbp]
  00c19	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00c20	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c27	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN70@load_jpeg_:
$LN68@load_jpeg_:

; 3463 :                     }
; 3464 :                 }

  00c2d	e9 d8 00 00 00	 jmp	 $LN66@load_jpeg_
$LN65@load_jpeg_:

; 3465 :                 else
; 3466 :                     for (i = 0; i < z->s->img_x; ++i) {

  00c32	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00c3c	eb 0e		 jmp	 SHORT $LN22@load_jpeg_
$LN20@load_jpeg_:
  00c3e	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00c44	ff c0		 inc	 eax
  00c46	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN22@load_jpeg_:
  00c4c	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c53	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c56	8b 00		 mov	 eax, DWORD PTR [rax]
  00c58	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00c5e	0f 83 a6 00 00
	00		 jae	 $LN21@load_jpeg_

; 3467 :                         out[0] = out[1] = out[2] = y[i];

  00c64	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00c6a	b9 01 00 00 00	 mov	 ecx, 1
  00c6f	48 6b c9 02	 imul	 rcx, rcx, 2
  00c73	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00c7a	4c 8b 85 88 02
	00 00		 mov	 r8, QWORD PTR y$15[rbp]
  00c81	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00c86	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c89	b8 01 00 00 00	 mov	 eax, 1
  00c8e	48 6b c0 02	 imul	 rax, rax, 2
  00c92	b9 01 00 00 00	 mov	 ecx, 1
  00c97	48 6b c9 01	 imul	 rcx, rcx, 1
  00c9b	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00ca2	4c 8b 85 28 02
	00 00		 mov	 r8, QWORD PTR out$12[rbp]
  00ca9	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00cae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00cb1	b8 01 00 00 00	 mov	 eax, 1
  00cb6	48 6b c0 01	 imul	 rax, rax, 1
  00cba	b9 01 00 00 00	 mov	 ecx, 1
  00cbf	48 6b c9 00	 imul	 rcx, rcx, 0
  00cc3	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00cca	4c 8b 85 28 02
	00 00		 mov	 r8, QWORD PTR out$12[rbp]
  00cd1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00cd6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3468 :                         out[3] = 255; // not used if n==3

  00cd9	b8 01 00 00 00	 mov	 eax, 1
  00cde	48 6b c0 03	 imul	 rax, rax, 3
  00ce2	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00ce9	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3469 :                         out += n;

  00ced	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  00cf1	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00cf8	48 03 c8	 add	 rcx, rax
  00cfb	48 8b c1	 mov	 rax, rcx
  00cfe	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3470 :                     }

  00d05	e9 34 ff ff ff	 jmp	 $LN20@load_jpeg_
$LN21@load_jpeg_:
$LN66@load_jpeg_:
$LN62@load_jpeg_:

; 3471 :             }

  00d0a	e9 10 05 00 00	 jmp	 $LN60@load_jpeg_
$LN59@load_jpeg_:

; 3472 :             else {
; 3473 :                 if (is_rgb) {

  00d0f	83 7d 44 00	 cmp	 DWORD PTR is_rgb$[rbp], 0
  00d13	0f 84 ab 01 00
	00		 je	 $LN71@load_jpeg_

; 3474 :                     if (n == 1)

  00d19	83 7d 04 01	 cmp	 DWORD PTR n$[rbp], 1
  00d1d	0f 85 c1 00 00
	00		 jne	 $LN73@load_jpeg_

; 3475 :                         for (i = 0; i < z->s->img_x; ++i)

  00d23	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00d2d	eb 0e		 jmp	 SHORT $LN25@load_jpeg_
$LN23@load_jpeg_:
  00d2f	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00d35	ff c0		 inc	 eax
  00d37	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN25@load_jpeg_:
  00d3d	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00d44	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d47	8b 00		 mov	 eax, DWORD PTR [rax]
  00d49	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00d4f	0f 83 8a 00 00
	00		 jae	 $LN24@load_jpeg_

; 3476 :                             *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00d55	b8 08 00 00 00	 mov	 eax, 8
  00d5a	48 6b c0 02	 imul	 rax, rax, 2
  00d5e	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00d64	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00d6c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00d70	b9 08 00 00 00	 mov	 ecx, 8
  00d75	48 6b c9 01	 imul	 rcx, rcx, 1
  00d79	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR i$6[rbp]
  00d7f	48 8b 8c 0d e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$9[rbp+rcx]
  00d87	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00d8b	ba 08 00 00 00	 mov	 edx, 8
  00d90	48 6b d2 00	 imul	 rdx, rdx, 0
  00d94	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR i$6[rbp]
  00d9b	48 8b 94 15 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$9[rbp+rdx]
  00da3	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00da8	89 95 f4 04 00
	00		 mov	 DWORD PTR tv516[rbp], edx
  00dae	44 8b c0	 mov	 r8d, eax
  00db1	8b d1		 mov	 edx, ecx
  00db3	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv516[rbp]
  00db9	8b c8		 mov	 ecx, eax
  00dbb	e8 00 00 00 00	 call	 stbi__compute_y
  00dc0	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00dc7	88 01		 mov	 BYTE PTR [rcx], al
  00dc9	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR out$12[rbp]
  00dd0	48 ff c0	 inc	 rax
  00dd3	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax
  00dda	e9 50 ff ff ff	 jmp	 $LN23@load_jpeg_
$LN24@load_jpeg_:
  00ddf	e9 db 00 00 00	 jmp	 $LN74@load_jpeg_
$LN73@load_jpeg_:

; 3477 :                     else {
; 3478 :                         for (i = 0; i < z->s->img_x; ++i, out += 2) {

  00de4	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00dee	eb 20		 jmp	 SHORT $LN28@load_jpeg_
$LN26@load_jpeg_:
  00df0	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00df6	ff c0		 inc	 eax
  00df8	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
  00dfe	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR out$12[rbp]
  00e05	48 83 c0 02	 add	 rax, 2
  00e09	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax
$LN28@load_jpeg_:
  00e10	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00e17	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e1a	8b 00		 mov	 eax, DWORD PTR [rax]
  00e1c	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00e22	0f 83 97 00 00
	00		 jae	 $LN27@load_jpeg_

; 3479 :                             out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00e28	b8 08 00 00 00	 mov	 eax, 8
  00e2d	48 6b c0 02	 imul	 rax, rax, 2
  00e31	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00e37	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00e3f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00e43	b9 08 00 00 00	 mov	 ecx, 8
  00e48	48 6b c9 01	 imul	 rcx, rcx, 1
  00e4c	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR i$6[rbp]
  00e52	48 8b 8c 0d e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$9[rbp+rcx]
  00e5a	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00e5e	ba 08 00 00 00	 mov	 edx, 8
  00e63	48 6b d2 00	 imul	 rdx, rdx, 0
  00e67	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR i$6[rbp]
  00e6e	48 8b 94 15 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$9[rbp+rdx]
  00e76	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00e7b	89 95 f4 04 00
	00		 mov	 DWORD PTR tv545[rbp], edx
  00e81	44 8b c0	 mov	 r8d, eax
  00e84	8b d1		 mov	 edx, ecx
  00e86	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv545[rbp]
  00e8c	8b c8		 mov	 ecx, eax
  00e8e	e8 00 00 00 00	 call	 stbi__compute_y
  00e93	b9 01 00 00 00	 mov	 ecx, 1
  00e98	48 6b c9 00	 imul	 rcx, rcx, 0
  00e9c	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  00ea3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3480 :                             out[1] = 255;

  00ea6	b8 01 00 00 00	 mov	 eax, 1
  00eab	48 6b c0 01	 imul	 rax, rax, 1
  00eaf	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  00eb6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3481 :                         }

  00eba	e9 31 ff ff ff	 jmp	 $LN26@load_jpeg_
$LN27@load_jpeg_:
$LN74@load_jpeg_:

; 3482 :                     }
; 3483 :                 }

  00ebf	e9 5b 03 00 00	 jmp	 $LN72@load_jpeg_
$LN71@load_jpeg_:

; 3484 :                 else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

  00ec4	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00ecb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ece	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00ed2	0f 85 64 01 00
	00		 jne	 $LN75@load_jpeg_
  00ed8	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00edf	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00ee6	0f 85 50 01 00
	00		 jne	 $LN75@load_jpeg_

; 3485 :                     for (i = 0; i < z->s->img_x; ++i) {

  00eec	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  00ef6	eb 0e		 jmp	 SHORT $LN31@load_jpeg_
$LN29@load_jpeg_:
  00ef8	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  00efe	ff c0		 inc	 eax
  00f00	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN31@load_jpeg_:
  00f06	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00f0d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f10	8b 00		 mov	 eax, DWORD PTR [rax]
  00f12	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  00f18	0f 83 19 01 00
	00		 jae	 $LN30@load_jpeg_

; 3486 :                         stbi_uc m = coutput[3][i];

  00f1e	b8 08 00 00 00	 mov	 eax, 8
  00f23	48 6b c0 03	 imul	 rax, rax, 3
  00f27	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00f2d	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00f35	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00f39	88 85 e4 02 00
	00		 mov	 BYTE PTR m$18[rbp], al

; 3487 :                         stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

  00f3f	b8 08 00 00 00	 mov	 eax, 8
  00f44	48 6b c0 00	 imul	 rax, rax, 0
  00f48	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00f4e	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00f56	0f b6 95 e4 02
	00 00		 movzx	 edx, BYTE PTR m$18[rbp]
  00f5d	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00f61	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00f66	88 85 04 03 00
	00		 mov	 BYTE PTR r$19[rbp], al

; 3488 :                         stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

  00f6c	b8 08 00 00 00	 mov	 eax, 8
  00f71	48 6b c0 01	 imul	 rax, rax, 1
  00f75	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00f7b	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00f83	0f b6 95 e4 02
	00 00		 movzx	 edx, BYTE PTR m$18[rbp]
  00f8a	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00f8e	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00f93	88 85 24 03 00
	00		 mov	 BYTE PTR g$20[rbp], al

; 3489 :                         stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

  00f99	b8 08 00 00 00	 mov	 eax, 8
  00f9e	48 6b c0 02	 imul	 rax, rax, 2
  00fa2	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  00fa8	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  00fb0	0f b6 95 e4 02
	00 00		 movzx	 edx, BYTE PTR m$18[rbp]
  00fb7	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00fbb	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00fc0	88 85 44 03 00
	00		 mov	 BYTE PTR b$21[rbp], al

; 3490 :                         out[0] = stbi__compute_y(r, g, b);

  00fc6	0f b6 85 44 03
	00 00		 movzx	 eax, BYTE PTR b$21[rbp]
  00fcd	0f b6 8d 24 03
	00 00		 movzx	 ecx, BYTE PTR g$20[rbp]
  00fd4	0f b6 95 04 03
	00 00		 movzx	 edx, BYTE PTR r$19[rbp]
  00fdb	89 95 f4 04 00
	00		 mov	 DWORD PTR tv626[rbp], edx
  00fe1	44 8b c0	 mov	 r8d, eax
  00fe4	8b d1		 mov	 edx, ecx
  00fe6	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv626[rbp]
  00fec	8b c8		 mov	 ecx, eax
  00fee	e8 00 00 00 00	 call	 stbi__compute_y
  00ff3	b9 01 00 00 00	 mov	 ecx, 1
  00ff8	48 6b c9 00	 imul	 rcx, rcx, 0
  00ffc	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  01003	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3491 :                         out[1] = 255;

  01006	b8 01 00 00 00	 mov	 eax, 1
  0100b	48 6b c0 01	 imul	 rax, rax, 1
  0100f	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  01016	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3492 :                         out += n;

  0101a	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  0101e	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  01025	48 03 c8	 add	 rcx, rax
  01028	48 8b c1	 mov	 rax, rcx
  0102b	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3493 :                     }

  01032	e9 c1 fe ff ff	 jmp	 $LN29@load_jpeg_
$LN30@load_jpeg_:

; 3494 :                 }

  01037	e9 e3 01 00 00	 jmp	 $LN76@load_jpeg_
$LN75@load_jpeg_:

; 3495 :                 else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

  0103c	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  01043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01046	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  0104a	0f 85 e7 00 00
	00		 jne	 $LN77@load_jpeg_
  01050	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  01057	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  0105e	0f 85 d3 00 00
	00		 jne	 $LN77@load_jpeg_

; 3496 :                     for (i = 0; i < z->s->img_x; ++i) {

  01064	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  0106e	eb 0e		 jmp	 SHORT $LN34@load_jpeg_
$LN32@load_jpeg_:
  01070	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  01076	ff c0		 inc	 eax
  01078	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN34@load_jpeg_:
  0107e	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  01085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01088	8b 00		 mov	 eax, DWORD PTR [rax]
  0108a	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  01090	0f 83 9c 00 00
	00		 jae	 $LN33@load_jpeg_

; 3497 :                         out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

  01096	b8 08 00 00 00	 mov	 eax, 8
  0109b	48 6b c0 03	 imul	 rax, rax, 3
  0109f	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  010a5	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  010ad	ba 08 00 00 00	 mov	 edx, 8
  010b2	48 6b d2 00	 imul	 rdx, rdx, 0
  010b6	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR i$6[rbp]
  010bd	48 8b 94 15 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$9[rbp+rdx]
  010c5	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  010ca	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  010d0	44 2b c2	 sub	 r8d, edx
  010d3	41 8b d0	 mov	 edx, r8d
  010d6	89 95 f4 04 00
	00		 mov	 DWORD PTR tv656[rbp], edx
  010dc	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  010e0	8b 85 f4 04 00
	00		 mov	 eax, DWORD PTR tv656[rbp]
  010e6	0f b6 c8	 movzx	 ecx, al
  010e9	e8 00 00 00 00	 call	 stbi__blinn_8x8
  010ee	b9 01 00 00 00	 mov	 ecx, 1
  010f3	48 6b c9 00	 imul	 rcx, rcx, 0
  010f7	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  010fe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3498 :                         out[1] = 255;

  01101	b8 01 00 00 00	 mov	 eax, 1
  01106	48 6b c0 01	 imul	 rax, rax, 1
  0110a	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  01111	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3499 :                         out += n;

  01115	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  01119	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  01120	48 03 c8	 add	 rcx, rax
  01123	48 8b c1	 mov	 rax, rcx
  01126	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax

; 3500 :                     }

  0112d	e9 3e ff ff ff	 jmp	 $LN32@load_jpeg_
$LN33@load_jpeg_:

; 3501 :                 }

  01132	e9 e8 00 00 00	 jmp	 $LN78@load_jpeg_
$LN77@load_jpeg_:

; 3502 :                 else {
; 3503 :                     stbi_uc* y = coutput[0];

  01137	b8 08 00 00 00	 mov	 eax, 8
  0113c	48 6b c0 00	 imul	 rax, rax, 0
  01140	48 8b 84 05 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$9[rbp+rax]
  01148	48 89 85 68 03
	00 00		 mov	 QWORD PTR y$22[rbp], rax

; 3504 :                     if (n == 1)

  0114f	83 7d 04 01	 cmp	 DWORD PTR n$[rbp], 1
  01153	75 54		 jne	 SHORT $LN79@load_jpeg_

; 3505 :                         for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];

  01155	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  0115f	eb 0e		 jmp	 SHORT $LN37@load_jpeg_
$LN35@load_jpeg_:
  01161	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  01167	ff c0		 inc	 eax
  01169	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN37@load_jpeg_:
  0116f	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  01176	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01179	8b 00		 mov	 eax, DWORD PTR [rax]
  0117b	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  01181	73 24		 jae	 SHORT $LN36@load_jpeg_
  01183	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  01189	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$6[rbp]
  0118f	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR out$12[rbp]
  01196	4c 8b 85 68 03
	00 00		 mov	 r8, QWORD PTR y$22[rbp]
  0119d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  011a2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  011a5	eb ba		 jmp	 SHORT $LN35@load_jpeg_
$LN36@load_jpeg_:
  011a7	eb 76		 jmp	 SHORT $LN80@load_jpeg_
$LN79@load_jpeg_:

; 3506 :                     else
; 3507 :                         for (i = 0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }

  011a9	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$6[rbp], 0
  011b3	eb 0e		 jmp	 SHORT $LN40@load_jpeg_
$LN38@load_jpeg_:
  011b5	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  011bb	ff c0		 inc	 eax
  011bd	89 85 84 00 00
	00		 mov	 DWORD PTR i$6[rbp], eax
$LN40@load_jpeg_:
  011c3	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  011ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011cd	8b 00		 mov	 eax, DWORD PTR [rax]
  011cf	39 85 84 00 00
	00		 cmp	 DWORD PTR i$6[rbp], eax
  011d5	73 48		 jae	 SHORT $LN39@load_jpeg_
  011d7	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$6[rbp]
  011dd	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR out$12[rbp]
  011e4	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR y$22[rbp]
  011eb	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  011ef	88 01		 mov	 BYTE PTR [rcx], al
  011f1	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR out$12[rbp]
  011f8	48 ff c0	 inc	 rax
  011fb	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax
  01202	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR out$12[rbp]
  01209	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0120c	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR out$12[rbp]
  01213	48 ff c0	 inc	 rax
  01216	48 89 85 28 02
	00 00		 mov	 QWORD PTR out$12[rbp], rax
  0121d	eb 96		 jmp	 SHORT $LN38@load_jpeg_
$LN39@load_jpeg_:
$LN80@load_jpeg_:
$LN78@load_jpeg_:
$LN76@load_jpeg_:
$LN72@load_jpeg_:
$LN60@load_jpeg_:

; 3508 :                 }
; 3509 :             }
; 3510 :         }

  0121f	e9 f5 f2 ff ff	 jmp	 $LN5@load_jpeg_
$LN6@load_jpeg_:

; 3511 :         stbi__cleanup_jpeg(z);

  01224	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0122b	e8 00 00 00 00	 call	 stbi__cleanup_jpeg

; 3512 :         *out_x = z->s->img_x;

  01230	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  01237	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0123a	48 8b 8d 38 05
	00 00		 mov	 rcx, QWORD PTR out_x$[rbp]
  01241	8b 00		 mov	 eax, DWORD PTR [rax]
  01243	89 01		 mov	 DWORD PTR [rcx], eax

; 3513 :         *out_y = z->s->img_y;

  01245	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0124c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0124f	48 8b 8d 40 05
	00 00		 mov	 rcx, QWORD PTR out_y$[rbp]
  01256	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01259	89 01		 mov	 DWORD PTR [rcx], eax

; 3514 :         if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

  0125b	48 83 bd 48 05
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  01263	74 35		 je	 SHORT $LN81@load_jpeg_
  01265	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0126c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0126f	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  01273	7c 0c		 jl	 SHORT $LN103@load_jpeg_
  01275	c7 85 f4 04 00
	00 03 00 00 00	 mov	 DWORD PTR tv694[rbp], 3
  0127f	eb 0a		 jmp	 SHORT $LN104@load_jpeg_
$LN103@load_jpeg_:
  01281	c7 85 f4 04 00
	00 01 00 00 00	 mov	 DWORD PTR tv694[rbp], 1
$LN104@load_jpeg_:
  0128b	48 8b 85 48 05
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  01292	8b 8d f4 04 00
	00		 mov	 ecx, DWORD PTR tv694[rbp]
  01298	89 08		 mov	 DWORD PTR [rax], ecx
$LN81@load_jpeg_:

; 3515 :         return output;

  0129a	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR output$8[rbp]
$LN1@load_jpeg_:

; 3516 :     }
; 3517 : }

  012a1	48 8b f8	 mov	 rdi, rax
  012a4	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  012a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:load_jpeg_image$rtcFrameData
  012af	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  012b4	48 8b c7	 mov	 rax, rdi
  012b7	48 8b 8d 08 05
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  012be	48 33 cd	 xor	 rcx, rbp
  012c1	e8 00 00 00 00	 call	 __security_check_cookie
  012c6	48 8d a5 18 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1304]
  012cd	5f		 pop	 rdi
  012ce	5d		 pop	 rbp
  012cf	c3		 ret	 0
load_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__blinn_8x8
_TEXT	SEGMENT
t$ = 4
x$ = 256
y$ = 264
stbi__blinn_8x8 PROC					; COMDAT

; 3342 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3343 :     unsigned int t = x * y + 128;

  00022	0f b6 85 00 01
	00 00		 movzx	 eax, BYTE PTR x$[rbp]
  00029	0f b6 8d 08 01
	00 00		 movzx	 ecx, BYTE PTR y$[rbp]
  00030	0f af c1	 imul	 eax, ecx
  00033	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00038	89 45 04	 mov	 DWORD PTR t$[rbp], eax

; 3344 :     return (stbi_uc)((t + (t >> 8)) >> 8);

  0003b	8b 45 04	 mov	 eax, DWORD PTR t$[rbp]
  0003e	c1 e8 08	 shr	 eax, 8
  00041	8b 4d 04	 mov	 ecx, DWORD PTR t$[rbp]
  00044	03 c8		 add	 ecx, eax
  00046	8b c1		 mov	 eax, ecx
  00048	c1 e8 08	 shr	 eax, 8

; 3345 : }

  0004b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00052	5f		 pop	 rdi
  00053	5d		 pop	 rbp
  00054	c3		 ret	 0
stbi__blinn_8x8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__cleanup_jpeg
_TEXT	SEGMENT
j$ = 224
stbi__cleanup_jpeg PROC					; COMDAT

; 3326 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3327 :     stbi__free_jpeg_components(j, j->s->img_n, 0);

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  0002f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00036	e8 00 00 00 00	 call	 stbi__free_jpeg_components

; 3328 : }

  0003b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00042	5f		 pop	 rdi
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
stbi__cleanup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__setup_jpeg
_TEXT	SEGMENT
j$ = 224
stbi__setup_jpeg PROC					; COMDAT

; 3304 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3305 :     j->idct_block_kernel = stbi__idct_block;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__idct_block
  0002d	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3306 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

  00034	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__YCbCr_to_RGB_row
  00042	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3307 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

  00049	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_hv_2
  00057	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx

; 3308 : 
; 3309 : #ifdef STBI_SSE2
; 3310 :     if (stbi__sse2_available()) {

  0005e	e8 00 00 00 00	 call	 stbi__sse2_available
  00063	85 c0		 test	 eax, eax
  00065	74 3f		 je	 SHORT $LN2@stbi__setu

; 3311 :         j->idct_block_kernel = stbi__idct_simd;

  00067	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__idct_simd
  00075	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3312 :         j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

  0007c	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__YCbCr_to_RGB_simd
  0008a	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3313 :         j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

  00091	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_hv_2_simd
  0009f	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx
$LN2@stbi__setu:

; 3314 :     }
; 3315 : #endif
; 3316 : 
; 3317 : #ifdef STBI_NEON
; 3318 :     j->idct_block_kernel = stbi__idct_simd;
; 3319 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3320 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3321 : #endif
; 3322 : }

  000a6	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000ad	5f		 pop	 rdi
  000ae	5d		 pop	 rbp
  000af	c3		 ret	 0
stbi__setup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__YCbCr_to_RGB_simd
_TEXT	SEGMENT
i$ = 4
signflip$1 = 48
cr_const0$2 = 96
cr_const1$3 = 144
cb_const0$4 = 192
cb_const1$5 = 240
y_bias$6 = 288
xw$7 = 336
y_bytes$8 = 384
cr_bytes$9 = 432
cb_bytes$10 = 480
cr_biased$11 = 528
cb_biased$12 = 576
yw$13 = 624
crw$14 = 672
cbw$15 = 720
yws$16 = 768
cr0$17 = 816
cb0$18 = 864
cb1$19 = 912
cr1$20 = 960
rws$21 = 1008
gwt$22 = 1056
bws$23 = 1104
gws$24 = 1152
rw$25 = 1200
bw$26 = 1248
gw$27 = 1296
brb$28 = 1344
gxb$29 = 1392
t0$30 = 1440
t1$31 = 1488
o0$32 = 1536
o1$33 = 1584
y_fixed$34 = 1620
r$35 = 1652
g$36 = 1684
b$37 = 1716
cr$38 = 1748
cb$39 = 1780
out$ = 2608
y$ = 2616
pcb$ = 2624
pcr$ = 2632
count$ = 2640
step$ = 2648
stbi__YCbCr_to_RGB_simd PROC				; COMDAT

; 3169 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 0a
	00 00		 sub	 rsp, 2616		; 00000a38H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3170 :     int i = 0;

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0

; 3171 : 
; 3172 : #ifdef STBI_SSE2
; 3173 :     // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3174 :     // it's useful in practice (you wouldn't use it for textures, for example).
; 3175 :     // so just accelerate step == 4 case.
; 3176 :     if (step == 4) {

  00035	83 bd 58 0a 00
	00 04		 cmp	 DWORD PTR step$[rbp], 4
  0003c	0f 85 28 03 00
	00		 jne	 $LN8@stbi__YCbC

; 3177 :         // this is a fairly straightforward implementation and not super-optimized.
; 3178 :         __m128i signflip = _mm_set1_epi8(-0x80);

  00042	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  0004a	66 0f 7f 45 30	 movdqa	 XMMWORD PTR signflip$1[rbp], xmm0

; 3179 :         __m128i cr_const0 = _mm_set1_epi16((short)(1.40200f * 4096.0f + 0.5f));

  0004f	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
  00057	66 0f 7f 45 60	 movdqa	 XMMWORD PTR cr_const0$2[rbp], xmm0

; 3180 :         __m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f * 4096.0f + 0.5f));

  0005c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
  00064	66 0f 7f 85 90
	00 00 00	 movdqa	 XMMWORD PTR cr_const1$3[rbp], xmm0

; 3181 :         __m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f * 4096.0f + 0.5f));

  0006c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
  00074	66 0f 7f 85 c0
	00 00 00	 movdqa	 XMMWORD PTR cb_const0$4[rbp], xmm0

; 3182 :         __m128i cb_const1 = _mm_set1_epi16((short)(1.77200f * 4096.0f + 0.5f));

  0007c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
  00084	66 0f 7f 85 f0
	00 00 00	 movdqa	 XMMWORD PTR cb_const1$5[rbp], xmm0

; 3183 :         __m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);

  0008c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  00094	66 0f 7f 85 20
	01 00 00	 movdqa	 XMMWORD PTR y_bias$6[rbp], xmm0

; 3184 :         __m128i xw = _mm_set1_epi16(255); // alpha channel

  0009c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  000a4	66 0f 7f 85 50
	01 00 00	 movdqa	 XMMWORD PTR xw$7[rbp], xmm0

; 3185 : 
; 3186 :         for (; i + 7 < count; i += 8) {

  000ac	eb 09		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  000ae	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000b1	83 c0 08	 add	 eax, 8
  000b4	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__YCbC:
  000b7	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000ba	83 c0 07	 add	 eax, 7
  000bd	3b 85 50 0a 00
	00		 cmp	 eax, DWORD PTR count$[rbp]
  000c3	0f 8d a1 02 00
	00		 jge	 $LN3@stbi__YCbC

; 3187 :             // load
; 3188 :             __m128i y_bytes = _mm_loadl_epi64((__m128i*) (y + i));

  000c9	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000cd	48 8b 8d 38 0a
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  000de	66 0f 7f 85 80
	01 00 00	 movdqa	 XMMWORD PTR y_bytes$8[rbp], xmm0

; 3189 :             __m128i cr_bytes = _mm_loadl_epi64((__m128i*) (pcr + i));

  000e6	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000ea	48 8b 8d 48 0a
	00 00		 mov	 rcx, QWORD PTR pcr$[rbp]
  000f1	48 03 c8	 add	 rcx, rax
  000f4	48 8b c1	 mov	 rax, rcx
  000f7	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  000fb	66 0f 7f 85 b0
	01 00 00	 movdqa	 XMMWORD PTR cr_bytes$9[rbp], xmm0

; 3190 :             __m128i cb_bytes = _mm_loadl_epi64((__m128i*) (pcb + i));

  00103	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00107	48 8b 8d 40 0a
	00 00		 mov	 rcx, QWORD PTR pcb$[rbp]
  0010e	48 03 c8	 add	 rcx, rax
  00111	48 8b c1	 mov	 rax, rcx
  00114	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00118	66 0f 7f 85 e0
	01 00 00	 movdqa	 XMMWORD PTR cb_bytes$10[rbp], xmm0

; 3191 :             __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

  00120	66 0f 6f 85 b0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR cr_bytes$9[rbp]
  00128	0f 57 45 30	 xorps	 xmm0, XMMWORD PTR signflip$1[rbp]
  0012c	66 0f 7f 85 10
	02 00 00	 movdqa	 XMMWORD PTR cr_biased$11[rbp], xmm0

; 3192 :             __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

  00134	66 0f 6f 85 e0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR cb_bytes$10[rbp]
  0013c	0f 57 45 30	 xorps	 xmm0, XMMWORD PTR signflip$1[rbp]
  00140	66 0f 7f 85 40
	02 00 00	 movdqa	 XMMWORD PTR cb_biased$12[rbp], xmm0

; 3193 : 
; 3194 :             // unpack to short (and left-shift cr, cb by 8)
; 3195 :             __m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);

  00148	66 0f 6f 85 20
	01 00 00	 movdqa	 xmm0, XMMWORD PTR y_bias$6[rbp]
  00150	66 0f 60 85 80
	01 00 00	 punpcklbw xmm0, XMMWORD PTR y_bytes$8[rbp]
  00158	66 0f 7f 85 70
	02 00 00	 movdqa	 XMMWORD PTR yw$13[rbp], xmm0

; 3196 :             __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

  00160	66 0f ef c0	 pxor	 xmm0, xmm0
  00164	66 0f 60 85 10
	02 00 00	 punpcklbw xmm0, XMMWORD PTR cr_biased$11[rbp]
  0016c	66 0f 7f 85 a0
	02 00 00	 movdqa	 XMMWORD PTR crw$14[rbp], xmm0

; 3197 :             __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

  00174	66 0f ef c0	 pxor	 xmm0, xmm0
  00178	66 0f 60 85 40
	02 00 00	 punpcklbw xmm0, XMMWORD PTR cb_biased$12[rbp]
  00180	66 0f 7f 85 d0
	02 00 00	 movdqa	 XMMWORD PTR cbw$15[rbp], xmm0

; 3198 : 
; 3199 :             // color transform
; 3200 :             __m128i yws = _mm_srli_epi16(yw, 4);

  00188	66 0f 6f 85 70
	02 00 00	 movdqa	 xmm0, XMMWORD PTR yw$13[rbp]
  00190	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00195	66 0f 7f 85 00
	03 00 00	 movdqa	 XMMWORD PTR yws$16[rbp], xmm0

; 3201 :             __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

  0019d	66 0f 6f 45 60	 movdqa	 xmm0, XMMWORD PTR cr_const0$2[rbp]
  001a2	66 0f e5 85 a0
	02 00 00	 pmulhw	 xmm0, XMMWORD PTR crw$14[rbp]
  001aa	66 0f 7f 85 30
	03 00 00	 movdqa	 XMMWORD PTR cr0$17[rbp], xmm0

; 3202 :             __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

  001b2	66 0f 6f 85 c0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR cb_const0$4[rbp]
  001ba	66 0f e5 85 d0
	02 00 00	 pmulhw	 xmm0, XMMWORD PTR cbw$15[rbp]
  001c2	66 0f 7f 85 60
	03 00 00	 movdqa	 XMMWORD PTR cb0$18[rbp], xmm0

; 3203 :             __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

  001ca	66 0f 6f 85 d0
	02 00 00	 movdqa	 xmm0, XMMWORD PTR cbw$15[rbp]
  001d2	66 0f e5 85 f0
	00 00 00	 pmulhw	 xmm0, XMMWORD PTR cb_const1$5[rbp]
  001da	66 0f 7f 85 90
	03 00 00	 movdqa	 XMMWORD PTR cb1$19[rbp], xmm0

; 3204 :             __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

  001e2	66 0f 6f 85 a0
	02 00 00	 movdqa	 xmm0, XMMWORD PTR crw$14[rbp]
  001ea	66 0f e5 85 90
	00 00 00	 pmulhw	 xmm0, XMMWORD PTR cr_const1$3[rbp]
  001f2	66 0f 7f 85 c0
	03 00 00	 movdqa	 XMMWORD PTR cr1$20[rbp], xmm0

; 3205 :             __m128i rws = _mm_add_epi16(cr0, yws);

  001fa	66 0f 6f 85 30
	03 00 00	 movdqa	 xmm0, XMMWORD PTR cr0$17[rbp]
  00202	66 0f fd 85 00
	03 00 00	 paddw	 xmm0, XMMWORD PTR yws$16[rbp]
  0020a	66 0f 7f 85 f0
	03 00 00	 movdqa	 XMMWORD PTR rws$21[rbp], xmm0

; 3206 :             __m128i gwt = _mm_add_epi16(cb0, yws);

  00212	66 0f 6f 85 60
	03 00 00	 movdqa	 xmm0, XMMWORD PTR cb0$18[rbp]
  0021a	66 0f fd 85 00
	03 00 00	 paddw	 xmm0, XMMWORD PTR yws$16[rbp]
  00222	66 0f 7f 85 20
	04 00 00	 movdqa	 XMMWORD PTR gwt$22[rbp], xmm0

; 3207 :             __m128i bws = _mm_add_epi16(yws, cb1);

  0022a	66 0f 6f 85 00
	03 00 00	 movdqa	 xmm0, XMMWORD PTR yws$16[rbp]
  00232	66 0f fd 85 90
	03 00 00	 paddw	 xmm0, XMMWORD PTR cb1$19[rbp]
  0023a	66 0f 7f 85 50
	04 00 00	 movdqa	 XMMWORD PTR bws$23[rbp], xmm0

; 3208 :             __m128i gws = _mm_add_epi16(gwt, cr1);

  00242	66 0f 6f 85 20
	04 00 00	 movdqa	 xmm0, XMMWORD PTR gwt$22[rbp]
  0024a	66 0f fd 85 c0
	03 00 00	 paddw	 xmm0, XMMWORD PTR cr1$20[rbp]
  00252	66 0f 7f 85 80
	04 00 00	 movdqa	 XMMWORD PTR gws$24[rbp], xmm0

; 3209 : 
; 3210 :             // descale
; 3211 :             __m128i rw = _mm_srai_epi16(rws, 4);

  0025a	66 0f 6f 85 f0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR rws$21[rbp]
  00262	66 0f 71 e0 04	 psraw	 xmm0, 4
  00267	66 0f 7f 85 b0
	04 00 00	 movdqa	 XMMWORD PTR rw$25[rbp], xmm0

; 3212 :             __m128i bw = _mm_srai_epi16(bws, 4);

  0026f	66 0f 6f 85 50
	04 00 00	 movdqa	 xmm0, XMMWORD PTR bws$23[rbp]
  00277	66 0f 71 e0 04	 psraw	 xmm0, 4
  0027c	66 0f 7f 85 e0
	04 00 00	 movdqa	 XMMWORD PTR bw$26[rbp], xmm0

; 3213 :             __m128i gw = _mm_srai_epi16(gws, 4);

  00284	66 0f 6f 85 80
	04 00 00	 movdqa	 xmm0, XMMWORD PTR gws$24[rbp]
  0028c	66 0f 71 e0 04	 psraw	 xmm0, 4
  00291	66 0f 7f 85 10
	05 00 00	 movdqa	 XMMWORD PTR gw$27[rbp], xmm0

; 3214 : 
; 3215 :             // back to byte, set up for transpose
; 3216 :             __m128i brb = _mm_packus_epi16(rw, bw);

  00299	66 0f 6f 85 b0
	04 00 00	 movdqa	 xmm0, XMMWORD PTR rw$25[rbp]
  002a1	66 0f 67 85 e0
	04 00 00	 packuswb xmm0, XMMWORD PTR bw$26[rbp]
  002a9	66 0f 7f 85 40
	05 00 00	 movdqa	 XMMWORD PTR brb$28[rbp], xmm0

; 3217 :             __m128i gxb = _mm_packus_epi16(gw, xw);

  002b1	66 0f 6f 85 10
	05 00 00	 movdqa	 xmm0, XMMWORD PTR gw$27[rbp]
  002b9	66 0f 67 85 50
	01 00 00	 packuswb xmm0, XMMWORD PTR xw$7[rbp]
  002c1	66 0f 7f 85 70
	05 00 00	 movdqa	 XMMWORD PTR gxb$29[rbp], xmm0

; 3218 : 
; 3219 :             // transpose to interleave channels
; 3220 :             __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

  002c9	66 0f 6f 85 40
	05 00 00	 movdqa	 xmm0, XMMWORD PTR brb$28[rbp]
  002d1	66 0f 60 85 70
	05 00 00	 punpcklbw xmm0, XMMWORD PTR gxb$29[rbp]
  002d9	66 0f 7f 85 a0
	05 00 00	 movdqa	 XMMWORD PTR t0$30[rbp], xmm0

; 3221 :             __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

  002e1	66 0f 6f 85 40
	05 00 00	 movdqa	 xmm0, XMMWORD PTR brb$28[rbp]
  002e9	66 0f 68 85 70
	05 00 00	 punpckhbw xmm0, XMMWORD PTR gxb$29[rbp]
  002f1	66 0f 7f 85 d0
	05 00 00	 movdqa	 XMMWORD PTR t1$31[rbp], xmm0

; 3222 :             __m128i o0 = _mm_unpacklo_epi16(t0, t1);

  002f9	66 0f 6f 85 a0
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0$30[rbp]
  00301	66 0f 61 85 d0
	05 00 00	 punpcklwd xmm0, XMMWORD PTR t1$31[rbp]
  00309	66 0f 7f 85 00
	06 00 00	 movdqa	 XMMWORD PTR o0$32[rbp], xmm0

; 3223 :             __m128i o1 = _mm_unpackhi_epi16(t0, t1);

  00311	66 0f 6f 85 a0
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0$30[rbp]
  00319	66 0f 69 85 d0
	05 00 00	 punpckhwd xmm0, XMMWORD PTR t1$31[rbp]
  00321	66 0f 7f 85 30
	06 00 00	 movdqa	 XMMWORD PTR o1$33[rbp], xmm0

; 3224 : 
; 3225 :             // store
; 3226 :             _mm_storeu_si128((__m128i*) (out + 0), o0);

  00329	48 8b 85 30 0a
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  00330	66 0f 6f 85 00
	06 00 00	 movdqa	 xmm0, XMMWORD PTR o0$32[rbp]
  00338	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3227 :             _mm_storeu_si128((__m128i*) (out + 16), o1);

  0033c	48 8b 85 30 0a
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  00343	48 83 c0 10	 add	 rax, 16
  00347	66 0f 6f 85 30
	06 00 00	 movdqa	 xmm0, XMMWORD PTR o1$33[rbp]
  0034f	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3228 :             out += 32;

  00353	48 8b 85 30 0a
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  0035a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0035e	48 89 85 30 0a
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 3229 :         }

  00365	e9 44 fd ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:
$LN8@stbi__YCbC:

; 3230 :     }
; 3231 : #endif
; 3232 : 
; 3233 : #ifdef STBI_NEON
; 3234 :     // in this version, step=3 support would be easy to add. but is there demand?
; 3235 :     if (step == 4) {
; 3236 :         // this is a fairly straightforward implementation and not super-optimized.
; 3237 :         uint8x8_t signflip = vdup_n_u8(0x80);
; 3238 :         int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f * 4096.0f + 0.5f));
; 3239 :         int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f * 4096.0f + 0.5f));
; 3240 :         int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f * 4096.0f + 0.5f));
; 3241 :         int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f * 4096.0f + 0.5f));
; 3242 : 
; 3243 :         for (; i + 7 < count; i += 8) {
; 3244 :             // load
; 3245 :             uint8x8_t y_bytes = vld1_u8(y + i);
; 3246 :             uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3247 :             uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3248 :             int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3249 :             int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3250 : 
; 3251 :             // expand to s16
; 3252 :             int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3253 :             int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3254 :             int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3255 : 
; 3256 :             // color transform
; 3257 :             int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3258 :             int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3259 :             int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3260 :             int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3261 :             int16x8_t rws = vaddq_s16(yws, cr0);
; 3262 :             int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3263 :             int16x8_t bws = vaddq_s16(yws, cb1);
; 3264 : 
; 3265 :             // undo scaling, round, convert to byte
; 3266 :             uint8x8x4_t o;
; 3267 :             o.val[0] = vqrshrun_n_s16(rws, 4);
; 3268 :             o.val[1] = vqrshrun_n_s16(gws, 4);
; 3269 :             o.val[2] = vqrshrun_n_s16(bws, 4);
; 3270 :             o.val[3] = vdup_n_u8(255);
; 3271 : 
; 3272 :             // store, interleaving r/g/b/a
; 3273 :             vst4_u8(out, o);
; 3274 :             out += 8 * 4;
; 3275 :         }
; 3276 :     }
; 3277 : #endif
; 3278 : 
; 3279 :     for (; i < count; ++i) {

  0036a	eb 08		 jmp	 SHORT $LN7@stbi__YCbC
$LN5@stbi__YCbC:
  0036c	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0036f	ff c0		 inc	 eax
  00371	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__YCbC:
  00374	8b 85 50 0a 00
	00		 mov	 eax, DWORD PTR count$[rbp]
  0037a	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  0037d	0f 8d e1 01 00
	00		 jge	 $LN6@stbi__YCbC

; 3280 :         int y_fixed = (y[i] << 20) + (1 << 19); // rounding

  00383	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00387	48 8b 8d 38 0a
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  0038e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00392	c1 e0 14	 shl	 eax, 20
  00395	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  0039a	89 85 54 06 00
	00		 mov	 DWORD PTR y_fixed$34[rbp], eax

; 3281 :         int r, g, b;
; 3282 :         int cr = pcr[i] - 128;

  003a0	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  003a4	48 8b 8d 48 0a
	00 00		 mov	 rcx, QWORD PTR pcr$[rbp]
  003ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003af	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  003b4	89 85 d4 06 00
	00		 mov	 DWORD PTR cr$38[rbp], eax

; 3283 :         int cb = pcb[i] - 128;

  003ba	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  003be	48 8b 8d 40 0a
	00 00		 mov	 rcx, QWORD PTR pcb$[rbp]
  003c5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c9	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  003ce	89 85 f4 06 00
	00		 mov	 DWORD PTR cb$39[rbp], eax

; 3284 :         r = y_fixed + cr * stbi__float2fixed(1.40200f);

  003d4	69 85 d4 06 00
	00 00 6f 16 00	 imul	 eax, DWORD PTR cr$38[rbp], 1470208 ; 00166f00H
  003de	8b 8d 54 06 00
	00		 mov	 ecx, DWORD PTR y_fixed$34[rbp]
  003e4	03 c8		 add	 ecx, eax
  003e6	8b c1		 mov	 eax, ecx
  003e8	89 85 74 06 00
	00		 mov	 DWORD PTR r$35[rbp], eax

; 3285 :         g = y_fixed + cr * -stbi__float2fixed(0.71414f) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);

  003ee	69 85 d4 06 00
	00 00 93 f4 ff	 imul	 eax, DWORD PTR cr$38[rbp], -748800 ; fffffffffff49300H
  003f8	8b 8d 54 06 00
	00		 mov	 ecx, DWORD PTR y_fixed$34[rbp]
  003fe	03 c8		 add	 ecx, eax
  00400	8b c1		 mov	 eax, ecx
  00402	69 8d f4 06 00
	00 00 7e fa ff	 imul	 ecx, DWORD PTR cb$39[rbp], -360960 ; fffffffffffa7e00H
  0040c	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00412	03 c1		 add	 eax, ecx
  00414	89 85 94 06 00
	00		 mov	 DWORD PTR g$36[rbp], eax

; 3286 :         b = y_fixed + cb * stbi__float2fixed(1.77200f);

  0041a	69 85 f4 06 00
	00 00 5a 1c 00	 imul	 eax, DWORD PTR cb$39[rbp], 1858048 ; 001c5a00H
  00424	8b 8d 54 06 00
	00		 mov	 ecx, DWORD PTR y_fixed$34[rbp]
  0042a	03 c8		 add	 ecx, eax
  0042c	8b c1		 mov	 eax, ecx
  0042e	89 85 b4 06 00
	00		 mov	 DWORD PTR b$37[rbp], eax

; 3287 :         r >>= 20;

  00434	8b 85 74 06 00
	00		 mov	 eax, DWORD PTR r$35[rbp]
  0043a	c1 f8 14	 sar	 eax, 20
  0043d	89 85 74 06 00
	00		 mov	 DWORD PTR r$35[rbp], eax

; 3288 :         g >>= 20;

  00443	8b 85 94 06 00
	00		 mov	 eax, DWORD PTR g$36[rbp]
  00449	c1 f8 14	 sar	 eax, 20
  0044c	89 85 94 06 00
	00		 mov	 DWORD PTR g$36[rbp], eax

; 3289 :         b >>= 20;

  00452	8b 85 b4 06 00
	00		 mov	 eax, DWORD PTR b$37[rbp]
  00458	c1 f8 14	 sar	 eax, 20
  0045b	89 85 b4 06 00
	00		 mov	 DWORD PTR b$37[rbp], eax

; 3290 :         if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }

  00461	81 bd 74 06 00
	00 ff 00 00 00	 cmp	 DWORD PTR r$35[rbp], 255 ; 000000ffH
  0046b	76 1f		 jbe	 SHORT $LN9@stbi__YCbC
  0046d	83 bd 74 06 00
	00 00		 cmp	 DWORD PTR r$35[rbp], 0
  00474	7d 0c		 jge	 SHORT $LN10@stbi__YCbC
  00476	c7 85 74 06 00
	00 00 00 00 00	 mov	 DWORD PTR r$35[rbp], 0
  00480	eb 0a		 jmp	 SHORT $LN11@stbi__YCbC
$LN10@stbi__YCbC:
  00482	c7 85 74 06 00
	00 ff 00 00 00	 mov	 DWORD PTR r$35[rbp], 255 ; 000000ffH
$LN11@stbi__YCbC:
$LN9@stbi__YCbC:

; 3291 :         if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }

  0048c	81 bd 94 06 00
	00 ff 00 00 00	 cmp	 DWORD PTR g$36[rbp], 255 ; 000000ffH
  00496	76 1f		 jbe	 SHORT $LN12@stbi__YCbC
  00498	83 bd 94 06 00
	00 00		 cmp	 DWORD PTR g$36[rbp], 0
  0049f	7d 0c		 jge	 SHORT $LN13@stbi__YCbC
  004a1	c7 85 94 06 00
	00 00 00 00 00	 mov	 DWORD PTR g$36[rbp], 0
  004ab	eb 0a		 jmp	 SHORT $LN14@stbi__YCbC
$LN13@stbi__YCbC:
  004ad	c7 85 94 06 00
	00 ff 00 00 00	 mov	 DWORD PTR g$36[rbp], 255 ; 000000ffH
$LN14@stbi__YCbC:
$LN12@stbi__YCbC:

; 3292 :         if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }

  004b7	81 bd b4 06 00
	00 ff 00 00 00	 cmp	 DWORD PTR b$37[rbp], 255 ; 000000ffH
  004c1	76 1f		 jbe	 SHORT $LN15@stbi__YCbC
  004c3	83 bd b4 06 00
	00 00		 cmp	 DWORD PTR b$37[rbp], 0
  004ca	7d 0c		 jge	 SHORT $LN16@stbi__YCbC
  004cc	c7 85 b4 06 00
	00 00 00 00 00	 mov	 DWORD PTR b$37[rbp], 0
  004d6	eb 0a		 jmp	 SHORT $LN17@stbi__YCbC
$LN16@stbi__YCbC:
  004d8	c7 85 b4 06 00
	00 ff 00 00 00	 mov	 DWORD PTR b$37[rbp], 255 ; 000000ffH
$LN17@stbi__YCbC:
$LN15@stbi__YCbC:

; 3293 :         out[0] = (stbi_uc)r;

  004e2	b8 01 00 00 00	 mov	 eax, 1
  004e7	48 6b c0 00	 imul	 rax, rax, 0
  004eb	48 8b 8d 30 0a
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  004f2	0f b6 95 74 06
	00 00		 movzx	 edx, BYTE PTR r$35[rbp]
  004f9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3294 :         out[1] = (stbi_uc)g;

  004fc	b8 01 00 00 00	 mov	 eax, 1
  00501	48 6b c0 01	 imul	 rax, rax, 1
  00505	48 8b 8d 30 0a
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0050c	0f b6 95 94 06
	00 00		 movzx	 edx, BYTE PTR g$36[rbp]
  00513	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3295 :         out[2] = (stbi_uc)b;

  00516	b8 01 00 00 00	 mov	 eax, 1
  0051b	48 6b c0 02	 imul	 rax, rax, 2
  0051f	48 8b 8d 30 0a
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00526	0f b6 95 b4 06
	00 00		 movzx	 edx, BYTE PTR b$37[rbp]
  0052d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3296 :         out[3] = 255;

  00530	b8 01 00 00 00	 mov	 eax, 1
  00535	48 6b c0 03	 imul	 rax, rax, 3
  00539	48 8b 8d 30 0a
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00540	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3297 :         out += step;

  00544	48 63 85 58 0a
	00 00		 movsxd	 rax, DWORD PTR step$[rbp]
  0054b	48 8b 8d 30 0a
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00552	48 03 c8	 add	 rcx, rax
  00555	48 8b c1	 mov	 rax, rcx
  00558	48 89 85 30 0a
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 3298 :     }

  0055f	e9 08 fe ff ff	 jmp	 $LN5@stbi__YCbC
$LN6@stbi__YCbC:

; 3299 : }

  00564	48 8d a5 18 0a
	00 00		 lea	 rsp, QWORD PTR [rbp+2584]
  0056b	5f		 pop	 rdi
  0056c	5d		 pop	 rbp
  0056d	c3		 ret	 0
stbi__YCbCr_to_RGB_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__YCbCr_to_RGB_row
_TEXT	SEGMENT
i$ = 4
y_fixed$1 = 36
r$2 = 68
g$3 = 100
b$4 = 132
cr$5 = 164
cb$6 = 196
out$ = 448
y$ = 456
pcb$ = 464
pcr$ = 472
count$ = 480
step$ = 488
stbi__YCbCr_to_RGB_row PROC				; COMDAT

; 3143 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3144 :     int i;
; 3145 :     for (i = 0; i < count; ++i) {

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00035	eb 08		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00037	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0003a	ff c0		 inc	 eax
  0003c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__YCbC:
  0003f	8b 85 e0 01 00
	00		 mov	 eax, DWORD PTR count$[rbp]
  00045	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00048	0f 8d a5 01 00
	00		 jge	 $LN3@stbi__YCbC

; 3146 :         int y_fixed = (y[i] << 20) + (1 << 19); // rounding

  0004e	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00052	48 8b 8d c8 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  00059	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005d	c1 e0 14	 shl	 eax, 20
  00060	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  00065	89 45 24	 mov	 DWORD PTR y_fixed$1[rbp], eax

; 3147 :         int r, g, b;
; 3148 :         int cr = pcr[i] - 128;

  00068	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0006c	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR pcr$[rbp]
  00073	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00077	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0007c	89 85 a4 00 00
	00		 mov	 DWORD PTR cr$5[rbp], eax

; 3149 :         int cb = pcb[i] - 128;

  00082	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00086	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR pcb$[rbp]
  0008d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00091	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00096	89 85 c4 00 00
	00		 mov	 DWORD PTR cb$6[rbp], eax

; 3150 :         r = y_fixed + cr * stbi__float2fixed(1.40200f);

  0009c	69 85 a4 00 00
	00 00 6f 16 00	 imul	 eax, DWORD PTR cr$5[rbp], 1470208 ; 00166f00H
  000a6	8b 4d 24	 mov	 ecx, DWORD PTR y_fixed$1[rbp]
  000a9	03 c8		 add	 ecx, eax
  000ab	8b c1		 mov	 eax, ecx
  000ad	89 45 44	 mov	 DWORD PTR r$2[rbp], eax

; 3151 :         g = y_fixed + (cr * -stbi__float2fixed(0.71414f)) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);

  000b0	69 85 a4 00 00
	00 00 93 f4 ff	 imul	 eax, DWORD PTR cr$5[rbp], -748800 ; fffffffffff49300H
  000ba	8b 4d 24	 mov	 ecx, DWORD PTR y_fixed$1[rbp]
  000bd	03 c8		 add	 ecx, eax
  000bf	8b c1		 mov	 eax, ecx
  000c1	69 8d c4 00 00
	00 00 7e fa ff	 imul	 ecx, DWORD PTR cb$6[rbp], -360960 ; fffffffffffa7e00H
  000cb	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  000d1	03 c1		 add	 eax, ecx
  000d3	89 45 64	 mov	 DWORD PTR g$3[rbp], eax

; 3152 :         b = y_fixed + cb * stbi__float2fixed(1.77200f);

  000d6	69 85 c4 00 00
	00 00 5a 1c 00	 imul	 eax, DWORD PTR cb$6[rbp], 1858048 ; 001c5a00H
  000e0	8b 4d 24	 mov	 ecx, DWORD PTR y_fixed$1[rbp]
  000e3	03 c8		 add	 ecx, eax
  000e5	8b c1		 mov	 eax, ecx
  000e7	89 85 84 00 00
	00		 mov	 DWORD PTR b$4[rbp], eax

; 3153 :         r >>= 20;

  000ed	8b 45 44	 mov	 eax, DWORD PTR r$2[rbp]
  000f0	c1 f8 14	 sar	 eax, 20
  000f3	89 45 44	 mov	 DWORD PTR r$2[rbp], eax

; 3154 :         g >>= 20;

  000f6	8b 45 64	 mov	 eax, DWORD PTR g$3[rbp]
  000f9	c1 f8 14	 sar	 eax, 20
  000fc	89 45 64	 mov	 DWORD PTR g$3[rbp], eax

; 3155 :         b >>= 20;

  000ff	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR b$4[rbp]
  00105	c1 f8 14	 sar	 eax, 20
  00108	89 85 84 00 00
	00		 mov	 DWORD PTR b$4[rbp], eax

; 3156 :         if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }

  0010e	81 7d 44 ff 00
	00 00		 cmp	 DWORD PTR r$2[rbp], 255	; 000000ffH
  00115	76 16		 jbe	 SHORT $LN5@stbi__YCbC
  00117	83 7d 44 00	 cmp	 DWORD PTR r$2[rbp], 0
  0011b	7d 09		 jge	 SHORT $LN6@stbi__YCbC
  0011d	c7 45 44 00 00
	00 00		 mov	 DWORD PTR r$2[rbp], 0
  00124	eb 07		 jmp	 SHORT $LN7@stbi__YCbC
$LN6@stbi__YCbC:
  00126	c7 45 44 ff 00
	00 00		 mov	 DWORD PTR r$2[rbp], 255	; 000000ffH
$LN7@stbi__YCbC:
$LN5@stbi__YCbC:

; 3157 :         if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }

  0012d	81 7d 64 ff 00
	00 00		 cmp	 DWORD PTR g$3[rbp], 255	; 000000ffH
  00134	76 16		 jbe	 SHORT $LN8@stbi__YCbC
  00136	83 7d 64 00	 cmp	 DWORD PTR g$3[rbp], 0
  0013a	7d 09		 jge	 SHORT $LN9@stbi__YCbC
  0013c	c7 45 64 00 00
	00 00		 mov	 DWORD PTR g$3[rbp], 0
  00143	eb 07		 jmp	 SHORT $LN10@stbi__YCbC
$LN9@stbi__YCbC:
  00145	c7 45 64 ff 00
	00 00		 mov	 DWORD PTR g$3[rbp], 255	; 000000ffH
$LN10@stbi__YCbC:
$LN8@stbi__YCbC:

; 3158 :         if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }

  0014c	81 bd 84 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR b$4[rbp], 255	; 000000ffH
  00156	76 1f		 jbe	 SHORT $LN11@stbi__YCbC
  00158	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR b$4[rbp], 0
  0015f	7d 0c		 jge	 SHORT $LN12@stbi__YCbC
  00161	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR b$4[rbp], 0
  0016b	eb 0a		 jmp	 SHORT $LN13@stbi__YCbC
$LN12@stbi__YCbC:
  0016d	c7 85 84 00 00
	00 ff 00 00 00	 mov	 DWORD PTR b$4[rbp], 255	; 000000ffH
$LN13@stbi__YCbC:
$LN11@stbi__YCbC:

; 3159 :         out[0] = (stbi_uc)r;

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00187	0f b6 55 44	 movzx	 edx, BYTE PTR r$2[rbp]
  0018b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3160 :         out[1] = (stbi_uc)g;

  0018e	b8 01 00 00 00	 mov	 eax, 1
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0019e	0f b6 55 64	 movzx	 edx, BYTE PTR g$3[rbp]
  001a2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3161 :         out[2] = (stbi_uc)b;

  001a5	b8 01 00 00 00	 mov	 eax, 1
  001aa	48 6b c0 02	 imul	 rax, rax, 2
  001ae	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  001b5	0f b6 95 84 00
	00 00		 movzx	 edx, BYTE PTR b$4[rbp]
  001bc	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3162 :         out[3] = 255;

  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	48 6b c0 03	 imul	 rax, rax, 3
  001c8	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  001cf	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3163 :         out += step;

  001d3	48 63 85 e8 01
	00 00		 movsxd	 rax, DWORD PTR step$[rbp]
  001da	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  001e1	48 03 c8	 add	 rcx, rax
  001e4	48 8b c1	 mov	 rax, rcx
  001e7	48 89 85 c0 01
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 3164 :     }

  001ee	e9 44 fe ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:

; 3165 : }

  001f3	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  001fa	5f		 pop	 rdi
  001fb	5d		 pop	 rbp
  001fc	c3		 ret	 0
stbi__YCbCr_to_RGB_row ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__resample_row_generic
_TEXT	SEGMENT
i$ = 4
j$ = 36
out$ = 288
in_near$ = 296
in_far$ = 304
w$ = 312
hs$ = 320
stbi__resample_row_generic PROC				; COMDAT

; 3129 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3130 :     // resample with nearest-neighbor
; 3131 :     int i, j;
; 3132 :     STBI_NOTUSED(in_far);
; 3133 :     for (i = 0; i < w; ++i)

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00035	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00037	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0003a	ff c0		 inc	 eax
  0003c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__resa:
  0003f	8b 85 38 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00045	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00048	7d 4a		 jge	 SHORT $LN3@stbi__resa

; 3134 :         for (j = 0; j < hs; ++j)

  0004a	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  00051	eb 08		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  00053	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00056	ff c0		 inc	 eax
  00058	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN7@stbi__resa:
  0005b	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR hs$[rbp]
  00061	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  00064	7d 2c		 jge	 SHORT $LN6@stbi__resa

; 3135 :             out[i * hs + j] = in_near[i];

  00066	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0006a	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  0006d	0f af 8d 40 01
	00 00		 imul	 ecx, DWORD PTR hs$[rbp]
  00074	03 4d 24	 add	 ecx, DWORD PTR j$[rbp]
  00077	48 63 c9	 movsxd	 rcx, ecx
  0007a	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00081	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR in_near$[rbp]
  00088	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0008d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00090	eb c1		 jmp	 SHORT $LN5@stbi__resa
$LN6@stbi__resa:
  00092	eb a3		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3136 :     return out;

  00094	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]

; 3137 : }

  0009b	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000a2	5f		 pop	 rdi
  000a3	5d		 pop	 rbp
  000a4	c3		 ret	 0
stbi__resample_row_generic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__resample_row_hv_2_simd
_TEXT	SEGMENT
i$ = 4
t0$ = 36
t1$ = 68
zero$1 = 112
farb$2 = 160
nearb$3 = 208
farw$4 = 256
nearw$5 = 304
diff$6 = 352
nears$7 = 400
curr$8 = 448
prv0$9 = 496
nxt0$10 = 544
prev$11 = 592
next$12 = 640
bias$13 = 688
curs$14 = 736
prvd$15 = 784
nxtd$16 = 832
curb$17 = 880
even$18 = 928
odd$19 = 976
int0$20 = 1024
int1$21 = 1072
de0$22 = 1120
de1$23 = 1168
outv$24 = 1216
tv78 = 1812
out$ = 1856
in_near$ = 1864
in_far$ = 1872
w$ = 1880
hs$ = 1888
stbi__resample_row_hv_2_simd PROC			; COMDAT

; 3013 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 07
	00 00		 sub	 rsp, 1864		; 00000748H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3014 :     // need to generate 2x2 samples for every one in input
; 3015 :     int i = 0, t0, t1;

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0

; 3016 : 
; 3017 :     if (w == 1) {

  00035	83 bd 58 07 00
	00 01		 cmp	 DWORD PTR w$[rbp], 1
  0003c	75 78		 jne	 SHORT $LN8@stbi__resa

; 3018 :         out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	6b c0 03	 imul	 eax, eax, 3
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	48 6b c9 00	 imul	 rcx, rcx, 0
  0005e	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  00065	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00069	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 85 14 07 00
	00		 mov	 DWORD PTR tv78[rbp], eax
  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	48 6b c0 01	 imul	 rax, rax, 1
  0007f	48 8b 8d 40 07
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00086	0f b6 95 14 07
	00 00		 movzx	 edx, BYTE PTR tv78[rbp]
  0008d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 8d 40 07
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  000a0	0f b6 95 14 07
	00 00		 movzx	 edx, BYTE PTR tv78[rbp]
  000a7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3019 :         return out;

  000aa	48 8b 85 40 07
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  000b1	e9 e8 03 00 00	 jmp	 $LN1@stbi__resa
$LN8@stbi__resa:

; 3020 :     }
; 3021 : 
; 3022 :     t1 = 3 * in_near[0] + in_far[0];

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	48 6b c0 00	 imul	 rax, rax, 0
  000bf	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  000c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ca	6b c0 03	 imul	 eax, eax, 3
  000cd	b9 01 00 00 00	 mov	 ecx, 1
  000d2	48 6b c9 00	 imul	 rcx, rcx, 0
  000d6	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  000dd	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000e1	03 c1		 add	 eax, ecx
  000e3	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 3023 :     // process groups of 8 pixels for as long as we can.
; 3024 :     // note we can't handle the last pixel in a row in this loop
; 3025 :     // because we need to handle the filter boundary conditions.
; 3026 :     for (; i < ((w - 1) & ~7); i += 8) {

  000e6	eb 09		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000e8	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000eb	83 c0 08	 add	 eax, 8
  000ee	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__resa:
  000f1	8b 85 58 07 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  000f7	ff c8		 dec	 eax
  000f9	83 e0 f8	 and	 eax, -8
  000fc	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000ff	0f 8d 96 02 00
	00		 jge	 $LN3@stbi__resa

; 3027 : #if defined(STBI_SSE2)
; 3028 :         // load and perform the vertical filtering pass
; 3029 :         // this uses 3*x + y = 4*x + (y - x)
; 3030 :         __m128i zero = _mm_setzero_si128();

  00105	66 0f ef c0	 pxor	 xmm0, xmm0
  00109	66 0f 7f 45 70	 movdqa	 XMMWORD PTR zero$1[rbp], xmm0

; 3031 :         __m128i farb = _mm_loadl_epi64((__m128i*) (in_far + i));

  0010e	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00112	48 8b 8d 50 07
	00 00		 mov	 rcx, QWORD PTR in_far$[rbp]
  00119	48 03 c8	 add	 rcx, rax
  0011c	48 8b c1	 mov	 rax, rcx
  0011f	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00123	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR farb$2[rbp], xmm0

; 3032 :         __m128i nearb = _mm_loadl_epi64((__m128i*) (in_near + i));

  0012b	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0012f	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00136	48 03 c8	 add	 rcx, rax
  00139	48 8b c1	 mov	 rax, rcx
  0013c	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00140	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR nearb$3[rbp], xmm0

; 3033 :         __m128i farw = _mm_unpacklo_epi8(farb, zero);

  00148	66 0f 6f 85 a0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR farb$2[rbp]
  00150	66 0f 60 45 70	 punpcklbw xmm0, XMMWORD PTR zero$1[rbp]
  00155	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR farw$4[rbp], xmm0

; 3034 :         __m128i nearw = _mm_unpacklo_epi8(nearb, zero);

  0015d	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR nearb$3[rbp]
  00165	66 0f 60 45 70	 punpcklbw xmm0, XMMWORD PTR zero$1[rbp]
  0016a	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR nearw$5[rbp], xmm0

; 3035 :         __m128i diff = _mm_sub_epi16(farw, nearw);

  00172	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR farw$4[rbp]
  0017a	66 0f f9 85 30
	01 00 00	 psubw	 xmm0, XMMWORD PTR nearw$5[rbp]
  00182	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR diff$6[rbp], xmm0

; 3036 :         __m128i nears = _mm_slli_epi16(nearw, 2);

  0018a	66 0f 6f 85 30
	01 00 00	 movdqa	 xmm0, XMMWORD PTR nearw$5[rbp]
  00192	66 0f 71 f0 02	 psllw	 xmm0, 2
  00197	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR nears$7[rbp], xmm0

; 3037 :         __m128i curr = _mm_add_epi16(nears, diff); // current row

  0019f	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR nears$7[rbp]
  001a7	66 0f fd 85 60
	01 00 00	 paddw	 xmm0, XMMWORD PTR diff$6[rbp]
  001af	66 0f 7f 85 c0
	01 00 00	 movdqa	 XMMWORD PTR curr$8[rbp], xmm0

; 3038 : 
; 3039 :         // horizontal filter works the same based on shifted vers of current
; 3040 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3041 :         // insert the previous pixel value (from t1).
; 3042 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3043 :         // of next block of 8 pixels added in.
; 3044 :         __m128i prv0 = _mm_slli_si128(curr, 2);

  001b7	66 0f 6f 85 c0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rbp]
  001bf	66 0f 73 f8 02	 pslldq	 xmm0, 2
  001c4	66 0f 7f 85 f0
	01 00 00	 movdqa	 XMMWORD PTR prv0$9[rbp], xmm0

; 3045 :         __m128i nxt0 = _mm_srli_si128(curr, 2);

  001cc	66 0f 6f 85 c0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rbp]
  001d4	66 0f 73 d8 02	 psrldq	 xmm0, 2
  001d9	66 0f 7f 85 20
	02 00 00	 movdqa	 XMMWORD PTR nxt0$10[rbp], xmm0

; 3046 :         __m128i prev = _mm_insert_epi16(prv0, t1, 0);

  001e1	66 0f 6f 85 f0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR prv0$9[rbp]
  001e9	66 0f c4 45 44
	00		 pinsrw	 xmm0, DWORD PTR t1$[rbp], 0
  001ef	66 0f 7f 85 50
	02 00 00	 movdqa	 XMMWORD PTR prev$11[rbp], xmm0

; 3047 :         __m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);

  001f7	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001fa	83 c0 08	 add	 eax, 8
  001fd	48 98		 cdqe
  001ff	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00206	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020a	6b c0 03	 imul	 eax, eax, 3
  0020d	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00210	83 c1 08	 add	 ecx, 8
  00213	48 63 c9	 movsxd	 rcx, ecx
  00216	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  0021d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00221	03 c1		 add	 eax, ecx
  00223	66 0f 6f 85 20
	02 00 00	 movdqa	 xmm0, XMMWORD PTR nxt0$10[rbp]
  0022b	66 0f c4 c0 07	 pinsrw	 xmm0, eax, 7
  00230	66 0f 7f 85 80
	02 00 00	 movdqa	 XMMWORD PTR next$12[rbp], xmm0

; 3048 : 
; 3049 :         // horizontal filter, polyphase implementation since it's convenient:
; 3050 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3051 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3052 :         // note the shared term.
; 3053 :         __m128i bias = _mm_set1_epi16(8);

  00238	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
  00240	66 0f 7f 85 b0
	02 00 00	 movdqa	 XMMWORD PTR bias$13[rbp], xmm0

; 3054 :         __m128i curs = _mm_slli_epi16(curr, 2);

  00248	66 0f 6f 85 c0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rbp]
  00250	66 0f 71 f0 02	 psllw	 xmm0, 2
  00255	66 0f 7f 85 e0
	02 00 00	 movdqa	 XMMWORD PTR curs$14[rbp], xmm0

; 3055 :         __m128i prvd = _mm_sub_epi16(prev, curr);

  0025d	66 0f 6f 85 50
	02 00 00	 movdqa	 xmm0, XMMWORD PTR prev$11[rbp]
  00265	66 0f f9 85 c0
	01 00 00	 psubw	 xmm0, XMMWORD PTR curr$8[rbp]
  0026d	66 0f 7f 85 10
	03 00 00	 movdqa	 XMMWORD PTR prvd$15[rbp], xmm0

; 3056 :         __m128i nxtd = _mm_sub_epi16(next, curr);

  00275	66 0f 6f 85 80
	02 00 00	 movdqa	 xmm0, XMMWORD PTR next$12[rbp]
  0027d	66 0f f9 85 c0
	01 00 00	 psubw	 xmm0, XMMWORD PTR curr$8[rbp]
  00285	66 0f 7f 85 40
	03 00 00	 movdqa	 XMMWORD PTR nxtd$16[rbp], xmm0

; 3057 :         __m128i curb = _mm_add_epi16(curs, bias);

  0028d	66 0f 6f 85 e0
	02 00 00	 movdqa	 xmm0, XMMWORD PTR curs$14[rbp]
  00295	66 0f fd 85 b0
	02 00 00	 paddw	 xmm0, XMMWORD PTR bias$13[rbp]
  0029d	66 0f 7f 85 70
	03 00 00	 movdqa	 XMMWORD PTR curb$17[rbp], xmm0

; 3058 :         __m128i even = _mm_add_epi16(prvd, curb);

  002a5	66 0f 6f 85 10
	03 00 00	 movdqa	 xmm0, XMMWORD PTR prvd$15[rbp]
  002ad	66 0f fd 85 70
	03 00 00	 paddw	 xmm0, XMMWORD PTR curb$17[rbp]
  002b5	66 0f 7f 85 a0
	03 00 00	 movdqa	 XMMWORD PTR even$18[rbp], xmm0

; 3059 :         __m128i odd = _mm_add_epi16(nxtd, curb);

  002bd	66 0f 6f 85 40
	03 00 00	 movdqa	 xmm0, XMMWORD PTR nxtd$16[rbp]
  002c5	66 0f fd 85 70
	03 00 00	 paddw	 xmm0, XMMWORD PTR curb$17[rbp]
  002cd	66 0f 7f 85 d0
	03 00 00	 movdqa	 XMMWORD PTR odd$19[rbp], xmm0

; 3060 : 
; 3061 :         // interleave even and odd pixels, then undo scaling.
; 3062 :         __m128i int0 = _mm_unpacklo_epi16(even, odd);

  002d5	66 0f 6f 85 a0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR even$18[rbp]
  002dd	66 0f 61 85 d0
	03 00 00	 punpcklwd xmm0, XMMWORD PTR odd$19[rbp]
  002e5	66 0f 7f 85 00
	04 00 00	 movdqa	 XMMWORD PTR int0$20[rbp], xmm0

; 3063 :         __m128i int1 = _mm_unpackhi_epi16(even, odd);

  002ed	66 0f 6f 85 a0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR even$18[rbp]
  002f5	66 0f 69 85 d0
	03 00 00	 punpckhwd xmm0, XMMWORD PTR odd$19[rbp]
  002fd	66 0f 7f 85 30
	04 00 00	 movdqa	 XMMWORD PTR int1$21[rbp], xmm0

; 3064 :         __m128i de0 = _mm_srli_epi16(int0, 4);

  00305	66 0f 6f 85 00
	04 00 00	 movdqa	 xmm0, XMMWORD PTR int0$20[rbp]
  0030d	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00312	66 0f 7f 85 60
	04 00 00	 movdqa	 XMMWORD PTR de0$22[rbp], xmm0

; 3065 :         __m128i de1 = _mm_srli_epi16(int1, 4);

  0031a	66 0f 6f 85 30
	04 00 00	 movdqa	 xmm0, XMMWORD PTR int1$21[rbp]
  00322	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00327	66 0f 7f 85 90
	04 00 00	 movdqa	 XMMWORD PTR de1$23[rbp], xmm0

; 3066 : 
; 3067 :         // pack and write output
; 3068 :         __m128i outv = _mm_packus_epi16(de0, de1);

  0032f	66 0f 6f 85 60
	04 00 00	 movdqa	 xmm0, XMMWORD PTR de0$22[rbp]
  00337	66 0f 67 85 90
	04 00 00	 packuswb xmm0, XMMWORD PTR de1$23[rbp]
  0033f	66 0f 7f 85 c0
	04 00 00	 movdqa	 XMMWORD PTR outv$24[rbp], xmm0

; 3069 :         _mm_storeu_si128((__m128i*) (out + i * 2), outv);

  00347	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0034a	03 c0		 add	 eax, eax
  0034c	48 98		 cdqe
  0034e	48 8b 8d 40 07
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00355	48 03 c8	 add	 rcx, rax
  00358	48 8b c1	 mov	 rax, rcx
  0035b	66 0f 6f 85 c0
	04 00 00	 movdqa	 xmm0, XMMWORD PTR outv$24[rbp]
  00363	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3070 : #elif defined(STBI_NEON)
; 3071 :         // load and perform the vertical filtering pass
; 3072 :         // this uses 3*x + y = 4*x + (y - x)
; 3073 :         uint8x8_t farb = vld1_u8(in_far + i);
; 3074 :         uint8x8_t nearb = vld1_u8(in_near + i);
; 3075 :         int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3076 :         int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3077 :         int16x8_t curr = vaddq_s16(nears, diff); // current row
; 3078 : 
; 3079 :         // horizontal filter works the same based on shifted vers of current
; 3080 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3081 :         // insert the previous pixel value (from t1).
; 3082 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3083 :         // of next block of 8 pixels added in.
; 3084 :         int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3085 :         int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3086 :         int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3087 :         int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);
; 3088 : 
; 3089 :         // horizontal filter, polyphase implementation since it's convenient:
; 3090 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3091 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3092 :         // note the shared term.
; 3093 :         int16x8_t curs = vshlq_n_s16(curr, 2);
; 3094 :         int16x8_t prvd = vsubq_s16(prev, curr);
; 3095 :         int16x8_t nxtd = vsubq_s16(next, curr);
; 3096 :         int16x8_t even = vaddq_s16(curs, prvd);
; 3097 :         int16x8_t odd = vaddq_s16(curs, nxtd);
; 3098 : 
; 3099 :         // undo scaling and round, then store with even/odd phases interleaved
; 3100 :         uint8x8x2_t o;
; 3101 :         o.val[0] = vqrshrun_n_s16(even, 4);
; 3102 :         o.val[1] = vqrshrun_n_s16(odd, 4);
; 3103 :         vst2_u8(out + i * 2, o);
; 3104 : #endif
; 3105 : 
; 3106 :         // "previous" value for next iter
; 3107 :         t1 = 3 * in_near[i + 7] + in_far[i + 7];

  00367	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0036a	83 c0 07	 add	 eax, 7
  0036d	48 98		 cdqe
  0036f	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00376	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0037a	6b c0 03	 imul	 eax, eax, 3
  0037d	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00380	83 c1 07	 add	 ecx, 7
  00383	48 63 c9	 movsxd	 rcx, ecx
  00386	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  0038d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00391	03 c1		 add	 eax, ecx
  00393	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 3108 :     }

  00396	e9 4d fd ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3109 : 
; 3110 :     t0 = t1;

  0039b	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  0039e	89 45 24	 mov	 DWORD PTR t0$[rbp], eax

; 3111 :     t1 = 3 * in_near[i] + in_far[i];

  003a1	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  003a5	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  003ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b0	6b c0 03	 imul	 eax, eax, 3
  003b3	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  003b7	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  003be	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003c2	03 c1		 add	 eax, ecx
  003c4	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 3112 :     out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

  003c7	6b 45 44 03	 imul	 eax, DWORD PTR t1$[rbp], 3
  003cb	8b 4d 24	 mov	 ecx, DWORD PTR t0$[rbp]
  003ce	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  003d2	c1 f8 04	 sar	 eax, 4
  003d5	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  003d8	03 c9		 add	 ecx, ecx
  003da	48 63 c9	 movsxd	 rcx, ecx
  003dd	48 8b 95 40 07
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  003e4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3113 : 
; 3114 :     for (++i; i < w; ++i) {

  003e7	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  003ea	ff c0		 inc	 eax
  003ec	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  003ef	eb 08		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  003f1	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  003f4	ff c0		 inc	 eax
  003f6	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__resa:
  003f9	8b 85 58 07 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  003ff	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00402	7d 73		 jge	 SHORT $LN6@stbi__resa

; 3115 :         t0 = t1;

  00404	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  00407	89 45 24	 mov	 DWORD PTR t0$[rbp], eax

; 3116 :         t1 = 3 * in_near[i] + in_far[i];

  0040a	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0040e	48 8b 8d 48 07
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00415	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00419	6b c0 03	 imul	 eax, eax, 3
  0041c	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00420	48 8b 95 50 07
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  00427	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0042b	03 c1		 add	 eax, ecx
  0042d	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 3117 :         out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);

  00430	6b 45 24 03	 imul	 eax, DWORD PTR t0$[rbp], 3
  00434	8b 4d 44	 mov	 ecx, DWORD PTR t1$[rbp]
  00437	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  0043b	c1 f8 04	 sar	 eax, 4
  0043e	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00441	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  00445	48 63 c9	 movsxd	 rcx, ecx
  00448	48 8b 95 40 07
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0044f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3118 :         out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

  00452	6b 45 44 03	 imul	 eax, DWORD PTR t1$[rbp], 3
  00456	8b 4d 24	 mov	 ecx, DWORD PTR t0$[rbp]
  00459	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  0045d	c1 f8 04	 sar	 eax, 4
  00460	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00463	d1 e1		 shl	 ecx, 1
  00465	48 63 c9	 movsxd	 rcx, ecx
  00468	48 8b 95 40 07
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0046f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3119 :     }

  00472	e9 7a ff ff ff	 jmp	 $LN5@stbi__resa
$LN6@stbi__resa:

; 3120 :     out[w * 2 - 1] = stbi__div4(t1 + 2);

  00477	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  0047a	83 c0 02	 add	 eax, 2
  0047d	c1 f8 02	 sar	 eax, 2
  00480	8b 8d 58 07 00
	00		 mov	 ecx, DWORD PTR w$[rbp]
  00486	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0048a	48 63 c9	 movsxd	 rcx, ecx
  0048d	48 8b 95 40 07
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00494	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3121 : 
; 3122 :     STBI_NOTUSED(hs);
; 3123 : 
; 3124 :     return out;

  00497	48 8b 85 40 07
	00 00		 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__resa:

; 3125 : }

  0049e	48 8d a5 28 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1832]
  004a5	5f		 pop	 rdi
  004a6	5d		 pop	 rbp
  004a7	c3		 ret	 0
stbi__resample_row_hv_2_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__resample_row_hv_2
_TEXT	SEGMENT
i$ = 4
t0$ = 36
t1$ = 68
tv78 = 276
out$ = 320
in_near$ = 328
in_far$ = 336
w$ = 344
hs$ = 352
stbi__resample_row_hv_2 PROC				; COMDAT

; 2988 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2989 :     // need to generate 2x2 samples for every one in input
; 2990 :     int i, t0, t1;
; 2991 :     if (w == 1) {

  0002e	83 bd 58 01 00
	00 01		 cmp	 DWORD PTR w$[rbp], 1
  00035	75 78		 jne	 SHORT $LN5@stbi__resa

; 2992 :         out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00047	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004b	6b c0 03	 imul	 eax, eax, 3
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	48 6b c9 00	 imul	 rcx, rcx, 0
  00057	48 8b 95 50 01
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  0005e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00062	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00066	c1 f8 02	 sar	 eax, 2
  00069	89 85 14 01 00
	00		 mov	 DWORD PTR tv78[rbp], eax
  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	48 6b c0 01	 imul	 rax, rax, 1
  00078	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0007f	0f b6 95 14 01
	00 00		 movzx	 edx, BYTE PTR tv78[rbp]
  00086	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	48 6b c0 00	 imul	 rax, rax, 0
  00092	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00099	0f b6 95 14 01
	00 00		 movzx	 edx, BYTE PTR tv78[rbp]
  000a0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2993 :         return out;

  000a3	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  000aa	e9 02 01 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 2994 :     }
; 2995 : 
; 2996 :     t1 = 3 * in_near[0] + in_far[0];

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	48 6b c0 00	 imul	 rax, rax, 0
  000b8	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  000bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c3	6b c0 03	 imul	 eax, eax, 3
  000c6	b9 01 00 00 00	 mov	 ecx, 1
  000cb	48 6b c9 00	 imul	 rcx, rcx, 0
  000cf	48 8b 95 50 01
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  000d6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000da	03 c1		 add	 eax, ecx
  000dc	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 2997 :     out[0] = stbi__div4(t1 + 2);

  000df	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  000e2	83 c0 02	 add	 eax, 2
  000e5	c1 f8 02	 sar	 eax, 2
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	48 6b c9 00	 imul	 rcx, rcx, 0
  000f1	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  000f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2998 :     for (i = 1; i < w; ++i) {

  000fb	c7 45 04 01 00
	00 00		 mov	 DWORD PTR i$[rbp], 1
  00102	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00104	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00107	ff c0		 inc	 eax
  00109	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__resa:
  0010c	8b 85 58 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00112	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00115	7d 73		 jge	 SHORT $LN3@stbi__resa

; 2999 :         t0 = t1;

  00117	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  0011a	89 45 24	 mov	 DWORD PTR t0$[rbp], eax

; 3000 :         t1 = 3 * in_near[i] + in_far[i];

  0011d	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00121	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00128	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0012c	6b c0 03	 imul	 eax, eax, 3
  0012f	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00133	48 8b 95 50 01
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  0013a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0013e	03 c1		 add	 eax, ecx
  00140	89 45 44	 mov	 DWORD PTR t1$[rbp], eax

; 3001 :         out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);

  00143	6b 45 24 03	 imul	 eax, DWORD PTR t0$[rbp], 3
  00147	8b 4d 44	 mov	 ecx, DWORD PTR t1$[rbp]
  0014a	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  0014e	c1 f8 04	 sar	 eax, 4
  00151	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00154	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  00158	48 63 c9	 movsxd	 rcx, ecx
  0015b	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00162	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3002 :         out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

  00165	6b 45 44 03	 imul	 eax, DWORD PTR t1$[rbp], 3
  00169	8b 4d 24	 mov	 ecx, DWORD PTR t0$[rbp]
  0016c	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00170	c1 f8 04	 sar	 eax, 4
  00173	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00176	d1 e1		 shl	 ecx, 1
  00178	48 63 c9	 movsxd	 rcx, ecx
  0017b	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00182	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3003 :     }

  00185	e9 7a ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3004 :     out[w * 2 - 1] = stbi__div4(t1 + 2);

  0018a	8b 45 44	 mov	 eax, DWORD PTR t1$[rbp]
  0018d	83 c0 02	 add	 eax, 2
  00190	c1 f8 02	 sar	 eax, 2
  00193	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR w$[rbp]
  00199	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0019d	48 63 c9	 movsxd	 rcx, ecx
  001a0	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  001a7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3005 : 
; 3006 :     STBI_NOTUSED(hs);
; 3007 : 
; 3008 :     return out;

  001aa	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__resa:

; 3009 : }

  001b1	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  001b8	5f		 pop	 rdi
  001b9	5d		 pop	 rbp
  001ba	c3		 ret	 0
stbi__resample_row_hv_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__resample_row_h_2
_TEXT	SEGMENT
i$ = 4
input$ = 40
n$1 = 68
out$ = 320
in_near$ = 328
in_far$ = 336
w$ = 344
hs$ = 352
stbi__resample_row_h_2 PROC				; COMDAT

; 2958 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2959 :     // need to generate two samples horizontally for every one in input
; 2960 :     int i;
; 2961 :     stbi_uc* input = in_near;

  0002e	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR in_near$[rbp]
  00035	48 89 45 28	 mov	 QWORD PTR input$[rbp], rax

; 2962 : 
; 2963 :     if (w == 1) {

  00039	83 bd 58 01 00
	00 01		 cmp	 DWORD PTR w$[rbp], 1
  00040	75 59		 jne	 SHORT $LN5@stbi__resa

; 2964 :         // if only one sample, can't do any interpolation
; 2965 :         out[0] = out[1] = input[0];

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	48 6b c0 00	 imul	 rax, rax, 0
  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	48 6b c9 01	 imul	 rcx, rcx, 1
  00054	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0005b	4c 8b 45 28	 mov	 r8, QWORD PTR input$[rbp]
  0005f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00064	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 01	 imul	 rax, rax, 1
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	48 6b c9 00	 imul	 rcx, rcx, 0
  00079	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00080	4c 8b 85 40 01
	00 00		 mov	 r8, QWORD PTR out$[rbp]
  00087	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0008c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2966 :         return out;

  0008f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  00096	e9 64 01 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 2967 :     }
; 2968 : 
; 2969 :     out[0] = input[0];

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	48 6b c0 00	 imul	 rax, rax, 0
  000a4	b9 01 00 00 00	 mov	 ecx, 1
  000a9	48 6b c9 00	 imul	 rcx, rcx, 0
  000ad	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  000b4	4c 8b 45 28	 mov	 r8, QWORD PTR input$[rbp]
  000b8	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000bd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2970 :     out[1] = stbi__div4(input[0] * 3 + input[1] + 2);

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	48 6b c0 00	 imul	 rax, rax, 0
  000c9	48 8b 4d 28	 mov	 rcx, QWORD PTR input$[rbp]
  000cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d1	6b c0 03	 imul	 eax, eax, 3
  000d4	b9 01 00 00 00	 mov	 ecx, 1
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	48 8b 55 28	 mov	 rdx, QWORD PTR input$[rbp]
  000e1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000e5	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  000e9	c1 f8 02	 sar	 eax, 2
  000ec	b9 01 00 00 00	 mov	 ecx, 1
  000f1	48 6b c9 01	 imul	 rcx, rcx, 1
  000f5	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  000fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2971 :     for (i = 1; i < w - 1; ++i) {

  000ff	c7 45 04 01 00
	00 00		 mov	 DWORD PTR i$[rbp], 1
  00106	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00108	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0010b	ff c0		 inc	 eax
  0010d	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__resa:
  00110	8b 85 58 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00116	ff c8		 dec	 eax
  00118	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  0011b	7d 72		 jge	 SHORT $LN3@stbi__resa

; 2972 :         int n = 3 * input[i] + 2;

  0011d	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00121	48 8b 4d 28	 mov	 rcx, QWORD PTR input$[rbp]
  00125	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00129	6b c0 03	 imul	 eax, eax, 3
  0012c	83 c0 02	 add	 eax, 2
  0012f	89 45 44	 mov	 DWORD PTR n$1[rbp], eax

; 2973 :         out[i * 2 + 0] = stbi__div4(n + input[i - 1]);

  00132	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00135	ff c8		 dec	 eax
  00137	48 98		 cdqe
  00139	48 8b 4d 28	 mov	 rcx, QWORD PTR input$[rbp]
  0013d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00141	8b 4d 44	 mov	 ecx, DWORD PTR n$1[rbp]
  00144	03 c8		 add	 ecx, eax
  00146	8b c1		 mov	 eax, ecx
  00148	c1 f8 02	 sar	 eax, 2
  0014b	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  0014e	03 c9		 add	 ecx, ecx
  00150	48 63 c9	 movsxd	 rcx, ecx
  00153	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0015a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2974 :         out[i * 2 + 1] = stbi__div4(n + input[i + 1]);

  0015d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00160	ff c0		 inc	 eax
  00162	48 98		 cdqe
  00164	48 8b 4d 28	 mov	 rcx, QWORD PTR input$[rbp]
  00168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016c	8b 4d 44	 mov	 ecx, DWORD PTR n$1[rbp]
  0016f	03 c8		 add	 ecx, eax
  00171	8b c1		 mov	 eax, ecx
  00173	c1 f8 02	 sar	 eax, 2
  00176	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00179	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  0017d	48 63 c9	 movsxd	 rcx, ecx
  00180	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  00187	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2975 :     }

  0018a	e9 79 ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 2976 :     out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);

  0018f	8b 85 58 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00195	83 e8 02	 sub	 eax, 2
  00198	48 98		 cdqe
  0019a	48 8b 4d 28	 mov	 rcx, QWORD PTR input$[rbp]
  0019e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a2	6b c0 03	 imul	 eax, eax, 3
  001a5	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR w$[rbp]
  001ab	ff c9		 dec	 ecx
  001ad	48 63 c9	 movsxd	 rcx, ecx
  001b0	48 8b 55 28	 mov	 rdx, QWORD PTR input$[rbp]
  001b4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001b8	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  001bc	c1 f8 02	 sar	 eax, 2
  001bf	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  001c2	03 c9		 add	 ecx, ecx
  001c4	48 63 c9	 movsxd	 rcx, ecx
  001c7	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  001ce	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2977 :     out[i * 2 + 1] = input[w - 1];

  001d1	8b 85 58 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  001d7	ff c8		 dec	 eax
  001d9	48 98		 cdqe
  001db	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  001de	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  001e2	48 63 c9	 movsxd	 rcx, ecx
  001e5	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  001ec	4c 8b 45 28	 mov	 r8, QWORD PTR input$[rbp]
  001f0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001f5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2978 : 
; 2979 :     STBI_NOTUSED(in_far);
; 2980 :     STBI_NOTUSED(hs);
; 2981 : 
; 2982 :     return out;

  001f8	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__resa:

; 2983 : }

  001ff	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00206	5f		 pop	 rdi
  00207	5d		 pop	 rbp
  00208	c3		 ret	 0
stbi__resample_row_h_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__resample_row_v_2
_TEXT	SEGMENT
i$ = 4
out$ = 256
in_near$ = 264
in_far$ = 272
w$ = 280
hs$ = 288
stbi__resample_row_v_2 PROC				; COMDAT

; 2948 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2949 :     // need to generate two samples vertically for every one in input
; 2950 :     int i;
; 2951 :     STBI_NOTUSED(hs);
; 2952 :     for (i = 0; i < w; ++i)

  0002e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00035	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00037	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0003a	ff c0		 inc	 eax
  0003c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__resa:
  0003f	8b 85 18 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00045	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00048	7d 38		 jge	 SHORT $LN3@stbi__resa

; 2953 :         out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);

  0004a	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0004e	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR in_near$[rbp]
  00055	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00059	6b c0 03	 imul	 eax, eax, 3
  0005c	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00060	48 8b 95 10 01
	00 00		 mov	 rdx, QWORD PTR in_far$[rbp]
  00067	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0006b	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0006f	c1 f8 02	 sar	 eax, 2
  00072	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00076	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR out$[rbp]
  0007d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00080	eb b5		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 2954 :     return out;

  00082	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]

; 2955 : }

  00089	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00090	5f		 pop	 rdi
  00091	5d		 pop	 rbp
  00092	c3		 ret	 0
stbi__resample_row_v_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT resample_row_1
_TEXT	SEGMENT
out$ = 224
in_near$ = 232
in_far$ = 240
w$ = 248
hs$ = 256
resample_row_1 PROC					; COMDAT

; 2939 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2940 :     STBI_NOTUSED(out);
; 2941 :     STBI_NOTUSED(in_far);
; 2942 :     STBI_NOTUSED(w);
; 2943 :     STBI_NOTUSED(hs);
; 2944 :     return in_near;

  0002e	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR in_near$[rbp]

; 2945 : }

  00035	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003c	5f		 pop	 rdi
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
resample_row_1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__decode_jpeg_image
_TEXT	SEGMENT
m$ = 4
Ld$1 = 36
NL$2 = 68
j$ = 320
stbi__decode_jpeg_image PROC				; COMDAT

; 2893 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2894 :     int m;
; 2895 :     for (m = 0; m < 4; m++) {

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR m$[rbp], 0
  00026	eb 08		 jmp	 SHORT $LN4@stbi__deco
$LN2@stbi__deco:
  00028	8b 45 04	 mov	 eax, DWORD PTR m$[rbp]
  0002b	ff c0		 inc	 eax
  0002d	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN4@stbi__deco:
  00030	83 7d 04 04	 cmp	 DWORD PTR m$[rbp], 4
  00034	7d 38		 jge	 SHORT $LN3@stbi__deco

; 2896 :         j->img_comp[m].raw_data = NULL;

  00036	48 63 45 04	 movsxd	 rax, DWORD PTR m$[rbp]
  0003a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0003e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00045	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 2897 :         j->img_comp[m].raw_coeff = NULL;

  00051	48 63 45 04	 movsxd	 rax, DWORD PTR m$[rbp]
  00055	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00059	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00060	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 2898 :     }

  0006c	eb ba		 jmp	 SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 2899 :     j->restart_interval = 0;

  0006e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00075	c7 80 68 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18536], 0

; 2900 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

  0007f	33 d2		 xor	 edx, edx
  00081	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00088	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  0008d	85 c0		 test	 eax, eax
  0008f	75 07		 jne	 SHORT $LN7@stbi__deco
  00091	33 c0		 xor	 eax, eax
  00093	e9 8d 01 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 2901 :     m = stbi__get_marker(j);

  00098	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0009f	e8 00 00 00 00	 call	 stbi__get_marker
  000a4	0f b6 c0	 movzx	 eax, al
  000a7	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN5@stbi__deco:

; 2902 :     while (!stbi__EOI(m)) {

  000aa	81 7d 04 d9 00
	00 00		 cmp	 DWORD PTR m$[rbp], 217	; 000000d9H
  000b1	0f 84 4d 01 00
	00		 je	 $LN6@stbi__deco

; 2903 :         if (stbi__SOS(m)) {

  000b7	81 7d 04 da 00
	00 00		 cmp	 DWORD PTR m$[rbp], 218	; 000000daH
  000be	0f 85 97 00 00
	00		 jne	 $LN8@stbi__deco

; 2904 :             if (!stbi__process_scan_header(j)) return 0;

  000c4	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000cb	e8 00 00 00 00	 call	 stbi__process_scan_header
  000d0	85 c0		 test	 eax, eax
  000d2	75 07		 jne	 SHORT $LN10@stbi__deco
  000d4	33 c0		 xor	 eax, eax
  000d6	e9 4a 01 00 00	 jmp	 $LN1@stbi__deco
$LN10@stbi__deco:

; 2905 :             if (!stbi__parse_entropy_coded_data(j)) return 0;

  000db	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000e2	e8 00 00 00 00	 call	 stbi__parse_entropy_coded_data
  000e7	85 c0		 test	 eax, eax
  000e9	75 07		 jne	 SHORT $LN11@stbi__deco
  000eb	33 c0		 xor	 eax, eax
  000ed	e9 33 01 00 00	 jmp	 $LN1@stbi__deco
$LN11@stbi__deco:

; 2906 :             if (j->marker == STBI__MARKER_none) {

  000f2	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000f9	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00100	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00105	75 19		 jne	 SHORT $LN12@stbi__deco

; 2907 :                 j->marker = stbi__skip_jpeg_junk_at_end(j);

  00107	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0010e	e8 00 00 00 00	 call	 stbi__skip_jpeg_junk_at_end
  00113	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0011a	88 81 28 48 00
	00		 mov	 BYTE PTR [rcx+18472], al
$LN12@stbi__deco:

; 2908 :                 // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 2909 :             }
; 2910 :             m = stbi__get_marker(j);

  00120	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00127	e8 00 00 00 00	 call	 stbi__get_marker
  0012c	0f b6 c0	 movzx	 eax, al
  0012f	89 45 04	 mov	 DWORD PTR m$[rbp], eax

; 2911 :             if (STBI__RESTART(m))

  00132	81 7d 04 d0 00
	00 00		 cmp	 DWORD PTR m$[rbp], 208	; 000000d0H
  00139	7c 1b		 jl	 SHORT $LN13@stbi__deco
  0013b	81 7d 04 d7 00
	00 00		 cmp	 DWORD PTR m$[rbp], 215	; 000000d7H
  00142	7f 12		 jg	 SHORT $LN13@stbi__deco

; 2912 :                 m = stbi__get_marker(j);

  00144	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0014b	e8 00 00 00 00	 call	 stbi__get_marker
  00150	0f b6 c0	 movzx	 eax, al
  00153	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN13@stbi__deco:

; 2913 :         }

  00156	e9 a4 00 00 00	 jmp	 $LN9@stbi__deco
$LN8@stbi__deco:

; 2914 :         else if (stbi__DNL(m)) {

  0015b	81 7d 04 dc 00
	00 00		 cmp	 DWORD PTR m$[rbp], 220	; 000000dcH
  00162	75 6f		 jne	 SHORT $LN14@stbi__deco

; 2915 :             int Ld = stbi__get16be(j->s);

  00164	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0016b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016e	e8 00 00 00 00	 call	 stbi__get16be
  00173	89 45 24	 mov	 DWORD PTR Ld$1[rbp], eax

; 2916 :             stbi__uint32 NL = stbi__get16be(j->s);

  00176	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0017d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00180	e8 00 00 00 00	 call	 stbi__get16be
  00185	89 45 44	 mov	 DWORD PTR NL$2[rbp], eax

; 2917 :             if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

  00188	83 7d 24 04	 cmp	 DWORD PTR Ld$1[rbp], 4
  0018c	74 11		 je	 SHORT $LN16@stbi__deco
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@EPMOIECP@bad?5DNL?5len@
  00195	e8 00 00 00 00	 call	 stbi__err
  0019a	e9 86 00 00 00	 jmp	 $LN1@stbi__deco
$LN16@stbi__deco:

; 2918 :             if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

  0019f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  001a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001ac	39 45 44	 cmp	 DWORD PTR NL$2[rbp], eax
  001af	74 0e		 je	 SHORT $LN17@stbi__deco
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
  001b8	e8 00 00 00 00	 call	 stbi__err
  001bd	eb 66		 jmp	 SHORT $LN1@stbi__deco
$LN17@stbi__deco:

; 2919 :             m = stbi__get_marker(j);

  001bf	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001c6	e8 00 00 00 00	 call	 stbi__get_marker
  001cb	0f b6 c0	 movzx	 eax, al
  001ce	89 45 04	 mov	 DWORD PTR m$[rbp], eax

; 2920 :         }

  001d1	eb 2c		 jmp	 SHORT $LN15@stbi__deco
$LN14@stbi__deco:

; 2921 :         else {
; 2922 :             if (!stbi__process_marker(j, m)) return 1;

  001d3	8b 55 04	 mov	 edx, DWORD PTR m$[rbp]
  001d6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001dd	e8 00 00 00 00	 call	 stbi__process_marker
  001e2	85 c0		 test	 eax, eax
  001e4	75 07		 jne	 SHORT $LN18@stbi__deco
  001e6	b8 01 00 00 00	 mov	 eax, 1
  001eb	eb 38		 jmp	 SHORT $LN1@stbi__deco
$LN18@stbi__deco:

; 2923 :             m = stbi__get_marker(j);

  001ed	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001f4	e8 00 00 00 00	 call	 stbi__get_marker
  001f9	0f b6 c0	 movzx	 eax, al
  001fc	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN15@stbi__deco:
$LN9@stbi__deco:

; 2924 :         }
; 2925 :     }

  001ff	e9 a6 fe ff ff	 jmp	 $LN5@stbi__deco
$LN6@stbi__deco:

; 2926 :     if (j->progressive)

  00204	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0020b	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00212	74 0c		 je	 SHORT $LN19@stbi__deco

; 2927 :         stbi__jpeg_finish(j);

  00214	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0021b	e8 00 00 00 00	 call	 stbi__jpeg_finish
$LN19@stbi__deco:

; 2928 :     return 1;

  00220	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 2929 : }

  00225	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0022c	5f		 pop	 rdi
  0022d	5d		 pop	 rbp
  0022e	c3		 ret	 0
stbi__decode_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__skip_jpeg_junk_at_end
_TEXT	SEGMENT
x$1 = 4
j$ = 256
stbi__skip_jpeg_junk_at_end PROC			; COMDAT

; 2870 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@stbi__skip:

; 2871 :     // some JPEGs have junk at end, skip over it but if we find what looks
; 2872 :     // like a valid marker, resume there
; 2873 :     while (!stbi__at_eof(j->s)) {

  0001f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00029	e8 00 00 00 00	 call	 stbi__at_eof
  0002e	85 c0		 test	 eax, eax
  00030	75 65		 jne	 SHORT $LN3@stbi__skip

; 2874 :         int x = stbi__get8(j->s);

  00032	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00039	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003c	e8 00 00 00 00	 call	 stbi__get8
  00041	0f b6 c0	 movzx	 eax, al
  00044	89 45 04	 mov	 DWORD PTR x$1[rbp], eax
$LN4@stbi__skip:

; 2875 :         while (x == 255) { // might be a marker

  00047	81 7d 04 ff 00
	00 00		 cmp	 DWORD PTR x$1[rbp], 255	; 000000ffH
  0004e	75 45		 jne	 SHORT $LN5@stbi__skip

; 2876 :             if (stbi__at_eof(j->s)) return STBI__MARKER_none;

  00050	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00057	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005a	e8 00 00 00 00	 call	 stbi__at_eof
  0005f	85 c0		 test	 eax, eax
  00061	74 07		 je	 SHORT $LN6@stbi__skip
  00063	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00068	eb 32		 jmp	 SHORT $LN1@stbi__skip
$LN6@stbi__skip:

; 2877 :             x = stbi__get8(j->s);

  0006a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00071	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00074	e8 00 00 00 00	 call	 stbi__get8
  00079	0f b6 c0	 movzx	 eax, al
  0007c	89 45 04	 mov	 DWORD PTR x$1[rbp], eax

; 2878 :             if (x != 0x00 && x != 0xff) {

  0007f	83 7d 04 00	 cmp	 DWORD PTR x$1[rbp], 0
  00083	74 0e		 je	 SHORT $LN7@stbi__skip
  00085	81 7d 04 ff 00
	00 00		 cmp	 DWORD PTR x$1[rbp], 255	; 000000ffH
  0008c	74 05		 je	 SHORT $LN7@stbi__skip

; 2879 :                 // not a stuffed zero or lead-in to another marker, looks
; 2880 :                 // like an actual marker, return it
; 2881 :                 return x;

  0008e	8b 45 04	 mov	 eax, DWORD PTR x$1[rbp]
  00091	eb 09		 jmp	 SHORT $LN1@stbi__skip
$LN7@stbi__skip:

; 2882 :             }
; 2883 :             // stuffed zero has x=0 now which ends the loop, meaning we go
; 2884 :             // back to regular scan loop.
; 2885 :             // repeated 0xff keeps trying to read the next byte of the marker.
; 2886 :         }

  00093	eb b2		 jmp	 SHORT $LN4@stbi__skip
$LN5@stbi__skip:

; 2887 :     }

  00095	eb 88		 jmp	 SHORT $LN2@stbi__skip
$LN3@stbi__skip:

; 2888 :     return STBI__MARKER_none;

  00097	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$LN1@stbi__skip:

; 2889 : }

  0009c	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a3	5f		 pop	 rdi
  000a4	5d		 pop	 rbp
  000a5	c3		 ret	 0
stbi__skip_jpeg_junk_at_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__decode_jpeg_header
_TEXT	SEGMENT
m$ = 4
tv131 = 212
z$ = 256
scan$ = 264
stbi__decode_jpeg_header PROC				; COMDAT

; 2846 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2847 :     int m;
; 2848 :     z->jfif = 0;

  00023	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0002a	c7 80 48 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18504], 0

; 2849 :     z->app14_color_transform = -1; // valid values are 0,1,2

  00034	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0003b	c7 80 4c 48 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+18508], -1

; 2850 :     z->marker = STBI__MARKER_none; // initialize cached marker to empty

  00045	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0004c	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 2851 :     m = stbi__get_marker(z);

  00053	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0005a	e8 00 00 00 00	 call	 stbi__get_marker
  0005f	0f b6 c0	 movzx	 eax, al
  00062	89 45 04	 mov	 DWORD PTR m$[rbp], eax

; 2852 :     if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");

  00065	81 7d 04 d8 00
	00 00		 cmp	 DWORD PTR m$[rbp], 216	; 000000d8H
  0006c	74 11		 je	 SHORT $LN6@stbi__deco
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CLMBLEP@no?5SOI@
  00075	e8 00 00 00 00	 call	 stbi__err
  0007a	e9 04 01 00 00	 jmp	 $LN1@stbi__deco
$LN6@stbi__deco:

; 2853 :     if (scan == STBI__SCAN_type) return 1;

  0007f	83 bd 08 01 00
	00 01		 cmp	 DWORD PTR scan$[rbp], 1
  00086	75 0a		 jne	 SHORT $LN7@stbi__deco
  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	e9 f1 00 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 2854 :     m = stbi__get_marker(z);

  00092	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00099	e8 00 00 00 00	 call	 stbi__get_marker
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN2@stbi__deco:

; 2855 :     while (!stbi__SOF(m)) {

  000a4	81 7d 04 c0 00
	00 00		 cmp	 DWORD PTR m$[rbp], 192	; 000000c0H
  000ab	0f 84 81 00 00
	00		 je	 $LN3@stbi__deco
  000b1	81 7d 04 c1 00
	00 00		 cmp	 DWORD PTR m$[rbp], 193	; 000000c1H
  000b8	74 78		 je	 SHORT $LN3@stbi__deco
  000ba	81 7d 04 c2 00
	00 00		 cmp	 DWORD PTR m$[rbp], 194	; 000000c2H
  000c1	74 6f		 je	 SHORT $LN3@stbi__deco

; 2856 :         if (!stbi__process_marker(z, m)) return 0;

  000c3	8b 55 04	 mov	 edx, DWORD PTR m$[rbp]
  000c6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000cd	e8 00 00 00 00	 call	 stbi__process_marker
  000d2	85 c0		 test	 eax, eax
  000d4	75 07		 jne	 SHORT $LN8@stbi__deco
  000d6	33 c0		 xor	 eax, eax
  000d8	e9 a6 00 00 00	 jmp	 $LN1@stbi__deco
$LN8@stbi__deco:

; 2857 :         m = stbi__get_marker(z);

  000dd	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000e4	e8 00 00 00 00	 call	 stbi__get_marker
  000e9	0f b6 c0	 movzx	 eax, al
  000ec	89 45 04	 mov	 DWORD PTR m$[rbp], eax
$LN4@stbi__deco:

; 2858 :         while (m == STBI__MARKER_none) {

  000ef	81 7d 04 ff 00
	00 00		 cmp	 DWORD PTR m$[rbp], 255	; 000000ffH
  000f6	75 35		 jne	 SHORT $LN5@stbi__deco

; 2859 :             // some files have extra padding after their blocks, so ok, we'll scan
; 2860 :             if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

  000f8	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000ff	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00102	e8 00 00 00 00	 call	 stbi__at_eof
  00107	85 c0		 test	 eax, eax
  00109	74 0e		 je	 SHORT $LN9@stbi__deco
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IFCEAHIA@no?5SOF@
  00112	e8 00 00 00 00	 call	 stbi__err
  00117	eb 6a		 jmp	 SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 2861 :             m = stbi__get_marker(z);

  00119	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00120	e8 00 00 00 00	 call	 stbi__get_marker
  00125	0f b6 c0	 movzx	 eax, al
  00128	89 45 04	 mov	 DWORD PTR m$[rbp], eax

; 2862 :         }

  0012b	eb c2		 jmp	 SHORT $LN4@stbi__deco
$LN5@stbi__deco:

; 2863 :     }

  0012d	e9 72 ff ff ff	 jmp	 $LN2@stbi__deco
$LN3@stbi__deco:

; 2864 :     z->progressive = stbi__SOF_progressive(m);

  00132	81 7d 04 c2 00
	00 00		 cmp	 DWORD PTR m$[rbp], 194	; 000000c2H
  00139	75 0c		 jne	 SHORT $LN12@stbi__deco
  0013b	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv131[rbp], 1
  00145	eb 0a		 jmp	 SHORT $LN13@stbi__deco
$LN12@stbi__deco:
  00147	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv131[rbp], 0
$LN13@stbi__deco:
  00151	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00158	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv131[rbp]
  0015e	89 88 30 48 00
	00		 mov	 DWORD PTR [rax+18480], ecx

; 2865 :     if (!stbi__process_frame_header(z, scan)) return 0;

  00164	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR scan$[rbp]
  0016a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00171	e8 00 00 00 00	 call	 stbi__process_frame_header
  00176	85 c0		 test	 eax, eax
  00178	75 04		 jne	 SHORT $LN10@stbi__deco
  0017a	33 c0		 xor	 eax, eax
  0017c	eb 05		 jmp	 SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 2866 :     return 1;

  0017e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 2867 : }

  00183	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0018a	5f		 pop	 rdi
  0018b	5d		 pop	 rbp
  0018c	c3		 ret	 0
stbi__decode_jpeg_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__process_frame_header
_TEXT	SEGMENT
s$ = 8
Lf$ = 36
p$ = 68
i$ = 100
q$ = 132
h_max$ = 164
v_max$ = 196
c$ = 228
tv294 = 440
tv285 = 440
z$ = 480
scan$ = 488
stbi__process_frame_header PROC				; COMDAT

; 2745 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2746 :     stbi__context* s = z->s;

  00023	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 08	 mov	 QWORD PTR s$[rbp], rax

; 2747 :     int Lf, p, i, q, h_max = 1, v_max = 1, c;

  00031	c7 85 a4 00 00
	00 01 00 00 00	 mov	 DWORD PTR h_max$[rbp], 1
  0003b	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR v_max$[rbp], 1

; 2748 :     Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG

  00045	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00049	e8 00 00 00 00	 call	 stbi__get16be
  0004e	89 45 24	 mov	 DWORD PTR Lf$[rbp], eax
  00051	83 7d 24 0b	 cmp	 DWORD PTR Lf$[rbp], 11
  00055	7d 11		 jge	 SHORT $LN17@stbi__proc
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DOFMJEMP@bad?5SOF?5len@
  0005e	e8 00 00 00 00	 call	 stbi__err
  00063	e9 11 09 00 00	 jmp	 $LN1@stbi__proc
$LN17@stbi__proc:

; 2749 :     p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline

  00068	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  0006c	e8 00 00 00 00	 call	 stbi__get8
  00071	0f b6 c0	 movzx	 eax, al
  00074	89 45 44	 mov	 DWORD PTR p$[rbp], eax
  00077	83 7d 44 08	 cmp	 DWORD PTR p$[rbp], 8
  0007b	74 11		 je	 SHORT $LN18@stbi__proc
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BCINMEBJ@only?58?9bit@
  00084	e8 00 00 00 00	 call	 stbi__err
  00089	e9 eb 08 00 00	 jmp	 $LN1@stbi__proc
$LN18@stbi__proc:

; 2750 :     s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

  0008e	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00092	e8 00 00 00 00	 call	 stbi__get16be
  00097	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  0009b	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0009e	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  000a2	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  000a6	75 11		 jne	 SHORT $LN19@stbi__proc
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LNEGOMA@no?5header?5height@
  000af	e8 00 00 00 00	 call	 stbi__err
  000b4	e9 c0 08 00 00	 jmp	 $LN1@stbi__proc
$LN19@stbi__proc:

; 2751 :     s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires

  000b9	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  000bd	e8 00 00 00 00	 call	 stbi__get16be
  000c2	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  000c6	89 01		 mov	 DWORD PTR [rcx], eax
  000c8	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  000cc	83 38 00	 cmp	 DWORD PTR [rax], 0
  000cf	75 11		 jne	 SHORT $LN20@stbi__proc
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BIDACDEF@0?5width@
  000d8	e8 00 00 00 00	 call	 stbi__err
  000dd	e9 97 08 00 00	 jmp	 $LN1@stbi__proc
$LN20@stbi__proc:

; 2752 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  000e2	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  000e6	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  000ed	76 11		 jbe	 SHORT $LN21@stbi__proc
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  000f6	e8 00 00 00 00	 call	 stbi__err
  000fb	e9 79 08 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 2753 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

  00100	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00104	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  0010a	76 11		 jbe	 SHORT $LN22@stbi__proc
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00113	e8 00 00 00 00	 call	 stbi__err
  00118	e9 5c 08 00 00	 jmp	 $LN1@stbi__proc
$LN22@stbi__proc:

; 2754 :     c = stbi__get8(s);

  0011d	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00121	e8 00 00 00 00	 call	 stbi__get8
  00126	0f b6 c0	 movzx	 eax, al
  00129	89 85 e4 00 00
	00		 mov	 DWORD PTR c$[rbp], eax

; 2755 :     if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count", "Corrupt JPEG");

  0012f	83 bd e4 00 00
	00 03		 cmp	 DWORD PTR c$[rbp], 3
  00136	74 23		 je	 SHORT $LN23@stbi__proc
  00138	83 bd e4 00 00
	00 01		 cmp	 DWORD PTR c$[rbp], 1
  0013f	74 1a		 je	 SHORT $LN23@stbi__proc
  00141	83 bd e4 00 00
	00 04		 cmp	 DWORD PTR c$[rbp], 4
  00148	74 11		 je	 SHORT $LN23@stbi__proc
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@DAPHADHL@bad?5component?5count@
  00151	e8 00 00 00 00	 call	 stbi__err
  00156	e9 1e 08 00 00	 jmp	 $LN1@stbi__proc
$LN23@stbi__proc:

; 2756 :     s->img_n = c;

  0015b	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  0015f	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR c$[rbp]
  00165	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 2757 :     for (i = 0; i < c; ++i) {

  00168	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0016f	eb 08		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  00171	8b 45 64	 mov	 eax, DWORD PTR i$[rbp]
  00174	ff c0		 inc	 eax
  00176	89 45 64	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__proc:
  00179	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR c$[rbp]
  0017f	39 45 64	 cmp	 DWORD PTR i$[rbp], eax
  00182	7d 38		 jge	 SHORT $LN3@stbi__proc

; 2758 :         z->img_comp[i].data = NULL;

  00184	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00188	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0018c	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00193	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0

; 2759 :         z->img_comp[i].linebuf = NULL;

  0019f	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  001a3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001a7	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  001ae	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 2760 :     }

  001ba	eb b5		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 2761 : 
; 2762 :     if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

  001bc	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  001c0	6b 40 08 03	 imul	 eax, DWORD PTR [rax+8], 3
  001c4	83 c0 08	 add	 eax, 8
  001c7	39 45 24	 cmp	 DWORD PTR Lf$[rbp], eax
  001ca	74 11		 je	 SHORT $LN24@stbi__proc
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DOFMJEMP@bad?5SOF?5len@
  001d3	e8 00 00 00 00	 call	 stbi__err
  001d8	e9 9c 07 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 2763 : 
; 2764 :     z->rgb = 0;

  001dd	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  001e4	c7 80 50 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18512], 0

; 2765 :     for (i = 0; i < s->img_n; ++i) {

  001ee	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  001f5	eb 08		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  001f7	8b 45 64	 mov	 eax, DWORD PTR i$[rbp]
  001fa	ff c0		 inc	 eax
  001fc	89 45 64	 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__proc:
  001ff	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00203	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00206	39 45 64	 cmp	 DWORD PTR i$[rbp], eax
  00209	0f 8d 96 01 00
	00		 jge	 $LN6@stbi__proc

; 2766 :         static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 2767 :         z->img_comp[i].id = stbi__get8(s);

  0020f	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00213	e8 00 00 00 00	 call	 stbi__get8
  00218	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  0021c	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00220	0f b6 c0	 movzx	 eax, al
  00223	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0022a	89 84 0a a0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18080], eax

; 2768 :         if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

  00231	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00235	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00239	75 43		 jne	 SHORT $LN25@stbi__proc
  0023b	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0023f	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00243	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?rgb@?5??stbi__process_frame_header@@9@9
  0024e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00252	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00259	39 8c 02 a0 46
	00 00		 cmp	 DWORD PTR [rdx+rax+18080], ecx
  00260	75 1c		 jne	 SHORT $LN25@stbi__proc

; 2769 :             ++z->rgb;

  00262	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00269	8b 80 50 48 00
	00		 mov	 eax, DWORD PTR [rax+18512]
  0026f	ff c0		 inc	 eax
  00271	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00278	89 81 50 48 00
	00		 mov	 DWORD PTR [rcx+18512], eax
$LN25@stbi__proc:

; 2770 :         q = stbi__get8(s);

  0027e	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00282	e8 00 00 00 00	 call	 stbi__get8
  00287	0f b6 c0	 movzx	 eax, al
  0028a	89 85 84 00 00
	00		 mov	 DWORD PTR q$[rbp], eax

; 2771 :         z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");

  00290	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR q$[rbp]
  00296	c1 f8 04	 sar	 eax, 4
  00299	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  0029d	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  002a1	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  002a8	89 84 0a a4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18084], eax
  002af	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  002b3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002b7	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002be	83 bc 01 a4 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18084], 0
  002c6	74 19		 je	 SHORT $LN27@stbi__proc
  002c8	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  002cc	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002d0	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002d7	83 bc 01 a4 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18084], 4
  002df	7e 11		 jle	 SHORT $LN26@stbi__proc
$LN27@stbi__proc:
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BLPKENEJ@bad?5H@
  002e8	e8 00 00 00 00	 call	 stbi__err
  002ed	e9 87 06 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 2772 :         z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");

  002f2	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR q$[rbp]
  002f8	83 e0 0f	 and	 eax, 15
  002fb	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  002ff	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00303	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0030a	89 84 0a a8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18088], eax
  00311	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00315	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00319	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00320	83 bc 01 a8 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18088], 0
  00328	74 19		 je	 SHORT $LN29@stbi__proc
  0032a	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0032e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00332	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00339	83 bc 01 a8 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18088], 4
  00341	7e 11		 jle	 SHORT $LN28@stbi__proc
$LN29@stbi__proc:
  00343	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MPLLHCJG@bad?5V@
  0034a	e8 00 00 00 00	 call	 stbi__err
  0034f	e9 25 06 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 2773 :         z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");

  00354	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00358	e8 00 00 00 00	 call	 stbi__get8
  0035d	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00361	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00365	0f b6 c0	 movzx	 eax, al
  00368	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0036f	89 84 0a ac 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18092], eax
  00376	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0037a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0037e	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00385	83 bc 01 ac 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18092], 3
  0038d	7e 11		 jle	 SHORT $LN30@stbi__proc
  0038f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06LJIHDFHI@bad?5TQ@
  00396	e8 00 00 00 00	 call	 stbi__err
  0039b	e9 d9 05 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 2774 :     }

  003a0	e9 52 fe ff ff	 jmp	 $LN5@stbi__proc
$LN6@stbi__proc:

; 2775 : 
; 2776 :     if (scan != STBI__SCAN_load) return 1;

  003a5	83 bd e8 01 00
	00 00		 cmp	 DWORD PTR scan$[rbp], 0
  003ac	74 0a		 je	 SHORT $LN31@stbi__proc
  003ae	b8 01 00 00 00	 mov	 eax, 1
  003b3	e9 c1 05 00 00	 jmp	 $LN1@stbi__proc
$LN31@stbi__proc:

; 2777 : 
; 2778 :     if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

  003b8	45 33 c9	 xor	 r9d, r9d
  003bb	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  003bf	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  003c3	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  003c7	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  003ca	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  003ce	8b 08		 mov	 ecx, DWORD PTR [rax]
  003d0	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  003d5	85 c0		 test	 eax, eax
  003d7	75 11		 jne	 SHORT $LN32@stbi__proc
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  003e0	e8 00 00 00 00	 call	 stbi__err
  003e5	e9 8f 05 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 2779 : 
; 2780 :     for (i = 0; i < s->img_n; ++i) {

  003ea	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  003f1	eb 08		 jmp	 SHORT $LN10@stbi__proc
$LN8@stbi__proc:
  003f3	8b 45 64	 mov	 eax, DWORD PTR i$[rbp]
  003f6	ff c0		 inc	 eax
  003f8	89 45 64	 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__proc:
  003fb	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  003ff	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00402	39 45 64	 cmp	 DWORD PTR i$[rbp], eax
  00405	7d 79		 jge	 SHORT $LN9@stbi__proc

; 2781 :         if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

  00407	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0040b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0040f	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00416	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR h_max$[rbp]
  0041c	39 94 01 a4 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18084], edx
  00423	7e 1c		 jle	 SHORT $LN33@stbi__proc
  00425	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00429	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0042d	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00434	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0043b	89 85 a4 00 00
	00		 mov	 DWORD PTR h_max$[rbp], eax
$LN33@stbi__proc:

; 2782 :         if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

  00441	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00445	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00449	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00450	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR v_max$[rbp]
  00456	39 94 01 a8 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18088], edx
  0045d	7e 1c		 jle	 SHORT $LN34@stbi__proc
  0045f	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00463	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00467	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0046e	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00475	89 85 c4 00 00
	00		 mov	 DWORD PTR v_max$[rbp], eax
$LN34@stbi__proc:

; 2783 :     }

  0047b	e9 73 ff ff ff	 jmp	 $LN8@stbi__proc
$LN9@stbi__proc:

; 2784 : 
; 2785 :     // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 2786 :     // and I've never seen a non-corrupted JPEG file actually use them
; 2787 :     for (i = 0; i < s->img_n; ++i) {

  00480	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00487	eb 08		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  00489	8b 45 64	 mov	 eax, DWORD PTR i$[rbp]
  0048c	ff c0		 inc	 eax
  0048e	89 45 64	 mov	 DWORD PTR i$[rbp], eax
$LN13@stbi__proc:
  00491	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00495	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00498	39 45 64	 cmp	 DWORD PTR i$[rbp], eax
  0049b	0f 8d 8b 00 00
	00		 jge	 $LN12@stbi__proc

; 2788 :         if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H", "Corrupt JPEG");

  004a1	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  004a5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004a9	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv285[rbp], rax
  004b0	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR h_max$[rbp]
  004b6	99		 cdq
  004b7	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004be	4c 8b 85 b8 01
	00 00		 mov	 r8, QWORD PTR tv285[rbp]
  004c5	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  004cd	8b c2		 mov	 eax, edx
  004cf	85 c0		 test	 eax, eax
  004d1	74 11		 je	 SHORT $LN35@stbi__proc
  004d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BLPKENEJ@bad?5H@
  004da	e8 00 00 00 00	 call	 stbi__err
  004df	e9 95 04 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 2789 :         if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V", "Corrupt JPEG");

  004e4	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  004e8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004ec	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv294[rbp], rax
  004f3	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR v_max$[rbp]
  004f9	99		 cdq
  004fa	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00501	4c 8b 85 b8 01
	00 00		 mov	 r8, QWORD PTR tv294[rbp]
  00508	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  00510	8b c2		 mov	 eax, edx
  00512	85 c0		 test	 eax, eax
  00514	74 11		 je	 SHORT $LN36@stbi__proc
  00516	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MPLLHCJG@bad?5V@
  0051d	e8 00 00 00 00	 call	 stbi__err
  00522	e9 52 04 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 2790 :     }

  00527	e9 5d ff ff ff	 jmp	 $LN11@stbi__proc
$LN12@stbi__proc:

; 2791 : 
; 2792 :     // compute interleaved mcu info
; 2793 :     z->img_h_max = h_max;

  0052c	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00533	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR h_max$[rbp]
  00539	89 88 88 46 00
	00		 mov	 DWORD PTR [rax+18056], ecx

; 2794 :     z->img_v_max = v_max;

  0053f	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00546	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR v_max$[rbp]
  0054c	89 88 8c 46 00
	00		 mov	 DWORD PTR [rax+18060], ecx

; 2795 :     z->img_mcu_w = h_max * 8;

  00552	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR h_max$[rbp]
  00558	c1 e0 03	 shl	 eax, 3
  0055b	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00562	89 81 98 46 00
	00		 mov	 DWORD PTR [rcx+18072], eax

; 2796 :     z->img_mcu_h = v_max * 8;

  00568	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR v_max$[rbp]
  0056e	c1 e0 03	 shl	 eax, 3
  00571	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00578	89 81 9c 46 00
	00		 mov	 DWORD PTR [rcx+18076], eax

; 2797 :     // these sizes can't be more than 17 bits
; 2798 :     z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;

  0057e	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  00582	8b 00		 mov	 eax, DWORD PTR [rax]
  00584	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0058b	8b 89 98 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18072]
  00591	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00595	33 d2		 xor	 edx, edx
  00597	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0059e	f7 b1 98 46 00
	00		 div	 DWORD PTR [rcx+18072]
  005a4	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  005ab	89 81 90 46 00
	00		 mov	 DWORD PTR [rcx+18064], eax

; 2799 :     z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

  005b1	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  005b5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  005b8	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  005bf	8b 89 9c 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18076]
  005c5	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  005c9	33 d2		 xor	 edx, edx
  005cb	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  005d2	f7 b1 9c 46 00
	00		 div	 DWORD PTR [rcx+18076]
  005d8	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  005df	89 81 94 46 00
	00		 mov	 DWORD PTR [rcx+18068], eax

; 2800 : 
; 2801 :     for (i = 0; i < s->img_n; ++i) {

  005e5	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  005ec	eb 08		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  005ee	8b 45 64	 mov	 eax, DWORD PTR i$[rbp]
  005f1	ff c0		 inc	 eax
  005f3	89 45 64	 mov	 DWORD PTR i$[rbp], eax
$LN16@stbi__proc:
  005f6	48 8b 45 08	 mov	 rax, QWORD PTR s$[rbp]
  005fa	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  005fd	39 45 64	 cmp	 DWORD PTR i$[rbp], eax
  00600	0f 8d 6e 03 00
	00		 jge	 $LN15@stbi__proc

; 2802 :         // number of effective pixels (e.g. for non-interleaved MCU)
; 2803 :         z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;

  00606	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0060a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0060e	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00612	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00619	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0061b	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  00623	8b c1		 mov	 eax, ecx
  00625	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR h_max$[rbp]
  0062b	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0062f	33 d2		 xor	 edx, edx
  00631	f7 b5 a4 00 00
	00		 div	 DWORD PTR h_max$[rbp]
  00637	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  0063b	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0063f	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00646	89 84 0a bc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18108], eax

; 2804 :         z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;

  0064d	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00651	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00655	48 8b 4d 08	 mov	 rcx, QWORD PTR s$[rbp]
  00659	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00660	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00663	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  0066b	8b c1		 mov	 eax, ecx
  0066d	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR v_max$[rbp]
  00673	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00677	33 d2		 xor	 edx, edx
  00679	f7 b5 c4 00 00
	00		 div	 DWORD PTR v_max$[rbp]
  0067f	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00683	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00687	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0068e	89 84 0a c0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18112], eax

; 2805 :         // to simplify generation, we'll allocate enough memory to decode
; 2806 :         // the bogus oversized data from using interleaved MCUs and their
; 2807 :         // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 2808 :         // discard the extra data until colorspace conversion
; 2809 :         //
; 2810 :         // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 2811 :         // so these muls can't overflow with 32-bit ints (which we require)
; 2812 :         z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

  00695	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00699	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0069d	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  006a4	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  006ab	8b 89 90 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18064]
  006b1	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  006b9	8b c1		 mov	 eax, ecx
  006bb	c1 e0 03	 shl	 eax, 3
  006be	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  006c2	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  006c6	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  006cd	89 84 0a c4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18116], eax

; 2813 :         z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

  006d4	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  006d8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006dc	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  006e3	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  006ea	8b 89 94 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18068]
  006f0	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  006f8	8b c1		 mov	 eax, ecx
  006fa	c1 e0 03	 shl	 eax, 3
  006fd	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00701	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00705	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0070c	89 84 0a c8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18120], eax

; 2814 :         z->img_comp[i].coeff = 0;

  00713	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00717	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0071b	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00722	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0

; 2815 :         z->img_comp[i].raw_coeff = 0;

  0072e	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00732	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00736	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0073d	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 2816 :         z->img_comp[i].linebuf = NULL;

  00749	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0074d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00751	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00758	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 2817 :         z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

  00764	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00768	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0076c	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00770	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00774	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0077a	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00781	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  00788	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0078f	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00796	e8 00 00 00 00	 call	 stbi__malloc_mad2
  0079b	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  0079f	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007a3	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  007aa	48 89 84 0a d8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18136], rax

; 2818 :         if (z->img_comp[i].raw_data == NULL)

  007b2	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  007b6	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007ba	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  007c1	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  007ca	75 27		 jne	 SHORT $LN37@stbi__proc

; 2819 :             return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));

  007cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  007d3	e8 00 00 00 00	 call	 stbi__err
  007d8	8b 4d 64	 mov	 ecx, DWORD PTR i$[rbp]
  007db	ff c1		 inc	 ecx
  007dd	44 8b c0	 mov	 r8d, eax
  007e0	8b d1		 mov	 edx, ecx
  007e2	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  007e9	e8 00 00 00 00	 call	 stbi__free_jpeg_components
  007ee	e9 86 01 00 00	 jmp	 $LN1@stbi__proc
$LN37@stbi__proc:

; 2820 :         // align blocks for idct using mmx/sse
; 2821 :         z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);

  007f3	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  007f7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007fb	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00802	48 8b 84 01 d8
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18136]
  0080a	48 83 c0 0f	 add	 rax, 15
  0080e	48 83 e0 f0	 and	 rax, -16
  00812	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00816	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0081a	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00821	48 89 84 0a d0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18128], rax

; 2822 :         if (z->progressive) {

  00829	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00830	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00837	0f 84 32 01 00
	00		 je	 $LN38@stbi__proc

; 2823 :             // w2, h2 are multiples of 8 (see above)
; 2824 :             z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

  0083d	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00841	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00845	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0084c	8b 84 01 c4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18116]
  00853	99		 cdq
  00854	83 e2 07	 and	 edx, 7
  00857	03 c2		 add	 eax, edx
  00859	c1 f8 03	 sar	 eax, 3
  0085c	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00860	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00864	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0086b	89 84 0a f8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18168], eax

; 2825 :             z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

  00872	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  00876	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0087a	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00881	8b 84 01 c8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18120]
  00888	99		 cdq
  00889	83 e2 07	 and	 edx, 7
  0088c	03 c2		 add	 eax, edx
  0088e	c1 f8 03	 sar	 eax, 3
  00891	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  00895	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00899	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  008a0	89 84 0a fc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18172], eax

; 2826 :             z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

  008a7	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  008ab	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  008af	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  008b3	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  008b7	41 b9 0f 00 00
	00		 mov	 r9d, 15
  008bd	41 b8 02 00 00
	00		 mov	 r8d, 2
  008c3	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  008ca	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  008d1	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  008d8	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  008df	e8 00 00 00 00	 call	 stbi__malloc_mad3
  008e4	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  008e8	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  008ec	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  008f3	48 89 84 0a e0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18144], rax

; 2827 :             if (z->img_comp[i].raw_coeff == NULL)

  008fb	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  008ff	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00903	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0090a	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  00913	75 24		 jne	 SHORT $LN39@stbi__proc

; 2828 :                 return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));

  00915	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0091c	e8 00 00 00 00	 call	 stbi__err
  00921	8b 4d 64	 mov	 ecx, DWORD PTR i$[rbp]
  00924	ff c1		 inc	 ecx
  00926	44 8b c0	 mov	 r8d, eax
  00929	8b d1		 mov	 edx, ecx
  0092b	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00932	e8 00 00 00 00	 call	 stbi__free_jpeg_components
  00937	eb 40		 jmp	 SHORT $LN1@stbi__proc
$LN39@stbi__proc:

; 2829 :             z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);

  00939	48 63 45 64	 movsxd	 rax, DWORD PTR i$[rbp]
  0093d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00941	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00948	48 8b 84 01 e0
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18144]
  00950	48 83 c0 0f	 add	 rax, 15
  00954	48 83 e0 f0	 and	 rax, -16
  00958	48 63 4d 64	 movsxd	 rcx, DWORD PTR i$[rbp]
  0095c	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00960	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00967	48 89 84 0a f0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18160], rax
$LN38@stbi__proc:

; 2830 :         }
; 2831 :     }

  0096f	e9 7a fc ff ff	 jmp	 $LN14@stbi__proc
$LN15@stbi__proc:

; 2832 : 
; 2833 :     return 1;

  00974	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 2834 : }

  00979	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  00980	5f		 pop	 rdi
  00981	5d		 pop	 rbp
  00982	c3		 ret	 0
stbi__process_frame_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__free_jpeg_components
_TEXT	SEGMENT
i$ = 4
z$ = 256
ncomp$ = 264
why$ = 272
stbi__free_jpeg_components PROC				; COMDAT

; 2723 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2724 :     int i;
; 2725 :     for (i = 0; i < ncomp; ++i) {

  00028	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0002f	eb 08		 jmp	 SHORT $LN4@stbi__free
$LN2@stbi__free:
  00031	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00034	ff c0		 inc	 eax
  00036	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__free:
  00039	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR ncomp$[rbp]
  0003f	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  00042	0f 8d 31 01 00
	00		 jge	 $LN3@stbi__free

; 2726 :         if (z->img_comp[i].raw_data) {

  00048	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0004c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00050	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00057	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  00060	74 53		 je	 SHORT $LN5@stbi__free

; 2727 :             STBI_FREE(z->img_comp[i].raw_data);

  00062	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00066	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0006a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00071	48 8b 8c 01 d8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18136]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2728 :             z->img_comp[i].raw_data = NULL;

  0007f	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00083	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00087	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0008e	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 2729 :             z->img_comp[i].data = NULL;

  0009a	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0009e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000a9	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0
$LN5@stbi__free:

; 2730 :         }
; 2731 :         if (z->img_comp[i].raw_coeff) {

  000b5	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000b9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000bd	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000c4	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  000cd	74 53		 je	 SHORT $LN6@stbi__free

; 2732 :             STBI_FREE(z->img_comp[i].raw_coeff);

  000cf	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000d3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000d7	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000de	48 8b 8c 01 e0
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18144]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2733 :             z->img_comp[i].raw_coeff = 0;

  000ec	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000f0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000f4	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000fb	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 2734 :             z->img_comp[i].coeff = 0;

  00107	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0010b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00116	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0
$LN6@stbi__free:

; 2735 :         }
; 2736 :         if (z->img_comp[i].linebuf) {

  00122	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00126	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0012a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00131	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  0013a	74 38		 je	 SHORT $LN7@stbi__free

; 2737 :             STBI_FREE(z->img_comp[i].linebuf);

  0013c	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00140	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00144	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0014b	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2738 :             z->img_comp[i].linebuf = NULL;

  00159	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0015d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00161	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00168	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0
$LN7@stbi__free:

; 2739 :         }
; 2740 :     }

  00174	e9 b8 fe ff ff	 jmp	 $LN2@stbi__free
$LN3@stbi__free:

; 2741 :     return why;

  00179	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR why$[rbp]

; 2742 : }

  0017f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00186	5f		 pop	 rdi
  00187	5d		 pop	 rbp
  00188	c3		 ret	 0
stbi__free_jpeg_components ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__process_scan_header
_TEXT	SEGMENT
i$ = 4
Ls$ = 36
id$1 = 68
which$2 = 100
q$3 = 132
aa$4 = 164
z$ = 416
stbi__process_scan_header PROC				; COMDAT

; 2683 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2684 :     int i;
; 2685 :     int Ls = stbi__get16be(z->s);

  0001f	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00029	e8 00 00 00 00	 call	 stbi__get16be
  0002e	89 45 24	 mov	 DWORD PTR Ls$[rbp], eax

; 2686 :     z->scan_n = stbi__get8(z->s);

  00031	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	e8 00 00 00 00	 call	 stbi__get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0004a	89 81 54 48 00
	00		 mov	 DWORD PTR [rcx+18516], eax

; 2687 :     if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");

  00050	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00057	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  0005e	7c 2c		 jl	 SHORT $LN9@stbi__proc
  00060	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00067	83 b8 54 48 00
	00 04		 cmp	 DWORD PTR [rax+18516], 4
  0006e	7f 1c		 jg	 SHORT $LN9@stbi__proc
  00070	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00081	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00084	39 81 54 48 00
	00		 cmp	 DWORD PTR [rcx+18516], eax
  0008a	7e 11		 jle	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
  00093	e8 00 00 00 00	 call	 stbi__err
  00098	e9 e2 02 00 00	 jmp	 $LN1@stbi__proc
$LN8@stbi__proc:

; 2688 :     if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");

  0009d	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000a4	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  000aa	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  000ae	39 45 24	 cmp	 DWORD PTR Ls$[rbp], eax
  000b1	74 11		 je	 SHORT $LN10@stbi__proc
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@GNEHAHOH@bad?5SOS?5len@
  000ba	e8 00 00 00 00	 call	 stbi__err
  000bf	e9 bb 02 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 2689 :     for (i = 0; i < z->scan_n; ++i) {

  000c4	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  000cb	eb 08		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  000cd	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000d0	ff c0		 inc	 eax
  000d2	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__proc:
  000d5	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000dc	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  000e2	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000e5	0f 8d 34 01 00
	00		 jge	 $LN3@stbi__proc

; 2690 :         int id = stbi__get8(z->s), which;

  000eb	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000f2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f5	e8 00 00 00 00	 call	 stbi__get8
  000fa	0f b6 c0	 movzx	 eax, al
  000fd	89 45 44	 mov	 DWORD PTR id$1[rbp], eax

; 2691 :         int q = stbi__get8(z->s);

  00100	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00107	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0010a	e8 00 00 00 00	 call	 stbi__get8
  0010f	0f b6 c0	 movzx	 eax, al
  00112	89 85 84 00 00
	00		 mov	 DWORD PTR q$3[rbp], eax

; 2692 :         for (which = 0; which < z->s->img_n; ++which)

  00118	c7 45 64 00 00
	00 00		 mov	 DWORD PTR which$2[rbp], 0
  0011f	eb 08		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  00121	8b 45 64	 mov	 eax, DWORD PTR which$2[rbp]
  00124	ff c0		 inc	 eax
  00126	89 45 64	 mov	 DWORD PTR which$2[rbp], eax
$LN7@stbi__proc:
  00129	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00130	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00133	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00136	39 45 64	 cmp	 DWORD PTR which$2[rbp], eax
  00139	7d 1f		 jge	 SHORT $LN6@stbi__proc

; 2693 :             if (z->img_comp[which].id == id)

  0013b	48 63 45 64	 movsxd	 rax, DWORD PTR which$2[rbp]
  0013f	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00143	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0014a	8b 55 44	 mov	 edx, DWORD PTR id$1[rbp]
  0014d	39 94 01 a0 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18080], edx
  00154	75 02		 jne	 SHORT $LN11@stbi__proc

; 2694 :                 break;

  00156	eb 02		 jmp	 SHORT $LN6@stbi__proc
$LN11@stbi__proc:
  00158	eb c7		 jmp	 SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 2695 :         if (which == z->s->img_n) return 0; // no match

  0015a	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00161	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00164	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00167	39 45 64	 cmp	 DWORD PTR which$2[rbp], eax
  0016a	75 07		 jne	 SHORT $LN12@stbi__proc
  0016c	33 c0		 xor	 eax, eax
  0016e	e9 0c 02 00 00	 jmp	 $LN1@stbi__proc
$LN12@stbi__proc:

; 2696 :         z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");

  00173	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR q$3[rbp]
  00179	c1 f8 04	 sar	 eax, 4
  0017c	48 63 4d 64	 movsxd	 rcx, DWORD PTR which$2[rbp]
  00180	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00184	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0018b	89 84 0a b0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18096], eax
  00192	48 63 45 64	 movsxd	 rax, DWORD PTR which$2[rbp]
  00196	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0019a	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  001a1	83 bc 01 b0 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18096], 3
  001a9	7e 11		 jle	 SHORT $LN13@stbi__proc
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@NOCCBFAC@bad?5DC?5huff@
  001b2	e8 00 00 00 00	 call	 stbi__err
  001b7	e9 c3 01 00 00	 jmp	 $LN1@stbi__proc
$LN13@stbi__proc:

; 2697 :         z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");

  001bc	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR q$3[rbp]
  001c2	83 e0 0f	 and	 eax, 15
  001c5	48 63 4d 64	 movsxd	 rcx, DWORD PTR which$2[rbp]
  001c9	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  001cd	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  001d4	89 84 0a b4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18100], eax
  001db	48 63 45 64	 movsxd	 rax, DWORD PTR which$2[rbp]
  001df	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001e3	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  001ea	83 bc 01 b4 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18100], 3
  001f2	7e 11		 jle	 SHORT $LN14@stbi__proc
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JGMCBLGG@bad?5AC?5huff@
  001fb	e8 00 00 00 00	 call	 stbi__err
  00200	e9 7a 01 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:

; 2698 :         z->order[i] = which;

  00205	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00209	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00210	8b 55 64	 mov	 edx, DWORD PTR which$2[rbp]
  00213	89 94 81 58 48
	00 00		 mov	 DWORD PTR [rcx+rax*4+18520], edx

; 2699 :     }

  0021a	e9 ae fe ff ff	 jmp	 $LN2@stbi__proc
$LN3@stbi__proc:

; 2700 : 
; 2701 :     {
; 2702 :         int aa;
; 2703 :         z->spec_start = stbi__get8(z->s);

  0021f	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00226	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00229	e8 00 00 00 00	 call	 stbi__get8
  0022e	0f b6 c0	 movzx	 eax, al
  00231	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00238	89 81 34 48 00
	00		 mov	 DWORD PTR [rcx+18484], eax

; 2704 :         z->spec_end = stbi__get8(z->s); // should be 63, but might be 0

  0023e	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00245	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00248	e8 00 00 00 00	 call	 stbi__get8
  0024d	0f b6 c0	 movzx	 eax, al
  00250	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00257	89 81 38 48 00
	00		 mov	 DWORD PTR [rcx+18488], eax

; 2705 :         aa = stbi__get8(z->s);

  0025d	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00264	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00267	e8 00 00 00 00	 call	 stbi__get8
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	89 85 a4 00 00
	00		 mov	 DWORD PTR aa$4[rbp], eax

; 2706 :         z->succ_high = (aa >> 4);

  00275	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR aa$4[rbp]
  0027b	c1 f8 04	 sar	 eax, 4
  0027e	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00285	89 81 3c 48 00
	00		 mov	 DWORD PTR [rcx+18492], eax

; 2707 :         z->succ_low = (aa & 15);

  0028b	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR aa$4[rbp]
  00291	83 e0 0f	 and	 eax, 15
  00294	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0029b	89 81 40 48 00
	00		 mov	 DWORD PTR [rcx+18496], eax

; 2708 :         if (z->progressive) {

  002a1	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002a8	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  002af	74 6c		 je	 SHORT $LN15@stbi__proc

; 2709 :             if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

  002b1	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002b8	83 b8 34 48 00
	00 3f		 cmp	 DWORD PTR [rax+18484], 63 ; 0000003fH
  002bf	7f 4c		 jg	 SHORT $LN18@stbi__proc
  002c1	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002c8	83 b8 38 48 00
	00 3f		 cmp	 DWORD PTR [rax+18488], 63 ; 0000003fH
  002cf	7f 3c		 jg	 SHORT $LN18@stbi__proc
  002d1	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002d8	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002df	8b 89 38 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18488]
  002e5	39 88 34 48 00
	00		 cmp	 DWORD PTR [rax+18484], ecx
  002eb	7f 20		 jg	 SHORT $LN18@stbi__proc
  002ed	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002f4	83 b8 3c 48 00
	00 0d		 cmp	 DWORD PTR [rax+18492], 13
  002fb	7f 10		 jg	 SHORT $LN18@stbi__proc
  002fd	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00304	83 b8 40 48 00
	00 0d		 cmp	 DWORD PTR [rax+18496], 13
  0030b	7e 0e		 jle	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 2710 :                 return stbi__err("bad SOS", "Corrupt JPEG");

  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  00314	e8 00 00 00 00	 call	 stbi__err
  00319	eb 64		 jmp	 SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 2711 :         }

  0031b	eb 5d		 jmp	 SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 2712 :         else {
; 2713 :             if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");

  0031d	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00324	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  0032b	74 0e		 je	 SHORT $LN19@stbi__proc
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  00334	e8 00 00 00 00	 call	 stbi__err
  00339	eb 44		 jmp	 SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 2714 :             if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");

  0033b	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00342	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  00349	75 10		 jne	 SHORT $LN21@stbi__proc
  0034b	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00352	83 b8 40 48 00
	00 00		 cmp	 DWORD PTR [rax+18496], 0
  00359	74 0e		 je	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  00362	e8 00 00 00 00	 call	 stbi__err
  00367	eb 16		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 2715 :             z->spec_end = 63;

  00369	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00370	c7 80 38 48 00
	00 3f 00 00 00	 mov	 DWORD PTR [rax+18488], 63 ; 0000003fH
$LN16@stbi__proc:

; 2716 :         }
; 2717 :     }
; 2718 : 
; 2719 :     return 1;

  0037a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 2720 : }

  0037f	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  00386	5f		 pop	 rdi
  00387	5d		 pop	 rbp
  00388	c3		 ret	 0
stbi__process_scan_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__process_marker
_TEXT	SEGMENT
L$ = 4
q$4 = 36
p$5 = 68
sixteen$6 = 100
t$7 = 132
i$8 = 164
v$9 = 200
sizes$10 = 240
i$11 = 324
n$12 = 356
q$13 = 388
tc$14 = 420
th$15 = 452
ok$16 = 484
i$17 = 516
ok$18 = 548
i$19 = 580
tv236 = 980
tv155 = 980
tv152 = 980
tv149 = 980
tv88 = 980
tv64 = 980
__$ArrayPad$ = 984
z$ = 1024
m$ = 1032
stbi__process_marker PROC				; COMDAT

; 2577 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 04
	00 00		 sub	 rsp, 1032		; 00000408H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 9a 00 00 00	 mov	 ecx, 154		; 0000009aH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR [rsp+1064]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 d8 03
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2578 :     int L;
; 2579 :     switch (m) {

  0004d	8b 85 08 04 00
	00		 mov	 eax, DWORD PTR m$[rbp]
  00053	89 85 d4 03 00
	00		 mov	 DWORD PTR tv64[rbp], eax
  00059	81 bd d4 03 00
	00 c4 00 00 00	 cmp	 DWORD PTR tv64[rbp], 196 ; 000000c4H
  00063	0f 84 19 02 00
	00		 je	 $LN29@stbi__proc
  00069	81 bd d4 03 00
	00 db 00 00 00	 cmp	 DWORD PTR tv64[rbp], 219 ; 000000dbH
  00073	74 79		 je	 SHORT $LN26@stbi__proc
  00075	81 bd d4 03 00
	00 dd 00 00 00	 cmp	 DWORD PTR tv64[rbp], 221 ; 000000ddH
  0007f	74 22		 je	 SHORT $LN24@stbi__proc
  00081	81 bd d4 03 00
	00 ff 00 00 00	 cmp	 DWORD PTR tv64[rbp], 255 ; 000000ffH
  0008b	74 05		 je	 SHORT $LN23@stbi__proc
  0008d	e9 8a 04 00 00	 jmp	 $LN2@stbi__proc
$LN23@stbi__proc:

; 2580 :     case STBI__MARKER_none: // no marker found
; 2581 :         return stbi__err("expected marker", "Corrupt JPEG");

  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KLNDOKJD@expected?5marker@
  00099	e8 00 00 00 00	 call	 stbi__err
  0009e	e9 9c 06 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 2582 : 
; 2583 :     case 0xDD: // DRI - specify restart interval
; 2584 :         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");

  000a3	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000aa	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ad	e8 00 00 00 00	 call	 stbi__get16be
  000b2	83 f8 04	 cmp	 eax, 4
  000b5	74 11		 je	 SHORT $LN25@stbi__proc
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@LPHNODCG@bad?5DRI?5len@
  000be	e8 00 00 00 00	 call	 stbi__err
  000c3	e9 77 06 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:

; 2585 :         z->restart_interval = stbi__get16be(z->s);

  000c8	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000cf	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d2	e8 00 00 00 00	 call	 stbi__get16be
  000d7	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000de	89 81 68 48 00
	00		 mov	 DWORD PTR [rcx+18536], eax

; 2586 :         return 1;

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	e9 51 06 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 2587 : 
; 2588 :     case 0xDB: // DQT - define quantization table
; 2589 :         L = stbi__get16be(z->s) - 2;

  000ee	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  000f5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f8	e8 00 00 00 00	 call	 stbi__get16be
  000fd	83 e8 02	 sub	 eax, 2
  00100	89 45 04	 mov	 DWORD PTR L$[rbp], eax
$LN4@stbi__proc:

; 2590 :         while (L > 0) {

  00103	83 7d 04 00	 cmp	 DWORD PTR L$[rbp], 0
  00107	0f 8e 4e 01 00
	00		 jle	 $LN5@stbi__proc

; 2591 :             int q = stbi__get8(z->s);

  0010d	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00114	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00117	e8 00 00 00 00	 call	 stbi__get8
  0011c	0f b6 c0	 movzx	 eax, al
  0011f	89 45 24	 mov	 DWORD PTR q$4[rbp], eax

; 2592 :             int p = q >> 4, sixteen = (p != 0);

  00122	8b 45 24	 mov	 eax, DWORD PTR q$4[rbp]
  00125	c1 f8 04	 sar	 eax, 4
  00128	89 45 44	 mov	 DWORD PTR p$5[rbp], eax
  0012b	83 7d 44 00	 cmp	 DWORD PTR p$5[rbp], 0
  0012f	74 0c		 je	 SHORT $LN52@stbi__proc
  00131	c7 85 d4 03 00
	00 01 00 00 00	 mov	 DWORD PTR tv88[rbp], 1
  0013b	eb 0a		 jmp	 SHORT $LN53@stbi__proc
$LN52@stbi__proc:
  0013d	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR tv88[rbp], 0
$LN53@stbi__proc:
  00147	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR tv88[rbp]
  0014d	89 45 64	 mov	 DWORD PTR sixteen$6[rbp], eax

; 2593 :             int t = q & 15, i;

  00150	8b 45 24	 mov	 eax, DWORD PTR q$4[rbp]
  00153	83 e0 0f	 and	 eax, 15
  00156	89 85 84 00 00
	00		 mov	 DWORD PTR t$7[rbp], eax

; 2594 :             if (p != 0 && p != 1) return stbi__err("bad DQT type", "Corrupt JPEG");

  0015c	83 7d 44 00	 cmp	 DWORD PTR p$5[rbp], 0
  00160	74 17		 je	 SHORT $LN27@stbi__proc
  00162	83 7d 44 01	 cmp	 DWORD PTR p$5[rbp], 1
  00166	74 11		 je	 SHORT $LN27@stbi__proc
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@BOFJCHAP@bad?5DQT?5type@
  0016f	e8 00 00 00 00	 call	 stbi__err
  00174	e9 c6 05 00 00	 jmp	 $LN1@stbi__proc
$LN27@stbi__proc:

; 2595 :             if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");

  00179	83 bd 84 00 00
	00 03		 cmp	 DWORD PTR t$7[rbp], 3
  00180	7e 11		 jle	 SHORT $LN28@stbi__proc
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CNHKKDIM@bad?5DQT?5table@
  00189	e8 00 00 00 00	 call	 stbi__err
  0018e	e9 ac 05 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 2596 : 
; 2597 :             for (i = 0; i < 64; ++i)

  00193	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$8[rbp], 0
  0019d	eb 0e		 jmp	 SHORT $LN8@stbi__proc
$LN6@stbi__proc:
  0019f	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$8[rbp]
  001a5	ff c0		 inc	 eax
  001a7	89 85 a4 00 00
	00		 mov	 DWORD PTR i$8[rbp], eax
$LN8@stbi__proc:
  001ad	83 bd a4 00 00
	00 40		 cmp	 DWORD PTR i$8[rbp], 64	; 00000040H
  001b4	7d 74		 jge	 SHORT $LN7@stbi__proc

; 2598 :                 z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

  001b6	83 7d 64 00	 cmp	 DWORD PTR sixteen$6[rbp], 0
  001ba	74 17		 je	 SHORT $LN54@stbi__proc
  001bc	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  001c3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c6	e8 00 00 00 00	 call	 stbi__get16be
  001cb	89 85 d4 03 00
	00		 mov	 DWORD PTR tv149[rbp], eax
  001d1	eb 18		 jmp	 SHORT $LN55@stbi__proc
$LN54@stbi__proc:
  001d3	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  001da	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001dd	e8 00 00 00 00	 call	 stbi__get8
  001e2	0f b6 c0	 movzx	 eax, al
  001e5	89 85 d4 03 00
	00		 mov	 DWORD PTR tv149[rbp], eax
$LN55@stbi__proc:
  001eb	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR t$7[rbp]
  001f2	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  001f9	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00200	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00208	48 63 8d a4 00
	00 00		 movsxd	 rcx, DWORD PTR i$8[rbp]
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__jpeg_dezigzag
  00216	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0021a	0f b7 95 d4 03
	00 00		 movzx	 edx, WORD PTR tv149[rbp]
  00221	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  00225	e9 75 ff ff ff	 jmp	 $LN6@stbi__proc
$LN7@stbi__proc:

; 2599 :             L -= (sixteen ? 129 : 65);

  0022a	83 7d 64 00	 cmp	 DWORD PTR sixteen$6[rbp], 0
  0022e	74 0c		 je	 SHORT $LN56@stbi__proc
  00230	c7 85 d4 03 00
	00 81 00 00 00	 mov	 DWORD PTR tv152[rbp], 129 ; 00000081H
  0023a	eb 0a		 jmp	 SHORT $LN57@stbi__proc
$LN56@stbi__proc:
  0023c	c7 85 d4 03 00
	00 41 00 00 00	 mov	 DWORD PTR tv152[rbp], 65 ; 00000041H
$LN57@stbi__proc:
  00246	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR tv152[rbp]
  0024c	8b 4d 04	 mov	 ecx, DWORD PTR L$[rbp]
  0024f	2b c8		 sub	 ecx, eax
  00251	8b c1		 mov	 eax, ecx
  00253	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2600 :         }

  00256	e9 a8 fe ff ff	 jmp	 $LN4@stbi__proc
$LN5@stbi__proc:

; 2601 :         return L == 0;

  0025b	83 7d 04 00	 cmp	 DWORD PTR L$[rbp], 0
  0025f	75 0c		 jne	 SHORT $LN58@stbi__proc
  00261	c7 85 d4 03 00
	00 01 00 00 00	 mov	 DWORD PTR tv155[rbp], 1
  0026b	eb 0a		 jmp	 SHORT $LN59@stbi__proc
$LN58@stbi__proc:
  0026d	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR tv155[rbp], 0
$LN59@stbi__proc:
  00277	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR tv155[rbp]
  0027d	e9 bd 04 00 00	 jmp	 $LN1@stbi__proc
$LN29@stbi__proc:

; 2602 : 
; 2603 :     case 0xC4: // DHT - define huffman table
; 2604 :         L = stbi__get16be(z->s) - 2;

  00282	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00289	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0028c	e8 00 00 00 00	 call	 stbi__get16be
  00291	83 e8 02	 sub	 eax, 2
  00294	89 45 04	 mov	 DWORD PTR L$[rbp], eax
$LN9@stbi__proc:

; 2605 :         while (L > 0) {

  00297	83 7d 04 00	 cmp	 DWORD PTR L$[rbp], 0
  0029b	0f 8e 54 02 00
	00		 jle	 $LN10@stbi__proc

; 2606 :             stbi_uc* v;
; 2607 :             int sizes[16], i, n = 0;

  002a1	c7 85 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR n$12[rbp], 0

; 2608 :             int q = stbi__get8(z->s);

  002ab	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002b2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002b5	e8 00 00 00 00	 call	 stbi__get8
  002ba	0f b6 c0	 movzx	 eax, al
  002bd	89 85 84 01 00
	00		 mov	 DWORD PTR q$13[rbp], eax

; 2609 :             int tc = q >> 4;

  002c3	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR q$13[rbp]
  002c9	c1 f8 04	 sar	 eax, 4
  002cc	89 85 a4 01 00
	00		 mov	 DWORD PTR tc$14[rbp], eax

; 2610 :             int th = q & 15;

  002d2	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR q$13[rbp]
  002d8	83 e0 0f	 and	 eax, 15
  002db	89 85 c4 01 00
	00		 mov	 DWORD PTR th$15[rbp], eax

; 2611 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");

  002e1	83 bd a4 01 00
	00 01		 cmp	 DWORD PTR tc$14[rbp], 1
  002e8	7f 09		 jg	 SHORT $LN31@stbi__proc
  002ea	83 bd c4 01 00
	00 03		 cmp	 DWORD PTR th$15[rbp], 3
  002f1	7e 11		 jle	 SHORT $LN30@stbi__proc
$LN31@stbi__proc:
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JLGKOCGN@bad?5DHT?5header@
  002fa	e8 00 00 00 00	 call	 stbi__err
  002ff	e9 3b 04 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 2612 :             for (i = 0; i < 16; ++i) {

  00304	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR i$11[rbp], 0
  0030e	eb 0e		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  00310	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR i$11[rbp]
  00316	ff c0		 inc	 eax
  00318	89 85 44 01 00
	00		 mov	 DWORD PTR i$11[rbp], eax
$LN13@stbi__proc:
  0031e	83 bd 44 01 00
	00 10		 cmp	 DWORD PTR i$11[rbp], 16
  00325	7d 40		 jge	 SHORT $LN12@stbi__proc

; 2613 :                 sizes[i] = stbi__get8(z->s);

  00327	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0032e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00331	e8 00 00 00 00	 call	 stbi__get8
  00336	48 63 8d 44 01
	00 00		 movsxd	 rcx, DWORD PTR i$11[rbp]
  0033d	0f b6 c0	 movzx	 eax, al
  00340	89 84 8d f0 00
	00 00		 mov	 DWORD PTR sizes$10[rbp+rcx*4], eax

; 2614 :                 n += sizes[i];

  00347	48 63 85 44 01
	00 00		 movsxd	 rax, DWORD PTR i$11[rbp]
  0034e	8b 84 85 f0 00
	00 00		 mov	 eax, DWORD PTR sizes$10[rbp+rax*4]
  00355	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR n$12[rbp]
  0035b	03 c8		 add	 ecx, eax
  0035d	8b c1		 mov	 eax, ecx
  0035f	89 85 64 01 00
	00		 mov	 DWORD PTR n$12[rbp], eax

; 2615 :             }

  00365	eb a9		 jmp	 SHORT $LN11@stbi__proc
$LN12@stbi__proc:

; 2616 :             if (n > 256) return stbi__err("bad DHT header", "Corrupt JPEG"); // Loop over i < n would write past end of values!

  00367	81 bd 64 01 00
	00 00 01 00 00	 cmp	 DWORD PTR n$12[rbp], 256 ; 00000100H
  00371	7e 11		 jle	 SHORT $LN32@stbi__proc
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JLGKOCGN@bad?5DHT?5header@
  0037a	e8 00 00 00 00	 call	 stbi__err
  0037f	e9 bb 03 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 2617 :             L -= 17;

  00384	8b 45 04	 mov	 eax, DWORD PTR L$[rbp]
  00387	83 e8 11	 sub	 eax, 17
  0038a	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2618 :             if (tc == 0) {

  0038d	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tc$14[rbp], 0
  00394	75 5a		 jne	 SHORT $LN33@stbi__proc

; 2619 :                 if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;

  00396	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR th$15[rbp]
  0039d	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  003a4	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  003ab	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  003b0	48 8d 95 f0 00
	00 00		 lea	 rdx, QWORD PTR sizes$10[rbp]
  003b7	48 8b c8	 mov	 rcx, rax
  003ba	e8 00 00 00 00	 call	 stbi__build_huffman
  003bf	85 c0		 test	 eax, eax
  003c1	75 07		 jne	 SHORT $LN35@stbi__proc
  003c3	33 c0		 xor	 eax, eax
  003c5	e9 75 03 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 2620 :                 v = z->huff_dc[th].values;

  003ca	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR th$15[rbp]
  003d1	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  003d8	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  003df	48 8d 84 01 08
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1032]
  003e7	48 89 85 c8 00
	00 00		 mov	 QWORD PTR v$9[rbp], rax

; 2621 :             }

  003ee	eb 5b		 jmp	 SHORT $LN34@stbi__proc
$LN33@stbi__proc:

; 2622 :             else {
; 2623 :                 if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;

  003f0	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR th$15[rbp]
  003f7	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  003fe	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00405	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  0040d	48 8d 95 f0 00
	00 00		 lea	 rdx, QWORD PTR sizes$10[rbp]
  00414	48 8b c8	 mov	 rcx, rax
  00417	e8 00 00 00 00	 call	 stbi__build_huffman
  0041c	85 c0		 test	 eax, eax
  0041e	75 07		 jne	 SHORT $LN36@stbi__proc
  00420	33 c0		 xor	 eax, eax
  00422	e9 18 03 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 2624 :                 v = z->huff_ac[th].values;

  00427	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR th$15[rbp]
  0042e	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00435	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0043c	48 8d 84 01 48
	1e 00 00	 lea	 rax, QWORD PTR [rcx+rax+7752]
  00444	48 89 85 c8 00
	00 00		 mov	 QWORD PTR v$9[rbp], rax
$LN34@stbi__proc:

; 2625 :             }
; 2626 :             for (i = 0; i < n; ++i)

  0044b	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR i$11[rbp], 0
  00455	eb 0e		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  00457	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR i$11[rbp]
  0045d	ff c0		 inc	 eax
  0045f	89 85 44 01 00
	00		 mov	 DWORD PTR i$11[rbp], eax
$LN16@stbi__proc:
  00465	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR n$12[rbp]
  0046b	39 85 44 01 00
	00		 cmp	 DWORD PTR i$11[rbp], eax
  00471	7d 22		 jge	 SHORT $LN15@stbi__proc

; 2627 :                 v[i] = stbi__get8(z->s);

  00473	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0047a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0047d	e8 00 00 00 00	 call	 stbi__get8
  00482	48 63 8d 44 01
	00 00		 movsxd	 rcx, DWORD PTR i$11[rbp]
  00489	48 8b 95 c8 00
	00 00		 mov	 rdx, QWORD PTR v$9[rbp]
  00490	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00493	eb c2		 jmp	 SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 2628 :             if (tc != 0)

  00495	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tc$14[rbp], 0
  0049c	74 42		 je	 SHORT $LN37@stbi__proc

; 2629 :                 stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

  0049e	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR th$15[rbp]
  004a5	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  004ac	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004b3	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  004bb	48 63 8d c4 01
	00 00		 movsxd	 rcx, DWORD PTR th$15[rbp]
  004c2	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  004c9	48 8b 95 00 04
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  004d0	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  004d8	48 8b d0	 mov	 rdx, rax
  004db	e8 00 00 00 00	 call	 stbi__build_fast_ac
$LN37@stbi__proc:

; 2630 :             L -= n;

  004e0	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR n$12[rbp]
  004e6	8b 4d 04	 mov	 ecx, DWORD PTR L$[rbp]
  004e9	2b c8		 sub	 ecx, eax
  004eb	8b c1		 mov	 eax, ecx
  004ed	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2631 :         }

  004f0	e9 a2 fd ff ff	 jmp	 $LN9@stbi__proc
$LN10@stbi__proc:

; 2632 :         return L == 0;

  004f5	83 7d 04 00	 cmp	 DWORD PTR L$[rbp], 0
  004f9	75 0c		 jne	 SHORT $LN60@stbi__proc
  004fb	c7 85 d4 03 00
	00 01 00 00 00	 mov	 DWORD PTR tv236[rbp], 1
  00505	eb 0a		 jmp	 SHORT $LN61@stbi__proc
$LN60@stbi__proc:
  00507	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR tv236[rbp], 0
$LN61@stbi__proc:
  00511	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR tv236[rbp]
  00517	e9 23 02 00 00	 jmp	 $LN1@stbi__proc
$LN2@stbi__proc:

; 2633 :     }
; 2634 : 
; 2635 :     // check for comment block or APP blocks
; 2636 :     if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

  0051c	81 bd 08 04 00
	00 e0 00 00 00	 cmp	 DWORD PTR m$[rbp], 224	; 000000e0H
  00526	7c 0c		 jl	 SHORT $LN40@stbi__proc
  00528	81 bd 08 04 00
	00 ef 00 00 00	 cmp	 DWORD PTR m$[rbp], 239	; 000000efH
  00532	7e 10		 jle	 SHORT $LN39@stbi__proc
$LN40@stbi__proc:
  00534	81 bd 08 04 00
	00 fe 00 00 00	 cmp	 DWORD PTR m$[rbp], 254	; 000000feH
  0053e	0f 85 ef 01 00
	00		 jne	 $LN38@stbi__proc
$LN39@stbi__proc:

; 2637 :         L = stbi__get16be(z->s);

  00544	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0054b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0054e	e8 00 00 00 00	 call	 stbi__get16be
  00553	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2638 :         if (L < 2) {

  00556	83 7d 04 02	 cmp	 DWORD PTR L$[rbp], 2
  0055a	7d 30		 jge	 SHORT $LN41@stbi__proc

; 2639 :             if (m == 0xFE)

  0055c	81 bd 08 04 00
	00 fe 00 00 00	 cmp	 DWORD PTR m$[rbp], 254	; 000000feH
  00566	75 13		 jne	 SHORT $LN42@stbi__proc

; 2640 :                 return stbi__err("bad COM len", "Corrupt JPEG");

  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CICAFFCH@bad?5COM?5len@
  0056f	e8 00 00 00 00	 call	 stbi__err
  00574	e9 c6 01 00 00	 jmp	 $LN1@stbi__proc
  00579	eb 11		 jmp	 SHORT $LN43@stbi__proc
$LN42@stbi__proc:

; 2641 :             else
; 2642 :                 return stbi__err("bad APP len", "Corrupt JPEG");

  0057b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@EENLKPDI@bad?5APP?5len@
  00582	e8 00 00 00 00	 call	 stbi__err
  00587	e9 b3 01 00 00	 jmp	 $LN1@stbi__proc
$LN43@stbi__proc:
$LN41@stbi__proc:

; 2643 :         }
; 2644 :         L -= 2;

  0058c	8b 45 04	 mov	 eax, DWORD PTR L$[rbp]
  0058f	83 e8 02	 sub	 eax, 2
  00592	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2645 : 
; 2646 :         if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

  00595	81 bd 08 04 00
	00 e0 00 00 00	 cmp	 DWORD PTR m$[rbp], 224	; 000000e0H
  0059f	0f 85 93 00 00
	00		 jne	 $LN44@stbi__proc
  005a5	83 7d 04 05	 cmp	 DWORD PTR L$[rbp], 5
  005a9	0f 8c 89 00 00
	00		 jl	 $LN44@stbi__proc

; 2647 :             static const unsigned char tag[5] = { 'J','F','I','F','\0' };
; 2648 :             int ok = 1;

  005af	c7 85 e4 01 00
	00 01 00 00 00	 mov	 DWORD PTR ok$16[rbp], 1

; 2649 :             int i;
; 2650 :             for (i = 0; i < 5; ++i)

  005b9	c7 85 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$17[rbp], 0
  005c3	eb 0e		 jmp	 SHORT $LN19@stbi__proc
$LN17@stbi__proc:
  005c5	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR i$17[rbp]
  005cb	ff c0		 inc	 eax
  005cd	89 85 04 02 00
	00		 mov	 DWORD PTR i$17[rbp], eax
$LN19@stbi__proc:
  005d3	83 bd 04 02 00
	00 05		 cmp	 DWORD PTR i$17[rbp], 5
  005da	7d 34		 jge	 SHORT $LN18@stbi__proc

; 2651 :                 if (stbi__get8(z->s) != tag[i])

  005dc	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  005e3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005e6	e8 00 00 00 00	 call	 stbi__get8
  005eb	0f b6 c0	 movzx	 eax, al
  005ee	48 63 8d 04 02
	00 00		 movsxd	 rcx, DWORD PTR i$17[rbp]
  005f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?O@??stbi__process_marker@@9@9
  005fc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00600	3b c1		 cmp	 eax, ecx
  00602	74 0a		 je	 SHORT $LN46@stbi__proc

; 2652 :                     ok = 0;

  00604	c7 85 e4 01 00
	00 00 00 00 00	 mov	 DWORD PTR ok$16[rbp], 0
$LN46@stbi__proc:
  0060e	eb b5		 jmp	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 2653 :             L -= 5;

  00610	8b 45 04	 mov	 eax, DWORD PTR L$[rbp]
  00613	83 e8 05	 sub	 eax, 5
  00616	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2654 :             if (ok)

  00619	83 bd e4 01 00
	00 00		 cmp	 DWORD PTR ok$16[rbp], 0
  00620	74 11		 je	 SHORT $LN47@stbi__proc

; 2655 :                 z->jfif = 1;

  00622	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00629	c7 80 48 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18504], 1
$LN47@stbi__proc:

; 2656 :         }

  00633	e9 e2 00 00 00	 jmp	 $LN45@stbi__proc
$LN44@stbi__proc:

; 2657 :         else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

  00638	81 bd 08 04 00
	00 ee 00 00 00	 cmp	 DWORD PTR m$[rbp], 238	; 000000eeH
  00642	0f 85 d2 00 00
	00		 jne	 $LN48@stbi__proc
  00648	83 7d 04 0c	 cmp	 DWORD PTR L$[rbp], 12
  0064c	0f 8c c8 00 00
	00		 jl	 $LN48@stbi__proc

; 2658 :             static const unsigned char tag[6] = { 'A','d','o','b','e','\0' };
; 2659 :             int ok = 1;

  00652	c7 85 24 02 00
	00 01 00 00 00	 mov	 DWORD PTR ok$18[rbp], 1

; 2660 :             int i;
; 2661 :             for (i = 0; i < 6; ++i)

  0065c	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$19[rbp], 0
  00666	eb 0e		 jmp	 SHORT $LN22@stbi__proc
$LN20@stbi__proc:
  00668	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR i$19[rbp]
  0066e	ff c0		 inc	 eax
  00670	89 85 44 02 00
	00		 mov	 DWORD PTR i$19[rbp], eax
$LN22@stbi__proc:
  00676	83 bd 44 02 00
	00 06		 cmp	 DWORD PTR i$19[rbp], 6
  0067d	7d 34		 jge	 SHORT $LN21@stbi__proc

; 2662 :                 if (stbi__get8(z->s) != tag[i])

  0067f	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00686	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00689	e8 00 00 00 00	 call	 stbi__get8
  0068e	0f b6 c0	 movzx	 eax, al
  00691	48 63 8d 44 02
	00 00		 movsxd	 rcx, DWORD PTR i$19[rbp]
  00698	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?BA@??stbi__process_marker@@9@9
  0069f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006a3	3b c1		 cmp	 eax, ecx
  006a5	74 0a		 je	 SHORT $LN49@stbi__proc

; 2663 :                     ok = 0;

  006a7	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR ok$18[rbp], 0
$LN49@stbi__proc:
  006b1	eb b5		 jmp	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:

; 2664 :             L -= 6;

  006b3	8b 45 04	 mov	 eax, DWORD PTR L$[rbp]
  006b6	83 e8 06	 sub	 eax, 6
  006b9	89 45 04	 mov	 DWORD PTR L$[rbp], eax

; 2665 :             if (ok) {

  006bc	83 bd 24 02 00
	00 00		 cmp	 DWORD PTR ok$18[rbp], 0
  006c3	74 55		 je	 SHORT $LN50@stbi__proc

; 2666 :                 stbi__get8(z->s); // version

  006c5	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  006cc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006cf	e8 00 00 00 00	 call	 stbi__get8

; 2667 :                 stbi__get16be(z->s); // flags0

  006d4	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  006db	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006de	e8 00 00 00 00	 call	 stbi__get16be

; 2668 :                 stbi__get16be(z->s); // flags1

  006e3	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  006ea	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006ed	e8 00 00 00 00	 call	 stbi__get16be

; 2669 :                 z->app14_color_transform = stbi__get8(z->s); // color transform

  006f2	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  006f9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006fc	e8 00 00 00 00	 call	 stbi__get8
  00701	0f b6 c0	 movzx	 eax, al
  00704	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0070b	89 81 4c 48 00
	00		 mov	 DWORD PTR [rcx+18508], eax

; 2670 :                 L -= 6;

  00711	8b 45 04	 mov	 eax, DWORD PTR L$[rbp]
  00714	83 e8 06	 sub	 eax, 6
  00717	89 45 04	 mov	 DWORD PTR L$[rbp], eax
$LN50@stbi__proc:
$LN48@stbi__proc:
$LN45@stbi__proc:

; 2671 :             }
; 2672 :         }
; 2673 : 
; 2674 :         stbi__skip(z->s, L);

  0071a	8b 55 04	 mov	 edx, DWORD PTR L$[rbp]
  0071d	48 8b 85 00 04
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00724	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00727	e8 00 00 00 00	 call	 stbi__skip

; 2675 :         return 1;

  0072c	b8 01 00 00 00	 mov	 eax, 1
  00731	eb 0c		 jmp	 SHORT $LN1@stbi__proc
$LN38@stbi__proc:

; 2676 :     }
; 2677 : 
; 2678 :     return stbi__err("unknown marker", "Corrupt JPEG");

  00733	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NNGPHMMK@unknown?5marker@
  0073a	e8 00 00 00 00	 call	 stbi__err
$LN1@stbi__proc:

; 2679 : }

  0073f	48 8b f8	 mov	 rdi, rax
  00742	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00746	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__process_marker$rtcFrameData
  0074d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00752	48 8b c7	 mov	 rax, rdi
  00755	48 8b 8d d8 03
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0075c	48 33 cd	 xor	 rcx, rbp
  0075f	e8 00 00 00 00	 call	 __security_check_cookie
  00764	48 8d a5 e8 03
	00 00		 lea	 rsp, QWORD PTR [rbp+1000]
  0076b	5f		 pop	 rdi
  0076c	5d		 pop	 rbp
  0076d	c3		 ret	 0
stbi__process_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_finish
_TEXT	SEGMENT
i$1 = 4
j$2 = 36
n$3 = 68
w$4 = 100
h$5 = 132
data$6 = 168
z$ = 416
stbi__jpeg_finish PROC					; COMDAT

; 2558 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2559 :     if (z->progressive) {

  0001f	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00026	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  0002d	0f 84 af 01 00
	00		 je	 $LN11@stbi__jpeg

; 2560 :         // dequantize and idct the data
; 2561 :         int i, j, n;
; 2562 :         for (n = 0; n < z->s->img_n; ++n) {

  00033	c7 45 44 00 00
	00 00		 mov	 DWORD PTR n$3[rbp], 0
  0003a	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  0003c	8b 45 44	 mov	 eax, DWORD PTR n$3[rbp]
  0003f	ff c0		 inc	 eax
  00041	89 45 44	 mov	 DWORD PTR n$3[rbp], eax
$LN4@stbi__jpeg:
  00044	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00051	39 45 44	 cmp	 DWORD PTR n$3[rbp], eax
  00054	0f 8d 88 01 00
	00		 jge	 $LN3@stbi__jpeg

; 2563 :             int w = (z->img_comp[n].x + 7) >> 3;

  0005a	48 63 45 44	 movsxd	 rax, DWORD PTR n$3[rbp]
  0005e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00062	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00069	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00070	83 c0 07	 add	 eax, 7
  00073	c1 f8 03	 sar	 eax, 3
  00076	89 45 64	 mov	 DWORD PTR w$4[rbp], eax

; 2564 :             int h = (z->img_comp[n].y + 7) >> 3;

  00079	48 63 45 44	 movsxd	 rax, DWORD PTR n$3[rbp]
  0007d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00081	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00088	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  0008f	83 c0 07	 add	 eax, 7
  00092	c1 f8 03	 sar	 eax, 3
  00095	89 85 84 00 00
	00		 mov	 DWORD PTR h$5[rbp], eax

; 2565 :             for (j = 0; j < h; ++j) {

  0009b	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$2[rbp], 0
  000a2	eb 08		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  000a4	8b 45 24	 mov	 eax, DWORD PTR j$2[rbp]
  000a7	ff c0		 inc	 eax
  000a9	89 45 24	 mov	 DWORD PTR j$2[rbp], eax
$LN7@stbi__jpeg:
  000ac	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR h$5[rbp]
  000b2	39 45 24	 cmp	 DWORD PTR j$2[rbp], eax
  000b5	0f 8d 22 01 00
	00		 jge	 $LN6@stbi__jpeg

; 2566 :                 for (i = 0; i < w; ++i) {

  000bb	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  000c2	eb 08		 jmp	 SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
  000c4	8b 45 04	 mov	 eax, DWORD PTR i$1[rbp]
  000c7	ff c0		 inc	 eax
  000c9	89 45 04	 mov	 DWORD PTR i$1[rbp], eax
$LN10@stbi__jpeg:
  000cc	8b 45 64	 mov	 eax, DWORD PTR w$4[rbp]
  000cf	39 45 04	 cmp	 DWORD PTR i$1[rbp], eax
  000d2	0f 8d 00 01 00
	00		 jge	 $LN9@stbi__jpeg

; 2567 :                     short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  000d8	48 63 45 44	 movsxd	 rax, DWORD PTR n$3[rbp]
  000dc	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000e0	48 63 4d 44	 movsxd	 rcx, DWORD PTR n$3[rbp]
  000e4	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  000e8	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  000ef	44 8b 45 24	 mov	 r8d, DWORD PTR j$2[rbp]
  000f3	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  000fc	41 8b c8	 mov	 ecx, r8d
  000ff	8b 55 04	 mov	 edx, DWORD PTR i$1[rbp]
  00102	03 d1		 add	 edx, ecx
  00104	8b ca		 mov	 ecx, edx
  00106	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00109	48 63 c9	 movsxd	 rcx, ecx
  0010c	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00113	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  0011b	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0011f	48 89 85 a8 00
	00 00		 mov	 QWORD PTR data$6[rbp], rax

; 2568 :                     stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

  00126	48 63 45 44	 movsxd	 rax, DWORD PTR n$3[rbp]
  0012a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0012e	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00135	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  0013d	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00144	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0014b	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00153	48 8b d0	 mov	 rdx, rax
  00156	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR data$6[rbp]
  0015d	e8 00 00 00 00	 call	 stbi__jpeg_dequantize

; 2569 :                     z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

  00162	48 63 45 44	 movsxd	 rax, DWORD PTR n$3[rbp]
  00166	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0016a	48 63 4d 44	 movsxd	 rcx, DWORD PTR n$3[rbp]
  0016e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00172	48 63 55 44	 movsxd	 rdx, DWORD PTR n$3[rbp]
  00176	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0017a	4c 8b 85 a0 01
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  00181	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  00189	0f af 55 24	 imul	 edx, DWORD PTR j$2[rbp]
  0018d	c1 e2 03	 shl	 edx, 3
  00190	48 63 d2	 movsxd	 rdx, edx
  00193	4c 8b 85 a0 01
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  0019a	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  001a2	48 03 ca	 add	 rcx, rdx
  001a5	8b 55 04	 mov	 edx, DWORD PTR i$1[rbp]
  001a8	c1 e2 03	 shl	 edx, 3
  001ab	48 63 d2	 movsxd	 rdx, edx
  001ae	48 03 ca	 add	 rcx, rdx
  001b1	4c 8b 85 a8 00
	00 00		 mov	 r8, QWORD PTR data$6[rbp]
  001b8	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  001bf	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  001c6	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  001cd	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2570 :                 }

  001d3	e9 ec fe ff ff	 jmp	 $LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 2571 :             }

  001d8	e9 c7 fe ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2572 :         }

  001dd	e9 5a fe ff ff	 jmp	 $LN2@stbi__jpeg
$LN3@stbi__jpeg:
$LN11@stbi__jpeg:

; 2573 :     }
; 2574 : }

  001e2	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  001e9	5f		 pop	 rdi
  001ea	5d		 pop	 rbp
  001eb	c3		 ret	 0
stbi__jpeg_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_dequantize
_TEXT	SEGMENT
i$ = 4
data$ = 256
dequant$ = 264
stbi__jpeg_dequantize PROC				; COMDAT

; 2551 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2552 :     int i;
; 2553 :     for (i = 0; i < 64; ++i)

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  0002d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00030	ff c0		 inc	 eax
  00032	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__jpeg:
  00035	83 7d 04 40	 cmp	 DWORD PTR i$[rbp], 64	; 00000040H
  00039	7d 32		 jge	 SHORT $LN3@stbi__jpeg

; 2554 :         data[i] *= dequant[i];

  0003b	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  0003f	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00043	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR dequant$[rbp]
  0004a	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0004e	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  00055	0f bf 04 42	 movsx	 eax, WORD PTR [rdx+rax*2]
  00059	0f af c1	 imul	 eax, ecx
  0005c	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  00060	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  00067	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  0006b	eb c0		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 2555 : }

  0006d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00074	5f		 pop	 rdi
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
stbi__jpeg_dequantize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__parse_entropy_coded_data
_TEXT	SEGMENT
i$5 = 4
j$6 = 36
data$7 = 80
n$8 = 228
w$9 = 260
h$10 = 292
ha$11 = 324
i$12 = 356
j$13 = 388
k$14 = 420
x$15 = 452
y$16 = 484
data$17 = 528
n$18 = 676
x2$19 = 708
y2$20 = 740
ha$21 = 772
i$22 = 804
j$23 = 836
n$24 = 868
w$25 = 900
h$26 = 932
data$27 = 968
ha$28 = 996
i$29 = 1028
j$30 = 1060
k$31 = 1092
x$32 = 1124
y$33 = 1156
n$34 = 1188
x2$35 = 1220
y2$36 = 1252
data$37 = 1288
tv518 = 1876
tv400 = 1876
tv311 = 1876
tv190 = 1876
__$ArrayPad$ = 1880
z$ = 1920
stbi__parse_entropy_coded_data PROC			; COMDAT

; 2423 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 07
	00 00		 sub	 rsp, 1960		; 000007a8H
  0000e	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00013	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00018	b9 4a 01 00 00	 mov	 ecx, 330		; 0000014aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 c8
	07 00 00	 mov	 rcx, QWORD PTR [rsp+1992]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 58 07
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2424 :     stbi__jpeg_reset(z);

  00049	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00050	e8 00 00 00 00	 call	 stbi__jpeg_reset

; 2425 :     if (!z->progressive) {

  00055	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0005c	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00063	0f 85 6c 06 00
	00		 jne	 $LN44@stbi__pars

; 2426 :         if (z->scan_n == 1) {

  00069	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00070	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00077	0f 85 ac 02 00
	00		 jne	 $LN46@stbi__pars

; 2427 :             int i, j;
; 2428 :             STBI_SIMD_ALIGN(short, data[64]);
; 2429 :             int n = z->order[0];

  0007d	b8 04 00 00 00	 mov	 eax, 4
  00082	48 6b c0 00	 imul	 rax, rax, 0
  00086	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0008d	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  00094	89 85 e4 00 00
	00		 mov	 DWORD PTR n$8[rbp], eax

; 2430 :             // non-interleaved data, we just need to process one block at a time,
; 2431 :             // in trivial scanline order
; 2432 :             // number of blocks to do just depends on how many actual "pixels" this
; 2433 :             // component has, independent of interleaved MCU blocking and such
; 2434 :             int w = (z->img_comp[n].x + 7) >> 3;

  0009a	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR n$8[rbp]
  000a1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a5	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000ac	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  000b3	83 c0 07	 add	 eax, 7
  000b6	c1 f8 03	 sar	 eax, 3
  000b9	89 85 04 01 00
	00		 mov	 DWORD PTR w$9[rbp], eax

; 2435 :             int h = (z->img_comp[n].y + 7) >> 3;

  000bf	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR n$8[rbp]
  000c6	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000ca	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  000d1	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  000d8	83 c0 07	 add	 eax, 7
  000db	c1 f8 03	 sar	 eax, 3
  000de	89 85 24 01 00
	00		 mov	 DWORD PTR h$10[rbp], eax

; 2436 :             for (j = 0; j < h; ++j) {

  000e4	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$6[rbp], 0
  000eb	eb 08		 jmp	 SHORT $LN4@stbi__pars
$LN2@stbi__pars:
  000ed	8b 45 24	 mov	 eax, DWORD PTR j$6[rbp]
  000f0	ff c0		 inc	 eax
  000f2	89 45 24	 mov	 DWORD PTR j$6[rbp], eax
$LN4@stbi__pars:
  000f5	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR h$10[rbp]
  000fb	39 45 24	 cmp	 DWORD PTR j$6[rbp], eax
  000fe	0f 8d 16 02 00
	00		 jge	 $LN3@stbi__pars

; 2437 :                 for (i = 0; i < w; ++i) {

  00104	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$5[rbp], 0
  0010b	eb 08		 jmp	 SHORT $LN7@stbi__pars
$LN5@stbi__pars:
  0010d	8b 45 04	 mov	 eax, DWORD PTR i$5[rbp]
  00110	ff c0		 inc	 eax
  00112	89 45 04	 mov	 DWORD PTR i$5[rbp], eax
$LN7@stbi__pars:
  00115	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR w$9[rbp]
  0011b	39 45 04	 cmp	 DWORD PTR i$5[rbp], eax
  0011e	0f 8d f1 01 00
	00		 jge	 $LN6@stbi__pars

; 2438 :                     int ha = z->img_comp[n].ha;

  00124	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR n$8[rbp]
  0012b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0012f	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00136	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  0013d	89 85 44 01 00
	00		 mov	 DWORD PTR ha$11[rbp], eax

; 2439 :                     if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  00143	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR n$8[rbp]
  0014a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0014e	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00155	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  0015d	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00164	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0016b	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00173	48 63 8d 44 01
	00 00		 movsxd	 rcx, DWORD PTR ha$11[rbp]
  0017a	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00181	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00188	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00190	48 63 95 44 01
	00 00		 movsxd	 rdx, DWORD PTR ha$11[rbp]
  00197	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  0019e	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  001a5	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  001ad	4c 63 85 e4 00
	00 00		 movsxd	 r8, DWORD PTR n$8[rbp]
  001b4	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  001b8	4c 8b 8d 80 07
	00 00		 mov	 r9, QWORD PTR z$[rbp]
  001bf	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  001c7	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  001ce	4c 8b 8d 80 07
	00 00		 mov	 r9, QWORD PTR z$[rbp]
  001d5	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  001da	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001df	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR n$8[rbp]
  001e5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001e9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001ee	4c 8b ca	 mov	 r9, rdx
  001f1	48 8d 55 50	 lea	 rdx, QWORD PTR data$7[rbp]
  001f5	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  001fc	e8 00 00 00 00	 call	 stbi__jpeg_decode_block
  00201	85 c0		 test	 eax, eax
  00203	75 07		 jne	 SHORT $LN48@stbi__pars
  00205	33 c0		 xor	 eax, eax
  00207	e9 65 0a 00 00	 jmp	 $LN1@stbi__pars
$LN48@stbi__pars:

; 2440 :                     z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

  0020c	48 63 85 e4 00
	00 00		 movsxd	 rax, DWORD PTR n$8[rbp]
  00213	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00217	48 63 8d e4 00
	00 00		 movsxd	 rcx, DWORD PTR n$8[rbp]
  0021e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00222	48 63 95 e4 00
	00 00		 movsxd	 rdx, DWORD PTR n$8[rbp]
  00229	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0022d	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  00234	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0023c	0f af 55 24	 imul	 edx, DWORD PTR j$6[rbp]
  00240	c1 e2 03	 shl	 edx, 3
  00243	48 63 d2	 movsxd	 rdx, edx
  00246	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  0024d	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  00255	48 03 ca	 add	 rcx, rdx
  00258	8b 55 04	 mov	 edx, DWORD PTR i$5[rbp]
  0025b	c1 e2 03	 shl	 edx, 3
  0025e	48 63 d2	 movsxd	 rdx, edx
  00261	48 03 ca	 add	 rcx, rdx
  00264	4c 8d 45 50	 lea	 r8, QWORD PTR data$7[rbp]
  00268	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0026f	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  00276	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0027d	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2441 :                     // every data block is an MCU, so countdown the restart interval
; 2442 :                     if (--z->todo <= 0) {

  00283	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0028a	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00290	ff c8		 dec	 eax
  00292	89 85 54 07 00
	00		 mov	 DWORD PTR tv190[rbp], eax
  00298	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0029f	8b 8d 54 07 00
	00		 mov	 ecx, DWORD PTR tv190[rbp]
  002a5	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  002ab	83 bd 54 07 00
	00 00		 cmp	 DWORD PTR tv190[rbp], 0
  002b2	7f 5c		 jg	 SHORT $LN49@stbi__pars

; 2443 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  002b4	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002bb	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  002c2	7d 0c		 jge	 SHORT $LN50@stbi__pars
  002c4	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  002cb	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN50@stbi__pars:

; 2444 :                         // if it's NOT a restart, then just bail, so we get corrupt data
; 2445 :                         // rather than no data
; 2446 :                         if (!STBI__RESTART(z->marker)) return 1;

  002d0	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002d7	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002de	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  002e3	7c 15		 jl	 SHORT $LN52@stbi__pars
  002e5	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  002ec	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002f3	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  002f8	7e 0a		 jle	 SHORT $LN51@stbi__pars
$LN52@stbi__pars:
  002fa	b8 01 00 00 00	 mov	 eax, 1
  002ff	e9 6d 09 00 00	 jmp	 $LN1@stbi__pars
$LN51@stbi__pars:

; 2447 :                         stbi__jpeg_reset(z);

  00304	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0030b	e8 00 00 00 00	 call	 stbi__jpeg_reset
$LN49@stbi__pars:

; 2448 :                     }
; 2449 :                 }

  00310	e9 f8 fd ff ff	 jmp	 $LN5@stbi__pars
$LN6@stbi__pars:

; 2450 :             }

  00315	e9 d3 fd ff ff	 jmp	 $LN2@stbi__pars
$LN3@stbi__pars:

; 2451 :             return 1;

  0031a	b8 01 00 00 00	 mov	 eax, 1
  0031f	e9 4d 09 00 00	 jmp	 $LN1@stbi__pars

; 2452 :         }

  00324	e9 a7 03 00 00	 jmp	 $LN47@stbi__pars
$LN46@stbi__pars:

; 2453 :         else { // interleaved
; 2454 :             int i, j, k, x, y;
; 2455 :             STBI_SIMD_ALIGN(short, data[64]);
; 2456 :             for (j = 0; j < z->img_mcu_y; ++j) {

  00329	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR j$13[rbp], 0
  00333	eb 0e		 jmp	 SHORT $LN10@stbi__pars
$LN8@stbi__pars:
  00335	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR j$13[rbp]
  0033b	ff c0		 inc	 eax
  0033d	89 85 84 01 00
	00		 mov	 DWORD PTR j$13[rbp], eax
$LN10@stbi__pars:
  00343	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0034a	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  00350	39 85 84 01 00
	00		 cmp	 DWORD PTR j$13[rbp], eax
  00356	0f 8d 6a 03 00
	00		 jge	 $LN9@stbi__pars

; 2457 :                 for (i = 0; i < z->img_mcu_x; ++i) {

  0035c	c7 85 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR i$12[rbp], 0
  00366	eb 0e		 jmp	 SHORT $LN13@stbi__pars
$LN11@stbi__pars:
  00368	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR i$12[rbp]
  0036e	ff c0		 inc	 eax
  00370	89 85 64 01 00
	00		 mov	 DWORD PTR i$12[rbp], eax
$LN13@stbi__pars:
  00376	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0037d	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  00383	39 85 64 01 00
	00		 cmp	 DWORD PTR i$12[rbp], eax
  00389	0f 8d 32 03 00
	00		 jge	 $LN12@stbi__pars

; 2458 :                     // scan an interleaved mcu... process scan_n components in order
; 2459 :                     for (k = 0; k < z->scan_n; ++k) {

  0038f	c7 85 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR k$14[rbp], 0
  00399	eb 0e		 jmp	 SHORT $LN16@stbi__pars
$LN14@stbi__pars:
  0039b	8b 85 a4 01 00
	00		 mov	 eax, DWORD PTR k$14[rbp]
  003a1	ff c0		 inc	 eax
  003a3	89 85 a4 01 00
	00		 mov	 DWORD PTR k$14[rbp], eax
$LN16@stbi__pars:
  003a9	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  003b0	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  003b6	39 85 a4 01 00
	00		 cmp	 DWORD PTR k$14[rbp], eax
  003bc	0f 8d 6d 02 00
	00		 jge	 $LN15@stbi__pars

; 2460 :                         int n = z->order[k];

  003c2	48 63 85 a4 01
	00 00		 movsxd	 rax, DWORD PTR k$14[rbp]
  003c9	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  003d0	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  003d7	89 85 a4 02 00
	00		 mov	 DWORD PTR n$18[rbp], eax

; 2461 :                         // scan out an mcu's worth of this component; that's just determined
; 2462 :                         // by the basic H and V specified for the component
; 2463 :                         for (y = 0; y < z->img_comp[n].v; ++y) {

  003dd	c7 85 e4 01 00
	00 00 00 00 00	 mov	 DWORD PTR y$16[rbp], 0
  003e7	eb 0e		 jmp	 SHORT $LN19@stbi__pars
$LN17@stbi__pars:
  003e9	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR y$16[rbp]
  003ef	ff c0		 inc	 eax
  003f1	89 85 e4 01 00
	00		 mov	 DWORD PTR y$16[rbp], eax
$LN19@stbi__pars:
  003f7	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  003fe	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00402	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00409	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00410	39 85 e4 01 00
	00		 cmp	 DWORD PTR y$16[rbp], eax
  00416	0f 8d 0e 02 00
	00		 jge	 $LN18@stbi__pars

; 2464 :                             for (x = 0; x < z->img_comp[n].h; ++x) {

  0041c	c7 85 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR x$15[rbp], 0
  00426	eb 0e		 jmp	 SHORT $LN22@stbi__pars
$LN20@stbi__pars:
  00428	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR x$15[rbp]
  0042e	ff c0		 inc	 eax
  00430	89 85 c4 01 00
	00		 mov	 DWORD PTR x$15[rbp], eax
$LN22@stbi__pars:
  00436	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  0043d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00441	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00448	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0044f	39 85 c4 01 00
	00		 cmp	 DWORD PTR x$15[rbp], eax
  00455	0f 8d ca 01 00
	00		 jge	 $LN21@stbi__pars

; 2465 :                                 int x2 = (i * z->img_comp[n].h + x) * 8;

  0045b	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  00462	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00466	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0046d	8b 95 64 01 00
	00		 mov	 edx, DWORD PTR i$12[rbp]
  00473	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  0047b	8b c2		 mov	 eax, edx
  0047d	03 85 c4 01 00
	00		 add	 eax, DWORD PTR x$15[rbp]
  00483	c1 e0 03	 shl	 eax, 3
  00486	89 85 c4 02 00
	00		 mov	 DWORD PTR x2$19[rbp], eax

; 2466 :                                 int y2 = (j * z->img_comp[n].v + y) * 8;

  0048c	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  00493	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00497	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0049e	8b 95 84 01 00
	00		 mov	 edx, DWORD PTR j$13[rbp]
  004a4	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  004ac	8b c2		 mov	 eax, edx
  004ae	03 85 e4 01 00
	00		 add	 eax, DWORD PTR y$16[rbp]
  004b4	c1 e0 03	 shl	 eax, 3
  004b7	89 85 e4 02 00
	00		 mov	 DWORD PTR y2$20[rbp], eax

; 2467 :                                 int ha = z->img_comp[n].ha;

  004bd	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  004c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004c8	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004cf	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  004d6	89 85 04 03 00
	00		 mov	 DWORD PTR ha$21[rbp], eax

; 2468 :                                 if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  004dc	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  004e3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004e7	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  004ee	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  004f6	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  004fd	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00504	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  0050c	48 63 8d 04 03
	00 00		 movsxd	 rcx, DWORD PTR ha$21[rbp]
  00513	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  0051a	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00521	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00529	48 63 95 04 03
	00 00		 movsxd	 rdx, DWORD PTR ha$21[rbp]
  00530	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  00537	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  0053e	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  00546	4c 63 85 a4 02
	00 00		 movsxd	 r8, DWORD PTR n$18[rbp]
  0054d	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  00551	4c 8b 8d 80 07
	00 00		 mov	 r9, QWORD PTR z$[rbp]
  00558	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  00560	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  00567	4c 8b 8d 80 07
	00 00		 mov	 r9, QWORD PTR z$[rbp]
  0056e	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  00573	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00578	8b 85 a4 02 00
	00		 mov	 eax, DWORD PTR n$18[rbp]
  0057e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00582	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00587	4c 8b ca	 mov	 r9, rdx
  0058a	48 8d 95 10 02
	00 00		 lea	 rdx, QWORD PTR data$17[rbp]
  00591	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00598	e8 00 00 00 00	 call	 stbi__jpeg_decode_block
  0059d	85 c0		 test	 eax, eax
  0059f	75 07		 jne	 SHORT $LN53@stbi__pars
  005a1	33 c0		 xor	 eax, eax
  005a3	e9 c9 06 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 2469 :                                 z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * y2 + x2, z->img_comp[n].w2, data);

  005a8	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR n$18[rbp]
  005af	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005b3	48 63 8d a4 02
	00 00		 movsxd	 rcx, DWORD PTR n$18[rbp]
  005ba	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  005be	48 63 95 a4 02
	00 00		 movsxd	 rdx, DWORD PTR n$18[rbp]
  005c5	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  005c9	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  005d0	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  005d8	0f af 95 e4 02
	00 00		 imul	 edx, DWORD PTR y2$20[rbp]
  005df	48 63 d2	 movsxd	 rdx, edx
  005e2	4c 8b 85 80 07
	00 00		 mov	 r8, QWORD PTR z$[rbp]
  005e9	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  005f1	48 03 ca	 add	 rcx, rdx
  005f4	48 63 95 c4 02
	00 00		 movsxd	 rdx, DWORD PTR x2$19[rbp]
  005fb	48 03 ca	 add	 rcx, rdx
  005fe	4c 8d 85 10 02
	00 00		 lea	 r8, QWORD PTR data$17[rbp]
  00605	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  0060c	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  00613	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0061a	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2470 :                             }

  00620	e9 03 fe ff ff	 jmp	 $LN20@stbi__pars
$LN21@stbi__pars:

; 2471 :                         }

  00625	e9 bf fd ff ff	 jmp	 $LN17@stbi__pars
$LN18@stbi__pars:

; 2472 :                     }

  0062a	e9 6c fd ff ff	 jmp	 $LN14@stbi__pars
$LN15@stbi__pars:

; 2473 :                     // after all interleaved components, that's an interleaved MCU,
; 2474 :                     // so now count down the restart interval
; 2475 :                     if (--z->todo <= 0) {

  0062f	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00636	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  0063c	ff c8		 dec	 eax
  0063e	89 85 54 07 00
	00		 mov	 DWORD PTR tv311[rbp], eax
  00644	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0064b	8b 8d 54 07 00
	00		 mov	 ecx, DWORD PTR tv311[rbp]
  00651	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00657	83 bd 54 07 00
	00 00		 cmp	 DWORD PTR tv311[rbp], 0
  0065e	7f 5c		 jg	 SHORT $LN54@stbi__pars

; 2476 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00660	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00667	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  0066e	7d 0c		 jge	 SHORT $LN55@stbi__pars
  00670	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00677	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN55@stbi__pars:

; 2477 :                         if (!STBI__RESTART(z->marker)) return 1;

  0067c	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00683	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0068a	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  0068f	7c 15		 jl	 SHORT $LN57@stbi__pars
  00691	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00698	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0069f	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  006a4	7e 0a		 jle	 SHORT $LN56@stbi__pars
$LN57@stbi__pars:
  006a6	b8 01 00 00 00	 mov	 eax, 1
  006ab	e9 c1 05 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 2478 :                         stbi__jpeg_reset(z);

  006b0	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  006b7	e8 00 00 00 00	 call	 stbi__jpeg_reset
$LN54@stbi__pars:

; 2479 :                     }
; 2480 :                 }

  006bc	e9 a7 fc ff ff	 jmp	 $LN11@stbi__pars
$LN12@stbi__pars:

; 2481 :             }

  006c1	e9 6f fc ff ff	 jmp	 $LN8@stbi__pars
$LN9@stbi__pars:

; 2482 :             return 1;

  006c6	b8 01 00 00 00	 mov	 eax, 1
  006cb	e9 a1 05 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 2483 :         }
; 2484 :     }

  006d0	e9 9c 05 00 00	 jmp	 $LN45@stbi__pars
$LN44@stbi__pars:

; 2485 :     else {
; 2486 :         if (z->scan_n == 1) {

  006d5	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  006dc	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  006e3	0f 85 a3 02 00
	00		 jne	 $LN58@stbi__pars

; 2487 :             int i, j;
; 2488 :             int n = z->order[0];

  006e9	b8 04 00 00 00	 mov	 eax, 4
  006ee	48 6b c0 00	 imul	 rax, rax, 0
  006f2	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  006f9	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  00700	89 85 64 03 00
	00		 mov	 DWORD PTR n$24[rbp], eax

; 2489 :             // non-interleaved data, we just need to process one block at a time,
; 2490 :             // in trivial scanline order
; 2491 :             // number of blocks to do just depends on how many actual "pixels" this
; 2492 :             // component has, independent of interleaved MCU blocking and such
; 2493 :             int w = (z->img_comp[n].x + 7) >> 3;

  00706	48 63 85 64 03
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  0070d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00711	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00718	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  0071f	83 c0 07	 add	 eax, 7
  00722	c1 f8 03	 sar	 eax, 3
  00725	89 85 84 03 00
	00		 mov	 DWORD PTR w$25[rbp], eax

; 2494 :             int h = (z->img_comp[n].y + 7) >> 3;

  0072b	48 63 85 64 03
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  00732	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00736	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0073d	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00744	83 c0 07	 add	 eax, 7
  00747	c1 f8 03	 sar	 eax, 3
  0074a	89 85 a4 03 00
	00		 mov	 DWORD PTR h$26[rbp], eax

; 2495 :             for (j = 0; j < h; ++j) {

  00750	c7 85 44 03 00
	00 00 00 00 00	 mov	 DWORD PTR j$23[rbp], 0
  0075a	eb 0e		 jmp	 SHORT $LN25@stbi__pars
$LN23@stbi__pars:
  0075c	8b 85 44 03 00
	00		 mov	 eax, DWORD PTR j$23[rbp]
  00762	ff c0		 inc	 eax
  00764	89 85 44 03 00
	00		 mov	 DWORD PTR j$23[rbp], eax
$LN25@stbi__pars:
  0076a	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR h$26[rbp]
  00770	39 85 44 03 00
	00		 cmp	 DWORD PTR j$23[rbp], eax
  00776	0f 8d 01 02 00
	00		 jge	 $LN24@stbi__pars

; 2496 :                 for (i = 0; i < w; ++i) {

  0077c	c7 85 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR i$22[rbp], 0
  00786	eb 0e		 jmp	 SHORT $LN28@stbi__pars
$LN26@stbi__pars:
  00788	8b 85 24 03 00
	00		 mov	 eax, DWORD PTR i$22[rbp]
  0078e	ff c0		 inc	 eax
  00790	89 85 24 03 00
	00		 mov	 DWORD PTR i$22[rbp], eax
$LN28@stbi__pars:
  00796	8b 85 84 03 00
	00		 mov	 eax, DWORD PTR w$25[rbp]
  0079c	39 85 24 03 00
	00		 cmp	 DWORD PTR i$22[rbp], eax
  007a2	0f 8d d0 01 00
	00		 jge	 $LN27@stbi__pars

; 2497 :                     short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  007a8	48 63 85 64 03
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  007af	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007b3	48 63 8d 64 03
	00 00		 movsxd	 rcx, DWORD PTR n$24[rbp]
  007ba	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007be	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  007c5	44 8b 85 44 03
	00 00		 mov	 r8d, DWORD PTR j$23[rbp]
  007cc	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  007d5	41 8b c8	 mov	 ecx, r8d
  007d8	8b 95 24 03 00
	00		 mov	 edx, DWORD PTR i$22[rbp]
  007de	03 d1		 add	 edx, ecx
  007e0	8b ca		 mov	 ecx, edx
  007e2	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  007e5	48 63 c9	 movsxd	 rcx, ecx
  007e8	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  007ef	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  007f7	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  007fb	48 89 85 c8 03
	00 00		 mov	 QWORD PTR data$27[rbp], rax

; 2498 :                     if (z->spec_start == 0) {

  00802	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00809	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  00810	75 57		 jne	 SHORT $LN60@stbi__pars

; 2499 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  00812	48 63 85 64 03
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  00819	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0081d	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00824	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  0082c	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00833	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0083a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0083f	44 8b 8d 64 03
	00 00		 mov	 r9d, DWORD PTR n$24[rbp]
  00846	4c 8b c0	 mov	 r8, rax
  00849	48 8b 95 c8 03
	00 00		 mov	 rdx, QWORD PTR data$27[rbp]
  00850	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00857	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_dc
  0085c	85 c0		 test	 eax, eax
  0085e	75 07		 jne	 SHORT $LN62@stbi__pars

; 2500 :                             return 0;

  00860	33 c0		 xor	 eax, eax
  00862	e9 0a 04 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 2501 :                     }

  00867	eb 7d		 jmp	 SHORT $LN61@stbi__pars
$LN60@stbi__pars:

; 2502 :                     else {
; 2503 :                         int ha = z->img_comp[n].ha;

  00869	48 63 85 64 03
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  00870	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00874	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0087b	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00882	89 85 e4 03 00
	00		 mov	 DWORD PTR ha$28[rbp], eax

; 2504 :                         if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

  00888	48 63 85 e4 03
	00 00		 movsxd	 rax, DWORD PTR ha$28[rbp]
  0088f	48 69 c0 00 04
	00 00		 imul	 rax, rax, 1024		; 00000400H
  00896	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0089d	48 8d 84 01 88
	36 00 00	 lea	 rax, QWORD PTR [rcx+rax+13960]
  008a5	48 63 8d e4 03
	00 00		 movsxd	 rcx, DWORD PTR ha$28[rbp]
  008ac	48 69 c9 90 06
	00 00		 imul	 rcx, rcx, 1680		; 00000690H
  008b3	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  008ba	48 8d 8c 0a 48
	1a 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+6728]
  008c2	4c 8b c8	 mov	 r9, rax
  008c5	4c 8b c1	 mov	 r8, rcx
  008c8	48 8b 95 c8 03
	00 00		 mov	 rdx, QWORD PTR data$27[rbp]
  008cf	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  008d6	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_ac
  008db	85 c0		 test	 eax, eax
  008dd	75 07		 jne	 SHORT $LN63@stbi__pars

; 2505 :                             return 0;

  008df	33 c0		 xor	 eax, eax
  008e1	e9 8b 03 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:
$LN61@stbi__pars:

; 2506 :                     }
; 2507 :                     // every data block is an MCU, so countdown the restart interval
; 2508 :                     if (--z->todo <= 0) {

  008e6	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  008ed	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  008f3	ff c8		 dec	 eax
  008f5	89 85 54 07 00
	00		 mov	 DWORD PTR tv400[rbp], eax
  008fb	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00902	8b 8d 54 07 00
	00		 mov	 ecx, DWORD PTR tv400[rbp]
  00908	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  0090e	83 bd 54 07 00
	00 00		 cmp	 DWORD PTR tv400[rbp], 0
  00915	7f 5c		 jg	 SHORT $LN64@stbi__pars

; 2509 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00917	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0091e	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00925	7d 0c		 jge	 SHORT $LN65@stbi__pars
  00927	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0092e	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN65@stbi__pars:

; 2510 :                         if (!STBI__RESTART(z->marker)) return 1;

  00933	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0093a	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00941	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00946	7c 15		 jl	 SHORT $LN67@stbi__pars
  00948	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0094f	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00956	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  0095b	7e 0a		 jle	 SHORT $LN66@stbi__pars
$LN67@stbi__pars:
  0095d	b8 01 00 00 00	 mov	 eax, 1
  00962	e9 0a 03 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 2511 :                         stbi__jpeg_reset(z);

  00967	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  0096e	e8 00 00 00 00	 call	 stbi__jpeg_reset
$LN64@stbi__pars:

; 2512 :                     }
; 2513 :                 }

  00973	e9 10 fe ff ff	 jmp	 $LN26@stbi__pars
$LN27@stbi__pars:

; 2514 :             }

  00978	e9 df fd ff ff	 jmp	 $LN23@stbi__pars
$LN24@stbi__pars:

; 2515 :             return 1;

  0097d	b8 01 00 00 00	 mov	 eax, 1
  00982	e9 ea 02 00 00	 jmp	 $LN1@stbi__pars

; 2516 :         }

  00987	e9 e5 02 00 00	 jmp	 $LN59@stbi__pars
$LN58@stbi__pars:

; 2517 :         else { // interleaved
; 2518 :             int i, j, k, x, y;
; 2519 :             for (j = 0; j < z->img_mcu_y; ++j) {

  0098c	c7 85 24 04 00
	00 00 00 00 00	 mov	 DWORD PTR j$30[rbp], 0
  00996	eb 0e		 jmp	 SHORT $LN31@stbi__pars
$LN29@stbi__pars:
  00998	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR j$30[rbp]
  0099e	ff c0		 inc	 eax
  009a0	89 85 24 04 00
	00		 mov	 DWORD PTR j$30[rbp], eax
$LN31@stbi__pars:
  009a6	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  009ad	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  009b3	39 85 24 04 00
	00		 cmp	 DWORD PTR j$30[rbp], eax
  009b9	0f 8d ad 02 00
	00		 jge	 $LN30@stbi__pars

; 2520 :                 for (i = 0; i < z->img_mcu_x; ++i) {

  009bf	c7 85 04 04 00
	00 00 00 00 00	 mov	 DWORD PTR i$29[rbp], 0
  009c9	eb 0e		 jmp	 SHORT $LN34@stbi__pars
$LN32@stbi__pars:
  009cb	8b 85 04 04 00
	00		 mov	 eax, DWORD PTR i$29[rbp]
  009d1	ff c0		 inc	 eax
  009d3	89 85 04 04 00
	00		 mov	 DWORD PTR i$29[rbp], eax
$LN34@stbi__pars:
  009d9	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  009e0	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  009e6	39 85 04 04 00
	00		 cmp	 DWORD PTR i$29[rbp], eax
  009ec	0f 8d 75 02 00
	00		 jge	 $LN33@stbi__pars

; 2521 :                     // scan an interleaved mcu... process scan_n components in order
; 2522 :                     for (k = 0; k < z->scan_n; ++k) {

  009f2	c7 85 44 04 00
	00 00 00 00 00	 mov	 DWORD PTR k$31[rbp], 0
  009fc	eb 0e		 jmp	 SHORT $LN37@stbi__pars
$LN35@stbi__pars:
  009fe	8b 85 44 04 00
	00		 mov	 eax, DWORD PTR k$31[rbp]
  00a04	ff c0		 inc	 eax
  00a06	89 85 44 04 00
	00		 mov	 DWORD PTR k$31[rbp], eax
$LN37@stbi__pars:
  00a0c	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00a13	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00a19	39 85 44 04 00
	00		 cmp	 DWORD PTR k$31[rbp], eax
  00a1f	0f 8d b3 01 00
	00		 jge	 $LN36@stbi__pars

; 2523 :                         int n = z->order[k];

  00a25	48 63 85 44 04
	00 00		 movsxd	 rax, DWORD PTR k$31[rbp]
  00a2c	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00a33	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  00a3a	89 85 a4 04 00
	00		 mov	 DWORD PTR n$34[rbp], eax

; 2524 :                         // scan out an mcu's worth of this component; that's just determined
; 2525 :                         // by the basic H and V specified for the component
; 2526 :                         for (y = 0; y < z->img_comp[n].v; ++y) {

  00a40	c7 85 84 04 00
	00 00 00 00 00	 mov	 DWORD PTR y$33[rbp], 0
  00a4a	eb 0e		 jmp	 SHORT $LN40@stbi__pars
$LN38@stbi__pars:
  00a4c	8b 85 84 04 00
	00		 mov	 eax, DWORD PTR y$33[rbp]
  00a52	ff c0		 inc	 eax
  00a54	89 85 84 04 00
	00		 mov	 DWORD PTR y$33[rbp], eax
$LN40@stbi__pars:
  00a5a	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00a61	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a65	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00a6c	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00a73	39 85 84 04 00
	00		 cmp	 DWORD PTR y$33[rbp], eax
  00a79	0f 8d 54 01 00
	00		 jge	 $LN39@stbi__pars

; 2527 :                             for (x = 0; x < z->img_comp[n].h; ++x) {

  00a7f	c7 85 64 04 00
	00 00 00 00 00	 mov	 DWORD PTR x$32[rbp], 0
  00a89	eb 0e		 jmp	 SHORT $LN43@stbi__pars
$LN41@stbi__pars:
  00a8b	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR x$32[rbp]
  00a91	ff c0		 inc	 eax
  00a93	89 85 64 04 00
	00		 mov	 DWORD PTR x$32[rbp], eax
$LN43@stbi__pars:
  00a99	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00aa0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00aa4	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00aab	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  00ab2	39 85 64 04 00
	00		 cmp	 DWORD PTR x$32[rbp], eax
  00ab8	0f 8d 10 01 00
	00		 jge	 $LN42@stbi__pars

; 2528 :                                 int x2 = (i * z->img_comp[n].h + x);

  00abe	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00ac5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ac9	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00ad0	8b 95 04 04 00
	00		 mov	 edx, DWORD PTR i$29[rbp]
  00ad6	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00ade	8b c2		 mov	 eax, edx
  00ae0	03 85 64 04 00
	00		 add	 eax, DWORD PTR x$32[rbp]
  00ae6	89 85 c4 04 00
	00		 mov	 DWORD PTR x2$35[rbp], eax

; 2529 :                                 int y2 = (j * z->img_comp[n].v + y);

  00aec	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00af3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00af7	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00afe	8b 95 24 04 00
	00		 mov	 edx, DWORD PTR j$30[rbp]
  00b04	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00b0c	8b c2		 mov	 eax, edx
  00b0e	03 85 84 04 00
	00		 add	 eax, DWORD PTR y$33[rbp]
  00b14	89 85 e4 04 00
	00		 mov	 DWORD PTR y2$36[rbp], eax

; 2530 :                                 short* data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

  00b1a	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00b21	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b25	48 63 8d a4 04
	00 00		 movsxd	 rcx, DWORD PTR n$34[rbp]
  00b2c	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00b30	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00b37	44 8b 85 e4 04
	00 00		 mov	 r8d, DWORD PTR y2$36[rbp]
  00b3e	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00b47	41 8b c8	 mov	 ecx, r8d
  00b4a	8b 95 c4 04 00
	00		 mov	 edx, DWORD PTR x2$35[rbp]
  00b50	03 d1		 add	 edx, ecx
  00b52	8b ca		 mov	 ecx, edx
  00b54	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00b57	48 63 c9	 movsxd	 rcx, ecx
  00b5a	48 8b 95 80 07
	00 00		 mov	 rdx, QWORD PTR z$[rbp]
  00b61	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00b69	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00b6d	48 89 85 08 05
	00 00		 mov	 QWORD PTR data$37[rbp], rax

; 2531 :                                 if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  00b74	48 63 85 a4 04
	00 00		 movsxd	 rax, DWORD PTR n$34[rbp]
  00b7b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b7f	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00b86	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  00b8e	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00b95	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00b9c	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00ba1	44 8b 8d a4 04
	00 00		 mov	 r9d, DWORD PTR n$34[rbp]
  00ba8	4c 8b c0	 mov	 r8, rax
  00bab	48 8b 95 08 05
	00 00		 mov	 rdx, QWORD PTR data$37[rbp]
  00bb2	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00bb9	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_dc
  00bbe	85 c0		 test	 eax, eax
  00bc0	75 07		 jne	 SHORT $LN68@stbi__pars

; 2532 :                                     return 0;

  00bc2	33 c0		 xor	 eax, eax
  00bc4	e9 a8 00 00 00	 jmp	 $LN1@stbi__pars
$LN68@stbi__pars:

; 2533 :                             }

  00bc9	e9 bd fe ff ff	 jmp	 $LN41@stbi__pars
$LN42@stbi__pars:

; 2534 :                         }

  00bce	e9 79 fe ff ff	 jmp	 $LN38@stbi__pars
$LN39@stbi__pars:

; 2535 :                     }

  00bd3	e9 26 fe ff ff	 jmp	 $LN35@stbi__pars
$LN36@stbi__pars:

; 2536 :                     // after all interleaved components, that's an interleaved MCU,
; 2537 :                     // so now count down the restart interval
; 2538 :                     if (--z->todo <= 0) {

  00bd8	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00bdf	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00be5	ff c8		 dec	 eax
  00be7	89 85 54 07 00
	00		 mov	 DWORD PTR tv518[rbp], eax
  00bed	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00bf4	8b 8d 54 07 00
	00		 mov	 ecx, DWORD PTR tv518[rbp]
  00bfa	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00c00	83 bd 54 07 00
	00 00		 cmp	 DWORD PTR tv518[rbp], 0
  00c07	7f 59		 jg	 SHORT $LN69@stbi__pars

; 2539 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00c09	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c10	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00c17	7d 0c		 jge	 SHORT $LN70@stbi__pars
  00c19	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00c20	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN70@stbi__pars:

; 2540 :                         if (!STBI__RESTART(z->marker)) return 1;

  00c25	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c2c	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00c33	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00c38	7c 15		 jl	 SHORT $LN72@stbi__pars
  00c3a	48 8b 85 80 07
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00c41	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00c48	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00c4d	7e 07		 jle	 SHORT $LN71@stbi__pars
$LN72@stbi__pars:
  00c4f	b8 01 00 00 00	 mov	 eax, 1
  00c54	eb 1b		 jmp	 SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 2541 :                         stbi__jpeg_reset(z);

  00c56	48 8b 8d 80 07
	00 00		 mov	 rcx, QWORD PTR z$[rbp]
  00c5d	e8 00 00 00 00	 call	 stbi__jpeg_reset
$LN69@stbi__pars:

; 2542 :                     }
; 2543 :                 }

  00c62	e9 64 fd ff ff	 jmp	 $LN32@stbi__pars
$LN33@stbi__pars:

; 2544 :             }

  00c67	e9 2c fd ff ff	 jmp	 $LN29@stbi__pars
$LN30@stbi__pars:

; 2545 :             return 1;

  00c6c	b8 01 00 00 00	 mov	 eax, 1
$LN59@stbi__pars:
$LN45@stbi__pars:
$LN1@stbi__pars:

; 2546 :         }
; 2547 :     }
; 2548 : }

  00c71	48 8b f8	 mov	 rdi, rax
  00c74	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  00c78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_entropy_coded_data$rtcFrameData
  00c7f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00c84	48 8b c7	 mov	 rax, rdi
  00c87	48 8b 8d 58 07
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00c8e	48 33 cd	 xor	 rcx, rbp
  00c91	e8 00 00 00 00	 call	 __security_check_cookie
  00c96	48 8d a5 68 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1896]
  00c9d	5f		 pop	 rdi
  00c9e	5d		 pop	 rbp
  00c9f	c3		 ret	 0
stbi__parse_entropy_coded_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_reset
_TEXT	SEGMENT
tv88 = 192
j$ = 240
stbi__jpeg_reset PROC					; COMDAT

; 2410 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2411 :     j->code_bits = 0;

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	c7 80 24 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18468], 0

; 2412 :     j->code_buffer = 0;

  00030	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00037	c7 80 20 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18464], 0

; 2413 :     j->nomore = 0;

  00041	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00048	c7 80 2c 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18476], 0

; 2414 :     j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

  00052	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00057	48 6b c0 03	 imul	 rax, rax, 3
  0005b	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00062	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  0006d	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00072	48 6b c0 02	 imul	 rax, rax, 2
  00076	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0007d	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00088	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0008d	48 6b c0 01	 imul	 rax, rax, 1
  00091	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00098	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  000a3	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  000a8	48 6b c0 00	 imul	 rax, rax, 0
  000ac	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000b3	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0

; 2415 :     j->marker = STBI__MARKER_none;

  000be	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000c5	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 2416 :     j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

  000cc	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000d3	83 b8 68 48 00
	00 00		 cmp	 DWORD PTR [rax+18536], 0
  000da	74 15		 je	 SHORT $LN3@stbi__jpeg
  000dc	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000e3	8b 80 68 48 00
	00		 mov	 eax, DWORD PTR [rax+18536]
  000e9	89 85 c0 00 00
	00		 mov	 DWORD PTR tv88[rbp], eax
  000ef	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
  000f1	c7 85 c0 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR tv88[rbp], 2147483647 ; 7fffffffH
$LN4@stbi__jpeg:
  000fb	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00102	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv88[rbp]
  00108	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx

; 2417 :     j->eob_run = 0;

  0010e	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00115	c7 80 44 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18500], 0

; 2418 :     // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2419 :     // since we don't even allow 1<<30 pixels
; 2420 : }

  0011f	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00126	5f		 pop	 rdi
  00127	5d		 pop	 rbp
  00128	c3		 ret	 0
stbi__jpeg_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get_marker
_TEXT	SEGMENT
x$ = 4
j$ = 256
stbi__get_marker PROC					; COMDAT

; 2393 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2394 :     stbi_uc x;
; 2395 :     if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

  0001f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0002d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00032	74 25		 je	 SHORT $LN4@stbi__get_
  00034	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0003b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00042	88 45 04	 mov	 BYTE PTR x$[rbp], al
  00045	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0004c	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH
  00053	0f b6 45 04	 movzx	 eax, BYTE PTR x$[rbp]
  00057	eb 44		 jmp	 SHORT $LN1@stbi__get_
$LN4@stbi__get_:

; 2396 :     x = stbi__get8(j->s);

  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00060	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00063	e8 00 00 00 00	 call	 stbi__get8
  00068	88 45 04	 mov	 BYTE PTR x$[rbp], al

; 2397 :     if (x != 0xff) return STBI__MARKER_none;

  0006b	0f b6 45 04	 movzx	 eax, BYTE PTR x$[rbp]
  0006f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00074	74 04		 je	 SHORT $LN5@stbi__get_
  00076	b0 ff		 mov	 al, 255			; 000000ffH
  00078	eb 23		 jmp	 SHORT $LN1@stbi__get_
$LN5@stbi__get_:
$LN2@stbi__get_:

; 2398 :     while (x == 0xff)

  0007a	0f b6 45 04	 movzx	 eax, BYTE PTR x$[rbp]
  0007e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00083	75 14		 jne	 SHORT $LN3@stbi__get_

; 2399 :         x = stbi__get8(j->s); // consume repeated 0xff fill bytes

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0008c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008f	e8 00 00 00 00	 call	 stbi__get8
  00094	88 45 04	 mov	 BYTE PTR x$[rbp], al
  00097	eb e1		 jmp	 SHORT $LN2@stbi__get_
$LN3@stbi__get_:

; 2400 :     return x;

  00099	0f b6 45 04	 movzx	 eax, BYTE PTR x$[rbp]
$LN1@stbi__get_:

; 2401 : }

  0009d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a4	5f		 pop	 rdi
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
stbi__get_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__idct_simd
_TEXT	SEGMENT
row0$ = 16
row1$ = 64
row2$ = 112
row3$ = 160
row4$ = 208
row5$ = 256
row6$ = 304
row7$ = 352
tmp$ = 400
rot0_0$ = 448
rot0_1$ = 496
rot1_0$ = 544
rot1_1$ = 592
rot2_0$ = 640
rot2_1$ = 688
rot3_0$ = 736
rot3_1$ = 784
bias_0$ = 832
bias_1$ = 880
rot0_0lo$1 = 928
rot0_0hi$2 = 976
t2e_l$3 = 1024
t2e_h$4 = 1072
t3e_l$5 = 1120
t3e_h$6 = 1168
sum04$7 = 1216
dif04$8 = 1264
t0e_l$9 = 1312
t0e_h$10 = 1360
t1e_l$11 = 1408
t1e_h$12 = 1456
x0_l$13 = 1504
x0_h$14 = 1552
x3_l$15 = 1600
x3_h$16 = 1648
x1_l$17 = 1696
x1_h$18 = 1744
x2_l$19 = 1792
x2_h$20 = 1840
rot2_0lo$21 = 1888
rot2_0hi$22 = 1936
y0o_l$23 = 1984
y0o_h$24 = 2032
y2o_l$25 = 2080
y2o_h$26 = 2128
rot3_0lo$27 = 2176
rot3_0hi$28 = 2224
y1o_l$29 = 2272
y1o_h$30 = 2320
y3o_l$31 = 2368
y3o_h$32 = 2416
sum17$33 = 2464
sum35$34 = 2512
rot1_0lo$35 = 2560
rot1_0hi$36 = 2608
y4o_l$37 = 2656
y4o_h$38 = 2704
y5o_l$39 = 2752
y5o_h$40 = 2800
x4_l$41 = 2848
x4_h$42 = 2896
x5_l$43 = 2944
x5_h$44 = 2992
x6_l$45 = 3040
x6_h$46 = 3088
x7_l$47 = 3136
x7_h$48 = 3184
abiased_l$49 = 3232
abiased_h$50 = 3280
sum_l$51 = 3328
sum_h$52 = 3376
dif_l$53 = 3424
dif_h$54 = 3472
abiased_l$55 = 3520
abiased_h$56 = 3568
sum_l$57 = 3616
sum_h$58 = 3664
dif_l$59 = 3712
dif_h$60 = 3760
abiased_l$61 = 3808
abiased_h$62 = 3856
sum_l$63 = 3904
sum_h$64 = 3952
dif_l$65 = 4000
dif_h$66 = 4048
abiased_l$67 = 4096
abiased_h$68 = 4144
sum_l$69 = 4192
sum_h$70 = 4240
dif_l$71 = 4288
dif_h$72 = 4336
rot0_0lo$73 = 4384
rot0_0hi$74 = 4432
t2e_l$75 = 4480
t2e_h$76 = 4528
t3e_l$77 = 4576
t3e_h$78 = 4624
sum04$79 = 4672
dif04$80 = 4720
t0e_l$81 = 4768
t0e_h$82 = 4816
t1e_l$83 = 4864
t1e_h$84 = 4912
x0_l$85 = 4960
x0_h$86 = 5008
x3_l$87 = 5056
x3_h$88 = 5104
x1_l$89 = 5152
x1_h$90 = 5200
x2_l$91 = 5248
x2_h$92 = 5296
rot2_0lo$93 = 5344
rot2_0hi$94 = 5392
y0o_l$95 = 5440
y0o_h$96 = 5488
y2o_l$97 = 5536
y2o_h$98 = 5584
rot3_0lo$99 = 5632
rot3_0hi$100 = 5680
y1o_l$101 = 5728
y1o_h$102 = 5776
y3o_l$103 = 5824
y3o_h$104 = 5872
sum17$105 = 5920
sum35$106 = 5968
rot1_0lo$107 = 6016
rot1_0hi$108 = 6064
y4o_l$109 = 6112
y4o_h$110 = 6160
y5o_l$111 = 6208
y5o_h$112 = 6256
x4_l$113 = 6304
x4_h$114 = 6352
x5_l$115 = 6400
x5_h$116 = 6448
x6_l$117 = 6496
x6_h$118 = 6544
x7_l$119 = 6592
x7_h$120 = 6640
abiased_l$121 = 6688
abiased_h$122 = 6736
sum_l$123 = 6784
sum_h$124 = 6832
dif_l$125 = 6880
dif_h$126 = 6928
abiased_l$127 = 6976
abiased_h$128 = 7024
sum_l$129 = 7072
sum_h$130 = 7120
dif_l$131 = 7168
dif_h$132 = 7216
abiased_l$133 = 7264
abiased_h$134 = 7312
sum_l$135 = 7360
sum_h$136 = 7408
dif_l$137 = 7456
dif_h$138 = 7504
abiased_l$139 = 7552
abiased_h$140 = 7600
sum_l$141 = 7648
sum_h$142 = 7696
dif_l$143 = 7744
dif_h$144 = 7792
p0$145 = 7840
p1$146 = 7888
p2$147 = 7936
p3$148 = 7984
out$ = 9584
out_stride$ = 9592
data$ = 9600
stbi__idct_simd PROC					; COMDAT

; 2004 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	b8 78 25 00 00	 mov	 eax, 9592		; 00002578H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2005 :     // This is constructed to match our regular (generic) integer IDCT exactly.
; 2006 :     __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2007 :     __m128i tmp;
; 2008 : 
; 2009 :     // dot product constant: even elems=x, odd elems=y
; 2010 : #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2011 : 
; 2012 : // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2013 : // out(1) = c1[even]*x + c1[odd]*y
; 2014 : #define dct_rot(out0,out1, x,y,c0,c1) \
; 2015 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2016 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2017 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2018 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2019 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2020 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2021 : 
; 2022 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2023 : #define dct_widen(out, in) \
; 2024 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2025 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2026 : 
; 2027 :    // wide add
; 2028 : #define dct_wadd(out, a, b) \
; 2029 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2030 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2031 : 
; 2032 :    // wide sub
; 2033 : #define dct_wsub(out, a, b) \
; 2034 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2035 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2036 : 
; 2037 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2038 : #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2039 :       { \
; 2040 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2041 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2042 :          dct_wadd(sum, abiased, b); \
; 2043 :          dct_wsub(dif, abiased, b); \
; 2044 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2045 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2046 :       }
; 2047 : 
; 2048 :    // 8-bit interleave step (for transposes)
; 2049 : #define dct_interleave8(a, b) \
; 2050 :       tmp = a; \
; 2051 :       a = _mm_unpacklo_epi8(a, b); \
; 2052 :       b = _mm_unpackhi_epi8(tmp, b)
; 2053 : 
; 2054 :    // 16-bit interleave step (for transposes)
; 2055 : #define dct_interleave16(a, b) \
; 2056 :       tmp = a; \
; 2057 :       a = _mm_unpacklo_epi16(a, b); \
; 2058 :       b = _mm_unpackhi_epi16(tmp, b)
; 2059 : 
; 2060 : #define dct_pass(bias,shift) \
; 2061 :       { \
; 2062 :          /* even part */ \
; 2063 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2064 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2065 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2066 :          dct_widen(t0e, sum04); \
; 2067 :          dct_widen(t1e, dif04); \
; 2068 :          dct_wadd(x0, t0e, t3e); \
; 2069 :          dct_wsub(x3, t0e, t3e); \
; 2070 :          dct_wadd(x1, t1e, t2e); \
; 2071 :          dct_wsub(x2, t1e, t2e); \
; 2072 :          /* odd part */ \
; 2073 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2074 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2075 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2076 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2077 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2078 :          dct_wadd(x4, y0o, y4o); \
; 2079 :          dct_wadd(x5, y1o, y5o); \
; 2080 :          dct_wadd(x6, y2o, y5o); \
; 2081 :          dct_wadd(x7, y3o, y4o); \
; 2082 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2083 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2084 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2085 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2086 :       }
; 2087 : 
; 2088 :     __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

  0002e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
  00036	66 0f 7f 85 c0
	01 00 00	 movdqa	 XMMWORD PTR rot0_0$[rbp], xmm0

; 2089 :     __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));

  0003e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
  00046	66 0f 7f 85 f0
	01 00 00	 movdqa	 XMMWORD PTR rot0_1$[rbp], xmm0

; 2090 :     __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

  0004e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
  00056	66 0f 7f 85 20
	02 00 00	 movdqa	 XMMWORD PTR rot1_0$[rbp], xmm0

; 2091 :     __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

  0005e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
  00066	66 0f 7f 85 50
	02 00 00	 movdqa	 XMMWORD PTR rot1_1$[rbp], xmm0

; 2092 :     __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));

  0006e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
  00076	66 0f 7f 85 80
	02 00 00	 movdqa	 XMMWORD PTR rot2_0$[rbp], xmm0

; 2093 :     __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));

  0007e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
  00086	66 0f 7f 85 b0
	02 00 00	 movdqa	 XMMWORD PTR rot2_1$[rbp], xmm0

; 2094 :     __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));

  0008e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
  00096	66 0f 7f 85 e0
	02 00 00	 movdqa	 XMMWORD PTR rot3_0$[rbp], xmm0

; 2095 :     __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));

  0009e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
  000a6	66 0f 7f 85 10
	03 00 00	 movdqa	 XMMWORD PTR rot3_1$[rbp], xmm0

; 2096 : 
; 2097 :     // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2098 :     __m128i bias_0 = _mm_set1_epi32(512);

  000ae	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
  000b6	66 0f 7f 85 40
	03 00 00	 movdqa	 XMMWORD PTR bias_0$[rbp], xmm0

; 2099 :     __m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));

  000be	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
  000c6	66 0f 7f 85 70
	03 00 00	 movdqa	 XMMWORD PTR bias_1$[rbp], xmm0

; 2100 : 
; 2101 :     // load
; 2102 :     row0 = _mm_load_si128((const __m128i*) (data + 0 * 8));

  000ce	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  000d5	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  000d9	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0

; 2103 :     row1 = _mm_load_si128((const __m128i*) (data + 1 * 8));

  000de	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  000e5	48 83 c0 10	 add	 rax, 16
  000e9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  000ed	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0

; 2104 :     row2 = _mm_load_si128((const __m128i*) (data + 2 * 8));

  000f2	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  000f9	48 83 c0 20	 add	 rax, 32			; 00000020H
  000fd	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00101	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0

; 2105 :     row3 = _mm_load_si128((const __m128i*) (data + 3 * 8));

  00106	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  0010d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00111	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00115	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0

; 2106 :     row4 = _mm_load_si128((const __m128i*) (data + 4 * 8));

  0011d	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00124	48 83 c0 40	 add	 rax, 64			; 00000040H
  00128	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0012c	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0

; 2107 :     row5 = _mm_load_si128((const __m128i*) (data + 5 * 8));

  00134	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  0013b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0013f	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00143	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0

; 2108 :     row6 = _mm_load_si128((const __m128i*) (data + 6 * 8));

  0014b	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00152	48 83 c0 60	 add	 rax, 96			; 00000060H
  00156	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0015a	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0

; 2109 :     row7 = _mm_load_si128((const __m128i*) (data + 7 * 8));

  00162	48 8b 85 80 25
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00169	48 83 c0 70	 add	 rax, 112		; 00000070H
  0016d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00171	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0

; 2110 : 
; 2111 :     // column pass
; 2112 :     dct_pass(bias_0, 10);

  00179	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  0017e	66 0f 61 85 30
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rbp]
  00186	66 0f 7f 85 a0
	03 00 00	 movdqa	 XMMWORD PTR rot0_0lo$1[rbp], xmm0
  0018e	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  00193	66 0f 69 85 30
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rbp]
  0019b	66 0f 7f 85 d0
	03 00 00	 movdqa	 XMMWORD PTR rot0_0hi$2[rbp], xmm0
  001a3	66 0f 6f 85 a0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$1[rbp]
  001ab	66 0f f5 85 c0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rbp]
  001b3	66 0f 7f 85 00
	04 00 00	 movdqa	 XMMWORD PTR t2e_l$3[rbp], xmm0
  001bb	66 0f 6f 85 d0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$2[rbp]
  001c3	66 0f f5 85 c0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rbp]
  001cb	66 0f 7f 85 30
	04 00 00	 movdqa	 XMMWORD PTR t2e_h$4[rbp], xmm0
  001d3	66 0f 6f 85 a0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$1[rbp]
  001db	66 0f f5 85 f0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rbp]
  001e3	66 0f 7f 85 60
	04 00 00	 movdqa	 XMMWORD PTR t3e_l$5[rbp], xmm0
  001eb	66 0f 6f 85 d0
	03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$2[rbp]
  001f3	66 0f f5 85 f0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rbp]
  001fb	66 0f 7f 85 90
	04 00 00	 movdqa	 XMMWORD PTR t3e_h$6[rbp], xmm0
  00203	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00208	66 0f fd 85 d0
	00 00 00	 paddw	 xmm0, XMMWORD PTR row4$[rbp]
  00210	66 0f 7f 85 c0
	04 00 00	 movdqa	 XMMWORD PTR sum04$7[rbp], xmm0
  00218	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  0021d	66 0f f9 85 d0
	00 00 00	 psubw	 xmm0, XMMWORD PTR row4$[rbp]
  00225	66 0f 7f 85 f0
	04 00 00	 movdqa	 XMMWORD PTR dif04$8[rbp], xmm0
  0022d	66 0f ef c0	 pxor	 xmm0, xmm0
  00231	66 0f 61 85 c0
	04 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$7[rbp]
  00239	66 0f 72 e0 04	 psrad	 xmm0, 4
  0023e	66 0f 7f 85 20
	05 00 00	 movdqa	 XMMWORD PTR t0e_l$9[rbp], xmm0
  00246	66 0f ef c0	 pxor	 xmm0, xmm0
  0024a	66 0f 69 85 c0
	04 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$7[rbp]
  00252	66 0f 72 e0 04	 psrad	 xmm0, 4
  00257	66 0f 7f 85 50
	05 00 00	 movdqa	 XMMWORD PTR t0e_h$10[rbp], xmm0
  0025f	66 0f ef c0	 pxor	 xmm0, xmm0
  00263	66 0f 61 85 f0
	04 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$8[rbp]
  0026b	66 0f 72 e0 04	 psrad	 xmm0, 4
  00270	66 0f 7f 85 80
	05 00 00	 movdqa	 XMMWORD PTR t1e_l$11[rbp], xmm0
  00278	66 0f ef c0	 pxor	 xmm0, xmm0
  0027c	66 0f 69 85 f0
	04 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$8[rbp]
  00284	66 0f 72 e0 04	 psrad	 xmm0, 4
  00289	66 0f 7f 85 b0
	05 00 00	 movdqa	 XMMWORD PTR t1e_h$12[rbp], xmm0
  00291	66 0f 6f 85 20
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rbp]
  00299	66 0f fe 85 60
	04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$5[rbp]
  002a1	66 0f 7f 85 e0
	05 00 00	 movdqa	 XMMWORD PTR x0_l$13[rbp], xmm0
  002a9	66 0f 6f 85 50
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$10[rbp]
  002b1	66 0f fe 85 90
	04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$6[rbp]
  002b9	66 0f 7f 85 10
	06 00 00	 movdqa	 XMMWORD PTR x0_h$14[rbp], xmm0
  002c1	66 0f 6f 85 20
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rbp]
  002c9	66 0f fa 85 60
	04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$5[rbp]
  002d1	66 0f 7f 85 40
	06 00 00	 movdqa	 XMMWORD PTR x3_l$15[rbp], xmm0
  002d9	66 0f 6f 85 50
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$10[rbp]
  002e1	66 0f fa 85 90
	04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$6[rbp]
  002e9	66 0f 7f 85 70
	06 00 00	 movdqa	 XMMWORD PTR x3_h$16[rbp], xmm0
  002f1	66 0f 6f 85 80
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$11[rbp]
  002f9	66 0f fe 85 00
	04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$3[rbp]
  00301	66 0f 7f 85 a0
	06 00 00	 movdqa	 XMMWORD PTR x1_l$17[rbp], xmm0
  00309	66 0f 6f 85 b0
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$12[rbp]
  00311	66 0f fe 85 30
	04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$4[rbp]
  00319	66 0f 7f 85 d0
	06 00 00	 movdqa	 XMMWORD PTR x1_h$18[rbp], xmm0
  00321	66 0f 6f 85 80
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$11[rbp]
  00329	66 0f fa 85 00
	04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$3[rbp]
  00331	66 0f 7f 85 00
	07 00 00	 movdqa	 XMMWORD PTR x2_l$19[rbp], xmm0
  00339	66 0f 6f 85 b0
	05 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$12[rbp]
  00341	66 0f fa 85 30
	04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$4[rbp]
  00349	66 0f 7f 85 30
	07 00 00	 movdqa	 XMMWORD PTR x2_h$20[rbp], xmm0
  00351	66 0f 6f 85 60
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rbp]
  00359	66 0f 61 85 a0
	00 00 00	 punpcklwd xmm0, XMMWORD PTR row3$[rbp]
  00361	66 0f 7f 85 60
	07 00 00	 movdqa	 XMMWORD PTR rot2_0lo$21[rbp], xmm0
  00369	66 0f 6f 85 60
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rbp]
  00371	66 0f 69 85 a0
	00 00 00	 punpckhwd xmm0, XMMWORD PTR row3$[rbp]
  00379	66 0f 7f 85 90
	07 00 00	 movdqa	 XMMWORD PTR rot2_0hi$22[rbp], xmm0
  00381	66 0f 6f 85 60
	07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$21[rbp]
  00389	66 0f f5 85 80
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rbp]
  00391	66 0f 7f 85 c0
	07 00 00	 movdqa	 XMMWORD PTR y0o_l$23[rbp], xmm0
  00399	66 0f 6f 85 90
	07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$22[rbp]
  003a1	66 0f f5 85 80
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rbp]
  003a9	66 0f 7f 85 f0
	07 00 00	 movdqa	 XMMWORD PTR y0o_h$24[rbp], xmm0
  003b1	66 0f 6f 85 60
	07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$21[rbp]
  003b9	66 0f f5 85 b0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rbp]
  003c1	66 0f 7f 85 20
	08 00 00	 movdqa	 XMMWORD PTR y2o_l$25[rbp], xmm0
  003c9	66 0f 6f 85 90
	07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$22[rbp]
  003d1	66 0f f5 85 b0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rbp]
  003d9	66 0f 7f 85 50
	08 00 00	 movdqa	 XMMWORD PTR y2o_h$26[rbp], xmm0
  003e1	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  003e9	66 0f 61 45 40	 punpcklwd xmm0, XMMWORD PTR row1$[rbp]
  003ee	66 0f 7f 85 80
	08 00 00	 movdqa	 XMMWORD PTR rot3_0lo$27[rbp], xmm0
  003f6	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  003fe	66 0f 69 45 40	 punpckhwd xmm0, XMMWORD PTR row1$[rbp]
  00403	66 0f 7f 85 b0
	08 00 00	 movdqa	 XMMWORD PTR rot3_0hi$28[rbp], xmm0
  0040b	66 0f 6f 85 80
	08 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$27[rbp]
  00413	66 0f f5 85 e0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rbp]
  0041b	66 0f 7f 85 e0
	08 00 00	 movdqa	 XMMWORD PTR y1o_l$29[rbp], xmm0
  00423	66 0f 6f 85 b0
	08 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$28[rbp]
  0042b	66 0f f5 85 e0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rbp]
  00433	66 0f 7f 85 10
	09 00 00	 movdqa	 XMMWORD PTR y1o_h$30[rbp], xmm0
  0043b	66 0f 6f 85 80
	08 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$27[rbp]
  00443	66 0f f5 85 10
	03 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rbp]
  0044b	66 0f 7f 85 40
	09 00 00	 movdqa	 XMMWORD PTR y3o_l$31[rbp], xmm0
  00453	66 0f 6f 85 b0
	08 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$28[rbp]
  0045b	66 0f f5 85 10
	03 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rbp]
  00463	66 0f 7f 85 70
	09 00 00	 movdqa	 XMMWORD PTR y3o_h$32[rbp], xmm0
  0046b	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  00470	66 0f fd 85 60
	01 00 00	 paddw	 xmm0, XMMWORD PTR row7$[rbp]
  00478	66 0f 7f 85 a0
	09 00 00	 movdqa	 XMMWORD PTR sum17$33[rbp], xmm0
  00480	66 0f 6f 85 a0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row3$[rbp]
  00488	66 0f fd 85 00
	01 00 00	 paddw	 xmm0, XMMWORD PTR row5$[rbp]
  00490	66 0f 7f 85 d0
	09 00 00	 movdqa	 XMMWORD PTR sum35$34[rbp], xmm0
  00498	66 0f 6f 85 a0
	09 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$33[rbp]
  004a0	66 0f 61 85 d0
	09 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$34[rbp]
  004a8	66 0f 7f 85 00
	0a 00 00	 movdqa	 XMMWORD PTR rot1_0lo$35[rbp], xmm0
  004b0	66 0f 6f 85 a0
	09 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$33[rbp]
  004b8	66 0f 69 85 d0
	09 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$34[rbp]
  004c0	66 0f 7f 85 30
	0a 00 00	 movdqa	 XMMWORD PTR rot1_0hi$36[rbp], xmm0
  004c8	66 0f 6f 85 00
	0a 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$35[rbp]
  004d0	66 0f f5 85 20
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rbp]
  004d8	66 0f 7f 85 60
	0a 00 00	 movdqa	 XMMWORD PTR y4o_l$37[rbp], xmm0
  004e0	66 0f 6f 85 30
	0a 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$36[rbp]
  004e8	66 0f f5 85 20
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rbp]
  004f0	66 0f 7f 85 90
	0a 00 00	 movdqa	 XMMWORD PTR y4o_h$38[rbp], xmm0
  004f8	66 0f 6f 85 00
	0a 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$35[rbp]
  00500	66 0f f5 85 50
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rbp]
  00508	66 0f 7f 85 c0
	0a 00 00	 movdqa	 XMMWORD PTR y5o_l$39[rbp], xmm0
  00510	66 0f 6f 85 30
	0a 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$36[rbp]
  00518	66 0f f5 85 50
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rbp]
  00520	66 0f 7f 85 f0
	0a 00 00	 movdqa	 XMMWORD PTR y5o_h$40[rbp], xmm0
  00528	66 0f 6f 85 c0
	07 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$23[rbp]
  00530	66 0f fe 85 60
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$37[rbp]
  00538	66 0f 7f 85 20
	0b 00 00	 movdqa	 XMMWORD PTR x4_l$41[rbp], xmm0
  00540	66 0f 6f 85 f0
	07 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$24[rbp]
  00548	66 0f fe 85 90
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$38[rbp]
  00550	66 0f 7f 85 50
	0b 00 00	 movdqa	 XMMWORD PTR x4_h$42[rbp], xmm0
  00558	66 0f 6f 85 e0
	08 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$29[rbp]
  00560	66 0f fe 85 c0
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$39[rbp]
  00568	66 0f 7f 85 80
	0b 00 00	 movdqa	 XMMWORD PTR x5_l$43[rbp], xmm0
  00570	66 0f 6f 85 10
	09 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$30[rbp]
  00578	66 0f fe 85 f0
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$40[rbp]
  00580	66 0f 7f 85 b0
	0b 00 00	 movdqa	 XMMWORD PTR x5_h$44[rbp], xmm0
  00588	66 0f 6f 85 20
	08 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$25[rbp]
  00590	66 0f fe 85 c0
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$39[rbp]
  00598	66 0f 7f 85 e0
	0b 00 00	 movdqa	 XMMWORD PTR x6_l$45[rbp], xmm0
  005a0	66 0f 6f 85 50
	08 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$26[rbp]
  005a8	66 0f fe 85 f0
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$40[rbp]
  005b0	66 0f 7f 85 10
	0c 00 00	 movdqa	 XMMWORD PTR x6_h$46[rbp], xmm0
  005b8	66 0f 6f 85 40
	09 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$31[rbp]
  005c0	66 0f fe 85 60
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$37[rbp]
  005c8	66 0f 7f 85 40
	0c 00 00	 movdqa	 XMMWORD PTR x7_l$47[rbp], xmm0
  005d0	66 0f 6f 85 70
	09 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$32[rbp]
  005d8	66 0f fe 85 90
	0a 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$38[rbp]
  005e0	66 0f 7f 85 70
	0c 00 00	 movdqa	 XMMWORD PTR x7_h$48[rbp], xmm0
  005e8	66 0f 6f 85 e0
	05 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$13[rbp]
  005f0	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  005f8	66 0f 7f 85 a0
	0c 00 00	 movdqa	 XMMWORD PTR abiased_l$49[rbp], xmm0
  00600	66 0f 6f 85 10
	06 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$14[rbp]
  00608	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  00610	66 0f 7f 85 d0
	0c 00 00	 movdqa	 XMMWORD PTR abiased_h$50[rbp], xmm0
  00618	66 0f 6f 85 a0
	0c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$49[rbp]
  00620	66 0f fe 85 40
	0c 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$47[rbp]
  00628	66 0f 7f 85 00
	0d 00 00	 movdqa	 XMMWORD PTR sum_l$51[rbp], xmm0
  00630	66 0f 6f 85 d0
	0c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$50[rbp]
  00638	66 0f fe 85 70
	0c 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$48[rbp]
  00640	66 0f 7f 85 30
	0d 00 00	 movdqa	 XMMWORD PTR sum_h$52[rbp], xmm0
  00648	66 0f 6f 85 a0
	0c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$49[rbp]
  00650	66 0f fa 85 40
	0c 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$47[rbp]
  00658	66 0f 7f 85 60
	0d 00 00	 movdqa	 XMMWORD PTR dif_l$53[rbp], xmm0
  00660	66 0f 6f 85 d0
	0c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$50[rbp]
  00668	66 0f fa 85 70
	0c 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$48[rbp]
  00670	66 0f 7f 85 90
	0d 00 00	 movdqa	 XMMWORD PTR dif_h$54[rbp], xmm0
  00678	66 0f 6f 85 30
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$52[rbp]
  00680	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00685	66 0f 6f 8d 00
	0d 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$51[rbp]
  0068d	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00692	66 0f 6b c8	 packssdw xmm1, xmm0
  00696	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0069a	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0
  0069f	66 0f 6f 85 90
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$54[rbp]
  006a7	66 0f 72 e0 0a	 psrad	 xmm0, 10
  006ac	66 0f 6f 8d 60
	0d 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$53[rbp]
  006b4	66 0f 72 e1 0a	 psrad	 xmm1, 10
  006b9	66 0f 6b c8	 packssdw xmm1, xmm0
  006bd	66 0f 6f c1	 movdqa	 xmm0, xmm1
  006c1	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0
  006c9	66 0f 6f 85 a0
	06 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$17[rbp]
  006d1	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  006d9	66 0f 7f 85 c0
	0d 00 00	 movdqa	 XMMWORD PTR abiased_l$55[rbp], xmm0
  006e1	66 0f 6f 85 d0
	06 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$18[rbp]
  006e9	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  006f1	66 0f 7f 85 f0
	0d 00 00	 movdqa	 XMMWORD PTR abiased_h$56[rbp], xmm0
  006f9	66 0f 6f 85 c0
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$55[rbp]
  00701	66 0f fe 85 e0
	0b 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$45[rbp]
  00709	66 0f 7f 85 20
	0e 00 00	 movdqa	 XMMWORD PTR sum_l$57[rbp], xmm0
  00711	66 0f 6f 85 f0
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$56[rbp]
  00719	66 0f fe 85 10
	0c 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$46[rbp]
  00721	66 0f 7f 85 50
	0e 00 00	 movdqa	 XMMWORD PTR sum_h$58[rbp], xmm0
  00729	66 0f 6f 85 c0
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$55[rbp]
  00731	66 0f fa 85 e0
	0b 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$45[rbp]
  00739	66 0f 7f 85 80
	0e 00 00	 movdqa	 XMMWORD PTR dif_l$59[rbp], xmm0
  00741	66 0f 6f 85 f0
	0d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$56[rbp]
  00749	66 0f fa 85 10
	0c 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$46[rbp]
  00751	66 0f 7f 85 b0
	0e 00 00	 movdqa	 XMMWORD PTR dif_h$60[rbp], xmm0
  00759	66 0f 6f 85 50
	0e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$58[rbp]
  00761	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00766	66 0f 6f 8d 20
	0e 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$57[rbp]
  0076e	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00773	66 0f 6b c8	 packssdw xmm1, xmm0
  00777	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0077b	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0
  00780	66 0f 6f 85 b0
	0e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$60[rbp]
  00788	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0078d	66 0f 6f 8d 80
	0e 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$59[rbp]
  00795	66 0f 72 e1 0a	 psrad	 xmm1, 10
  0079a	66 0f 6b c8	 packssdw xmm1, xmm0
  0079e	66 0f 6f c1	 movdqa	 xmm0, xmm1
  007a2	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0
  007aa	66 0f 6f 85 00
	07 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$19[rbp]
  007b2	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  007ba	66 0f 7f 85 e0
	0e 00 00	 movdqa	 XMMWORD PTR abiased_l$61[rbp], xmm0
  007c2	66 0f 6f 85 30
	07 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$20[rbp]
  007ca	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  007d2	66 0f 7f 85 10
	0f 00 00	 movdqa	 XMMWORD PTR abiased_h$62[rbp], xmm0
  007da	66 0f 6f 85 e0
	0e 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$61[rbp]
  007e2	66 0f fe 85 80
	0b 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$43[rbp]
  007ea	66 0f 7f 85 40
	0f 00 00	 movdqa	 XMMWORD PTR sum_l$63[rbp], xmm0
  007f2	66 0f 6f 85 10
	0f 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$62[rbp]
  007fa	66 0f fe 85 b0
	0b 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$44[rbp]
  00802	66 0f 7f 85 70
	0f 00 00	 movdqa	 XMMWORD PTR sum_h$64[rbp], xmm0
  0080a	66 0f 6f 85 e0
	0e 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$61[rbp]
  00812	66 0f fa 85 80
	0b 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$43[rbp]
  0081a	66 0f 7f 85 a0
	0f 00 00	 movdqa	 XMMWORD PTR dif_l$65[rbp], xmm0
  00822	66 0f 6f 85 10
	0f 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$62[rbp]
  0082a	66 0f fa 85 b0
	0b 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$44[rbp]
  00832	66 0f 7f 85 d0
	0f 00 00	 movdqa	 XMMWORD PTR dif_h$66[rbp], xmm0
  0083a	66 0f 6f 85 70
	0f 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$64[rbp]
  00842	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00847	66 0f 6f 8d 40
	0f 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$63[rbp]
  0084f	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00854	66 0f 6b c8	 packssdw xmm1, xmm0
  00858	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0085c	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0
  00861	66 0f 6f 85 d0
	0f 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$66[rbp]
  00869	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0086e	66 0f 6f 8d a0
	0f 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$65[rbp]
  00876	66 0f 72 e1 0a	 psrad	 xmm1, 10
  0087b	66 0f 6b c8	 packssdw xmm1, xmm0
  0087f	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00883	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0
  0088b	66 0f 6f 85 40
	06 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$15[rbp]
  00893	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  0089b	66 0f 7f 85 00
	10 00 00	 movdqa	 XMMWORD PTR abiased_l$67[rbp], xmm0
  008a3	66 0f 6f 85 70
	06 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$16[rbp]
  008ab	66 0f fe 85 40
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rbp]
  008b3	66 0f 7f 85 30
	10 00 00	 movdqa	 XMMWORD PTR abiased_h$68[rbp], xmm0
  008bb	66 0f 6f 85 00
	10 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$67[rbp]
  008c3	66 0f fe 85 20
	0b 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$41[rbp]
  008cb	66 0f 7f 85 60
	10 00 00	 movdqa	 XMMWORD PTR sum_l$69[rbp], xmm0
  008d3	66 0f 6f 85 30
	10 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$68[rbp]
  008db	66 0f fe 85 50
	0b 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$42[rbp]
  008e3	66 0f 7f 85 90
	10 00 00	 movdqa	 XMMWORD PTR sum_h$70[rbp], xmm0
  008eb	66 0f 6f 85 00
	10 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$67[rbp]
  008f3	66 0f fa 85 20
	0b 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$41[rbp]
  008fb	66 0f 7f 85 c0
	10 00 00	 movdqa	 XMMWORD PTR dif_l$71[rbp], xmm0
  00903	66 0f 6f 85 30
	10 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$68[rbp]
  0090b	66 0f fa 85 50
	0b 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$42[rbp]
  00913	66 0f 7f 85 f0
	10 00 00	 movdqa	 XMMWORD PTR dif_h$72[rbp], xmm0
  0091b	66 0f 6f 85 90
	10 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$70[rbp]
  00923	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00928	66 0f 6f 8d 60
	10 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$69[rbp]
  00930	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00935	66 0f 6b c8	 packssdw xmm1, xmm0
  00939	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0093d	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0
  00945	66 0f 6f 85 f0
	10 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$72[rbp]
  0094d	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00952	66 0f 6f 8d c0
	10 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$71[rbp]
  0095a	66 0f 72 e1 0a	 psrad	 xmm1, 10
  0095f	66 0f 6b c8	 packssdw xmm1, xmm0
  00963	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00967	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0

; 2113 : 
; 2114 :     {
; 2115 :         // 16bit 8x8 transpose pass 1
; 2116 :         dct_interleave16(row0, row4);

  0096f	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00974	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  0097c	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00981	66 0f 61 85 d0
	00 00 00	 punpcklwd xmm0, XMMWORD PTR row4$[rbp]
  00989	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0
  0098e	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00996	66 0f 69 85 d0
	00 00 00	 punpckhwd xmm0, XMMWORD PTR row4$[rbp]
  0099e	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0

; 2117 :         dct_interleave16(row1, row5);

  009a6	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  009ab	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  009b3	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  009b8	66 0f 61 85 00
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row5$[rbp]
  009c0	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0
  009c5	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  009cd	66 0f 69 85 00
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row5$[rbp]
  009d5	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0

; 2118 :         dct_interleave16(row2, row6);

  009dd	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  009e2	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  009ea	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  009ef	66 0f 61 85 30
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rbp]
  009f7	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0
  009fc	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00a04	66 0f 69 85 30
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rbp]
  00a0c	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0

; 2119 :         dct_interleave16(row3, row7);

  00a14	66 0f 6f 85 a0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row3$[rbp]
  00a1c	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00a24	66 0f 6f 85 a0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row3$[rbp]
  00a2c	66 0f 61 85 60
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rbp]
  00a34	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0
  00a3c	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00a44	66 0f 69 85 60
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rbp]
  00a4c	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0

; 2120 : 
; 2121 :         // transpose pass 2
; 2122 :         dct_interleave16(row0, row2);

  00a54	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00a59	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00a61	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00a66	66 0f 61 45 70	 punpcklwd xmm0, XMMWORD PTR row2$[rbp]
  00a6b	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0
  00a70	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00a78	66 0f 69 45 70	 punpckhwd xmm0, XMMWORD PTR row2$[rbp]
  00a7d	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0

; 2123 :         dct_interleave16(row1, row3);

  00a82	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  00a87	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00a8f	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  00a94	66 0f 61 85 a0
	00 00 00	 punpcklwd xmm0, XMMWORD PTR row3$[rbp]
  00a9c	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0
  00aa1	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00aa9	66 0f 69 85 a0
	00 00 00	 punpckhwd xmm0, XMMWORD PTR row3$[rbp]
  00ab1	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0

; 2124 :         dct_interleave16(row4, row6);

  00ab9	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row4$[rbp]
  00ac1	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00ac9	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row4$[rbp]
  00ad1	66 0f 61 85 30
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rbp]
  00ad9	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0
  00ae1	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00ae9	66 0f 69 85 30
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rbp]
  00af1	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0

; 2125 :         dct_interleave16(row5, row7);

  00af9	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  00b01	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00b09	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  00b11	66 0f 61 85 60
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rbp]
  00b19	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0
  00b21	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00b29	66 0f 69 85 60
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rbp]
  00b31	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0

; 2126 : 
; 2127 :         // transpose pass 3
; 2128 :         dct_interleave16(row0, row1);

  00b39	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00b3e	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00b46	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00b4b	66 0f 61 45 40	 punpcklwd xmm0, XMMWORD PTR row1$[rbp]
  00b50	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0
  00b55	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00b5d	66 0f 69 45 40	 punpckhwd xmm0, XMMWORD PTR row1$[rbp]
  00b62	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0

; 2129 :         dct_interleave16(row2, row3);

  00b67	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  00b6c	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00b74	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  00b79	66 0f 61 85 a0
	00 00 00	 punpcklwd xmm0, XMMWORD PTR row3$[rbp]
  00b81	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0
  00b86	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00b8e	66 0f 69 85 a0
	00 00 00	 punpckhwd xmm0, XMMWORD PTR row3$[rbp]
  00b96	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0

; 2130 :         dct_interleave16(row4, row5);

  00b9e	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row4$[rbp]
  00ba6	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00bae	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row4$[rbp]
  00bb6	66 0f 61 85 00
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row5$[rbp]
  00bbe	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0
  00bc6	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00bce	66 0f 69 85 00
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row5$[rbp]
  00bd6	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0

; 2131 :         dct_interleave16(row6, row7);

  00bde	66 0f 6f 85 30
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rbp]
  00be6	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  00bee	66 0f 6f 85 30
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rbp]
  00bf6	66 0f 61 85 60
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rbp]
  00bfe	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0
  00c06	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  00c0e	66 0f 69 85 60
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rbp]
  00c16	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0

; 2132 :     }
; 2133 : 
; 2134 :     // row pass
; 2135 :     dct_pass(bias_1, 17);

  00c1e	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  00c23	66 0f 61 85 30
	01 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rbp]
  00c2b	66 0f 7f 85 20
	11 00 00	 movdqa	 XMMWORD PTR rot0_0lo$73[rbp], xmm0
  00c33	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  00c38	66 0f 69 85 30
	01 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rbp]
  00c40	66 0f 7f 85 50
	11 00 00	 movdqa	 XMMWORD PTR rot0_0hi$74[rbp], xmm0
  00c48	66 0f 6f 85 20
	11 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$73[rbp]
  00c50	66 0f f5 85 c0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rbp]
  00c58	66 0f 7f 85 80
	11 00 00	 movdqa	 XMMWORD PTR t2e_l$75[rbp], xmm0
  00c60	66 0f 6f 85 50
	11 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$74[rbp]
  00c68	66 0f f5 85 c0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rbp]
  00c70	66 0f 7f 85 b0
	11 00 00	 movdqa	 XMMWORD PTR t2e_h$76[rbp], xmm0
  00c78	66 0f 6f 85 20
	11 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$73[rbp]
  00c80	66 0f f5 85 f0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rbp]
  00c88	66 0f 7f 85 e0
	11 00 00	 movdqa	 XMMWORD PTR t3e_l$77[rbp], xmm0
  00c90	66 0f 6f 85 50
	11 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$74[rbp]
  00c98	66 0f f5 85 f0
	01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rbp]
  00ca0	66 0f 7f 85 10
	12 00 00	 movdqa	 XMMWORD PTR t3e_h$78[rbp], xmm0
  00ca8	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00cad	66 0f fd 85 d0
	00 00 00	 paddw	 xmm0, XMMWORD PTR row4$[rbp]
  00cb5	66 0f 7f 85 40
	12 00 00	 movdqa	 XMMWORD PTR sum04$79[rbp], xmm0
  00cbd	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  00cc2	66 0f f9 85 d0
	00 00 00	 psubw	 xmm0, XMMWORD PTR row4$[rbp]
  00cca	66 0f 7f 85 70
	12 00 00	 movdqa	 XMMWORD PTR dif04$80[rbp], xmm0
  00cd2	66 0f ef c0	 pxor	 xmm0, xmm0
  00cd6	66 0f 61 85 40
	12 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$79[rbp]
  00cde	66 0f 72 e0 04	 psrad	 xmm0, 4
  00ce3	66 0f 7f 85 a0
	12 00 00	 movdqa	 XMMWORD PTR t0e_l$81[rbp], xmm0
  00ceb	66 0f ef c0	 pxor	 xmm0, xmm0
  00cef	66 0f 69 85 40
	12 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$79[rbp]
  00cf7	66 0f 72 e0 04	 psrad	 xmm0, 4
  00cfc	66 0f 7f 85 d0
	12 00 00	 movdqa	 XMMWORD PTR t0e_h$82[rbp], xmm0
  00d04	66 0f ef c0	 pxor	 xmm0, xmm0
  00d08	66 0f 61 85 70
	12 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$80[rbp]
  00d10	66 0f 72 e0 04	 psrad	 xmm0, 4
  00d15	66 0f 7f 85 00
	13 00 00	 movdqa	 XMMWORD PTR t1e_l$83[rbp], xmm0
  00d1d	66 0f ef c0	 pxor	 xmm0, xmm0
  00d21	66 0f 69 85 70
	12 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$80[rbp]
  00d29	66 0f 72 e0 04	 psrad	 xmm0, 4
  00d2e	66 0f 7f 85 30
	13 00 00	 movdqa	 XMMWORD PTR t1e_h$84[rbp], xmm0
  00d36	66 0f 6f 85 a0
	12 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$81[rbp]
  00d3e	66 0f fe 85 e0
	11 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$77[rbp]
  00d46	66 0f 7f 85 60
	13 00 00	 movdqa	 XMMWORD PTR x0_l$85[rbp], xmm0
  00d4e	66 0f 6f 85 d0
	12 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$82[rbp]
  00d56	66 0f fe 85 10
	12 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$78[rbp]
  00d5e	66 0f 7f 85 90
	13 00 00	 movdqa	 XMMWORD PTR x0_h$86[rbp], xmm0
  00d66	66 0f 6f 85 a0
	12 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$81[rbp]
  00d6e	66 0f fa 85 e0
	11 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$77[rbp]
  00d76	66 0f 7f 85 c0
	13 00 00	 movdqa	 XMMWORD PTR x3_l$87[rbp], xmm0
  00d7e	66 0f 6f 85 d0
	12 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$82[rbp]
  00d86	66 0f fa 85 10
	12 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$78[rbp]
  00d8e	66 0f 7f 85 f0
	13 00 00	 movdqa	 XMMWORD PTR x3_h$88[rbp], xmm0
  00d96	66 0f 6f 85 00
	13 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$83[rbp]
  00d9e	66 0f fe 85 80
	11 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$75[rbp]
  00da6	66 0f 7f 85 20
	14 00 00	 movdqa	 XMMWORD PTR x1_l$89[rbp], xmm0
  00dae	66 0f 6f 85 30
	13 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$84[rbp]
  00db6	66 0f fe 85 b0
	11 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$76[rbp]
  00dbe	66 0f 7f 85 50
	14 00 00	 movdqa	 XMMWORD PTR x1_h$90[rbp], xmm0
  00dc6	66 0f 6f 85 00
	13 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$83[rbp]
  00dce	66 0f fa 85 80
	11 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$75[rbp]
  00dd6	66 0f 7f 85 80
	14 00 00	 movdqa	 XMMWORD PTR x2_l$91[rbp], xmm0
  00dde	66 0f 6f 85 30
	13 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$84[rbp]
  00de6	66 0f fa 85 b0
	11 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$76[rbp]
  00dee	66 0f 7f 85 b0
	14 00 00	 movdqa	 XMMWORD PTR x2_h$92[rbp], xmm0
  00df6	66 0f 6f 85 60
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rbp]
  00dfe	66 0f 61 85 a0
	00 00 00	 punpcklwd xmm0, XMMWORD PTR row3$[rbp]
  00e06	66 0f 7f 85 e0
	14 00 00	 movdqa	 XMMWORD PTR rot2_0lo$93[rbp], xmm0
  00e0e	66 0f 6f 85 60
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rbp]
  00e16	66 0f 69 85 a0
	00 00 00	 punpckhwd xmm0, XMMWORD PTR row3$[rbp]
  00e1e	66 0f 7f 85 10
	15 00 00	 movdqa	 XMMWORD PTR rot2_0hi$94[rbp], xmm0
  00e26	66 0f 6f 85 e0
	14 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$93[rbp]
  00e2e	66 0f f5 85 80
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rbp]
  00e36	66 0f 7f 85 40
	15 00 00	 movdqa	 XMMWORD PTR y0o_l$95[rbp], xmm0
  00e3e	66 0f 6f 85 10
	15 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$94[rbp]
  00e46	66 0f f5 85 80
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rbp]
  00e4e	66 0f 7f 85 70
	15 00 00	 movdqa	 XMMWORD PTR y0o_h$96[rbp], xmm0
  00e56	66 0f 6f 85 e0
	14 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$93[rbp]
  00e5e	66 0f f5 85 b0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rbp]
  00e66	66 0f 7f 85 a0
	15 00 00	 movdqa	 XMMWORD PTR y2o_l$97[rbp], xmm0
  00e6e	66 0f 6f 85 10
	15 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$94[rbp]
  00e76	66 0f f5 85 b0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rbp]
  00e7e	66 0f 7f 85 d0
	15 00 00	 movdqa	 XMMWORD PTR y2o_h$98[rbp], xmm0
  00e86	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  00e8e	66 0f 61 45 40	 punpcklwd xmm0, XMMWORD PTR row1$[rbp]
  00e93	66 0f 7f 85 00
	16 00 00	 movdqa	 XMMWORD PTR rot3_0lo$99[rbp], xmm0
  00e9b	66 0f 6f 85 00
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row5$[rbp]
  00ea3	66 0f 69 45 40	 punpckhwd xmm0, XMMWORD PTR row1$[rbp]
  00ea8	66 0f 7f 85 30
	16 00 00	 movdqa	 XMMWORD PTR rot3_0hi$100[rbp], xmm0
  00eb0	66 0f 6f 85 00
	16 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$99[rbp]
  00eb8	66 0f f5 85 e0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rbp]
  00ec0	66 0f 7f 85 60
	16 00 00	 movdqa	 XMMWORD PTR y1o_l$101[rbp], xmm0
  00ec8	66 0f 6f 85 30
	16 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$100[rbp]
  00ed0	66 0f f5 85 e0
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rbp]
  00ed8	66 0f 7f 85 90
	16 00 00	 movdqa	 XMMWORD PTR y1o_h$102[rbp], xmm0
  00ee0	66 0f 6f 85 00
	16 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$99[rbp]
  00ee8	66 0f f5 85 10
	03 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rbp]
  00ef0	66 0f 7f 85 c0
	16 00 00	 movdqa	 XMMWORD PTR y3o_l$103[rbp], xmm0
  00ef8	66 0f 6f 85 30
	16 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$100[rbp]
  00f00	66 0f f5 85 10
	03 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rbp]
  00f08	66 0f 7f 85 f0
	16 00 00	 movdqa	 XMMWORD PTR y3o_h$104[rbp], xmm0
  00f10	66 0f 6f 45 40	 movdqa	 xmm0, XMMWORD PTR row1$[rbp]
  00f15	66 0f fd 85 60
	01 00 00	 paddw	 xmm0, XMMWORD PTR row7$[rbp]
  00f1d	66 0f 7f 85 20
	17 00 00	 movdqa	 XMMWORD PTR sum17$105[rbp], xmm0
  00f25	66 0f 6f 85 a0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row3$[rbp]
  00f2d	66 0f fd 85 00
	01 00 00	 paddw	 xmm0, XMMWORD PTR row5$[rbp]
  00f35	66 0f 7f 85 50
	17 00 00	 movdqa	 XMMWORD PTR sum35$106[rbp], xmm0
  00f3d	66 0f 6f 85 20
	17 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$105[rbp]
  00f45	66 0f 61 85 50
	17 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$106[rbp]
  00f4d	66 0f 7f 85 80
	17 00 00	 movdqa	 XMMWORD PTR rot1_0lo$107[rbp], xmm0
  00f55	66 0f 6f 85 20
	17 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$105[rbp]
  00f5d	66 0f 69 85 50
	17 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$106[rbp]
  00f65	66 0f 7f 85 b0
	17 00 00	 movdqa	 XMMWORD PTR rot1_0hi$108[rbp], xmm0
  00f6d	66 0f 6f 85 80
	17 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$107[rbp]
  00f75	66 0f f5 85 20
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rbp]
  00f7d	66 0f 7f 85 e0
	17 00 00	 movdqa	 XMMWORD PTR y4o_l$109[rbp], xmm0
  00f85	66 0f 6f 85 b0
	17 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$108[rbp]
  00f8d	66 0f f5 85 20
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rbp]
  00f95	66 0f 7f 85 10
	18 00 00	 movdqa	 XMMWORD PTR y4o_h$110[rbp], xmm0
  00f9d	66 0f 6f 85 80
	17 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$107[rbp]
  00fa5	66 0f f5 85 50
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rbp]
  00fad	66 0f 7f 85 40
	18 00 00	 movdqa	 XMMWORD PTR y5o_l$111[rbp], xmm0
  00fb5	66 0f 6f 85 b0
	17 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$108[rbp]
  00fbd	66 0f f5 85 50
	02 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rbp]
  00fc5	66 0f 7f 85 70
	18 00 00	 movdqa	 XMMWORD PTR y5o_h$112[rbp], xmm0
  00fcd	66 0f 6f 85 40
	15 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$95[rbp]
  00fd5	66 0f fe 85 e0
	17 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$109[rbp]
  00fdd	66 0f 7f 85 a0
	18 00 00	 movdqa	 XMMWORD PTR x4_l$113[rbp], xmm0
  00fe5	66 0f 6f 85 70
	15 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$96[rbp]
  00fed	66 0f fe 85 10
	18 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$110[rbp]
  00ff5	66 0f 7f 85 d0
	18 00 00	 movdqa	 XMMWORD PTR x4_h$114[rbp], xmm0
  00ffd	66 0f 6f 85 60
	16 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$101[rbp]
  01005	66 0f fe 85 40
	18 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$111[rbp]
  0100d	66 0f 7f 85 00
	19 00 00	 movdqa	 XMMWORD PTR x5_l$115[rbp], xmm0
  01015	66 0f 6f 85 90
	16 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$102[rbp]
  0101d	66 0f fe 85 70
	18 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$112[rbp]
  01025	66 0f 7f 85 30
	19 00 00	 movdqa	 XMMWORD PTR x5_h$116[rbp], xmm0
  0102d	66 0f 6f 85 a0
	15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$97[rbp]
  01035	66 0f fe 85 40
	18 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$111[rbp]
  0103d	66 0f 7f 85 60
	19 00 00	 movdqa	 XMMWORD PTR x6_l$117[rbp], xmm0
  01045	66 0f 6f 85 d0
	15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$98[rbp]
  0104d	66 0f fe 85 70
	18 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$112[rbp]
  01055	66 0f 7f 85 90
	19 00 00	 movdqa	 XMMWORD PTR x6_h$118[rbp], xmm0
  0105d	66 0f 6f 85 c0
	16 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$103[rbp]
  01065	66 0f fe 85 e0
	17 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$109[rbp]
  0106d	66 0f 7f 85 c0
	19 00 00	 movdqa	 XMMWORD PTR x7_l$119[rbp], xmm0
  01075	66 0f 6f 85 f0
	16 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$104[rbp]
  0107d	66 0f fe 85 10
	18 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$110[rbp]
  01085	66 0f 7f 85 f0
	19 00 00	 movdqa	 XMMWORD PTR x7_h$120[rbp], xmm0
  0108d	66 0f 6f 85 60
	13 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$85[rbp]
  01095	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  0109d	66 0f 7f 85 20
	1a 00 00	 movdqa	 XMMWORD PTR abiased_l$121[rbp], xmm0
  010a5	66 0f 6f 85 90
	13 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$86[rbp]
  010ad	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  010b5	66 0f 7f 85 50
	1a 00 00	 movdqa	 XMMWORD PTR abiased_h$122[rbp], xmm0
  010bd	66 0f 6f 85 20
	1a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$121[rbp]
  010c5	66 0f fe 85 c0
	19 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$119[rbp]
  010cd	66 0f 7f 85 80
	1a 00 00	 movdqa	 XMMWORD PTR sum_l$123[rbp], xmm0
  010d5	66 0f 6f 85 50
	1a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$122[rbp]
  010dd	66 0f fe 85 f0
	19 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$120[rbp]
  010e5	66 0f 7f 85 b0
	1a 00 00	 movdqa	 XMMWORD PTR sum_h$124[rbp], xmm0
  010ed	66 0f 6f 85 20
	1a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$121[rbp]
  010f5	66 0f fa 85 c0
	19 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$119[rbp]
  010fd	66 0f 7f 85 e0
	1a 00 00	 movdqa	 XMMWORD PTR dif_l$125[rbp], xmm0
  01105	66 0f 6f 85 50
	1a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$122[rbp]
  0110d	66 0f fa 85 f0
	19 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$120[rbp]
  01115	66 0f 7f 85 10
	1b 00 00	 movdqa	 XMMWORD PTR dif_h$126[rbp], xmm0
  0111d	66 0f 6f 85 b0
	1a 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$124[rbp]
  01125	66 0f 72 e0 11	 psrad	 xmm0, 17
  0112a	66 0f 6f 8d 80
	1a 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$123[rbp]
  01132	66 0f 72 e1 11	 psrad	 xmm1, 17
  01137	66 0f 6b c8	 packssdw xmm1, xmm0
  0113b	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0113f	66 0f 7f 45 10	 movdqa	 XMMWORD PTR row0$[rbp], xmm0
  01144	66 0f 6f 85 10
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$126[rbp]
  0114c	66 0f 72 e0 11	 psrad	 xmm0, 17
  01151	66 0f 6f 8d e0
	1a 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$125[rbp]
  01159	66 0f 72 e1 11	 psrad	 xmm1, 17
  0115e	66 0f 6b c8	 packssdw xmm1, xmm0
  01162	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01166	66 0f 7f 85 60
	01 00 00	 movdqa	 XMMWORD PTR row7$[rbp], xmm0
  0116e	66 0f 6f 85 20
	14 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$89[rbp]
  01176	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  0117e	66 0f 7f 85 40
	1b 00 00	 movdqa	 XMMWORD PTR abiased_l$127[rbp], xmm0
  01186	66 0f 6f 85 50
	14 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$90[rbp]
  0118e	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  01196	66 0f 7f 85 70
	1b 00 00	 movdqa	 XMMWORD PTR abiased_h$128[rbp], xmm0
  0119e	66 0f 6f 85 40
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$127[rbp]
  011a6	66 0f fe 85 60
	19 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$117[rbp]
  011ae	66 0f 7f 85 a0
	1b 00 00	 movdqa	 XMMWORD PTR sum_l$129[rbp], xmm0
  011b6	66 0f 6f 85 70
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$128[rbp]
  011be	66 0f fe 85 90
	19 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$118[rbp]
  011c6	66 0f 7f 85 d0
	1b 00 00	 movdqa	 XMMWORD PTR sum_h$130[rbp], xmm0
  011ce	66 0f 6f 85 40
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$127[rbp]
  011d6	66 0f fa 85 60
	19 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$117[rbp]
  011de	66 0f 7f 85 00
	1c 00 00	 movdqa	 XMMWORD PTR dif_l$131[rbp], xmm0
  011e6	66 0f 6f 85 70
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$128[rbp]
  011ee	66 0f fa 85 90
	19 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$118[rbp]
  011f6	66 0f 7f 85 30
	1c 00 00	 movdqa	 XMMWORD PTR dif_h$132[rbp], xmm0
  011fe	66 0f 6f 85 d0
	1b 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$130[rbp]
  01206	66 0f 72 e0 11	 psrad	 xmm0, 17
  0120b	66 0f 6f 8d a0
	1b 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$129[rbp]
  01213	66 0f 72 e1 11	 psrad	 xmm1, 17
  01218	66 0f 6b c8	 packssdw xmm1, xmm0
  0121c	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01220	66 0f 7f 45 40	 movdqa	 XMMWORD PTR row1$[rbp], xmm0
  01225	66 0f 6f 85 30
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$132[rbp]
  0122d	66 0f 72 e0 11	 psrad	 xmm0, 17
  01232	66 0f 6f 8d 00
	1c 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$131[rbp]
  0123a	66 0f 72 e1 11	 psrad	 xmm1, 17
  0123f	66 0f 6b c8	 packssdw xmm1, xmm0
  01243	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01247	66 0f 7f 85 30
	01 00 00	 movdqa	 XMMWORD PTR row6$[rbp], xmm0
  0124f	66 0f 6f 85 80
	14 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$91[rbp]
  01257	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  0125f	66 0f 7f 85 60
	1c 00 00	 movdqa	 XMMWORD PTR abiased_l$133[rbp], xmm0
  01267	66 0f 6f 85 b0
	14 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$92[rbp]
  0126f	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  01277	66 0f 7f 85 90
	1c 00 00	 movdqa	 XMMWORD PTR abiased_h$134[rbp], xmm0
  0127f	66 0f 6f 85 60
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$133[rbp]
  01287	66 0f fe 85 00
	19 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$115[rbp]
  0128f	66 0f 7f 85 c0
	1c 00 00	 movdqa	 XMMWORD PTR sum_l$135[rbp], xmm0
  01297	66 0f 6f 85 90
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$134[rbp]
  0129f	66 0f fe 85 30
	19 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$116[rbp]
  012a7	66 0f 7f 85 f0
	1c 00 00	 movdqa	 XMMWORD PTR sum_h$136[rbp], xmm0
  012af	66 0f 6f 85 60
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$133[rbp]
  012b7	66 0f fa 85 00
	19 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$115[rbp]
  012bf	66 0f 7f 85 20
	1d 00 00	 movdqa	 XMMWORD PTR dif_l$137[rbp], xmm0
  012c7	66 0f 6f 85 90
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$134[rbp]
  012cf	66 0f fa 85 30
	19 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$116[rbp]
  012d7	66 0f 7f 85 50
	1d 00 00	 movdqa	 XMMWORD PTR dif_h$138[rbp], xmm0
  012df	66 0f 6f 85 f0
	1c 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$136[rbp]
  012e7	66 0f 72 e0 11	 psrad	 xmm0, 17
  012ec	66 0f 6f 8d c0
	1c 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$135[rbp]
  012f4	66 0f 72 e1 11	 psrad	 xmm1, 17
  012f9	66 0f 6b c8	 packssdw xmm1, xmm0
  012fd	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01301	66 0f 7f 45 70	 movdqa	 XMMWORD PTR row2$[rbp], xmm0
  01306	66 0f 6f 85 50
	1d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$138[rbp]
  0130e	66 0f 72 e0 11	 psrad	 xmm0, 17
  01313	66 0f 6f 8d 20
	1d 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$137[rbp]
  0131b	66 0f 72 e1 11	 psrad	 xmm1, 17
  01320	66 0f 6b c8	 packssdw xmm1, xmm0
  01324	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01328	66 0f 7f 85 00
	01 00 00	 movdqa	 XMMWORD PTR row5$[rbp], xmm0
  01330	66 0f 6f 85 c0
	13 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$87[rbp]
  01338	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  01340	66 0f 7f 85 80
	1d 00 00	 movdqa	 XMMWORD PTR abiased_l$139[rbp], xmm0
  01348	66 0f 6f 85 f0
	13 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$88[rbp]
  01350	66 0f fe 85 70
	03 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rbp]
  01358	66 0f 7f 85 b0
	1d 00 00	 movdqa	 XMMWORD PTR abiased_h$140[rbp], xmm0
  01360	66 0f 6f 85 80
	1d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$139[rbp]
  01368	66 0f fe 85 a0
	18 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$113[rbp]
  01370	66 0f 7f 85 e0
	1d 00 00	 movdqa	 XMMWORD PTR sum_l$141[rbp], xmm0
  01378	66 0f 6f 85 b0
	1d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$140[rbp]
  01380	66 0f fe 85 d0
	18 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$114[rbp]
  01388	66 0f 7f 85 10
	1e 00 00	 movdqa	 XMMWORD PTR sum_h$142[rbp], xmm0
  01390	66 0f 6f 85 80
	1d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$139[rbp]
  01398	66 0f fa 85 a0
	18 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$113[rbp]
  013a0	66 0f 7f 85 40
	1e 00 00	 movdqa	 XMMWORD PTR dif_l$143[rbp], xmm0
  013a8	66 0f 6f 85 b0
	1d 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$140[rbp]
  013b0	66 0f fa 85 d0
	18 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$114[rbp]
  013b8	66 0f 7f 85 70
	1e 00 00	 movdqa	 XMMWORD PTR dif_h$144[rbp], xmm0
  013c0	66 0f 6f 85 10
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$142[rbp]
  013c8	66 0f 72 e0 11	 psrad	 xmm0, 17
  013cd	66 0f 6f 8d e0
	1d 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$141[rbp]
  013d5	66 0f 72 e1 11	 psrad	 xmm1, 17
  013da	66 0f 6b c8	 packssdw xmm1, xmm0
  013de	66 0f 6f c1	 movdqa	 xmm0, xmm1
  013e2	66 0f 7f 85 a0
	00 00 00	 movdqa	 XMMWORD PTR row3$[rbp], xmm0
  013ea	66 0f 6f 85 70
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$144[rbp]
  013f2	66 0f 72 e0 11	 psrad	 xmm0, 17
  013f7	66 0f 6f 8d 40
	1e 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$143[rbp]
  013ff	66 0f 72 e1 11	 psrad	 xmm1, 17
  01404	66 0f 6b c8	 packssdw xmm1, xmm0
  01408	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0140c	66 0f 7f 85 d0
	00 00 00	 movdqa	 XMMWORD PTR row4$[rbp], xmm0

; 2136 : 
; 2137 :     {
; 2138 :         // pack
; 2139 :         __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

  01414	66 0f 6f 45 10	 movdqa	 xmm0, XMMWORD PTR row0$[rbp]
  01419	66 0f 67 45 40	 packuswb xmm0, XMMWORD PTR row1$[rbp]
  0141e	66 0f 7f 85 a0
	1e 00 00	 movdqa	 XMMWORD PTR p0$145[rbp], xmm0

; 2140 :         __m128i p1 = _mm_packus_epi16(row2, row3);

  01426	66 0f 6f 45 70	 movdqa	 xmm0, XMMWORD PTR row2$[rbp]
  0142b	66 0f 67 85 a0
	00 00 00	 packuswb xmm0, XMMWORD PTR row3$[rbp]
  01433	66 0f 7f 85 d0
	1e 00 00	 movdqa	 XMMWORD PTR p1$146[rbp], xmm0

; 2141 :         __m128i p2 = _mm_packus_epi16(row4, row5);

  0143b	66 0f 6f 85 d0
	00 00 00	 movdqa	 xmm0, XMMWORD PTR row4$[rbp]
  01443	66 0f 67 85 00
	01 00 00	 packuswb xmm0, XMMWORD PTR row5$[rbp]
  0144b	66 0f 7f 85 00
	1f 00 00	 movdqa	 XMMWORD PTR p2$147[rbp], xmm0

; 2142 :         __m128i p3 = _mm_packus_epi16(row6, row7);

  01453	66 0f 6f 85 30
	01 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rbp]
  0145b	66 0f 67 85 60
	01 00 00	 packuswb xmm0, XMMWORD PTR row7$[rbp]
  01463	66 0f 7f 85 30
	1f 00 00	 movdqa	 XMMWORD PTR p3$148[rbp], xmm0

; 2143 : 
; 2144 :         // 8bit 8x8 transpose pass 1
; 2145 :         dct_interleave8(p0, p2); // a0e0a1e1...

  0146b	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01473	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  0147b	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01483	66 0f 60 85 00
	1f 00 00	 punpcklbw xmm0, XMMWORD PTR p2$147[rbp]
  0148b	66 0f 7f 85 a0
	1e 00 00	 movdqa	 XMMWORD PTR p0$145[rbp], xmm0
  01493	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  0149b	66 0f 68 85 00
	1f 00 00	 punpckhbw xmm0, XMMWORD PTR p2$147[rbp]
  014a3	66 0f 7f 85 00
	1f 00 00	 movdqa	 XMMWORD PTR p2$147[rbp], xmm0

; 2146 :         dct_interleave8(p1, p3); // c0g0c1g1...

  014ab	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  014b3	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  014bb	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  014c3	66 0f 60 85 30
	1f 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rbp]
  014cb	66 0f 7f 85 d0
	1e 00 00	 movdqa	 XMMWORD PTR p1$146[rbp], xmm0
  014d3	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  014db	66 0f 68 85 30
	1f 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rbp]
  014e3	66 0f 7f 85 30
	1f 00 00	 movdqa	 XMMWORD PTR p3$148[rbp], xmm0

; 2147 : 
; 2148 :         // transpose pass 2
; 2149 :         dct_interleave8(p0, p1); // a0c0e0g0...

  014eb	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  014f3	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  014fb	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01503	66 0f 60 85 d0
	1e 00 00	 punpcklbw xmm0, XMMWORD PTR p1$146[rbp]
  0150b	66 0f 7f 85 a0
	1e 00 00	 movdqa	 XMMWORD PTR p0$145[rbp], xmm0
  01513	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  0151b	66 0f 68 85 d0
	1e 00 00	 punpckhbw xmm0, XMMWORD PTR p1$146[rbp]
  01523	66 0f 7f 85 d0
	1e 00 00	 movdqa	 XMMWORD PTR p1$146[rbp], xmm0

; 2150 :         dct_interleave8(p2, p3); // b0d0f0h0...

  0152b	66 0f 6f 85 00
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rbp]
  01533	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  0153b	66 0f 6f 85 00
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rbp]
  01543	66 0f 60 85 30
	1f 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rbp]
  0154b	66 0f 7f 85 00
	1f 00 00	 movdqa	 XMMWORD PTR p2$147[rbp], xmm0
  01553	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  0155b	66 0f 68 85 30
	1f 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rbp]
  01563	66 0f 7f 85 30
	1f 00 00	 movdqa	 XMMWORD PTR p3$148[rbp], xmm0

; 2151 : 
; 2152 :         // transpose pass 3
; 2153 :         dct_interleave8(p0, p2); // a0b0c0d0...

  0156b	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01573	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  0157b	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01583	66 0f 60 85 00
	1f 00 00	 punpcklbw xmm0, XMMWORD PTR p2$147[rbp]
  0158b	66 0f 7f 85 a0
	1e 00 00	 movdqa	 XMMWORD PTR p0$145[rbp], xmm0
  01593	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  0159b	66 0f 68 85 00
	1f 00 00	 punpckhbw xmm0, XMMWORD PTR p2$147[rbp]
  015a3	66 0f 7f 85 00
	1f 00 00	 movdqa	 XMMWORD PTR p2$147[rbp], xmm0

; 2154 :         dct_interleave8(p1, p3); // a4b4c4d4...

  015ab	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  015b3	66 0f 7f 85 90
	01 00 00	 movdqa	 XMMWORD PTR tmp$[rbp], xmm0
  015bb	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  015c3	66 0f 60 85 30
	1f 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rbp]
  015cb	66 0f 7f 85 d0
	1e 00 00	 movdqa	 XMMWORD PTR p1$146[rbp], xmm0
  015d3	66 0f 6f 85 90
	01 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rbp]
  015db	66 0f 68 85 30
	1f 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rbp]
  015e3	66 0f 7f 85 30
	1f 00 00	 movdqa	 XMMWORD PTR p3$148[rbp], xmm0

; 2155 : 
; 2156 :         // store
; 2157 :         _mm_storel_epi64((__m128i*) out, p0); out += out_stride;

  015eb	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  015f2	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  015fa	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  015fe	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  01605	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0160c	48 03 c8	 add	 rcx, rax
  0160f	48 8b c1	 mov	 rax, rcx
  01612	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2158 :         _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

  01619	66 0f 6f 85 a0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rbp]
  01621	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  01626	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  0162d	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01631	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  01638	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0163f	48 03 c8	 add	 rcx, rax
  01642	48 8b c1	 mov	 rax, rcx
  01645	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2159 :         _mm_storel_epi64((__m128i*) out, p2); out += out_stride;

  0164c	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  01653	66 0f 6f 85 00
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rbp]
  0165b	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  0165f	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  01666	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0166d	48 03 c8	 add	 rcx, rax
  01670	48 8b c1	 mov	 rax, rcx
  01673	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2160 :         _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

  0167a	66 0f 6f 85 00
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rbp]
  01682	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  01687	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  0168e	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01692	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  01699	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  016a0	48 03 c8	 add	 rcx, rax
  016a3	48 8b c1	 mov	 rax, rcx
  016a6	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2161 :         _mm_storel_epi64((__m128i*) out, p1); out += out_stride;

  016ad	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  016b4	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  016bc	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  016c0	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  016c7	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  016ce	48 03 c8	 add	 rcx, rax
  016d1	48 8b c1	 mov	 rax, rcx
  016d4	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2162 :         _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

  016db	66 0f 6f 85 d0
	1e 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rbp]
  016e3	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  016e8	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  016ef	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  016f3	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  016fa	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  01701	48 03 c8	 add	 rcx, rax
  01704	48 8b c1	 mov	 rax, rcx
  01707	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2163 :         _mm_storel_epi64((__m128i*) out, p3); out += out_stride;

  0170e	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  01715	66 0f 6f 85 30
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p3$148[rbp]
  0171d	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01721	48 63 85 78 25
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  01728	48 8b 8d 70 25
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0172f	48 03 c8	 add	 rcx, rax
  01732	48 8b c1	 mov	 rax, rcx
  01735	48 89 85 70 25
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 2164 :         _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p3, 0x4e));

  0173c	66 0f 6f 85 30
	1f 00 00	 movdqa	 xmm0, XMMWORD PTR p3$148[rbp]
  01744	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  01749	48 8b 85 70 25
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  01750	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0

; 2165 :     }
; 2166 : 
; 2167 : #undef dct_const
; 2168 : #undef dct_rot
; 2169 : #undef dct_widen
; 2170 : #undef dct_wadd
; 2171 : #undef dct_wsub
; 2172 : #undef dct_bfly32o
; 2173 : #undef dct_interleave8
; 2174 : #undef dct_interleave16
; 2175 : #undef dct_pass
; 2176 : }

  01754	48 8d a5 58 25
	00 00		 lea	 rsp, QWORD PTR [rbp+9560]
  0175b	5f		 pop	 rdi
  0175c	5d		 pop	 rbp
  0175d	c3		 ret	 0
stbi__idct_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__idct_block
_TEXT	SEGMENT
i$ = 4
val$ = 48
v$ = 328
o$ = 360
d$ = 392
dcterm$4 = 420
t0$5 = 452
t1$6 = 484
t2$7 = 516
t3$8 = 548
p1$9 = 580
p2$10 = 612
p3$11 = 644
p4$12 = 676
p5$13 = 708
x0$14 = 740
x1$15 = 772
x2$16 = 804
x3$17 = 836
t0$18 = 868
t1$19 = 900
t2$20 = 932
t3$21 = 964
p1$22 = 996
p2$23 = 1028
p3$24 = 1060
p4$25 = 1092
p5$26 = 1124
x0$27 = 1156
x1$28 = 1188
x2$29 = 1220
x3$30 = 1252
__$ArrayPad$ = 1848
out$ = 1888
out_stride$ = 1896
data$ = 1904
stbi__idct_block PROC					; COMDAT

; 1940 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 68 07
	00 00		 sub	 rsp, 1896		; 00000768H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 42 01 00 00	 mov	 ecx, 322		; 00000142H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 88
	07 00 00	 mov	 rcx, QWORD PTR [rsp+1928]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c5	 xor	 rax, rbp
  0003f	48 89 85 38 07
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1941 :     int i, val[64], * v = val;

  00052	48 8d 45 30	 lea	 rax, QWORD PTR val$[rbp]
  00056	48 89 85 48 01
	00 00		 mov	 QWORD PTR v$[rbp], rax

; 1942 :     stbi_uc* o;
; 1943 :     short* d = data;

  0005d	48 8b 85 70 07
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00064	48 89 85 88 01
	00 00		 mov	 QWORD PTR d$[rbp], rax

; 1944 : 
; 1945 :     // columns
; 1946 :     for (i = 0; i < 8; ++i, ++d, ++v) {

  0006b	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00072	eb 2c		 jmp	 SHORT $LN4@stbi__idct
$LN2@stbi__idct:
  00074	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00077	ff c0		 inc	 eax
  00079	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0007c	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR d$[rbp]
  00083	48 83 c0 02	 add	 rax, 2
  00087	48 89 85 88 01
	00 00		 mov	 QWORD PTR d$[rbp], rax
  0008e	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR v$[rbp]
  00095	48 83 c0 04	 add	 rax, 4
  00099	48 89 85 48 01
	00 00		 mov	 QWORD PTR v$[rbp], rax
$LN4@stbi__idct:
  000a0	83 7d 04 08	 cmp	 DWORD PTR i$[rbp], 8
  000a4	0f 8d 5f 06 00
	00		 jge	 $LN3@stbi__idct

; 1947 :         // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 1948 :         if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
; 1949 :             && d[40] == 0 && d[48] == 0 && d[56] == 0) {

  000aa	b8 02 00 00 00	 mov	 eax, 2
  000af	48 6b c0 08	 imul	 rax, rax, 8
  000b3	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  000ba	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000be	85 c0		 test	 eax, eax
  000c0	0f 85 92 01 00
	00		 jne	 $LN8@stbi__idct
  000c6	b8 02 00 00 00	 mov	 eax, 2
  000cb	48 6b c0 10	 imul	 rax, rax, 16
  000cf	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  000d6	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000da	85 c0		 test	 eax, eax
  000dc	0f 85 76 01 00
	00		 jne	 $LN8@stbi__idct
  000e2	b8 02 00 00 00	 mov	 eax, 2
  000e7	48 6b c0 18	 imul	 rax, rax, 24
  000eb	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  000f2	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000f6	85 c0		 test	 eax, eax
  000f8	0f 85 5a 01 00
	00		 jne	 $LN8@stbi__idct
  000fe	b8 02 00 00 00	 mov	 eax, 2
  00103	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00107	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  0010e	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00112	85 c0		 test	 eax, eax
  00114	0f 85 3e 01 00
	00		 jne	 $LN8@stbi__idct
  0011a	b8 02 00 00 00	 mov	 eax, 2
  0011f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00123	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  0012a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0012e	85 c0		 test	 eax, eax
  00130	0f 85 22 01 00
	00		 jne	 $LN8@stbi__idct
  00136	b8 02 00 00 00	 mov	 eax, 2
  0013b	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0013f	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  00146	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 06 01 00
	00		 jne	 $LN8@stbi__idct
  00152	b8 02 00 00 00	 mov	 eax, 2
  00157	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0015b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  00162	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00166	85 c0		 test	 eax, eax
  00168	0f 85 ea 00 00
	00		 jne	 $LN8@stbi__idct

; 1950 :             //    no shortcut                 0     seconds
; 1951 :             //    (1|2|3|4|5|6|7)==0          0     seconds
; 1952 :             //    all separate               -0.047 seconds
; 1953 :             //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 1954 :             int dcterm = d[0] * 4;

  0016e	b8 02 00 00 00	 mov	 eax, 2
  00173	48 6b c0 00	 imul	 rax, rax, 0
  00177	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  0017e	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00182	c1 e0 02	 shl	 eax, 2
  00185	89 85 a4 01 00
	00		 mov	 DWORD PTR dcterm$4[rbp], eax

; 1955 :             v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

  0018b	b8 04 00 00 00	 mov	 eax, 4
  00190	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00194	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  0019b	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  001a1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001a4	b8 04 00 00 00	 mov	 eax, 4
  001a9	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  001ad	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  001b4	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  001ba	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001bd	b8 04 00 00 00	 mov	 eax, 4
  001c2	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  001c6	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  001cd	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  001d3	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001d6	b8 04 00 00 00	 mov	 eax, 4
  001db	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001df	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  001e6	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  001ec	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001ef	b8 04 00 00 00	 mov	 eax, 4
  001f4	48 6b c0 18	 imul	 rax, rax, 24
  001f8	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  001ff	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  00205	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00208	b8 04 00 00 00	 mov	 eax, 4
  0020d	48 6b c0 10	 imul	 rax, rax, 16
  00211	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  00218	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  0021e	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00221	b8 04 00 00 00	 mov	 eax, 4
  00226	48 6b c0 08	 imul	 rax, rax, 8
  0022a	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  00231	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  00237	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0023a	b8 04 00 00 00	 mov	 eax, 4
  0023f	48 6b c0 00	 imul	 rax, rax, 0
  00243	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  0024a	8b 95 a4 01 00
	00		 mov	 edx, DWORD PTR dcterm$4[rbp]
  00250	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 1956 :         }

  00253	e9 ac 04 00 00	 jmp	 $LN9@stbi__idct
$LN8@stbi__idct:

; 1957 :         else {
; 1958 :             STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])

  00258	b8 02 00 00 00	 mov	 eax, 2
  0025d	48 6b c0 10	 imul	 rax, rax, 16
  00261	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  00268	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0026c	89 85 64 02 00
	00		 mov	 DWORD PTR p2$10[rbp], eax
  00272	b8 02 00 00 00	 mov	 eax, 2
  00277	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0027b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  00282	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00286	89 85 84 02 00
	00		 mov	 DWORD PTR p3$11[rbp], eax
  0028c	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR p3$11[rbp]
  00292	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR p2$10[rbp]
  00298	03 c8		 add	 ecx, eax
  0029a	8b c1		 mov	 eax, ecx
  0029c	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  002a2	89 85 44 02 00
	00		 mov	 DWORD PTR p1$9[rbp], eax
  002a8	69 85 84 02 00
	00 71 e2 ff ff	 imul	 eax, DWORD PTR p3$11[rbp], -7567 ; ffffffffffffe271H
  002b2	8b 8d 44 02 00
	00		 mov	 ecx, DWORD PTR p1$9[rbp]
  002b8	03 c8		 add	 ecx, eax
  002ba	8b c1		 mov	 eax, ecx
  002bc	89 85 04 02 00
	00		 mov	 DWORD PTR t2$7[rbp], eax
  002c2	69 85 64 02 00
	00 3f 0c 00 00	 imul	 eax, DWORD PTR p2$10[rbp], 3135 ; 00000c3fH
  002cc	8b 8d 44 02 00
	00		 mov	 ecx, DWORD PTR p1$9[rbp]
  002d2	03 c8		 add	 ecx, eax
  002d4	8b c1		 mov	 eax, ecx
  002d6	89 85 24 02 00
	00		 mov	 DWORD PTR t3$8[rbp], eax
  002dc	b8 02 00 00 00	 mov	 eax, 2
  002e1	48 6b c0 00	 imul	 rax, rax, 0
  002e5	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  002ec	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  002f0	89 85 64 02 00
	00		 mov	 DWORD PTR p2$10[rbp], eax
  002f6	b8 02 00 00 00	 mov	 eax, 2
  002fb	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002ff	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  00306	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0030a	89 85 84 02 00
	00		 mov	 DWORD PTR p3$11[rbp], eax
  00310	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR p3$11[rbp]
  00316	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR p2$10[rbp]
  0031c	03 c8		 add	 ecx, eax
  0031e	8b c1		 mov	 eax, ecx
  00320	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00326	89 85 c4 01 00
	00		 mov	 DWORD PTR t0$5[rbp], eax
  0032c	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR p3$11[rbp]
  00332	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR p2$10[rbp]
  00338	2b c8		 sub	 ecx, eax
  0033a	8b c1		 mov	 eax, ecx
  0033c	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00342	89 85 e4 01 00
	00		 mov	 DWORD PTR t1$6[rbp], eax
  00348	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  0034e	8b 8d c4 01 00
	00		 mov	 ecx, DWORD PTR t0$5[rbp]
  00354	03 c8		 add	 ecx, eax
  00356	8b c1		 mov	 eax, ecx
  00358	89 85 e4 02 00
	00		 mov	 DWORD PTR x0$14[rbp], eax
  0035e	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  00364	8b 8d c4 01 00
	00		 mov	 ecx, DWORD PTR t0$5[rbp]
  0036a	2b c8		 sub	 ecx, eax
  0036c	8b c1		 mov	 eax, ecx
  0036e	89 85 44 03 00
	00		 mov	 DWORD PTR x3$17[rbp], eax
  00374	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  0037a	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR t1$6[rbp]
  00380	03 c8		 add	 ecx, eax
  00382	8b c1		 mov	 eax, ecx
  00384	89 85 04 03 00
	00		 mov	 DWORD PTR x1$15[rbp], eax
  0038a	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  00390	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR t1$6[rbp]
  00396	2b c8		 sub	 ecx, eax
  00398	8b c1		 mov	 eax, ecx
  0039a	89 85 24 03 00
	00		 mov	 DWORD PTR x2$16[rbp], eax
  003a0	b8 02 00 00 00	 mov	 eax, 2
  003a5	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  003a9	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  003b0	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  003b4	89 85 c4 01 00
	00		 mov	 DWORD PTR t0$5[rbp], eax
  003ba	b8 02 00 00 00	 mov	 eax, 2
  003bf	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  003c3	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  003ca	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  003ce	89 85 e4 01 00
	00		 mov	 DWORD PTR t1$6[rbp], eax
  003d4	b8 02 00 00 00	 mov	 eax, 2
  003d9	48 6b c0 18	 imul	 rax, rax, 24
  003dd	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  003e4	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  003e8	89 85 04 02 00
	00		 mov	 DWORD PTR t2$7[rbp], eax
  003ee	b8 02 00 00 00	 mov	 eax, 2
  003f3	48 6b c0 08	 imul	 rax, rax, 8
  003f7	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR d$[rbp]
  003fe	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00402	89 85 24 02 00
	00		 mov	 DWORD PTR t3$8[rbp], eax
  00408	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  0040e	8b 8d c4 01 00
	00		 mov	 ecx, DWORD PTR t0$5[rbp]
  00414	03 c8		 add	 ecx, eax
  00416	8b c1		 mov	 eax, ecx
  00418	89 85 84 02 00
	00		 mov	 DWORD PTR p3$11[rbp], eax
  0041e	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  00424	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR t1$6[rbp]
  0042a	03 c8		 add	 ecx, eax
  0042c	8b c1		 mov	 eax, ecx
  0042e	89 85 a4 02 00
	00		 mov	 DWORD PTR p4$12[rbp], eax
  00434	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  0043a	8b 8d c4 01 00
	00		 mov	 ecx, DWORD PTR t0$5[rbp]
  00440	03 c8		 add	 ecx, eax
  00442	8b c1		 mov	 eax, ecx
  00444	89 85 44 02 00
	00		 mov	 DWORD PTR p1$9[rbp], eax
  0044a	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  00450	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR t1$6[rbp]
  00456	03 c8		 add	 ecx, eax
  00458	8b c1		 mov	 eax, ecx
  0045a	89 85 64 02 00
	00		 mov	 DWORD PTR p2$10[rbp], eax
  00460	8b 85 a4 02 00
	00		 mov	 eax, DWORD PTR p4$12[rbp]
  00466	8b 8d 84 02 00
	00		 mov	 ecx, DWORD PTR p3$11[rbp]
  0046c	03 c8		 add	 ecx, eax
  0046e	8b c1		 mov	 eax, ecx
  00470	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  00476	89 85 c4 02 00
	00		 mov	 DWORD PTR p5$13[rbp], eax
  0047c	69 85 c4 01 00
	00 c7 04 00 00	 imul	 eax, DWORD PTR t0$5[rbp], 1223 ; 000004c7H
  00486	89 85 c4 01 00
	00		 mov	 DWORD PTR t0$5[rbp], eax
  0048c	69 85 e4 01 00
	00 da 20 00 00	 imul	 eax, DWORD PTR t1$6[rbp], 8410 ; 000020daH
  00496	89 85 e4 01 00
	00		 mov	 DWORD PTR t1$6[rbp], eax
  0049c	69 85 04 02 00
	00 2a 31 00 00	 imul	 eax, DWORD PTR t2$7[rbp], 12586 ; 0000312aH
  004a6	89 85 04 02 00
	00		 mov	 DWORD PTR t2$7[rbp], eax
  004ac	69 85 24 02 00
	00 05 18 00 00	 imul	 eax, DWORD PTR t3$8[rbp], 6149 ; 00001805H
  004b6	89 85 24 02 00
	00		 mov	 DWORD PTR t3$8[rbp], eax
  004bc	69 85 44 02 00
	00 9b f1 ff ff	 imul	 eax, DWORD PTR p1$9[rbp], -3685 ; fffffffffffff19bH
  004c6	8b 8d c4 02 00
	00		 mov	 ecx, DWORD PTR p5$13[rbp]
  004cc	03 c8		 add	 ecx, eax
  004ce	8b c1		 mov	 eax, ecx
  004d0	89 85 44 02 00
	00		 mov	 DWORD PTR p1$9[rbp], eax
  004d6	69 85 64 02 00
	00 ff d6 ff ff	 imul	 eax, DWORD PTR p2$10[rbp], -10497 ; ffffffffffffd6ffH
  004e0	8b 8d c4 02 00
	00		 mov	 ecx, DWORD PTR p5$13[rbp]
  004e6	03 c8		 add	 ecx, eax
  004e8	8b c1		 mov	 eax, ecx
  004ea	89 85 64 02 00
	00		 mov	 DWORD PTR p2$10[rbp], eax
  004f0	69 85 84 02 00
	00 9e e0 ff ff	 imul	 eax, DWORD PTR p3$11[rbp], -8034 ; ffffffffffffe09eH
  004fa	89 85 84 02 00
	00		 mov	 DWORD PTR p3$11[rbp], eax
  00500	69 85 a4 02 00
	00 c3 f9 ff ff	 imul	 eax, DWORD PTR p4$12[rbp], -1597 ; fffffffffffff9c3H
  0050a	89 85 a4 02 00
	00		 mov	 DWORD PTR p4$12[rbp], eax
  00510	8b 85 a4 02 00
	00		 mov	 eax, DWORD PTR p4$12[rbp]
  00516	8b 8d 44 02 00
	00		 mov	 ecx, DWORD PTR p1$9[rbp]
  0051c	03 c8		 add	 ecx, eax
  0051e	8b c1		 mov	 eax, ecx
  00520	8b 8d 24 02 00
	00		 mov	 ecx, DWORD PTR t3$8[rbp]
  00526	03 c8		 add	 ecx, eax
  00528	8b c1		 mov	 eax, ecx
  0052a	89 85 24 02 00
	00		 mov	 DWORD PTR t3$8[rbp], eax
  00530	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR p3$11[rbp]
  00536	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR p2$10[rbp]
  0053c	03 c8		 add	 ecx, eax
  0053e	8b c1		 mov	 eax, ecx
  00540	8b 8d 04 02 00
	00		 mov	 ecx, DWORD PTR t2$7[rbp]
  00546	03 c8		 add	 ecx, eax
  00548	8b c1		 mov	 eax, ecx
  0054a	89 85 04 02 00
	00		 mov	 DWORD PTR t2$7[rbp], eax
  00550	8b 85 a4 02 00
	00		 mov	 eax, DWORD PTR p4$12[rbp]
  00556	8b 8d 64 02 00
	00		 mov	 ecx, DWORD PTR p2$10[rbp]
  0055c	03 c8		 add	 ecx, eax
  0055e	8b c1		 mov	 eax, ecx
  00560	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR t1$6[rbp]
  00566	03 c8		 add	 ecx, eax
  00568	8b c1		 mov	 eax, ecx
  0056a	89 85 e4 01 00
	00		 mov	 DWORD PTR t1$6[rbp], eax
  00570	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR p3$11[rbp]
  00576	8b 8d 44 02 00
	00		 mov	 ecx, DWORD PTR p1$9[rbp]
  0057c	03 c8		 add	 ecx, eax
  0057e	8b c1		 mov	 eax, ecx
  00580	8b 8d c4 01 00
	00		 mov	 ecx, DWORD PTR t0$5[rbp]
  00586	03 c8		 add	 ecx, eax
  00588	8b c1		 mov	 eax, ecx
  0058a	89 85 c4 01 00
	00		 mov	 DWORD PTR t0$5[rbp], eax

; 1959 :                 // constants scaled things up by 1<<12; let's bring them back
; 1960 :                 // down, but keep 2 extra bits of precision
; 1961 :                 x0 += 512; x1 += 512; x2 += 512; x3 += 512;

  00590	8b 85 e4 02 00
	00		 mov	 eax, DWORD PTR x0$14[rbp]
  00596	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0059b	89 85 e4 02 00
	00		 mov	 DWORD PTR x0$14[rbp], eax
  005a1	8b 85 04 03 00
	00		 mov	 eax, DWORD PTR x1$15[rbp]
  005a7	05 00 02 00 00	 add	 eax, 512		; 00000200H
  005ac	89 85 04 03 00
	00		 mov	 DWORD PTR x1$15[rbp], eax
  005b2	8b 85 24 03 00
	00		 mov	 eax, DWORD PTR x2$16[rbp]
  005b8	05 00 02 00 00	 add	 eax, 512		; 00000200H
  005bd	89 85 24 03 00
	00		 mov	 DWORD PTR x2$16[rbp], eax
  005c3	8b 85 44 03 00
	00		 mov	 eax, DWORD PTR x3$17[rbp]
  005c9	05 00 02 00 00	 add	 eax, 512		; 00000200H
  005ce	89 85 44 03 00
	00		 mov	 DWORD PTR x3$17[rbp], eax

; 1962 :             v[0] = (x0 + t3) >> 10;

  005d4	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  005da	8b 8d e4 02 00
	00		 mov	 ecx, DWORD PTR x0$14[rbp]
  005e0	03 c8		 add	 ecx, eax
  005e2	8b c1		 mov	 eax, ecx
  005e4	c1 f8 0a	 sar	 eax, 10
  005e7	b9 04 00 00 00	 mov	 ecx, 4
  005ec	48 6b c9 00	 imul	 rcx, rcx, 0
  005f0	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  005f7	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1963 :             v[56] = (x0 - t3) >> 10;

  005fa	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR t3$8[rbp]
  00600	8b 8d e4 02 00
	00		 mov	 ecx, DWORD PTR x0$14[rbp]
  00606	2b c8		 sub	 ecx, eax
  00608	8b c1		 mov	 eax, ecx
  0060a	c1 f8 0a	 sar	 eax, 10
  0060d	b9 04 00 00 00	 mov	 ecx, 4
  00612	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  00616	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  0061d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1964 :             v[8] = (x1 + t2) >> 10;

  00620	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  00626	8b 8d 04 03 00
	00		 mov	 ecx, DWORD PTR x1$15[rbp]
  0062c	03 c8		 add	 ecx, eax
  0062e	8b c1		 mov	 eax, ecx
  00630	c1 f8 0a	 sar	 eax, 10
  00633	b9 04 00 00 00	 mov	 ecx, 4
  00638	48 6b c9 08	 imul	 rcx, rcx, 8
  0063c	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00643	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1965 :             v[48] = (x1 - t2) >> 10;

  00646	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR t2$7[rbp]
  0064c	8b 8d 04 03 00
	00		 mov	 ecx, DWORD PTR x1$15[rbp]
  00652	2b c8		 sub	 ecx, eax
  00654	8b c1		 mov	 eax, ecx
  00656	c1 f8 0a	 sar	 eax, 10
  00659	b9 04 00 00 00	 mov	 ecx, 4
  0065e	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  00662	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00669	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1966 :             v[16] = (x2 + t1) >> 10;

  0066c	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR t1$6[rbp]
  00672	8b 8d 24 03 00
	00		 mov	 ecx, DWORD PTR x2$16[rbp]
  00678	03 c8		 add	 ecx, eax
  0067a	8b c1		 mov	 eax, ecx
  0067c	c1 f8 0a	 sar	 eax, 10
  0067f	b9 04 00 00 00	 mov	 ecx, 4
  00684	48 6b c9 10	 imul	 rcx, rcx, 16
  00688	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  0068f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1967 :             v[40] = (x2 - t1) >> 10;

  00692	8b 85 e4 01 00
	00		 mov	 eax, DWORD PTR t1$6[rbp]
  00698	8b 8d 24 03 00
	00		 mov	 ecx, DWORD PTR x2$16[rbp]
  0069e	2b c8		 sub	 ecx, eax
  006a0	8b c1		 mov	 eax, ecx
  006a2	c1 f8 0a	 sar	 eax, 10
  006a5	b9 04 00 00 00	 mov	 ecx, 4
  006aa	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  006ae	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  006b5	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1968 :             v[24] = (x3 + t0) >> 10;

  006b8	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR t0$5[rbp]
  006be	8b 8d 44 03 00
	00		 mov	 ecx, DWORD PTR x3$17[rbp]
  006c4	03 c8		 add	 ecx, eax
  006c6	8b c1		 mov	 eax, ecx
  006c8	c1 f8 0a	 sar	 eax, 10
  006cb	b9 04 00 00 00	 mov	 ecx, 4
  006d0	48 6b c9 18	 imul	 rcx, rcx, 24
  006d4	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  006db	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1969 :             v[32] = (x3 - t0) >> 10;

  006de	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR t0$5[rbp]
  006e4	8b 8d 44 03 00
	00		 mov	 ecx, DWORD PTR x3$17[rbp]
  006ea	2b c8		 sub	 ecx, eax
  006ec	8b c1		 mov	 eax, ecx
  006ee	c1 f8 0a	 sar	 eax, 10
  006f1	b9 04 00 00 00	 mov	 ecx, 4
  006f6	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  006fa	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00701	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN9@stbi__idct:

; 1970 :         }
; 1971 :     }

  00704	e9 6b f9 ff ff	 jmp	 $LN2@stbi__idct
$LN3@stbi__idct:

; 1972 : 
; 1973 :     for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {

  00709	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00710	48 8d 45 30	 lea	 rax, QWORD PTR val$[rbp]
  00714	48 89 85 48 01
	00 00		 mov	 QWORD PTR v$[rbp], rax
  0071b	48 8b 85 60 07
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  00722	48 89 85 68 01
	00 00		 mov	 QWORD PTR o$[rbp], rax
  00729	eb 35		 jmp	 SHORT $LN7@stbi__idct
$LN5@stbi__idct:
  0072b	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0072e	ff c0		 inc	 eax
  00730	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00733	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR v$[rbp]
  0073a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0073e	48 89 85 48 01
	00 00		 mov	 QWORD PTR v$[rbp], rax
  00745	48 63 85 68 07
	00 00		 movsxd	 rax, DWORD PTR out_stride$[rbp]
  0074c	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR o$[rbp]
  00753	48 03 c8	 add	 rcx, rax
  00756	48 8b c1	 mov	 rax, rcx
  00759	48 89 85 68 01
	00 00		 mov	 QWORD PTR o$[rbp], rax
$LN7@stbi__idct:
  00760	83 7d 04 08	 cmp	 DWORD PTR i$[rbp], 8
  00764	0f 8d e1 04 00
	00		 jge	 $LN6@stbi__idct

; 1974 :         // no fast case since the first 1D IDCT spread components out
; 1975 :         STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])

  0076a	b8 04 00 00 00	 mov	 eax, 4
  0076f	48 6b c0 02	 imul	 rax, rax, 2
  00773	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  0077a	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0077d	89 85 04 04 00
	00		 mov	 DWORD PTR p2$23[rbp], eax
  00783	b8 04 00 00 00	 mov	 eax, 4
  00788	48 6b c0 06	 imul	 rax, rax, 6
  0078c	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  00793	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00796	89 85 24 04 00
	00		 mov	 DWORD PTR p3$24[rbp], eax
  0079c	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR p3$24[rbp]
  007a2	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR p2$23[rbp]
  007a8	03 c8		 add	 ecx, eax
  007aa	8b c1		 mov	 eax, ecx
  007ac	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  007b2	89 85 e4 03 00
	00		 mov	 DWORD PTR p1$22[rbp], eax
  007b8	69 85 24 04 00
	00 71 e2 ff ff	 imul	 eax, DWORD PTR p3$24[rbp], -7567 ; ffffffffffffe271H
  007c2	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR p1$22[rbp]
  007c8	03 c8		 add	 ecx, eax
  007ca	8b c1		 mov	 eax, ecx
  007cc	89 85 a4 03 00
	00		 mov	 DWORD PTR t2$20[rbp], eax
  007d2	69 85 04 04 00
	00 3f 0c 00 00	 imul	 eax, DWORD PTR p2$23[rbp], 3135 ; 00000c3fH
  007dc	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR p1$22[rbp]
  007e2	03 c8		 add	 ecx, eax
  007e4	8b c1		 mov	 eax, ecx
  007e6	89 85 c4 03 00
	00		 mov	 DWORD PTR t3$21[rbp], eax
  007ec	b8 04 00 00 00	 mov	 eax, 4
  007f1	48 6b c0 00	 imul	 rax, rax, 0
  007f5	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  007fc	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  007ff	89 85 04 04 00
	00		 mov	 DWORD PTR p2$23[rbp], eax
  00805	b8 04 00 00 00	 mov	 eax, 4
  0080a	48 6b c0 04	 imul	 rax, rax, 4
  0080e	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  00815	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00818	89 85 24 04 00
	00		 mov	 DWORD PTR p3$24[rbp], eax
  0081e	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR p3$24[rbp]
  00824	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR p2$23[rbp]
  0082a	03 c8		 add	 ecx, eax
  0082c	8b c1		 mov	 eax, ecx
  0082e	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00834	89 85 64 03 00
	00		 mov	 DWORD PTR t0$18[rbp], eax
  0083a	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR p3$24[rbp]
  00840	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR p2$23[rbp]
  00846	2b c8		 sub	 ecx, eax
  00848	8b c1		 mov	 eax, ecx
  0084a	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00850	89 85 84 03 00
	00		 mov	 DWORD PTR t1$19[rbp], eax
  00856	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  0085c	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR t0$18[rbp]
  00862	03 c8		 add	 ecx, eax
  00864	8b c1		 mov	 eax, ecx
  00866	89 85 84 04 00
	00		 mov	 DWORD PTR x0$27[rbp], eax
  0086c	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  00872	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR t0$18[rbp]
  00878	2b c8		 sub	 ecx, eax
  0087a	8b c1		 mov	 eax, ecx
  0087c	89 85 e4 04 00
	00		 mov	 DWORD PTR x3$30[rbp], eax
  00882	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  00888	8b 8d 84 03 00
	00		 mov	 ecx, DWORD PTR t1$19[rbp]
  0088e	03 c8		 add	 ecx, eax
  00890	8b c1		 mov	 eax, ecx
  00892	89 85 a4 04 00
	00		 mov	 DWORD PTR x1$28[rbp], eax
  00898	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  0089e	8b 8d 84 03 00
	00		 mov	 ecx, DWORD PTR t1$19[rbp]
  008a4	2b c8		 sub	 ecx, eax
  008a6	8b c1		 mov	 eax, ecx
  008a8	89 85 c4 04 00
	00		 mov	 DWORD PTR x2$29[rbp], eax
  008ae	b8 04 00 00 00	 mov	 eax, 4
  008b3	48 6b c0 07	 imul	 rax, rax, 7
  008b7	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  008be	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  008c1	89 85 64 03 00
	00		 mov	 DWORD PTR t0$18[rbp], eax
  008c7	b8 04 00 00 00	 mov	 eax, 4
  008cc	48 6b c0 05	 imul	 rax, rax, 5
  008d0	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  008d7	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  008da	89 85 84 03 00
	00		 mov	 DWORD PTR t1$19[rbp], eax
  008e0	b8 04 00 00 00	 mov	 eax, 4
  008e5	48 6b c0 03	 imul	 rax, rax, 3
  008e9	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  008f0	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  008f3	89 85 a4 03 00
	00		 mov	 DWORD PTR t2$20[rbp], eax
  008f9	b8 04 00 00 00	 mov	 eax, 4
  008fe	48 6b c0 01	 imul	 rax, rax, 1
  00902	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR v$[rbp]
  00909	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0090c	89 85 c4 03 00
	00		 mov	 DWORD PTR t3$21[rbp], eax
  00912	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  00918	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR t0$18[rbp]
  0091e	03 c8		 add	 ecx, eax
  00920	8b c1		 mov	 eax, ecx
  00922	89 85 24 04 00
	00		 mov	 DWORD PTR p3$24[rbp], eax
  00928	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  0092e	8b 8d 84 03 00
	00		 mov	 ecx, DWORD PTR t1$19[rbp]
  00934	03 c8		 add	 ecx, eax
  00936	8b c1		 mov	 eax, ecx
  00938	89 85 44 04 00
	00		 mov	 DWORD PTR p4$25[rbp], eax
  0093e	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  00944	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR t0$18[rbp]
  0094a	03 c8		 add	 ecx, eax
  0094c	8b c1		 mov	 eax, ecx
  0094e	89 85 e4 03 00
	00		 mov	 DWORD PTR p1$22[rbp], eax
  00954	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  0095a	8b 8d 84 03 00
	00		 mov	 ecx, DWORD PTR t1$19[rbp]
  00960	03 c8		 add	 ecx, eax
  00962	8b c1		 mov	 eax, ecx
  00964	89 85 04 04 00
	00		 mov	 DWORD PTR p2$23[rbp], eax
  0096a	8b 85 44 04 00
	00		 mov	 eax, DWORD PTR p4$25[rbp]
  00970	8b 8d 24 04 00
	00		 mov	 ecx, DWORD PTR p3$24[rbp]
  00976	03 c8		 add	 ecx, eax
  00978	8b c1		 mov	 eax, ecx
  0097a	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  00980	89 85 64 04 00
	00		 mov	 DWORD PTR p5$26[rbp], eax
  00986	69 85 64 03 00
	00 c7 04 00 00	 imul	 eax, DWORD PTR t0$18[rbp], 1223 ; 000004c7H
  00990	89 85 64 03 00
	00		 mov	 DWORD PTR t0$18[rbp], eax
  00996	69 85 84 03 00
	00 da 20 00 00	 imul	 eax, DWORD PTR t1$19[rbp], 8410 ; 000020daH
  009a0	89 85 84 03 00
	00		 mov	 DWORD PTR t1$19[rbp], eax
  009a6	69 85 a4 03 00
	00 2a 31 00 00	 imul	 eax, DWORD PTR t2$20[rbp], 12586 ; 0000312aH
  009b0	89 85 a4 03 00
	00		 mov	 DWORD PTR t2$20[rbp], eax
  009b6	69 85 c4 03 00
	00 05 18 00 00	 imul	 eax, DWORD PTR t3$21[rbp], 6149 ; 00001805H
  009c0	89 85 c4 03 00
	00		 mov	 DWORD PTR t3$21[rbp], eax
  009c6	69 85 e4 03 00
	00 9b f1 ff ff	 imul	 eax, DWORD PTR p1$22[rbp], -3685 ; fffffffffffff19bH
  009d0	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR p5$26[rbp]
  009d6	03 c8		 add	 ecx, eax
  009d8	8b c1		 mov	 eax, ecx
  009da	89 85 e4 03 00
	00		 mov	 DWORD PTR p1$22[rbp], eax
  009e0	69 85 04 04 00
	00 ff d6 ff ff	 imul	 eax, DWORD PTR p2$23[rbp], -10497 ; ffffffffffffd6ffH
  009ea	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR p5$26[rbp]
  009f0	03 c8		 add	 ecx, eax
  009f2	8b c1		 mov	 eax, ecx
  009f4	89 85 04 04 00
	00		 mov	 DWORD PTR p2$23[rbp], eax
  009fa	69 85 24 04 00
	00 9e e0 ff ff	 imul	 eax, DWORD PTR p3$24[rbp], -8034 ; ffffffffffffe09eH
  00a04	89 85 24 04 00
	00		 mov	 DWORD PTR p3$24[rbp], eax
  00a0a	69 85 44 04 00
	00 c3 f9 ff ff	 imul	 eax, DWORD PTR p4$25[rbp], -1597 ; fffffffffffff9c3H
  00a14	89 85 44 04 00
	00		 mov	 DWORD PTR p4$25[rbp], eax
  00a1a	8b 85 44 04 00
	00		 mov	 eax, DWORD PTR p4$25[rbp]
  00a20	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR p1$22[rbp]
  00a26	03 c8		 add	 ecx, eax
  00a28	8b c1		 mov	 eax, ecx
  00a2a	8b 8d c4 03 00
	00		 mov	 ecx, DWORD PTR t3$21[rbp]
  00a30	03 c8		 add	 ecx, eax
  00a32	8b c1		 mov	 eax, ecx
  00a34	89 85 c4 03 00
	00		 mov	 DWORD PTR t3$21[rbp], eax
  00a3a	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR p3$24[rbp]
  00a40	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR p2$23[rbp]
  00a46	03 c8		 add	 ecx, eax
  00a48	8b c1		 mov	 eax, ecx
  00a4a	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR t2$20[rbp]
  00a50	03 c8		 add	 ecx, eax
  00a52	8b c1		 mov	 eax, ecx
  00a54	89 85 a4 03 00
	00		 mov	 DWORD PTR t2$20[rbp], eax
  00a5a	8b 85 44 04 00
	00		 mov	 eax, DWORD PTR p4$25[rbp]
  00a60	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR p2$23[rbp]
  00a66	03 c8		 add	 ecx, eax
  00a68	8b c1		 mov	 eax, ecx
  00a6a	8b 8d 84 03 00
	00		 mov	 ecx, DWORD PTR t1$19[rbp]
  00a70	03 c8		 add	 ecx, eax
  00a72	8b c1		 mov	 eax, ecx
  00a74	89 85 84 03 00
	00		 mov	 DWORD PTR t1$19[rbp], eax
  00a7a	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR p3$24[rbp]
  00a80	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR p1$22[rbp]
  00a86	03 c8		 add	 ecx, eax
  00a88	8b c1		 mov	 eax, ecx
  00a8a	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR t0$18[rbp]
  00a90	03 c8		 add	 ecx, eax
  00a92	8b c1		 mov	 eax, ecx
  00a94	89 85 64 03 00
	00		 mov	 DWORD PTR t0$18[rbp], eax

; 1976 :             // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 1977 :             // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 1978 :             // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 1979 :             // so we want to round that, which means adding 0.5 * 1<<17,
; 1980 :             // aka 65536. Also, we'll end up with -128 to 127 that we want
; 1981 :             // to encode as 0..255 by adding 128, so we'll add that before the shift
; 1982 :             x0 += 65536 + (128 << 17);

  00a9a	8b 85 84 04 00
	00		 mov	 eax, DWORD PTR x0$27[rbp]
  00aa0	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00aa5	89 85 84 04 00
	00		 mov	 DWORD PTR x0$27[rbp], eax

; 1983 :         x1 += 65536 + (128 << 17);

  00aab	8b 85 a4 04 00
	00		 mov	 eax, DWORD PTR x1$28[rbp]
  00ab1	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00ab6	89 85 a4 04 00
	00		 mov	 DWORD PTR x1$28[rbp], eax

; 1984 :         x2 += 65536 + (128 << 17);

  00abc	8b 85 c4 04 00
	00		 mov	 eax, DWORD PTR x2$29[rbp]
  00ac2	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00ac7	89 85 c4 04 00
	00		 mov	 DWORD PTR x2$29[rbp], eax

; 1985 :         x3 += 65536 + (128 << 17);

  00acd	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR x3$30[rbp]
  00ad3	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00ad8	89 85 e4 04 00
	00		 mov	 DWORD PTR x3$30[rbp], eax

; 1986 :         // tried computing the shifts into temps, or'ing the temps to see
; 1987 :         // if any were out of range, but that was slower
; 1988 :         o[0] = stbi__clamp((x0 + t3) >> 17);

  00ade	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  00ae4	8b 8d 84 04 00
	00		 mov	 ecx, DWORD PTR x0$27[rbp]
  00aea	03 c8		 add	 ecx, eax
  00aec	8b c1		 mov	 eax, ecx
  00aee	c1 f8 11	 sar	 eax, 17
  00af1	8b c8		 mov	 ecx, eax
  00af3	e8 00 00 00 00	 call	 stbi__clamp
  00af8	b9 01 00 00 00	 mov	 ecx, 1
  00afd	48 6b c9 00	 imul	 rcx, rcx, 0
  00b01	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00b08	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1989 :         o[7] = stbi__clamp((x0 - t3) >> 17);

  00b0b	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR t3$21[rbp]
  00b11	8b 8d 84 04 00
	00		 mov	 ecx, DWORD PTR x0$27[rbp]
  00b17	2b c8		 sub	 ecx, eax
  00b19	8b c1		 mov	 eax, ecx
  00b1b	c1 f8 11	 sar	 eax, 17
  00b1e	8b c8		 mov	 ecx, eax
  00b20	e8 00 00 00 00	 call	 stbi__clamp
  00b25	b9 01 00 00 00	 mov	 ecx, 1
  00b2a	48 6b c9 07	 imul	 rcx, rcx, 7
  00b2e	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00b35	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1990 :         o[1] = stbi__clamp((x1 + t2) >> 17);

  00b38	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  00b3e	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR x1$28[rbp]
  00b44	03 c8		 add	 ecx, eax
  00b46	8b c1		 mov	 eax, ecx
  00b48	c1 f8 11	 sar	 eax, 17
  00b4b	8b c8		 mov	 ecx, eax
  00b4d	e8 00 00 00 00	 call	 stbi__clamp
  00b52	b9 01 00 00 00	 mov	 ecx, 1
  00b57	48 6b c9 01	 imul	 rcx, rcx, 1
  00b5b	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00b62	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1991 :         o[6] = stbi__clamp((x1 - t2) >> 17);

  00b65	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR t2$20[rbp]
  00b6b	8b 8d a4 04 00
	00		 mov	 ecx, DWORD PTR x1$28[rbp]
  00b71	2b c8		 sub	 ecx, eax
  00b73	8b c1		 mov	 eax, ecx
  00b75	c1 f8 11	 sar	 eax, 17
  00b78	8b c8		 mov	 ecx, eax
  00b7a	e8 00 00 00 00	 call	 stbi__clamp
  00b7f	b9 01 00 00 00	 mov	 ecx, 1
  00b84	48 6b c9 06	 imul	 rcx, rcx, 6
  00b88	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00b8f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1992 :         o[2] = stbi__clamp((x2 + t1) >> 17);

  00b92	8b 85 84 03 00
	00		 mov	 eax, DWORD PTR t1$19[rbp]
  00b98	8b 8d c4 04 00
	00		 mov	 ecx, DWORD PTR x2$29[rbp]
  00b9e	03 c8		 add	 ecx, eax
  00ba0	8b c1		 mov	 eax, ecx
  00ba2	c1 f8 11	 sar	 eax, 17
  00ba5	8b c8		 mov	 ecx, eax
  00ba7	e8 00 00 00 00	 call	 stbi__clamp
  00bac	b9 01 00 00 00	 mov	 ecx, 1
  00bb1	48 6b c9 02	 imul	 rcx, rcx, 2
  00bb5	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00bbc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1993 :         o[5] = stbi__clamp((x2 - t1) >> 17);

  00bbf	8b 85 84 03 00
	00		 mov	 eax, DWORD PTR t1$19[rbp]
  00bc5	8b 8d c4 04 00
	00		 mov	 ecx, DWORD PTR x2$29[rbp]
  00bcb	2b c8		 sub	 ecx, eax
  00bcd	8b c1		 mov	 eax, ecx
  00bcf	c1 f8 11	 sar	 eax, 17
  00bd2	8b c8		 mov	 ecx, eax
  00bd4	e8 00 00 00 00	 call	 stbi__clamp
  00bd9	b9 01 00 00 00	 mov	 ecx, 1
  00bde	48 6b c9 05	 imul	 rcx, rcx, 5
  00be2	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00be9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1994 :         o[3] = stbi__clamp((x3 + t0) >> 17);

  00bec	8b 85 64 03 00
	00		 mov	 eax, DWORD PTR t0$18[rbp]
  00bf2	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR x3$30[rbp]
  00bf8	03 c8		 add	 ecx, eax
  00bfa	8b c1		 mov	 eax, ecx
  00bfc	c1 f8 11	 sar	 eax, 17
  00bff	8b c8		 mov	 ecx, eax
  00c01	e8 00 00 00 00	 call	 stbi__clamp
  00c06	b9 01 00 00 00	 mov	 ecx, 1
  00c0b	48 6b c9 03	 imul	 rcx, rcx, 3
  00c0f	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00c16	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1995 :         o[4] = stbi__clamp((x3 - t0) >> 17);

  00c19	8b 85 64 03 00
	00		 mov	 eax, DWORD PTR t0$18[rbp]
  00c1f	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR x3$30[rbp]
  00c25	2b c8		 sub	 ecx, eax
  00c27	8b c1		 mov	 eax, ecx
  00c29	c1 f8 11	 sar	 eax, 17
  00c2c	8b c8		 mov	 ecx, eax
  00c2e	e8 00 00 00 00	 call	 stbi__clamp
  00c33	b9 01 00 00 00	 mov	 ecx, 1
  00c38	48 6b c9 04	 imul	 rcx, rcx, 4
  00c3c	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR o$[rbp]
  00c43	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1996 :     }

  00c46	e9 e0 fa ff ff	 jmp	 $LN5@stbi__idct
$LN6@stbi__idct:

; 1997 : }

  00c4b	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00c4f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__idct_block$rtcFrameData
  00c56	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00c5b	48 8b 8d 38 07
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00c62	48 33 cd	 xor	 rcx, rbp
  00c65	e8 00 00 00 00	 call	 __security_check_cookie
  00c6a	48 8d a5 48 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1864]
  00c71	5f		 pop	 rdi
  00c72	5d		 pop	 rbp
  00c73	c3		 ret	 0
stbi__idct_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__clamp
_TEXT	SEGMENT
x$ = 224
stbi__clamp PROC					; COMDAT

; 1889 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1890 :     // trick to use a single test to catch both cases
; 1891 :     if ((unsigned int)x > 255) {

  0001e	81 bd e0 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR x$[rbp], 255	; 000000ffH
  00028	76 1d		 jbe	 SHORT $LN2@stbi__clam

; 1892 :         if (x < 0) return 0;

  0002a	83 bd e0 00 00
	00 00		 cmp	 DWORD PTR x$[rbp], 0
  00031	7d 04		 jge	 SHORT $LN3@stbi__clam
  00033	32 c0		 xor	 al, al
  00035	eb 17		 jmp	 SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 1893 :         if (x > 255) return 255;

  00037	81 bd e0 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR x$[rbp], 255	; 000000ffH
  00041	7e 04		 jle	 SHORT $LN4@stbi__clam
  00043	b0 ff		 mov	 al, 255			; 000000ffH
  00045	eb 07		 jmp	 SHORT $LN1@stbi__clam
$LN4@stbi__clam:
$LN2@stbi__clam:

; 1894 :     }
; 1895 :     return (stbi_uc)x;

  00047	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR x$[rbp]
$LN1@stbi__clam:

; 1896 : }

  0004e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00055	5f		 pop	 rdi
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
stbi__clamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_decode_block_prog_ac
_TEXT	SEGMENT
k$ = 4
shift$1 = 36
zig$2 = 68
c$3 = 100
r$4 = 132
s$5 = 164
rs$6 = 196
bit$7 = 228
p$8 = 264
r$9 = 292
s$10 = 324
rs$11 = 356
p$12 = 392
tv420 = 596
tv393 = 596
tv371 = 596
tv354 = 600
j$ = 640
data$ = 648
hac$ = 656
fac$ = 664
stbi__jpeg_decode_block_prog_ac PROC			; COMDAT

; 1761 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1762 :     int k;
; 1763 :     if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0002e	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00035	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  0003c	75 11		 jne	 SHORT $LN13@stbi__jpeg
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  00045	e8 00 00 00 00	 call	 stbi__err
  0004a	e9 74 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 1764 : 
; 1765 :     if (j->succ_high == 0) {

  0004f	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00056	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  0005d	0f 85 f3 02 00
	00		 jne	 $LN14@stbi__jpeg

; 1766 :         int shift = j->succ_low;

  00063	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0006a	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00070	89 45 24	 mov	 DWORD PTR shift$1[rbp], eax

; 1767 : 
; 1768 :         if (j->eob_run) {

  00073	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0007a	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00081	74 26		 je	 SHORT $LN16@stbi__jpeg

; 1769 :             --j->eob_run;

  00083	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0008a	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00090	ff c8		 dec	 eax
  00092	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00099	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 1770 :             return 1;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	e9 1a 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 1771 :         }
; 1772 : 
; 1773 :         k = j->spec_start;

  000a9	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000b0	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  000b6	89 45 04	 mov	 DWORD PTR k$[rbp], eax
$LN4@stbi__jpeg:

; 1774 :         do {
; 1775 :             unsigned int zig;
; 1776 :             int c, r, s;
; 1777 :             if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  000b9	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000c0	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  000c7	7d 0c		 jge	 SHORT $LN17@stbi__jpeg
  000c9	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000d0	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN17@stbi__jpeg:

; 1778 :             c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

  000d5	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000dc	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000e2	c1 e8 17	 shr	 eax, 23
  000e5	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000ea	89 45 64	 mov	 DWORD PTR c$3[rbp], eax

; 1779 :             r = fac[c];

  000ed	48 63 45 64	 movsxd	 rax, DWORD PTR c$3[rbp]
  000f1	48 8b 8d 98 02
	00 00		 mov	 rcx, QWORD PTR fac$[rbp]
  000f8	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  000fc	89 85 84 00 00
	00		 mov	 DWORD PTR r$4[rbp], eax

; 1780 :             if (r) { // fast-AC path

  00102	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR r$4[rbp], 0
  00109	0f 84 e5 00 00
	00		 je	 $LN18@stbi__jpeg

; 1781 :                 k += (r >> 4) & 15; // run

  0010f	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR r$4[rbp]
  00115	c1 f8 04	 sar	 eax, 4
  00118	83 e0 0f	 and	 eax, 15
  0011b	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  0011e	03 c8		 add	 ecx, eax
  00120	8b c1		 mov	 eax, ecx
  00122	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1782 :                 s = r & 15; // combined length

  00125	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR r$4[rbp]
  0012b	83 e0 0f	 and	 eax, 15
  0012e	89 85 a4 00 00
	00		 mov	 DWORD PTR s$5[rbp], eax

; 1783 :                 if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  00134	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0013b	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00141	39 85 a4 00 00
	00		 cmp	 DWORD PTR s$5[rbp], eax
  00147	7e 11		 jle	 SHORT $LN20@stbi__jpeg
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00150	e8 00 00 00 00	 call	 stbi__err
  00155	e9 69 05 00 00	 jmp	 $LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 1784 :                 j->code_buffer <<= s;

  0015a	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR s$5[rbp]
  00160	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00167	48 89 8d 58 02
	00 00		 mov	 QWORD PTR tv354[rbp], rcx
  0016e	0f b6 c8	 movzx	 ecx, al
  00171	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv354[rbp]
  00178	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0017e	d3 e0		 shl	 eax, cl
  00180	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00187	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1785 :                 j->code_bits -= s;

  0018d	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00194	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR s$5[rbp]
  0019a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001a0	2b c1		 sub	 eax, ecx
  001a2	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001a9	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1786 :                 zig = stbi__jpeg_dezigzag[k++];

  001af	48 63 45 04	 movsxd	 rax, DWORD PTR k$[rbp]
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  001ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001be	89 45 44	 mov	 DWORD PTR zig$2[rbp], eax
  001c1	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  001c4	ff c0		 inc	 eax
  001c6	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1787 :                 data[zig] = (short)((r >> 8) * (1 << shift));

  001c9	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR r$4[rbp]
  001cf	c1 f8 08	 sar	 eax, 8
  001d2	8b 4d 24	 mov	 ecx, DWORD PTR shift$1[rbp]
  001d5	ba 01 00 00 00	 mov	 edx, 1
  001da	d3 e2		 shl	 edx, cl
  001dc	8b ca		 mov	 ecx, edx
  001de	0f af c1	 imul	 eax, ecx
  001e1	8b 4d 44	 mov	 ecx, DWORD PTR zig$2[rbp]
  001e4	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  001eb	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 1788 :             }

  001ef	e9 47 01 00 00	 jmp	 $LN19@stbi__jpeg
$LN18@stbi__jpeg:

; 1789 :             else {
; 1790 :                 int rs = stbi__jpeg_huff_decode(j, hac);

  001f4	48 8b 95 90 02
	00 00		 mov	 rdx, QWORD PTR hac$[rbp]
  001fb	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00202	e8 00 00 00 00	 call	 stbi__jpeg_huff_decode
  00207	89 85 c4 00 00
	00		 mov	 DWORD PTR rs$6[rbp], eax

; 1791 :                 if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

  0020d	83 bd c4 00 00
	00 00		 cmp	 DWORD PTR rs$6[rbp], 0
  00214	7d 11		 jge	 SHORT $LN21@stbi__jpeg
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  0021d	e8 00 00 00 00	 call	 stbi__err
  00222	e9 9c 04 00 00	 jmp	 $LN1@stbi__jpeg
$LN21@stbi__jpeg:

; 1792 :                 s = rs & 15;

  00227	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR rs$6[rbp]
  0022d	83 e0 0f	 and	 eax, 15
  00230	89 85 a4 00 00
	00		 mov	 DWORD PTR s$5[rbp], eax

; 1793 :                 r = rs >> 4;

  00236	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR rs$6[rbp]
  0023c	c1 f8 04	 sar	 eax, 4
  0023f	89 85 84 00 00
	00		 mov	 DWORD PTR r$4[rbp], eax

; 1794 :                 if (s == 0) {

  00245	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR s$5[rbp], 0
  0024c	0f 85 90 00 00
	00		 jne	 $LN22@stbi__jpeg

; 1795 :                     if (r < 15) {

  00252	83 bd 84 00 00
	00 0f		 cmp	 DWORD PTR r$4[rbp], 15
  00259	7d 7c		 jge	 SHORT $LN24@stbi__jpeg

; 1796 :                         j->eob_run = (1 << r);

  0025b	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR r$4[rbp]
  00261	b9 01 00 00 00	 mov	 ecx, 1
  00266	89 8d 54 02 00
	00		 mov	 DWORD PTR tv371[rbp], ecx
  0026c	0f b6 c8	 movzx	 ecx, al
  0026f	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv371[rbp]
  00275	d3 e0		 shl	 eax, cl
  00277	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0027e	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 1797 :                         if (r)

  00284	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR r$4[rbp], 0
  0028b	74 2c		 je	 SHORT $LN25@stbi__jpeg

; 1798 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  0028d	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR r$4[rbp]
  00293	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0029a	e8 00 00 00 00	 call	 stbi__jpeg_get_bits
  0029f	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002a6	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  002ac	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002b3	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN25@stbi__jpeg:

; 1799 :                         --j->eob_run;

  002b9	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  002c0	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  002c6	ff c8		 dec	 eax
  002c8	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002cf	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 1800 :                         break;

  002d5	eb 7a		 jmp	 SHORT $LN3@stbi__jpeg
$LN24@stbi__jpeg:

; 1801 :                     }
; 1802 :                     k += 16;

  002d7	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  002da	83 c0 10	 add	 eax, 16
  002dd	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1803 :                 }

  002e0	eb 59		 jmp	 SHORT $LN23@stbi__jpeg
$LN22@stbi__jpeg:

; 1804 :                 else {
; 1805 :                     k += r;

  002e2	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR r$4[rbp]
  002e8	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  002eb	03 c8		 add	 ecx, eax
  002ed	8b c1		 mov	 eax, ecx
  002ef	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1806 :                     zig = stbi__jpeg_dezigzag[k++];

  002f2	48 63 45 04	 movsxd	 rax, DWORD PTR k$[rbp]
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  002fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00301	89 45 44	 mov	 DWORD PTR zig$2[rbp], eax
  00304	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  00307	ff c0		 inc	 eax
  00309	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1807 :                     data[zig] = (short)(stbi__extend_receive(j, s) * (1 << shift));

  0030c	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR s$5[rbp]
  00312	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00319	e8 00 00 00 00	 call	 stbi__extend_receive
  0031e	8b 4d 24	 mov	 ecx, DWORD PTR shift$1[rbp]
  00321	ba 01 00 00 00	 mov	 edx, 1
  00326	d3 e2		 shl	 edx, cl
  00328	8b ca		 mov	 ecx, edx
  0032a	0f af c1	 imul	 eax, ecx
  0032d	8b 4d 44	 mov	 ecx, DWORD PTR zig$2[rbp]
  00330	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  00337	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN23@stbi__jpeg:
$LN19@stbi__jpeg:

; 1808 :                 }
; 1809 :             }
; 1810 :         } while (k <= j->spec_end);

  0033b	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00342	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00348	39 45 04	 cmp	 DWORD PTR k$[rbp], eax
  0034b	0f 8e 68 fd ff
	ff		 jle	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 1811 :     }

  00351	e9 68 03 00 00	 jmp	 $LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 1812 :     else {
; 1813 :         // refinement scan for these AC coefficients
; 1814 : 
; 1815 :         short bit = (short)(1 << j->succ_low);

  00356	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0035d	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	89 8d 54 02 00
	00		 mov	 DWORD PTR tv393[rbp], ecx
  0036e	0f b6 c8	 movzx	 ecx, al
  00371	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv393[rbp]
  00377	d3 e0		 shl	 eax, cl
  00379	66 89 85 e4 00
	00 00		 mov	 WORD PTR bit$7[rbp], ax

; 1816 : 
; 1817 :         if (j->eob_run) {

  00380	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00387	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  0038e	0f 84 fa 00 00
	00		 je	 $LN26@stbi__jpeg

; 1818 :             --j->eob_run;

  00394	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0039b	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  003a1	ff c8		 dec	 eax
  003a3	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  003aa	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 1819 :             for (k = j->spec_start; k <= j->spec_end; ++k) {

  003b0	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  003b7	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  003bd	89 45 04	 mov	 DWORD PTR k$[rbp], eax
  003c0	eb 08		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  003c2	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  003c5	ff c0		 inc	 eax
  003c7	89 45 04	 mov	 DWORD PTR k$[rbp], eax
$LN7@stbi__jpeg:
  003ca	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  003d1	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  003d7	39 45 04	 cmp	 DWORD PTR k$[rbp], eax
  003da	0f 8f a9 00 00
	00		 jg	 $LN6@stbi__jpeg

; 1820 :                 short* p = &data[stbi__jpeg_dezigzag[k]];

  003e0	48 63 45 04	 movsxd	 rax, DWORD PTR k$[rbp]
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  003eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ef	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  003f6	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  003fa	48 89 85 08 01
	00 00		 mov	 QWORD PTR p$8[rbp], rax

; 1821 :                 if (*p != 0)

  00401	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR p$8[rbp]
  00408	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0040b	85 c0		 test	 eax, eax
  0040d	74 75		 je	 SHORT $LN28@stbi__jpeg

; 1822 :                     if (stbi__jpeg_get_bit(j))

  0040f	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00416	e8 00 00 00 00	 call	 stbi__jpeg_get_bit
  0041b	85 c0		 test	 eax, eax
  0041d	74 65		 je	 SHORT $LN29@stbi__jpeg

; 1823 :                         if ((*p & bit) == 0) {

  0041f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR p$8[rbp]
  00426	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00429	0f bf 8d e4 00
	00 00		 movsx	 ecx, WORD PTR bit$7[rbp]
  00430	23 c1		 and	 eax, ecx
  00432	85 c0		 test	 eax, eax
  00434	75 4e		 jne	 SHORT $LN30@stbi__jpeg

; 1824 :                             if (*p > 0)

  00436	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR p$8[rbp]
  0043d	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00440	85 c0		 test	 eax, eax
  00442	7e 21		 jle	 SHORT $LN31@stbi__jpeg

; 1825 :                                 *p += bit;

  00444	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  0044b	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$8[rbp]
  00452	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00455	03 c8		 add	 ecx, eax
  00457	8b c1		 mov	 eax, ecx
  00459	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$8[rbp]
  00460	66 89 01	 mov	 WORD PTR [rcx], ax
  00463	eb 1f		 jmp	 SHORT $LN32@stbi__jpeg
$LN31@stbi__jpeg:

; 1826 :                             else
; 1827 :                                 *p -= bit;

  00465	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  0046c	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$8[rbp]
  00473	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00476	2b c8		 sub	 ecx, eax
  00478	8b c1		 mov	 eax, ecx
  0047a	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$8[rbp]
  00481	66 89 01	 mov	 WORD PTR [rcx], ax
$LN32@stbi__jpeg:
$LN30@stbi__jpeg:
$LN29@stbi__jpeg:
$LN28@stbi__jpeg:

; 1828 :                         }
; 1829 :             }

  00484	e9 39 ff ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 1830 :         }

  00489	e9 30 02 00 00	 jmp	 $LN27@stbi__jpeg
$LN26@stbi__jpeg:

; 1831 :         else {
; 1832 :             k = j->spec_start;

  0048e	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00495	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  0049b	89 45 04	 mov	 DWORD PTR k$[rbp], eax
$LN10@stbi__jpeg:

; 1833 :             do {
; 1834 :                 int r, s;
; 1835 :                 int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

  0049e	48 8b 95 90 02
	00 00		 mov	 rdx, QWORD PTR hac$[rbp]
  004a5	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  004ac	e8 00 00 00 00	 call	 stbi__jpeg_huff_decode
  004b1	89 85 64 01 00
	00		 mov	 DWORD PTR rs$11[rbp], eax

; 1836 :                 if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

  004b7	83 bd 64 01 00
	00 00		 cmp	 DWORD PTR rs$11[rbp], 0
  004be	7d 11		 jge	 SHORT $LN33@stbi__jpeg
  004c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  004c7	e8 00 00 00 00	 call	 stbi__err
  004cc	e9 f2 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN33@stbi__jpeg:

; 1837 :                 s = rs & 15;

  004d1	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR rs$11[rbp]
  004d7	83 e0 0f	 and	 eax, 15
  004da	89 85 44 01 00
	00		 mov	 DWORD PTR s$10[rbp], eax

; 1838 :                 r = rs >> 4;

  004e0	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR rs$11[rbp]
  004e6	c1 f8 04	 sar	 eax, 4
  004e9	89 85 24 01 00
	00		 mov	 DWORD PTR r$9[rbp], eax

; 1839 :                 if (s == 0) {

  004ef	83 bd 44 01 00
	00 00		 cmp	 DWORD PTR s$10[rbp], 0
  004f6	75 75		 jne	 SHORT $LN34@stbi__jpeg

; 1840 :                     if (r < 15) {

  004f8	83 bd 24 01 00
	00 0f		 cmp	 DWORD PTR r$9[rbp], 15
  004ff	7d 6a		 jge	 SHORT $LN36@stbi__jpeg

; 1841 :                         j->eob_run = (1 << r) - 1;

  00501	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR r$9[rbp]
  00507	b9 01 00 00 00	 mov	 ecx, 1
  0050c	89 8d 54 02 00
	00		 mov	 DWORD PTR tv420[rbp], ecx
  00512	0f b6 c8	 movzx	 ecx, al
  00515	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR tv420[rbp]
  0051b	d3 e0		 shl	 eax, cl
  0051d	ff c8		 dec	 eax
  0051f	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00526	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 1842 :                         if (r)

  0052c	83 bd 24 01 00
	00 00		 cmp	 DWORD PTR r$9[rbp], 0
  00533	74 2c		 je	 SHORT $LN38@stbi__jpeg

; 1843 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  00535	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR r$9[rbp]
  0053b	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00542	e8 00 00 00 00	 call	 stbi__jpeg_get_bits
  00547	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0054e	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  00554	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0055b	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN38@stbi__jpeg:

; 1844 :                         r = 64; // force end of block

  00561	c7 85 24 01 00
	00 40 00 00 00	 mov	 DWORD PTR r$9[rbp], 64	; 00000040H
$LN36@stbi__jpeg:

; 1845 :                     }
; 1846 :                     else {
; 1847 :                         // r=15 s=0 should write 16 0s, so we just do
; 1848 :                         // a run of 15 0s and then write s (which is 0),
; 1849 :                         // so we don't have to do anything special here
; 1850 :                     }
; 1851 :                 }

  0056b	eb 48		 jmp	 SHORT $LN35@stbi__jpeg
$LN34@stbi__jpeg:

; 1852 :                 else {
; 1853 :                     if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

  0056d	83 bd 44 01 00
	00 01		 cmp	 DWORD PTR s$10[rbp], 1
  00574	74 11		 je	 SHORT $LN39@stbi__jpeg
  00576	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  0057d	e8 00 00 00 00	 call	 stbi__err
  00582	e9 3c 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN39@stbi__jpeg:

; 1854 :                     // sign bit
; 1855 :                     if (stbi__jpeg_get_bit(j))

  00587	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0058e	e8 00 00 00 00	 call	 stbi__jpeg_get_bit
  00593	85 c0		 test	 eax, eax
  00595	74 0f		 je	 SHORT $LN40@stbi__jpeg

; 1856 :                         s = bit;

  00597	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  0059e	89 85 44 01 00
	00		 mov	 DWORD PTR s$10[rbp], eax
  005a4	eb 0f		 jmp	 SHORT $LN41@stbi__jpeg
$LN40@stbi__jpeg:

; 1857 :                     else
; 1858 :                         s = -bit;

  005a6	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  005ad	f7 d8		 neg	 eax
  005af	89 85 44 01 00
	00		 mov	 DWORD PTR s$10[rbp], eax
$LN41@stbi__jpeg:
$LN35@stbi__jpeg:
$LN11@stbi__jpeg:

; 1859 :                 }
; 1860 : 
; 1861 :                 // advance by r
; 1862 :                 while (k <= j->spec_end) {

  005b5	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  005bc	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  005c2	39 45 04	 cmp	 DWORD PTR k$[rbp], eax
  005c5	0f 8f dd 00 00
	00		 jg	 $LN12@stbi__jpeg

; 1863 :                     short* p = &data[stbi__jpeg_dezigzag[k++]];

  005cb	48 63 45 04	 movsxd	 rax, DWORD PTR k$[rbp]
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  005d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005da	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  005e1	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  005e5	48 89 85 88 01
	00 00		 mov	 QWORD PTR p$12[rbp], rax
  005ec	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  005ef	ff c0		 inc	 eax
  005f1	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1864 :                     if (*p != 0) {

  005f4	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$12[rbp]
  005fb	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005fe	85 c0		 test	 eax, eax
  00600	74 77		 je	 SHORT $LN42@stbi__jpeg

; 1865 :                         if (stbi__jpeg_get_bit(j))

  00602	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00609	e8 00 00 00 00	 call	 stbi__jpeg_get_bit
  0060e	85 c0		 test	 eax, eax
  00610	74 65		 je	 SHORT $LN44@stbi__jpeg

; 1866 :                             if ((*p & bit) == 0) {

  00612	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$12[rbp]
  00619	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0061c	0f bf 8d e4 00
	00 00		 movsx	 ecx, WORD PTR bit$7[rbp]
  00623	23 c1		 and	 eax, ecx
  00625	85 c0		 test	 eax, eax
  00627	75 4e		 jne	 SHORT $LN45@stbi__jpeg

; 1867 :                                 if (*p > 0)

  00629	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$12[rbp]
  00630	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00633	85 c0		 test	 eax, eax
  00635	7e 21		 jle	 SHORT $LN46@stbi__jpeg

; 1868 :                                     *p += bit;

  00637	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  0063e	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR p$12[rbp]
  00645	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00648	03 c8		 add	 ecx, eax
  0064a	8b c1		 mov	 eax, ecx
  0064c	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR p$12[rbp]
  00653	66 89 01	 mov	 WORD PTR [rcx], ax
  00656	eb 1f		 jmp	 SHORT $LN47@stbi__jpeg
$LN46@stbi__jpeg:

; 1869 :                                 else
; 1870 :                                     *p -= bit;

  00658	0f bf 85 e4 00
	00 00		 movsx	 eax, WORD PTR bit$7[rbp]
  0065f	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR p$12[rbp]
  00666	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00669	2b c8		 sub	 ecx, eax
  0066b	8b c1		 mov	 eax, ecx
  0066d	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR p$12[rbp]
  00674	66 89 01	 mov	 WORD PTR [rcx], ax
$LN47@stbi__jpeg:
$LN45@stbi__jpeg:
$LN44@stbi__jpeg:

; 1871 :                             }
; 1872 :                     }

  00677	eb 2a		 jmp	 SHORT $LN43@stbi__jpeg
$LN42@stbi__jpeg:

; 1873 :                     else {
; 1874 :                         if (r == 0) {

  00679	83 bd 24 01 00
	00 00		 cmp	 DWORD PTR r$9[rbp], 0
  00680	75 13		 jne	 SHORT $LN48@stbi__jpeg

; 1875 :                             *p = (short)s;

  00682	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$12[rbp]
  00689	0f b7 8d 44 01
	00 00		 movzx	 ecx, WORD PTR s$10[rbp]
  00690	66 89 08	 mov	 WORD PTR [rax], cx

; 1876 :                             break;

  00693	eb 13		 jmp	 SHORT $LN12@stbi__jpeg
$LN48@stbi__jpeg:

; 1877 :                         }
; 1878 :                         --r;

  00695	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR r$9[rbp]
  0069b	ff c8		 dec	 eax
  0069d	89 85 24 01 00
	00		 mov	 DWORD PTR r$9[rbp], eax
$LN43@stbi__jpeg:

; 1879 :                     }
; 1880 :                 }

  006a3	e9 0d ff ff ff	 jmp	 $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 1881 :             } while (k <= j->spec_end);

  006a8	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  006af	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  006b5	39 45 04	 cmp	 DWORD PTR k$[rbp], eax
  006b8	0f 8e e0 fd ff
	ff		 jle	 $LN10@stbi__jpeg
$LN27@stbi__jpeg:
$LN15@stbi__jpeg:

; 1882 :         }
; 1883 :     }
; 1884 :     return 1;

  006be	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 1885 : }

  006c3	48 8d a5 68 02
	00 00		 lea	 rsp, QWORD PTR [rbp+616]
  006ca	5f		 pop	 rdi
  006cb	5d		 pop	 rbp
  006cc	c3		 ret	 0
stbi__jpeg_decode_block_prog_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_decode_block_prog_dc
_TEXT	SEGMENT
diff$ = 4
dc$ = 36
t$ = 68
tv211 = 276
tv207 = 276
tv87 = 276
j$ = 320
data$ = 328
hdc$ = 336
b$ = 344
stbi__jpeg_decode_block_prog_dc PROC			; COMDAT

; 1730 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1731 :     int diff, dc;
; 1732 :     int t;
; 1733 :     if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0002e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00035	83 b8 38 48 00
	00 00		 cmp	 DWORD PTR [rax+18488], 0
  0003c	74 11		 je	 SHORT $LN2@stbi__jpeg
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  00045	e8 00 00 00 00	 call	 stbi__err
  0004a	e9 f5 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 1734 : 
; 1735 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0004f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00056	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0005d	7d 0c		 jge	 SHORT $LN3@stbi__jpeg
  0005f	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00066	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN3@stbi__jpeg:

; 1736 : 
; 1737 :     if (j->succ_high == 0) {

  0006b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00072	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  00079	0f 85 6d 01 00
	00		 jne	 $LN4@stbi__jpeg

; 1738 :         // first scan for DC coefficient, must be first
; 1739 :         memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now

  0007f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00085	33 d2		 xor	 edx, edx
  00087	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0008e	e8 00 00 00 00	 call	 memset

; 1740 :         t = stbi__jpeg_huff_decode(j, hdc);

  00093	48 8b 95 50 01
	00 00		 mov	 rdx, QWORD PTR hdc$[rbp]
  0009a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000a1	e8 00 00 00 00	 call	 stbi__jpeg_huff_decode
  000a6	89 45 44	 mov	 DWORD PTR t$[rbp], eax

; 1741 :         if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  000a9	83 7d 44 00	 cmp	 DWORD PTR t$[rbp], 0
  000ad	7c 06		 jl	 SHORT $LN7@stbi__jpeg
  000af	83 7d 44 0f	 cmp	 DWORD PTR t$[rbp], 15
  000b3	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  000bc	e8 00 00 00 00	 call	 stbi__err
  000c1	e9 7e 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1742 :         diff = t ? stbi__extend_receive(j, t) : 0;

  000c6	83 7d 44 00	 cmp	 DWORD PTR t$[rbp], 0
  000ca	74 17		 je	 SHORT $LN12@stbi__jpeg
  000cc	8b 55 44	 mov	 edx, DWORD PTR t$[rbp]
  000cf	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000d6	e8 00 00 00 00	 call	 stbi__extend_receive
  000db	89 85 14 01 00
	00		 mov	 DWORD PTR tv87[rbp], eax
  000e1	eb 0a		 jmp	 SHORT $LN13@stbi__jpeg
$LN12@stbi__jpeg:
  000e3	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv87[rbp], 0
$LN13@stbi__jpeg:
  000ed	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv87[rbp]
  000f3	89 45 04	 mov	 DWORD PTR diff$[rbp], eax

; 1743 : 
; 1744 :         if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

  000f6	48 63 85 58 01
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  000fd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00101	8b 55 04	 mov	 edx, DWORD PTR diff$[rbp]
  00104	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0010b	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  00112	e8 00 00 00 00	 call	 stbi__addints_valid
  00117	85 c0		 test	 eax, eax
  00119	75 11		 jne	 SHORT $LN8@stbi__jpeg
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
  00122	e8 00 00 00 00	 call	 stbi__err
  00127	e9 18 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 1745 :         dc = j->img_comp[b].dc_pred + diff;

  0012c	48 63 85 58 01
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  00133	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00137	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0013e	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  00145	03 45 04	 add	 eax, DWORD PTR diff$[rbp]
  00148	89 45 24	 mov	 DWORD PTR dc$[rbp], eax

; 1746 :         j->img_comp[b].dc_pred = dc;

  0014b	48 63 85 58 01
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  00152	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00156	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0015d	8b 55 24	 mov	 edx, DWORD PTR dc$[rbp]
  00160	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 1747 :         if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00167	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0016e	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00174	b9 01 00 00 00	 mov	 ecx, 1
  00179	89 8d 14 01 00
	00		 mov	 DWORD PTR tv207[rbp], ecx
  0017f	0f b6 c8	 movzx	 ecx, al
  00182	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv207[rbp]
  00188	d3 e0		 shl	 eax, cl
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	0f b7 4d 24	 movzx	 ecx, WORD PTR dc$[rbp]
  00191	e8 00 00 00 00	 call	 stbi__mul2shorts_valid
  00196	85 c0		 test	 eax, eax
  00198	75 11		 jne	 SHORT $LN9@stbi__jpeg
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  001a1	e8 00 00 00 00	 call	 stbi__err
  001a6	e9 99 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 1748 :         data[0] = (short)(dc * (1 << j->succ_low));

  001ab	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  001b2	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  001b8	b9 01 00 00 00	 mov	 ecx, 1
  001bd	89 8d 14 01 00
	00		 mov	 DWORD PTR tv211[rbp], ecx
  001c3	0f b6 c8	 movzx	 ecx, al
  001c6	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv211[rbp]
  001cc	d3 e0		 shl	 eax, cl
  001ce	8b 4d 24	 mov	 ecx, DWORD PTR dc$[rbp]
  001d1	0f af c8	 imul	 ecx, eax
  001d4	8b c1		 mov	 eax, ecx
  001d6	b9 02 00 00 00	 mov	 ecx, 2
  001db	48 6b c9 00	 imul	 rcx, rcx, 0
  001df	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  001e6	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 1749 :     }

  001ea	eb 53		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 1750 :     else {
; 1751 :         // refinement scan for DC coefficient
; 1752 :         if (stbi__jpeg_get_bit(j))

  001ec	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001f3	e8 00 00 00 00	 call	 stbi__jpeg_get_bit
  001f8	85 c0		 test	 eax, eax
  001fa	74 43		 je	 SHORT $LN10@stbi__jpeg

; 1753 :             data[0] += (short)(1 << j->succ_low);

  001fc	b8 02 00 00 00	 mov	 eax, 2
  00201	48 6b c0 00	 imul	 rax, rax, 0
  00205	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0020c	8b 89 40 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18496]
  00212	ba 01 00 00 00	 mov	 edx, 1
  00217	d3 e2		 shl	 edx, cl
  00219	8b ca		 mov	 ecx, edx
  0021b	0f bf c9	 movsx	 ecx, cx
  0021e	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  00225	0f bf 04 02	 movsx	 eax, WORD PTR [rdx+rax]
  00229	03 c1		 add	 eax, ecx
  0022b	b9 02 00 00 00	 mov	 ecx, 2
  00230	48 6b c9 00	 imul	 rcx, rcx, 0
  00234	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  0023b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN10@stbi__jpeg:
$LN5@stbi__jpeg:

; 1754 :     }
; 1755 :     return 1;

  0023f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 1756 : }

  00244	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0024b	5f		 pop	 rdi
  0024c	5d		 pop	 rbp
  0024d	c3		 ret	 0
stbi__jpeg_decode_block_prog_dc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_decode_block
_TEXT	SEGMENT
diff$ = 4
dc$ = 36
k$ = 68
t$ = 100
zig$1 = 132
c$2 = 164
r$3 = 196
s$4 = 228
rs$5 = 260
tv81 = 468
tv275 = 472
j$ = 512
data$ = 520
hdc$ = 528
hac$ = 536
fac$ = 544
b$ = 552
dequant$ = 560
stbi__jpeg_decode_block PROC				; COMDAT

; 1673 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1674 :     int diff, dc, k;
; 1675 :     int t;
; 1676 : 
; 1677 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0002e	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00035	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0003c	7d 0c		 jge	 SHORT $LN5@stbi__jpeg
  0003e	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00045	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 1678 :     t = stbi__jpeg_huff_decode(j, hdc);

  0004a	48 8b 95 10 02
	00 00		 mov	 rdx, QWORD PTR hdc$[rbp]
  00051	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00058	e8 00 00 00 00	 call	 stbi__jpeg_huff_decode
  0005d	89 45 64	 mov	 DWORD PTR t$[rbp], eax

; 1679 :     if (t < 0 || t > 15) return stbi__err("bad huffman code", "Corrupt JPEG");

  00060	83 7d 64 00	 cmp	 DWORD PTR t$[rbp], 0
  00064	7c 06		 jl	 SHORT $LN7@stbi__jpeg
  00066	83 7d 64 0f	 cmp	 DWORD PTR t$[rbp], 15
  0006a	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00073	e8 00 00 00 00	 call	 stbi__err
  00078	e9 50 03 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1680 : 
; 1681 :     // 0 all the ac values now so we can do it 32-bits at a time
; 1682 :     memset(data, 0, 64 * sizeof(data[0]));

  0007d	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00083	33 d2		 xor	 edx, edx
  00085	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0008c	e8 00 00 00 00	 call	 memset

; 1683 : 
; 1684 :     diff = t ? stbi__extend_receive(j, t) : 0;

  00091	83 7d 64 00	 cmp	 DWORD PTR t$[rbp], 0
  00095	74 17		 je	 SHORT $LN19@stbi__jpeg
  00097	8b 55 64	 mov	 edx, DWORD PTR t$[rbp]
  0009a	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000a1	e8 00 00 00 00	 call	 stbi__extend_receive
  000a6	89 85 d4 01 00
	00		 mov	 DWORD PTR tv81[rbp], eax
  000ac	eb 0a		 jmp	 SHORT $LN20@stbi__jpeg
$LN19@stbi__jpeg:
  000ae	c7 85 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv81[rbp], 0
$LN20@stbi__jpeg:
  000b8	8b 85 d4 01 00
	00		 mov	 eax, DWORD PTR tv81[rbp]
  000be	89 45 04	 mov	 DWORD PTR diff$[rbp], eax

; 1685 :     if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

  000c1	48 63 85 28 02
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  000c8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000cc	8b 55 04	 mov	 edx, DWORD PTR diff$[rbp]
  000cf	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000d6	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  000dd	e8 00 00 00 00	 call	 stbi__addints_valid
  000e2	85 c0		 test	 eax, eax
  000e4	75 11		 jne	 SHORT $LN8@stbi__jpeg
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
  000ed	e8 00 00 00 00	 call	 stbi__err
  000f2	e9 d6 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 1686 :     dc = j->img_comp[b].dc_pred + diff;

  000f7	48 63 85 28 02
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  000fe	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00102	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00109	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  00110	03 45 04	 add	 eax, DWORD PTR diff$[rbp]
  00113	89 45 24	 mov	 DWORD PTR dc$[rbp], eax

; 1687 :     j->img_comp[b].dc_pred = dc;

  00116	48 63 85 28 02
	00 00		 movsxd	 rax, DWORD PTR b$[rbp]
  0011d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00121	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00128	8b 55 24	 mov	 edx, DWORD PTR dc$[rbp]
  0012b	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 1688 :     if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	48 6b c0 00	 imul	 rax, rax, 0
  0013b	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR dequant$[rbp]
  00142	0f b7 14 01	 movzx	 edx, WORD PTR [rcx+rax]
  00146	0f b7 4d 24	 movzx	 ecx, WORD PTR dc$[rbp]
  0014a	e8 00 00 00 00	 call	 stbi__mul2shorts_valid
  0014f	85 c0		 test	 eax, eax
  00151	75 11		 jne	 SHORT $LN9@stbi__jpeg
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  0015a	e8 00 00 00 00	 call	 stbi__err
  0015f	e9 69 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 1689 :     data[0] = (short)(dc * dequant[0]);

  00164	b8 02 00 00 00	 mov	 eax, 2
  00169	48 6b c0 00	 imul	 rax, rax, 0
  0016d	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR dequant$[rbp]
  00174	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00178	8b 4d 24	 mov	 ecx, DWORD PTR dc$[rbp]
  0017b	0f af c8	 imul	 ecx, eax
  0017e	8b c1		 mov	 eax, ecx
  00180	b9 02 00 00 00	 mov	 ecx, 2
  00185	48 6b c9 00	 imul	 rcx, rcx, 0
  00189	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  00190	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 1690 : 
; 1691 :     // decode AC components, see JPEG spec
; 1692 :     k = 1;

  00194	c7 45 44 01 00
	00 00		 mov	 DWORD PTR k$[rbp], 1
$LN4@stbi__jpeg:

; 1693 :     do {
; 1694 :         unsigned int zig;
; 1695 :         int c, r, s;
; 1696 :         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0019b	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  001a2	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  001a9	7d 0c		 jge	 SHORT $LN10@stbi__jpeg
  001ab	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001b2	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN10@stbi__jpeg:

; 1697 :         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

  001b7	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  001be	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  001c4	c1 e8 17	 shr	 eax, 23
  001c7	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  001cc	89 85 a4 00 00
	00		 mov	 DWORD PTR c$2[rbp], eax

; 1698 :         r = fac[c];

  001d2	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR c$2[rbp]
  001d9	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR fac$[rbp]
  001e0	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  001e4	89 85 c4 00 00
	00		 mov	 DWORD PTR r$3[rbp], eax

; 1699 :         if (r) { // fast-AC path

  001ea	83 bd c4 00 00
	00 00		 cmp	 DWORD PTR r$3[rbp], 0
  001f1	0f 84 f0 00 00
	00		 je	 $LN11@stbi__jpeg

; 1700 :             k += (r >> 4) & 15; // run

  001f7	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR r$3[rbp]
  001fd	c1 f8 04	 sar	 eax, 4
  00200	83 e0 0f	 and	 eax, 15
  00203	8b 4d 44	 mov	 ecx, DWORD PTR k$[rbp]
  00206	03 c8		 add	 ecx, eax
  00208	8b c1		 mov	 eax, ecx
  0020a	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1701 :             s = r & 15; // combined length

  0020d	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR r$3[rbp]
  00213	83 e0 0f	 and	 eax, 15
  00216	89 85 e4 00 00
	00		 mov	 DWORD PTR s$4[rbp], eax

; 1702 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  0021c	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00223	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00229	39 85 e4 00 00
	00		 cmp	 DWORD PTR s$4[rbp], eax
  0022f	7e 11		 jle	 SHORT $LN13@stbi__jpeg
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00238	e8 00 00 00 00	 call	 stbi__err
  0023d	e9 8b 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 1703 :             j->code_buffer <<= s;

  00242	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR s$4[rbp]
  00248	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0024f	48 89 8d d8 01
	00 00		 mov	 QWORD PTR tv275[rbp], rcx
  00256	0f b6 c8	 movzx	 ecx, al
  00259	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR tv275[rbp]
  00260	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00266	d3 e0		 shl	 eax, cl
  00268	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0026f	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1704 :             j->code_bits -= s;

  00275	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0027c	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR s$4[rbp]
  00282	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00288	2b c1		 sub	 eax, ecx
  0028a	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00291	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1705 :             // decode into unzigzag'd location
; 1706 :             zig = stbi__jpeg_dezigzag[k++];

  00297	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  002a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a6	89 85 84 00 00
	00		 mov	 DWORD PTR zig$1[rbp], eax
  002ac	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  002af	ff c0		 inc	 eax
  002b1	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1707 :             data[zig] = (short)((r >> 8) * dequant[zig]);

  002b4	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR r$3[rbp]
  002ba	c1 f8 08	 sar	 eax, 8
  002bd	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR zig$1[rbp]
  002c3	48 8b 95 30 02
	00 00		 mov	 rdx, QWORD PTR dequant$[rbp]
  002ca	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  002ce	0f af c1	 imul	 eax, ecx
  002d1	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR zig$1[rbp]
  002d7	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  002de	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 1708 :         }

  002e2	e9 d7 00 00 00	 jmp	 $LN12@stbi__jpeg
$LN11@stbi__jpeg:

; 1709 :         else {
; 1710 :             int rs = stbi__jpeg_huff_decode(j, hac);

  002e7	48 8b 95 18 02
	00 00		 mov	 rdx, QWORD PTR hac$[rbp]
  002ee	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002f5	e8 00 00 00 00	 call	 stbi__jpeg_huff_decode
  002fa	89 85 04 01 00
	00		 mov	 DWORD PTR rs$5[rbp], eax

; 1711 :             if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

  00300	83 bd 04 01 00
	00 00		 cmp	 DWORD PTR rs$5[rbp], 0
  00307	7d 11		 jge	 SHORT $LN14@stbi__jpeg
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00310	e8 00 00 00 00	 call	 stbi__err
  00315	e9 b3 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN14@stbi__jpeg:

; 1712 :             s = rs & 15;

  0031a	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR rs$5[rbp]
  00320	83 e0 0f	 and	 eax, 15
  00323	89 85 e4 00 00
	00		 mov	 DWORD PTR s$4[rbp], eax

; 1713 :             r = rs >> 4;

  00329	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR rs$5[rbp]
  0032f	c1 f8 04	 sar	 eax, 4
  00332	89 85 c4 00 00
	00		 mov	 DWORD PTR r$3[rbp], eax

; 1714 :             if (s == 0) {

  00338	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR s$4[rbp], 0
  0033f	75 19		 jne	 SHORT $LN15@stbi__jpeg

; 1715 :                 if (rs != 0xf0) break; // end block

  00341	81 bd 04 01 00
	00 f0 00 00 00	 cmp	 DWORD PTR rs$5[rbp], 240 ; 000000f0H
  0034b	74 02		 je	 SHORT $LN17@stbi__jpeg
  0034d	eb 79		 jmp	 SHORT $LN3@stbi__jpeg
$LN17@stbi__jpeg:

; 1716 :                 k += 16;

  0034f	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  00352	83 c0 10	 add	 eax, 16
  00355	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1717 :             }

  00358	eb 64		 jmp	 SHORT $LN16@stbi__jpeg
$LN15@stbi__jpeg:

; 1718 :             else {
; 1719 :                 k += r;

  0035a	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR r$3[rbp]
  00360	8b 4d 44	 mov	 ecx, DWORD PTR k$[rbp]
  00363	03 c8		 add	 ecx, eax
  00365	8b c1		 mov	 eax, ecx
  00367	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1720 :                 // decode into unzigzag'd location
; 1721 :                 zig = stbi__jpeg_dezigzag[k++];

  0036a	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  0036e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  00375	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00379	89 85 84 00 00
	00		 mov	 DWORD PTR zig$1[rbp], eax
  0037f	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  00382	ff c0		 inc	 eax
  00384	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1722 :                 data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);

  00387	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR s$4[rbp]
  0038d	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00394	e8 00 00 00 00	 call	 stbi__extend_receive
  00399	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR zig$1[rbp]
  0039f	48 8b 95 30 02
	00 00		 mov	 rdx, QWORD PTR dequant$[rbp]
  003a6	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  003aa	0f af c1	 imul	 eax, ecx
  003ad	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR zig$1[rbp]
  003b3	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR data$[rbp]
  003ba	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN16@stbi__jpeg:
$LN12@stbi__jpeg:

; 1723 :             }
; 1724 :         }
; 1725 :     } while (k < 64);

  003be	83 7d 44 40	 cmp	 DWORD PTR k$[rbp], 64	; 00000040H
  003c2	0f 8c d3 fd ff
	ff		 jl	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 1726 :     return 1;

  003c8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 1727 : }

  003cd	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  003d4	5f		 pop	 rdi
  003d5	5d		 pop	 rbp
  003d6	c3		 ret	 0
stbi__jpeg_decode_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_get_bit
_TEXT	SEGMENT
k$ = 4
j$ = 256
stbi__jpeg_get_bit PROC					; COMDAT

; 1644 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1645 :     unsigned int k;
; 1646 :     if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  0001f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  0002d	7d 0c		 jge	 SHORT $LN2@stbi__jpeg
  0002f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00036	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 1647 :     if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  0003b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00042	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00049	7d 04		 jge	 SHORT $LN3@stbi__jpeg
  0004b	33 c0		 xor	 eax, eax
  0004d	eb 50		 jmp	 SHORT $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 1648 :     k = j->code_buffer;

  0004f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00056	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0005c	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1649 :     j->code_buffer <<= 1;

  0005f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00066	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0006c	d1 e0		 shl	 eax, 1
  0006e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00075	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1650 :     --j->code_bits;

  0007b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00082	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00088	ff c8		 dec	 eax
  0008a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00091	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1651 :     return k & 0x80000000;

  00097	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
  0009a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
$LN1@stbi__jpeg:

; 1652 : }

  0009f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a6	5f		 pop	 rdi
  000a7	5d		 pop	 rbp
  000a8	c3		 ret	 0
stbi__jpeg_get_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_get_bits
_TEXT	SEGMENT
k$ = 4
j$ = 256
n$ = 264
stbi__jpeg_get_bits PROC				; COMDAT

; 1632 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1633 :     unsigned int k;
; 1634 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  00023	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0002a	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00030	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00036	7d 0c		 jge	 SHORT $LN2@stbi__jpeg
  00038	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0003f	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 1635 :     if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0004b	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00051	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00057	7d 07		 jge	 SHORT $LN3@stbi__jpeg
  00059	33 c0		 xor	 eax, eax
  0005b	e9 82 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 1636 :     k = stbi_lrot(j->code_buffer, n);

  00060	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00066	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0006d	8b 88 20 48 00
	00		 mov	 ecx, DWORD PTR [rax+18464]
  00073	e8 00 00 00 00	 call	 _lrotl
  00078	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1637 :     j->code_buffer = k & ~stbi__bmask[n];

  0007b	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00089	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0008c	f7 d0		 not	 eax
  0008e	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  00091	23 c8		 and	 ecx, eax
  00093	8b c1		 mov	 eax, ecx
  00095	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0009c	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1638 :     k &= stbi__bmask[n];

  000a2	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  000b0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000b3	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  000b6	23 c8		 and	 ecx, eax
  000b8	8b c1		 mov	 eax, ecx
  000ba	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1639 :     j->code_bits -= n;

  000bd	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000c4	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  000ca	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000d0	2b c1		 sub	 eax, ecx
  000d2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000d9	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1640 :     return k;

  000df	8b 45 04	 mov	 eax, DWORD PTR k$[rbp]
$LN1@stbi__jpeg:

; 1641 : }

  000e2	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000e9	5f		 pop	 rdi
  000ea	5d		 pop	 rbp
  000eb	c3		 ret	 0
stbi__jpeg_get_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__extend_receive
_TEXT	SEGMENT
k$ = 4
sgn$ = 36
j$ = 288
n$ = 296
stbi__extend_receive PROC				; COMDAT

; 1616 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1617 :     unsigned int k;
; 1618 :     int sgn;
; 1619 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  00023	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0002a	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00030	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00036	7d 0c		 jge	 SHORT $LN2@stbi__exte
  00038	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0003f	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN2@stbi__exte:

; 1620 :     if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00044	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0004b	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00051	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00057	7d 07		 jge	 SHORT $LN3@stbi__exte
  00059	33 c0		 xor	 eax, eax
  0005b	e9 b1 00 00 00	 jmp	 $LN1@stbi__exte
$LN3@stbi__exte:

; 1621 : 
; 1622 :     sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  00060	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00067	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0006d	c1 e8 1f	 shr	 eax, 31
  00070	89 45 24	 mov	 DWORD PTR sgn$[rbp], eax

; 1623 :     k = stbi_lrot(j->code_buffer, n);

  00073	8b 95 28 01 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00079	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00080	8b 88 20 48 00
	00		 mov	 ecx, DWORD PTR [rax+18464]
  00086	e8 00 00 00 00	 call	 _lrotl
  0008b	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1624 :     j->code_buffer = k & ~stbi__bmask[n];

  0008e	48 63 85 28 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  0009c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0009f	f7 d0		 not	 eax
  000a1	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  000a4	23 c8		 and	 ecx, eax
  000a6	8b c1		 mov	 eax, ecx
  000a8	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000af	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1625 :     k &= stbi__bmask[n];

  000b5	48 63 85 28 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  000c3	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c6	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  000c9	23 c8		 and	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	89 45 04	 mov	 DWORD PTR k$[rbp], eax

; 1626 :     j->code_bits -= n;

  000d0	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000d7	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  000dd	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000e3	2b c1		 sub	 eax, ecx
  000e5	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000ec	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1627 :     return k + (stbi__jbias[n] & (sgn - 1));

  000f2	48 63 85 28 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  00100	8b 55 24	 mov	 edx, DWORD PTR sgn$[rbp]
  00103	ff ca		 dec	 edx
  00105	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00108	23 c2		 and	 eax, edx
  0010a	8b 4d 04	 mov	 ecx, DWORD PTR k$[rbp]
  0010d	03 c8		 add	 ecx, eax
  0010f	8b c1		 mov	 eax, ecx
$LN1@stbi__exte:

; 1628 : }

  00111	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00118	5f		 pop	 rdi
  00119	5d		 pop	 rbp
  0011a	c3		 ret	 0
stbi__extend_receive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_huff_decode
_TEXT	SEGMENT
temp$ = 4
c$ = 36
k$ = 68
s$1 = 100
tv253 = 312
tv242 = 312
tv233 = 312
tv212 = 312
j$ = 352
h$ = 360
stbi__jpeg_huff_decode PROC				; COMDAT

; 1560 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1561 :     unsigned int temp;
; 1562 :     int c, k;
; 1563 : 
; 1564 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00024	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0002b	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00032	7d 0c		 jge	 SHORT $LN5@stbi__jpeg
  00034	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0003b	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 1565 : 
; 1566 :     // look at the top FAST_BITS and determine what symbol ID it is,
; 1567 :     // if the code is <= FAST_BITS
; 1568 :     c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

  00040	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00047	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0004d	c1 e8 17	 shr	 eax, 23
  00050	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00055	89 45 24	 mov	 DWORD PTR c$[rbp], eax

; 1569 :     k = h->fast[c];

  00058	48 63 45 24	 movsxd	 rax, DWORD PTR c$[rbp]
  0005c	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00067	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1570 :     if (k < 255) {

  0006a	81 7d 44 ff 00
	00 00		 cmp	 DWORD PTR k$[rbp], 255	; 000000ffH
  00071	0f 8d 99 00 00
	00		 jge	 $LN6@stbi__jpeg

; 1571 :         int s = h->size[k];

  00077	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  0007b	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00082	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0008a	89 45 64	 mov	 DWORD PTR s$1[rbp], eax

; 1572 :         if (s > j->code_bits)

  0008d	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00094	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0009a	39 45 64	 cmp	 DWORD PTR s$1[rbp], eax
  0009d	7e 0a		 jle	 SHORT $LN7@stbi__jpeg

; 1573 :             return -1;

  0009f	b8 ff ff ff ff	 mov	 eax, -1
  000a4	e9 41 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 1574 :         j->code_buffer <<= s;

  000a9	8b 45 64	 mov	 eax, DWORD PTR s$1[rbp]
  000ac	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000b3	48 89 8d 38 01
	00 00		 mov	 QWORD PTR tv212[rbp], rcx
  000ba	0f b6 c8	 movzx	 ecx, al
  000bd	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR tv212[rbp]
  000c4	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000ca	d3 e0		 shl	 eax, cl
  000cc	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000d3	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1575 :         j->code_bits -= s;

  000d9	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000e0	8b 4d 64	 mov	 ecx, DWORD PTR s$1[rbp]
  000e3	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000e9	2b c1		 sub	 eax, ecx
  000eb	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000f2	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1576 :         return h->values[k];

  000f8	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  000fc	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00103	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0010b	e9 da 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1577 :     }
; 1578 : 
; 1579 :     // naive test is to shift the code_buffer down so k bits are
; 1580 :     // valid, then test against maxcode. To speed this up, we've
; 1581 :     // preshifted maxcode left so that it has (16-k) 0s at the
; 1582 :     // end; in other words, regardless of the number of bits, it
; 1583 :     // wants to be compared against something shifted to have 16;
; 1584 :     // that way we don't need to shift inside the loop.
; 1585 :     temp = j->code_buffer >> 16;

  00110	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00117	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0011d	c1 e8 10	 shr	 eax, 16
  00120	89 45 04	 mov	 DWORD PTR temp$[rbp], eax

; 1586 :     for (k = FAST_BITS + 1; ; ++k)

  00123	c7 45 44 0a 00
	00 00		 mov	 DWORD PTR k$[rbp], 10
  0012a	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  0012c	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  0012f	ff c0		 inc	 eax
  00131	89 45 44	 mov	 DWORD PTR k$[rbp], eax
$LN4@stbi__jpeg:

; 1587 :         if (temp < h->maxcode[k])

  00134	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  00138	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  0013f	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00146	39 45 04	 cmp	 DWORD PTR temp$[rbp], eax
  00149	73 02		 jae	 SHORT $LN8@stbi__jpeg

; 1588 :             break;

  0014b	eb 02		 jmp	 SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
  0014d	eb dd		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 1589 :     if (k == 17) {

  0014f	83 7d 44 11	 cmp	 DWORD PTR k$[rbp], 17
  00153	75 27		 jne	 SHORT $LN9@stbi__jpeg

; 1590 :         // error! code not found
; 1591 :         j->code_bits -= 16;

  00155	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0015c	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00162	83 e8 10	 sub	 eax, 16
  00165	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0016c	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1592 :         return -1;

  00172	b8 ff ff ff ff	 mov	 eax, -1
  00177	e9 6e 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 1593 :     }
; 1594 : 
; 1595 :     if (k > j->code_bits)

  0017c	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00183	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00189	39 45 44	 cmp	 DWORD PTR k$[rbp], eax
  0018c	7e 0a		 jle	 SHORT $LN10@stbi__jpeg

; 1596 :         return -1;

  0018e	b8 ff ff ff ff	 mov	 eax, -1
  00193	e9 52 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 1597 : 
; 1598 :     // convert the huffman code to the symbol id
; 1599 :     c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  00198	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0019d	2b 45 44	 sub	 eax, DWORD PTR k$[rbp]
  001a0	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  001a7	48 89 8d 38 01
	00 00		 mov	 QWORD PTR tv233[rbp], rcx
  001ae	0f b6 c8	 movzx	 ecx, al
  001b1	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR tv233[rbp]
  001b8	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  001be	d3 e8		 shr	 eax, cl
  001c0	48 63 4d 44	 movsxd	 rcx, DWORD PTR k$[rbp]
  001c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  001cb	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  001ce	48 63 4d 44	 movsxd	 rcx, DWORD PTR k$[rbp]
  001d2	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  001d9	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  001e0	89 45 24	 mov	 DWORD PTR c$[rbp], eax

; 1600 :     if (c < 0 || c >= 256) // symbol id out of bounds!

  001e3	83 7d 24 00	 cmp	 DWORD PTR c$[rbp], 0
  001e7	7c 09		 jl	 SHORT $LN12@stbi__jpeg
  001e9	81 7d 24 00 01
	00 00		 cmp	 DWORD PTR c$[rbp], 256	; 00000100H
  001f0	7c 0a		 jl	 SHORT $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 1601 :         return -1;

  001f2	b8 ff ff ff ff	 mov	 eax, -1
  001f7	e9 ee 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN11@stbi__jpeg:

; 1602 :     STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  001fc	48 63 45 24	 movsxd	 rax, DWORD PTR c$[rbp]
  00200	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00207	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0020f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00214	2b c8		 sub	 ecx, eax
  00216	8b c1		 mov	 eax, ecx
  00218	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  0021f	48 89 8d 38 01
	00 00		 mov	 QWORD PTR tv242[rbp], rcx
  00226	0f b6 c8	 movzx	 ecx, al
  00229	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR tv242[rbp]
  00230	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00236	d3 e8		 shr	 eax, cl
  00238	48 63 4d 24	 movsxd	 rcx, DWORD PTR c$[rbp]
  0023c	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  00243	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00252	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00255	48 63 4d 24	 movsxd	 rcx, DWORD PTR c$[rbp]
  00259	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  00260	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00268	3b c1		 cmp	 eax, ecx
  0026a	74 1c		 je	 SHORT $LN14@stbi__jpeg
  0026c	41 b8 42 06 00
	00		 mov	 r8d, 1602		; 00000642H
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00286	33 c0		 xor	 eax, eax
$LN14@stbi__jpeg:

; 1603 : 
; 1604 :     // convert the id to a symbol
; 1605 :     j->code_bits -= k;

  00288	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0028f	8b 4d 44	 mov	 ecx, DWORD PTR k$[rbp]
  00292	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00298	2b c1		 sub	 eax, ecx
  0029a	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002a1	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1606 :     j->code_buffer <<= k;

  002a7	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  002aa	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002b1	48 89 8d 38 01
	00 00		 mov	 QWORD PTR tv253[rbp], rcx
  002b8	0f b6 c8	 movzx	 ecx, al
  002bb	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR tv253[rbp]
  002c2	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  002c8	d3 e0		 shl	 eax, cl
  002ca	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  002d1	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1607 :     return h->values[c];

  002d7	48 63 45 24	 movsxd	 rax, DWORD PTR c$[rbp]
  002db	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  002e2	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
$LN1@stbi__jpeg:

; 1608 : }

  002ea	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  002f1	5f		 pop	 rdi
  002f2	5d		 pop	 rbp
  002f3	c3		 ret	 0
stbi__jpeg_huff_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__grow_buffer_unsafe
_TEXT	SEGMENT
b$1 = 4
c$2 = 36
tv70 = 244
j$ = 288
stbi__grow_buffer_unsafe PROC				; COMDAT

; 1538 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@stbi__grow:

; 1539 :     do {
; 1540 :         unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

  0001f	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00026	83 b8 2c 48 00
	00 00		 cmp	 DWORD PTR [rax+18476], 0
  0002d	74 0c		 je	 SHORT $LN10@stbi__grow
  0002f	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv70[rbp], 0
  00039	eb 18		 jmp	 SHORT $LN11@stbi__grow
$LN10@stbi__grow:
  0003b	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	e8 00 00 00 00	 call	 stbi__get8
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	89 85 f4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
$LN11@stbi__grow:
  00053	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  00059	89 45 04	 mov	 DWORD PTR b$1[rbp], eax

; 1541 :         if (b == 0xff) {

  0005c	81 7d 04 ff 00
	00 00		 cmp	 DWORD PTR b$1[rbp], 255	; 000000ffH
  00063	75 5f		 jne	 SHORT $LN7@stbi__grow

; 1542 :             int c = stbi__get8(j->s);

  00065	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0006c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006f	e8 00 00 00 00	 call	 stbi__get8
  00074	0f b6 c0	 movzx	 eax, al
  00077	89 45 24	 mov	 DWORD PTR c$2[rbp], eax
$LN5@stbi__grow:

; 1543 :             while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

  0007a	81 7d 24 ff 00
	00 00		 cmp	 DWORD PTR c$2[rbp], 255	; 000000ffH
  00081	75 17		 jne	 SHORT $LN6@stbi__grow
  00083	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  0008a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008d	e8 00 00 00 00	 call	 stbi__get8
  00092	0f b6 c0	 movzx	 eax, al
  00095	89 45 24	 mov	 DWORD PTR c$2[rbp], eax
  00098	eb e0		 jmp	 SHORT $LN5@stbi__grow
$LN6@stbi__grow:

; 1544 :             if (c != 0) {

  0009a	83 7d 24 00	 cmp	 DWORD PTR c$2[rbp], 0
  0009e	74 24		 je	 SHORT $LN8@stbi__grow

; 1545 :                 j->marker = (unsigned char)c;

  000a0	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000a7	0f b6 4d 24	 movzx	 ecx, BYTE PTR c$2[rbp]
  000ab	88 88 28 48 00
	00		 mov	 BYTE PTR [rax+18472], cl

; 1546 :                 j->nomore = 1;

  000b1	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000b8	c7 80 2c 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18476], 1

; 1547 :                 return;

  000c2	eb 6b		 jmp	 SHORT $LN1@stbi__grow
$LN8@stbi__grow:
$LN7@stbi__grow:

; 1548 :             }
; 1549 :         }
; 1550 :         j->code_buffer |= b << (24 - j->code_bits);

  000c4	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  000cb	b9 18 00 00 00	 mov	 ecx, 24
  000d0	2b 88 24 48 00
	00		 sub	 ecx, DWORD PTR [rax+18468]
  000d6	8b c1		 mov	 eax, ecx
  000d8	0f b6 c8	 movzx	 ecx, al
  000db	8b 45 04	 mov	 eax, DWORD PTR b$1[rbp]
  000de	d3 e0		 shl	 eax, cl
  000e0	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000e7	8b 89 20 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18464]
  000ed	0b c8		 or	 ecx, eax
  000ef	8b c1		 mov	 eax, ecx
  000f1	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  000f8	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 1551 :         j->code_bits += 8;

  000fe	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00105	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0010b	83 c0 08	 add	 eax, 8
  0010e	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR j$[rbp]
  00115	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 1552 :     } while (j->code_bits <= 24);

  0011b	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR j$[rbp]
  00122	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00129	0f 8e f0 fe ff
	ff		 jle	 $LN4@stbi__grow
$LN1@stbi__grow:

; 1553 : }

  0012f	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00136	5f		 pop	 rdi
  00137	5d		 pop	 rbp
  00138	c3		 ret	 0
stbi__grow_buffer_unsafe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__build_fast_ac
_TEXT	SEGMENT
i$ = 4
fast$1 = 36
rs$2 = 68
run$3 = 100
magbits$4 = 132
len$5 = 164
k$6 = 196
m$7 = 228
tv178 = 436
tv174 = 436
fast_ac$ = 480
h$ = 488
stbi__build_fast_ac PROC				; COMDAT

; 1513 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1514 :     int i;
; 1515 :     for (i = 0; i < (1 << FAST_BITS); ++i) {

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  0002d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00030	ff c0		 inc	 eax
  00032	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__buil:
  00035	81 7d 04 00 02
	00 00		 cmp	 DWORD PTR i$[rbp], 512	; 00000200H
  0003c	0f 8d 6b 01 00
	00		 jge	 $LN3@stbi__buil

; 1516 :         stbi_uc fast = h->fast[i];

  00042	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00046	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  0004d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00051	88 45 24	 mov	 BYTE PTR fast$1[rbp], al

; 1517 :         fast_ac[i] = 0;

  00054	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00058	33 c9		 xor	 ecx, ecx
  0005a	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR fast_ac$[rbp]
  00061	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 1518 :         if (fast < 255) {

  00065	0f b6 45 24	 movzx	 eax, BYTE PTR fast$1[rbp]
  00069	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0006e	0f 8d 34 01 00
	00		 jge	 $LN5@stbi__buil

; 1519 :             int rs = h->values[fast];

  00074	0f b6 45 24	 movzx	 eax, BYTE PTR fast$1[rbp]
  00078	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  0007f	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00087	89 45 44	 mov	 DWORD PTR rs$2[rbp], eax

; 1520 :             int run = (rs >> 4) & 15;

  0008a	8b 45 44	 mov	 eax, DWORD PTR rs$2[rbp]
  0008d	c1 f8 04	 sar	 eax, 4
  00090	83 e0 0f	 and	 eax, 15
  00093	89 45 64	 mov	 DWORD PTR run$3[rbp], eax

; 1521 :             int magbits = rs & 15;

  00096	8b 45 44	 mov	 eax, DWORD PTR rs$2[rbp]
  00099	83 e0 0f	 and	 eax, 15
  0009c	89 85 84 00 00
	00		 mov	 DWORD PTR magbits$4[rbp], eax

; 1522 :             int len = h->size[fast];

  000a2	0f b6 45 24	 movzx	 eax, BYTE PTR fast$1[rbp]
  000a6	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  000ad	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  000b5	89 85 a4 00 00
	00		 mov	 DWORD PTR len$5[rbp], eax

; 1523 : 
; 1524 :             if (magbits && len + magbits <= FAST_BITS) {

  000bb	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR magbits$4[rbp], 0
  000c2	0f 84 e0 00 00
	00		 je	 $LN6@stbi__buil
  000c8	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR magbits$4[rbp]
  000ce	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR len$5[rbp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	83 f8 09	 cmp	 eax, 9
  000db	0f 8f c7 00 00
	00		 jg	 $LN6@stbi__buil

; 1525 :                 // magnitude code followed by receive_extend code
; 1526 :                 int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

  000e1	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR len$5[rbp]
  000e7	0f b6 c8	 movzx	 ecx, al
  000ea	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000ed	d3 e0		 shl	 eax, cl
  000ef	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000f4	b9 09 00 00 00	 mov	 ecx, 9
  000f9	2b 8d 84 00 00
	00		 sub	 ecx, DWORD PTR magbits$4[rbp]
  000ff	d3 f8		 sar	 eax, cl
  00101	89 85 c4 00 00
	00		 mov	 DWORD PTR k$6[rbp], eax

; 1527 :                 int m = 1 << (magbits - 1);

  00107	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR magbits$4[rbp]
  0010d	ff c8		 dec	 eax
  0010f	b9 01 00 00 00	 mov	 ecx, 1
  00114	89 8d b4 01 00
	00		 mov	 DWORD PTR tv174[rbp], ecx
  0011a	0f b6 c8	 movzx	 ecx, al
  0011d	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv174[rbp]
  00123	d3 e0		 shl	 eax, cl
  00125	89 85 e4 00 00
	00		 mov	 DWORD PTR m$7[rbp], eax

; 1528 :                 if (k < m) k += (~0U << magbits) + 1;

  0012b	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR m$7[rbp]
  00131	39 85 c4 00 00
	00		 cmp	 DWORD PTR k$6[rbp], eax
  00137	7d 2c		 jge	 SHORT $LN7@stbi__buil
  00139	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR magbits$4[rbp]
  0013f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00144	89 8d b4 01 00
	00		 mov	 DWORD PTR tv178[rbp], ecx
  0014a	0f b6 c8	 movzx	 ecx, al
  0014d	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv178[rbp]
  00153	d3 e0		 shl	 eax, cl
  00155	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR k$6[rbp]
  0015b	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  0015f	89 85 c4 00 00
	00		 mov	 DWORD PTR k$6[rbp], eax
$LN7@stbi__buil:

; 1529 :                 // if the result is small enough, we can fit it in fast_ac table
; 1530 :                 if (k >= -128 && k <= 127)

  00165	83 bd c4 00 00
	00 80		 cmp	 DWORD PTR k$6[rbp], -128 ; ffffffffffffff80H
  0016c	7c 3a		 jl	 SHORT $LN8@stbi__buil
  0016e	83 bd c4 00 00
	00 7f		 cmp	 DWORD PTR k$6[rbp], 127	; 0000007fH
  00175	7f 31		 jg	 SHORT $LN8@stbi__buil

; 1531 :                     fast_ac[i] = (stbi__int16)((k * 256) + (run * 16) + (len + magbits));

  00177	69 85 c4 00 00
	00 00 01 00 00	 imul	 eax, DWORD PTR k$6[rbp], 256 ; 00000100H
  00181	6b 4d 64 10	 imul	 ecx, DWORD PTR run$3[rbp], 16
  00185	03 c1		 add	 eax, ecx
  00187	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR magbits$4[rbp]
  0018d	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR len$5[rbp]
  00193	03 d1		 add	 edx, ecx
  00195	8b ca		 mov	 ecx, edx
  00197	03 c1		 add	 eax, ecx
  00199	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  0019d	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR fast_ac$[rbp]
  001a4	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN8@stbi__buil:
$LN6@stbi__buil:
$LN5@stbi__buil:

; 1532 :             }
; 1533 :         }
; 1534 :     }

  001a8	e9 80 fe ff ff	 jmp	 $LN2@stbi__buil
$LN3@stbi__buil:

; 1535 : }

  001ad	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  001b4	5f		 pop	 rdi
  001b5	5d		 pop	 rbp
  001b6	c3		 ret	 0
stbi__build_fast_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__build_huffman
_TEXT	SEGMENT
i$ = 4
j$ = 36
k$ = 68
code$ = 100
s$1 = 132
c$2 = 164
m$3 = 196
tv238 = 404
h$ = 448
count$ = 456
stbi__build_huffman PROC				; COMDAT

; 1466 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1467 :     int i, j, k = 0;

  00024	c7 45 44 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0

; 1468 :     unsigned int code;
; 1469 :     // build size list for each symbol (from JPEG spec)
; 1470 :     for (i = 0; i < 16; ++i) {

  0002b	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00032	eb 08		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00034	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00037	ff c0		 inc	 eax
  00039	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__buil:
  0003c	83 7d 04 10	 cmp	 DWORD PTR i$[rbp], 16
  00040	7d 61		 jge	 SHORT $LN3@stbi__buil

; 1471 :         for (j = 0; j < count[i]; ++j) {

  00042	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  00049	eb 08		 jmp	 SHORT $LN7@stbi__buil
$LN5@stbi__buil:
  0004b	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  0004e	ff c0		 inc	 eax
  00050	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN7@stbi__buil:
  00053	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00057	48 8b 8d c8 01
	00 00		 mov	 rcx, QWORD PTR count$[rbp]
  0005e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00061	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  00064	7d 3b		 jge	 SHORT $LN6@stbi__buil

; 1472 :             h->size[k++] = (stbi_uc)(i + 1);

  00066	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00069	ff c0		 inc	 eax
  0006b	48 63 4d 44	 movsxd	 rcx, DWORD PTR k$[rbp]
  0006f	48 8b 95 c0 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  00076	88 84 0a 00 05
	00 00		 mov	 BYTE PTR [rdx+rcx+1280], al
  0007d	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  00080	ff c0		 inc	 eax
  00082	89 45 44	 mov	 DWORD PTR k$[rbp], eax

; 1473 :             if (k >= 257) return stbi__err("bad size list", "Corrupt JPEG");

  00085	81 7d 44 01 01
	00 00		 cmp	 DWORD PTR k$[rbp], 257	; 00000101H
  0008c	7c 11		 jl	 SHORT $LN19@stbi__buil
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DEFOLMLB@bad?5size?5list@
  00095	e8 00 00 00 00	 call	 stbi__err
  0009a	e9 0f 02 00 00	 jmp	 $LN1@stbi__buil
$LN19@stbi__buil:

; 1474 :         }

  0009f	eb aa		 jmp	 SHORT $LN5@stbi__buil
$LN6@stbi__buil:

; 1475 :     }

  000a1	eb 91		 jmp	 SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 1476 :     h->size[k] = 0;

  000a3	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  000a7	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  000ae	c6 84 01 00 05
	00 00 00	 mov	 BYTE PTR [rcx+rax+1280], 0

; 1477 : 
; 1478 :     // compute actual symbols (from jpeg spec)
; 1479 :     code = 0;

  000b6	c7 45 64 00 00
	00 00		 mov	 DWORD PTR code$[rbp], 0

; 1480 :     k = 0;

  000bd	c7 45 44 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0

; 1481 :     for (j = 1; j <= 16; ++j) {

  000c4	c7 45 24 01 00
	00 00		 mov	 DWORD PTR j$[rbp], 1
  000cb	eb 08		 jmp	 SHORT $LN10@stbi__buil
$LN8@stbi__buil:
  000cd	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  000d0	ff c0		 inc	 eax
  000d2	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN10@stbi__buil:
  000d5	83 7d 24 10	 cmp	 DWORD PTR j$[rbp], 16
  000d9	0f 8f ca 00 00
	00		 jg	 $LN9@stbi__buil

; 1482 :         // compute delta to add to code to compute symbol id
; 1483 :         h->delta[j] = k - code;

  000df	8b 45 64	 mov	 eax, DWORD PTR code$[rbp]
  000e2	8b 4d 44	 mov	 ecx, DWORD PTR k$[rbp]
  000e5	2b c8		 sub	 ecx, eax
  000e7	8b c1		 mov	 eax, ecx
  000e9	48 63 4d 24	 movsxd	 rcx, DWORD PTR j$[rbp]
  000ed	48 8b 95 c0 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  000f4	89 84 8a 4c 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1612], eax

; 1484 :         if (h->size[k] == j) {

  000fb	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  000ff	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00106	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0010e	3b 45 24	 cmp	 eax, DWORD PTR j$[rbp]
  00111	75 67		 jne	 SHORT $LN20@stbi__buil
$LN11@stbi__buil:

; 1485 :             while (h->size[k] == j)

  00113	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  00117	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  0011e	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00126	3b 45 24	 cmp	 eax, DWORD PTR j$[rbp]
  00129	75 29		 jne	 SHORT $LN12@stbi__buil

; 1486 :                 h->code[k++] = (stbi__uint16)(code++);

  0012b	48 63 45 44	 movsxd	 rax, DWORD PTR k$[rbp]
  0012f	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00136	0f b7 55 64	 movzx	 edx, WORD PTR code$[rbp]
  0013a	66 89 94 41 00
	02 00 00	 mov	 WORD PTR [rcx+rax*2+512], dx
  00142	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  00145	ff c0		 inc	 eax
  00147	89 45 44	 mov	 DWORD PTR k$[rbp], eax
  0014a	8b 45 64	 mov	 eax, DWORD PTR code$[rbp]
  0014d	ff c0		 inc	 eax
  0014f	89 45 64	 mov	 DWORD PTR code$[rbp], eax
  00152	eb bf		 jmp	 SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 1487 :             if (code - 1 >= (1u << j)) return stbi__err("bad code lengths", "Corrupt JPEG");

  00154	8b 45 64	 mov	 eax, DWORD PTR code$[rbp]
  00157	ff c8		 dec	 eax
  00159	8b 4d 24	 mov	 ecx, DWORD PTR j$[rbp]
  0015c	ba 01 00 00 00	 mov	 edx, 1
  00161	d3 e2		 shl	 edx, cl
  00163	8b ca		 mov	 ecx, edx
  00165	3b c1		 cmp	 eax, ecx
  00167	72 11		 jb	 SHORT $LN21@stbi__buil
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
  00170	e8 00 00 00 00	 call	 stbi__err
  00175	e9 34 01 00 00	 jmp	 $LN1@stbi__buil
$LN21@stbi__buil:
$LN20@stbi__buil:

; 1488 :         }
; 1489 :         // compute largest code + 1 for this size, preshifted as needed later
; 1490 :         h->maxcode[j] = code << (16 - j);

  0017a	b8 10 00 00 00	 mov	 eax, 16
  0017f	2b 45 24	 sub	 eax, DWORD PTR j$[rbp]
  00182	0f b6 c8	 movzx	 ecx, al
  00185	8b 45 64	 mov	 eax, DWORD PTR code$[rbp]
  00188	d3 e0		 shl	 eax, cl
  0018a	48 63 4d 24	 movsxd	 rcx, DWORD PTR j$[rbp]
  0018e	48 8b 95 c0 01
	00 00		 mov	 rdx, QWORD PTR h$[rbp]
  00195	89 84 8a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1540], eax

; 1491 :         code <<= 1;

  0019c	8b 45 64	 mov	 eax, DWORD PTR code$[rbp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	89 45 64	 mov	 DWORD PTR code$[rbp], eax

; 1492 :     }

  001a4	e9 24 ff ff ff	 jmp	 $LN8@stbi__buil
$LN9@stbi__buil:

; 1493 :     h->maxcode[j] = 0xffffffff;

  001a9	48 63 45 24	 movsxd	 rax, DWORD PTR j$[rbp]
  001ad	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  001b4	c7 84 81 04 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+1540], -1 ; ffffffffH

; 1494 : 
; 1495 :     // build non-spec acceleration table; 255 is flag for not-accelerated
; 1496 :     memset(h->fast, 255, 1 << FAST_BITS);

  001bf	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR h$[rbp]
  001c6	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  001cc	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001d1	48 8b c8	 mov	 rcx, rax
  001d4	e8 00 00 00 00	 call	 memset

; 1497 :     for (i = 0; i < k; ++i) {

  001d9	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  001e0	eb 08		 jmp	 SHORT $LN15@stbi__buil
$LN13@stbi__buil:
  001e2	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001e5	ff c0		 inc	 eax
  001e7	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN15@stbi__buil:
  001ea	8b 45 44	 mov	 eax, DWORD PTR k$[rbp]
  001ed	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  001f0	0f 8d b3 00 00
	00		 jge	 $LN14@stbi__buil

; 1498 :         int s = h->size[i];

  001f6	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  001fa	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00201	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00209	89 85 84 00 00
	00		 mov	 DWORD PTR s$1[rbp], eax

; 1499 :         if (s <= FAST_BITS) {

  0020f	83 bd 84 00 00
	00 09		 cmp	 DWORD PTR s$1[rbp], 9
  00216	0f 8f 88 00 00
	00		 jg	 $LN22@stbi__buil

; 1500 :             int c = h->code[i] << (FAST_BITS - s);

  0021c	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  00220	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  00227	0f b7 84 41 00
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+512]
  0022f	b9 09 00 00 00	 mov	 ecx, 9
  00234	2b 8d 84 00 00
	00		 sub	 ecx, DWORD PTR s$1[rbp]
  0023a	d3 e0		 shl	 eax, cl
  0023c	89 85 a4 00 00
	00		 mov	 DWORD PTR c$2[rbp], eax

; 1501 :             int m = 1 << (FAST_BITS - s);

  00242	b8 09 00 00 00	 mov	 eax, 9
  00247	2b 85 84 00 00
	00		 sub	 eax, DWORD PTR s$1[rbp]
  0024d	b9 01 00 00 00	 mov	 ecx, 1
  00252	89 8d 94 01 00
	00		 mov	 DWORD PTR tv238[rbp], ecx
  00258	0f b6 c8	 movzx	 ecx, al
  0025b	8b 85 94 01 00
	00		 mov	 eax, DWORD PTR tv238[rbp]
  00261	d3 e0		 shl	 eax, cl
  00263	89 85 c4 00 00
	00		 mov	 DWORD PTR m$3[rbp], eax

; 1502 :             for (j = 0; j < m; ++j) {

  00269	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  00270	eb 08		 jmp	 SHORT $LN18@stbi__buil
$LN16@stbi__buil:
  00272	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00275	ff c0		 inc	 eax
  00277	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN18@stbi__buil:
  0027a	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR m$3[rbp]
  00280	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  00283	7d 1f		 jge	 SHORT $LN17@stbi__buil

; 1503 :                 h->fast[c + j] = (stbi_uc)i;

  00285	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00288	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR c$2[rbp]
  0028e	03 c8		 add	 ecx, eax
  00290	8b c1		 mov	 eax, ecx
  00292	48 98		 cdqe
  00294	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR h$[rbp]
  0029b	0f b6 55 04	 movzx	 edx, BYTE PTR i$[rbp]
  0029f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1504 :             }

  002a2	eb ce		 jmp	 SHORT $LN16@stbi__buil
$LN17@stbi__buil:
$LN22@stbi__buil:

; 1505 :         }
; 1506 :     }

  002a4	e9 39 ff ff ff	 jmp	 $LN13@stbi__buil
$LN14@stbi__buil:

; 1507 :     return 1;

  002a9	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__buil:

; 1508 : }

  002ae	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  002b5	5f		 pop	 rdi
  002b6	5d		 pop	 rbp
  002b7	c3		 ret	 0
stbi__build_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__convert_format16
_TEXT	SEGMENT
i$ = 4
j$ = 36
good$ = 72
src$1 = 104
dest$2 = 136
tv323 = 340
tv303 = 340
tv281 = 340
tv261 = 340
tv129 = 340
tv356 = 344
tv82 = 344
data$ = 384
img_n$ = 392
req_comp$ = 400
x$ = 408
y$ = 416
stbi__convert_format16 PROC				; COMDAT

; 1275 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1276 :     int i, j;
; 1277 :     stbi__uint16* good;
; 1278 : 
; 1279 :     if (req_comp == img_n) return data;

  0002d	8b 85 88 01 00
	00		 mov	 eax, DWORD PTR img_n$[rbp]
  00033	39 85 90 01 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  00039	75 0c		 jne	 SHORT $LN43@stbi__conv
  0003b	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00042	e9 33 0a 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1280 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  00047	83 bd 90 01 00
	00 01		 cmp	 DWORD PTR req_comp$[rbp], 1
  0004e	7c 09		 jl	 SHORT $LN59@stbi__conv
  00050	83 bd 90 01 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  00057	7e 1c		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00059	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1281 : 
; 1282 :     good = (stbi__uint16*)stbi__malloc(req_comp * x * y * 2);

  00075	8b 85 90 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0007b	0f af 85 98 01
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  00082	0f af 85 a0 01
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  00089	d1 e0		 shl	 eax, 1
  0008b	8b c0		 mov	 eax, eax
  0008d	8b c8		 mov	 ecx, eax
  0008f	e8 00 00 00 00	 call	 stbi__malloc
  00094	48 89 45 48	 mov	 QWORD PTR good$[rbp], rax

; 1283 :     if (good == NULL) {

  00098	48 83 7d 48 00	 cmp	 QWORD PTR good$[rbp], 0
  0009d	75 41		 jne	 SHORT $LN44@stbi__conv

; 1284 :         STBI_FREE(data);

  0009f	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1285 :         return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");

  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000b3	e8 00 00 00 00	 call	 stbi__err
  000b8	85 c0		 test	 eax, eax
  000ba	74 0d		 je	 SHORT $LN61@stbi__conv
  000bc	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv82[rbp], 0
  000c7	eb 0b		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000c9	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv82[rbp], 0
$LN62@stbi__conv:
  000d4	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv82[rbp]
  000db	e9 9a 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1286 :     }
; 1287 : 
; 1288 :     for (j = 0; j < (int)y; ++j) {

  000e0	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  000e7	eb 08		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000e9	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  000ec	ff c0		 inc	 eax
  000ee	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN4@stbi__conv:
  000f1	8b 85 a0 01 00
	00		 mov	 eax, DWORD PTR y$[rbp]
  000f7	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  000fa	0f 8d 69 09 00
	00		 jge	 $LN3@stbi__conv

; 1289 :         stbi__uint16* src = data + j * x * img_n;

  00100	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00103	0f af 85 98 01
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  0010a	0f af 85 88 01
	00 00		 imul	 eax, DWORD PTR img_n$[rbp]
  00111	8b c0		 mov	 eax, eax
  00113	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0011a	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0011e	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax

; 1290 :         stbi__uint16* dest = good + j * x * req_comp;

  00122	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00125	0f af 85 98 01
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  0012c	0f af 85 90 01
	00 00		 imul	 eax, DWORD PTR req_comp$[rbp]
  00133	8b c0		 mov	 eax, eax
  00135	48 8b 4d 48	 mov	 rcx, QWORD PTR good$[rbp]
  00139	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0013d	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax

; 1291 : 
; 1292 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1293 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1294 :         // convert source image with img_n components to one with req_comp components;
; 1295 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1296 :         switch (STBI__COMBO(img_n, req_comp)) {

  00144	8b 85 90 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0014a	8b 8d 88 01 00
	00		 mov	 ecx, DWORD PTR img_n$[rbp]
  00150	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  00153	89 85 54 01 00
	00		 mov	 DWORD PTR tv129[rbp], eax
  00159	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv129[rbp]
  0015f	83 e8 0a	 sub	 eax, 10
  00162	89 85 54 01 00
	00		 mov	 DWORD PTR tv129[rbp], eax
  00168	83 bd 54 01 00
	00 19		 cmp	 DWORD PTR tv129[rbp], 25
  0016f	0f 87 85 08 00
	00		 ja	 $LN57@stbi__conv
  00175	48 63 85 54 01
	00 00		 movsxd	 rax, DWORD PTR tv129[rbp]
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00183	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  0018a	48 03 c1	 add	 rax, rcx
  0018d	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1297 :             STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 0xffff; } break;

  0018f	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00195	ff c8		 dec	 eax
  00197	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0019a	eb 26		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0019c	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0019f	ff c8		 dec	 eax
  001a1	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  001a4	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  001a8	48 83 c0 02	 add	 rax, 2
  001ac	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  001b0	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  001b7	48 83 c0 04	 add	 rax, 4
  001bb	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN9@stbi__conv:
  001c2	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  001c6	7c 41		 jl	 SHORT $LN8@stbi__conv
  001c8	b8 02 00 00 00	 mov	 eax, 2
  001cd	48 6b c0 00	 imul	 rax, rax, 0
  001d1	b9 02 00 00 00	 mov	 ecx, 2
  001d6	48 6b c9 00	 imul	 rcx, rcx, 0
  001da	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  001e1	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  001e5	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  001ea	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  001ee	b8 02 00 00 00	 mov	 eax, 2
  001f3	48 6b c0 01	 imul	 rax, rax, 1
  001f7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001fc	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00203	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00207	eb 93		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  00209	e9 56 08 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1298 :             STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

  0020e	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00214	ff c8		 dec	 eax
  00216	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00219	eb 26		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  0021b	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0021e	ff c8		 dec	 eax
  00220	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00223	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00227	48 83 c0 02	 add	 rax, 2
  0022b	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  0022f	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00236	48 83 c0 06	 add	 rax, 6
  0023a	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN12@stbi__conv:
  00241	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  00245	7c 7d		 jl	 SHORT $LN11@stbi__conv
  00247	b8 02 00 00 00	 mov	 eax, 2
  0024c	48 6b c0 00	 imul	 rax, rax, 0
  00250	b9 02 00 00 00	 mov	 ecx, 2
  00255	48 6b c9 02	 imul	 rcx, rcx, 2
  00259	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00260	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00264	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00269	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0026d	b8 02 00 00 00	 mov	 eax, 2
  00272	48 6b c0 02	 imul	 rax, rax, 2
  00276	b9 02 00 00 00	 mov	 ecx, 2
  0027b	48 6b c9 01	 imul	 rcx, rcx, 1
  0027f	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00286	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0028d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00292	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00296	b8 02 00 00 00	 mov	 eax, 2
  0029b	48 6b c0 01	 imul	 rax, rax, 1
  0029f	b9 02 00 00 00	 mov	 ecx, 2
  002a4	48 6b c9 00	 imul	 rcx, rcx, 0
  002a8	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  002af	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  002b6	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  002bb	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  002bf	e9 57 ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  002c4	e9 9b 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1299 :             STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 0xffff; } break;

  002c9	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  002cf	ff c8		 dec	 eax
  002d1	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  002d4	eb 26		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002d6	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  002d9	ff c8		 dec	 eax
  002db	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  002de	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  002e2	48 83 c0 02	 add	 rax, 2
  002e6	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  002ea	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  002f1	48 83 c0 08	 add	 rax, 8
  002f5	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN15@stbi__conv:
  002fc	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  00300	0f 8c 96 00 00
	00		 jl	 $LN14@stbi__conv
  00306	b8 02 00 00 00	 mov	 eax, 2
  0030b	48 6b c0 00	 imul	 rax, rax, 0
  0030f	b9 02 00 00 00	 mov	 ecx, 2
  00314	48 6b c9 02	 imul	 rcx, rcx, 2
  00318	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0031f	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00323	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00328	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0032c	b8 02 00 00 00	 mov	 eax, 2
  00331	48 6b c0 02	 imul	 rax, rax, 2
  00335	b9 02 00 00 00	 mov	 ecx, 2
  0033a	48 6b c9 01	 imul	 rcx, rcx, 1
  0033e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00345	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0034c	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00351	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00355	b8 02 00 00 00	 mov	 eax, 2
  0035a	48 6b c0 01	 imul	 rax, rax, 1
  0035e	b9 02 00 00 00	 mov	 ecx, 2
  00363	48 6b c9 00	 imul	 rcx, rcx, 0
  00367	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0036e	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00375	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0037a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0037e	b8 02 00 00 00	 mov	 eax, 2
  00383	48 6b c0 03	 imul	 rax, rax, 3
  00387	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0038c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00393	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00397	e9 3a ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  0039c	e9 c3 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1300 :             STBI__CASE(2, 1) { dest[0] = src[0]; } break;

  003a1	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  003a7	ff c8		 dec	 eax
  003a9	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  003ac	eb 26		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  003ae	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  003b1	ff c8		 dec	 eax
  003b3	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  003b6	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  003ba	48 83 c0 04	 add	 rax, 4
  003be	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  003c2	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  003c9	48 83 c0 02	 add	 rax, 2
  003cd	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN18@stbi__conv:
  003d4	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  003d8	7c 28		 jl	 SHORT $LN17@stbi__conv
  003da	b8 02 00 00 00	 mov	 eax, 2
  003df	48 6b c0 00	 imul	 rax, rax, 0
  003e3	b9 02 00 00 00	 mov	 ecx, 2
  003e8	48 6b c9 00	 imul	 rcx, rcx, 0
  003ec	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  003f3	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  003f7	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  003fc	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00400	eb ac		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  00402	e9 5d 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1301 :             STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

  00407	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0040d	ff c8		 dec	 eax
  0040f	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00412	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  00414	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00417	ff c8		 dec	 eax
  00419	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0041c	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00420	48 83 c0 04	 add	 rax, 4
  00424	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00428	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  0042f	48 83 c0 06	 add	 rax, 6
  00433	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN21@stbi__conv:
  0043a	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0043e	7c 7d		 jl	 SHORT $LN20@stbi__conv
  00440	b8 02 00 00 00	 mov	 eax, 2
  00445	48 6b c0 00	 imul	 rax, rax, 0
  00449	b9 02 00 00 00	 mov	 ecx, 2
  0044e	48 6b c9 02	 imul	 rcx, rcx, 2
  00452	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00459	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0045d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00462	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00466	b8 02 00 00 00	 mov	 eax, 2
  0046b	48 6b c0 02	 imul	 rax, rax, 2
  0046f	b9 02 00 00 00	 mov	 ecx, 2
  00474	48 6b c9 01	 imul	 rcx, rcx, 1
  00478	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0047f	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00486	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0048b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0048f	b8 02 00 00 00	 mov	 eax, 2
  00494	48 6b c0 01	 imul	 rax, rax, 1
  00498	b9 02 00 00 00	 mov	 ecx, 2
  0049d	48 6b c9 00	 imul	 rcx, rcx, 0
  004a1	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  004a8	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  004af	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  004b4	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  004b8	e9 57 ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  004bd	e9 a2 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1302 :             STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;

  004c2	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  004c8	ff c8		 dec	 eax
  004ca	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  004cd	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  004cf	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  004d2	ff c8		 dec	 eax
  004d4	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  004d7	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  004db	48 83 c0 04	 add	 rax, 4
  004df	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  004e3	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  004ea	48 83 c0 08	 add	 rax, 8
  004ee	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN24@stbi__conv:
  004f5	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  004f9	0f 8c a3 00 00
	00		 jl	 $LN23@stbi__conv
  004ff	b8 02 00 00 00	 mov	 eax, 2
  00504	48 6b c0 00	 imul	 rax, rax, 0
  00508	b9 02 00 00 00	 mov	 ecx, 2
  0050d	48 6b c9 02	 imul	 rcx, rcx, 2
  00511	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00518	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0051c	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00521	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00525	b8 02 00 00 00	 mov	 eax, 2
  0052a	48 6b c0 02	 imul	 rax, rax, 2
  0052e	b9 02 00 00 00	 mov	 ecx, 2
  00533	48 6b c9 01	 imul	 rcx, rcx, 1
  00537	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0053e	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00545	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0054a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0054e	b8 02 00 00 00	 mov	 eax, 2
  00553	48 6b c0 01	 imul	 rax, rax, 1
  00557	b9 02 00 00 00	 mov	 ecx, 2
  0055c	48 6b c9 00	 imul	 rcx, rcx, 0
  00560	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00567	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0056e	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00573	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00577	b8 02 00 00 00	 mov	 eax, 2
  0057c	48 6b c0 01	 imul	 rax, rax, 1
  00580	b9 02 00 00 00	 mov	 ecx, 2
  00585	48 6b c9 03	 imul	 rcx, rcx, 3
  00589	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00590	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00594	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00599	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0059d	e9 2d ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  005a2	e9 bd 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1303 :             STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 0xffff; } break;

  005a7	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  005ad	ff c8		 dec	 eax
  005af	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  005b2	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  005b4	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  005b7	ff c8		 dec	 eax
  005b9	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  005bc	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  005c0	48 83 c0 06	 add	 rax, 6
  005c4	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  005c8	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  005cf	48 83 c0 08	 add	 rax, 8
  005d3	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN27@stbi__conv:
  005da	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  005de	0f 8c 90 00 00
	00		 jl	 $LN26@stbi__conv
  005e4	b8 02 00 00 00	 mov	 eax, 2
  005e9	48 6b c0 00	 imul	 rax, rax, 0
  005ed	b9 02 00 00 00	 mov	 ecx, 2
  005f2	48 6b c9 00	 imul	 rcx, rcx, 0
  005f6	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  005fd	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00601	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00606	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0060a	b8 02 00 00 00	 mov	 eax, 2
  0060f	48 6b c0 01	 imul	 rax, rax, 1
  00613	b9 02 00 00 00	 mov	 ecx, 2
  00618	48 6b c9 01	 imul	 rcx, rcx, 1
  0061c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00623	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00627	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0062c	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00630	b8 02 00 00 00	 mov	 eax, 2
  00635	48 6b c0 02	 imul	 rax, rax, 2
  00639	b9 02 00 00 00	 mov	 ecx, 2
  0063e	48 6b c9 02	 imul	 rcx, rcx, 2
  00642	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00649	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0064d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00652	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00656	b8 02 00 00 00	 mov	 eax, 2
  0065b	48 6b c0 03	 imul	 rax, rax, 3
  0065f	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00664	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0066b	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  0066f	e9 40 ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00674	e9 eb 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1304 :             STBI__CASE(3, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;

  00679	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0067f	ff c8		 dec	 eax
  00681	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00684	eb 26		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  00686	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00689	ff c8		 dec	 eax
  0068b	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0068e	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00692	48 83 c0 06	 add	 rax, 6
  00696	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  0069a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  006a1	48 83 c0 02	 add	 rax, 2
  006a5	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN30@stbi__conv:
  006ac	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  006b0	7c 65		 jl	 SHORT $LN29@stbi__conv
  006b2	b8 02 00 00 00	 mov	 eax, 2
  006b7	48 6b c0 02	 imul	 rax, rax, 2
  006bb	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  006bf	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  006c3	b9 02 00 00 00	 mov	 ecx, 2
  006c8	48 6b c9 01	 imul	 rcx, rcx, 1
  006cc	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  006d0	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  006d4	ba 02 00 00 00	 mov	 edx, 2
  006d9	48 6b d2 00	 imul	 rdx, rdx, 0
  006dd	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  006e1	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  006e6	89 95 54 01 00
	00		 mov	 DWORD PTR tv261[rbp], edx
  006ec	44 8b c0	 mov	 r8d, eax
  006ef	8b d1		 mov	 edx, ecx
  006f1	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv261[rbp]
  006f7	8b c8		 mov	 ecx, eax
  006f9	e8 00 00 00 00	 call	 stbi__compute_y_16
  006fe	b9 02 00 00 00	 mov	 ecx, 2
  00703	48 6b c9 00	 imul	 rcx, rcx, 0
  00707	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0070e	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00712	e9 6f ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  00717	e9 48 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1305 :             STBI__CASE(3, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = 0xffff; } break;

  0071c	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00722	ff c8		 dec	 eax
  00724	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00727	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  00729	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0072c	ff c8		 dec	 eax
  0072e	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00731	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00735	48 83 c0 06	 add	 rax, 6
  00739	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  0073d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00744	48 83 c0 04	 add	 rax, 4
  00748	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN33@stbi__conv:
  0074f	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  00753	7c 7e		 jl	 SHORT $LN32@stbi__conv
  00755	b8 02 00 00 00	 mov	 eax, 2
  0075a	48 6b c0 02	 imul	 rax, rax, 2
  0075e	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  00762	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00766	b9 02 00 00 00	 mov	 ecx, 2
  0076b	48 6b c9 01	 imul	 rcx, rcx, 1
  0076f	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  00773	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00777	ba 02 00 00 00	 mov	 edx, 2
  0077c	48 6b d2 00	 imul	 rdx, rdx, 0
  00780	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00784	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  00789	89 95 54 01 00
	00		 mov	 DWORD PTR tv281[rbp], edx
  0078f	44 8b c0	 mov	 r8d, eax
  00792	8b d1		 mov	 edx, ecx
  00794	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv281[rbp]
  0079a	8b c8		 mov	 ecx, eax
  0079c	e8 00 00 00 00	 call	 stbi__compute_y_16
  007a1	b9 02 00 00 00	 mov	 ecx, 2
  007a6	48 6b c9 00	 imul	 rcx, rcx, 0
  007aa	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  007b1	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  007b5	b8 02 00 00 00	 mov	 eax, 2
  007ba	48 6b c0 01	 imul	 rax, rax, 1
  007be	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  007c3	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  007ca	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  007ce	e9 56 ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  007d3	e9 8c 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1306 :             STBI__CASE(4, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;

  007d8	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  007de	ff c8		 dec	 eax
  007e0	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  007e3	eb 26		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  007e5	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  007e8	ff c8		 dec	 eax
  007ea	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  007ed	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  007f1	48 83 c0 08	 add	 rax, 8
  007f5	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  007f9	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00800	48 83 c0 02	 add	 rax, 2
  00804	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN36@stbi__conv:
  0080b	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0080f	7c 65		 jl	 SHORT $LN35@stbi__conv
  00811	b8 02 00 00 00	 mov	 eax, 2
  00816	48 6b c0 02	 imul	 rax, rax, 2
  0081a	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  0081e	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00822	b9 02 00 00 00	 mov	 ecx, 2
  00827	48 6b c9 01	 imul	 rcx, rcx, 1
  0082b	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  0082f	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00833	ba 02 00 00 00	 mov	 edx, 2
  00838	48 6b d2 00	 imul	 rdx, rdx, 0
  0083c	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00840	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  00845	89 95 54 01 00
	00		 mov	 DWORD PTR tv303[rbp], edx
  0084b	44 8b c0	 mov	 r8d, eax
  0084e	8b d1		 mov	 edx, ecx
  00850	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv303[rbp]
  00856	8b c8		 mov	 ecx, eax
  00858	e8 00 00 00 00	 call	 stbi__compute_y_16
  0085d	b9 02 00 00 00	 mov	 ecx, 2
  00862	48 6b c9 00	 imul	 rcx, rcx, 0
  00866	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0086d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00871	e9 6f ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00876	e9 e9 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1307 :             STBI__CASE(4, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = src[3]; } break;

  0087b	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00881	ff c8		 dec	 eax
  00883	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00886	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  00888	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0088b	ff c8		 dec	 eax
  0088d	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00890	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00894	48 83 c0 08	 add	 rax, 8
  00898	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  0089c	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  008a3	48 83 c0 04	 add	 rax, 4
  008a7	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN39@stbi__conv:
  008ae	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  008b2	0f 8c 8b 00 00
	00		 jl	 $LN38@stbi__conv
  008b8	b8 02 00 00 00	 mov	 eax, 2
  008bd	48 6b c0 02	 imul	 rax, rax, 2
  008c1	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  008c5	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008c9	b9 02 00 00 00	 mov	 ecx, 2
  008ce	48 6b c9 01	 imul	 rcx, rcx, 1
  008d2	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  008d6	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  008da	ba 02 00 00 00	 mov	 edx, 2
  008df	48 6b d2 00	 imul	 rdx, rdx, 0
  008e3	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  008e7	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  008ec	89 95 54 01 00
	00		 mov	 DWORD PTR tv323[rbp], edx
  008f2	44 8b c0	 mov	 r8d, eax
  008f5	8b d1		 mov	 edx, ecx
  008f7	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv323[rbp]
  008fd	8b c8		 mov	 ecx, eax
  008ff	e8 00 00 00 00	 call	 stbi__compute_y_16
  00904	b9 02 00 00 00	 mov	 ecx, 2
  00909	48 6b c9 00	 imul	 rcx, rcx, 0
  0090d	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00914	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00918	b8 02 00 00 00	 mov	 eax, 2
  0091d	48 6b c0 03	 imul	 rax, rax, 3
  00921	b9 02 00 00 00	 mov	 ecx, 2
  00926	48 6b c9 01	 imul	 rcx, rcx, 1
  0092a	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00931	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00935	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0093a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0093e	e9 45 ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  00943	e9 1c 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1308 :             STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;

  00948	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0094e	ff c8		 dec	 eax
  00950	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00953	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00955	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00958	ff c8		 dec	 eax
  0095a	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0095d	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00961	48 83 c0 08	 add	 rax, 8
  00965	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00969	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00970	48 83 c0 06	 add	 rax, 6
  00974	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN42@stbi__conv:
  0097b	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0097f	7c 77		 jl	 SHORT $LN41@stbi__conv
  00981	b8 02 00 00 00	 mov	 eax, 2
  00986	48 6b c0 00	 imul	 rax, rax, 0
  0098a	b9 02 00 00 00	 mov	 ecx, 2
  0098f	48 6b c9 00	 imul	 rcx, rcx, 0
  00993	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0099a	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0099e	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009a3	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009a7	b8 02 00 00 00	 mov	 eax, 2
  009ac	48 6b c0 01	 imul	 rax, rax, 1
  009b0	b9 02 00 00 00	 mov	 ecx, 2
  009b5	48 6b c9 01	 imul	 rcx, rcx, 1
  009b9	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  009c0	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  009c4	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009c9	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009cd	b8 02 00 00 00	 mov	 eax, 2
  009d2	48 6b c0 02	 imul	 rax, rax, 2
  009d6	b9 02 00 00 00	 mov	 ecx, 2
  009db	48 6b c9 02	 imul	 rcx, rcx, 2
  009df	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  009e6	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  009ea	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009ef	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009f3	e9 5d ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009f8	eb 6a		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1309 :         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*)stbi__errpuc("unsupported", "Unsupported format conversion");

  009fa	33 c0		 xor	 eax, eax
  009fc	85 c0		 test	 eax, eax
  009fe	75 1c		 jne	 SHORT $LN63@stbi__conv
  00a00	41 b8 1d 05 00
	00		 mov	 r8d, 1309		; 0000051dH
  00a06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00a0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00a14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a1a	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  00a1c	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00a23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00a29	48 8b 4d 48	 mov	 rcx, QWORD PTR good$[rbp]
  00a2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00a33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
  00a3a	e8 00 00 00 00	 call	 stbi__err
  00a3f	85 c0		 test	 eax, eax
  00a41	74 0d		 je	 SHORT $LN64@stbi__conv
  00a43	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv356[rbp], 0
  00a4e	eb 0b		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  00a50	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv356[rbp], 0
$LN65@stbi__conv:
  00a5b	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv356[rbp]
  00a62	eb 16		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1310 :         }
; 1311 : #undef STBI__CASE
; 1312 :     }

  00a64	e9 80 f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1313 : 
; 1314 :     STBI_FREE(data);

  00a69	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00a70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1315 :     return good;

  00a76	48 8b 45 48	 mov	 rax, QWORD PTR good$[rbp]
$LN1@stbi__conv:

; 1316 : }

  00a7a	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  00a81	5f		 pop	 rdi
  00a82	5d		 pop	 rbp
  00a83	c3		 ret	 0
$LN66@stbi__conv:
  00a84	00 00 00 00	 DD	 $LN45@stbi__conv
  00a88	00 00 00 00	 DD	 $LN46@stbi__conv
  00a8c	00 00 00 00	 DD	 $LN47@stbi__conv
  00a90	00 00 00 00	 DD	 $LN57@stbi__conv
  00a94	00 00 00 00	 DD	 $LN57@stbi__conv
  00a98	00 00 00 00	 DD	 $LN57@stbi__conv
  00a9c	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa0	00 00 00 00	 DD	 $LN48@stbi__conv
  00aa4	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa8	00 00 00 00	 DD	 $LN49@stbi__conv
  00aac	00 00 00 00	 DD	 $LN50@stbi__conv
  00ab0	00 00 00 00	 DD	 $LN57@stbi__conv
  00ab4	00 00 00 00	 DD	 $LN57@stbi__conv
  00ab8	00 00 00 00	 DD	 $LN57@stbi__conv
  00abc	00 00 00 00	 DD	 $LN57@stbi__conv
  00ac0	00 00 00 00	 DD	 $LN52@stbi__conv
  00ac4	00 00 00 00	 DD	 $LN53@stbi__conv
  00ac8	00 00 00 00	 DD	 $LN57@stbi__conv
  00acc	00 00 00 00	 DD	 $LN51@stbi__conv
  00ad0	00 00 00 00	 DD	 $LN57@stbi__conv
  00ad4	00 00 00 00	 DD	 $LN57@stbi__conv
  00ad8	00 00 00 00	 DD	 $LN57@stbi__conv
  00adc	00 00 00 00	 DD	 $LN57@stbi__conv
  00ae0	00 00 00 00	 DD	 $LN54@stbi__conv
  00ae4	00 00 00 00	 DD	 $LN55@stbi__conv
  00ae8	00 00 00 00	 DD	 $LN56@stbi__conv
stbi__convert_format16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__compute_y_16
_TEXT	SEGMENT
r$ = 224
g$ = 232
b$ = 240
stbi__compute_y_16 PROC					; COMDAT

; 1266 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1267 :     return (stbi__uint16)(((r * 77) + (g * 150) + (29 * b)) >> 8);

  00027	6b 85 e0 00 00
	00 4d		 imul	 eax, DWORD PTR r$[rbp], 77 ; 0000004dH
  0002e	69 8d e8 00 00
	00 96 00 00 00	 imul	 ecx, DWORD PTR g$[rbp], 150 ; 00000096H
  00038	03 c1		 add	 eax, ecx
  0003a	6b 8d f0 00 00
	00 1d		 imul	 ecx, DWORD PTR b$[rbp], 29
  00041	03 c1		 add	 eax, ecx
  00043	c1 f8 08	 sar	 eax, 8

; 1268 : }

  00046	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004d	5f		 pop	 rdi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
stbi__compute_y_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__convert_format
_TEXT	SEGMENT
i$ = 4
j$ = 36
good$ = 72
src$1 = 104
dest$2 = 136
tv320 = 340
tv300 = 340
tv278 = 340
tv258 = 340
tv94 = 340
tv353 = 344
tv81 = 344
data$ = 384
img_n$ = 392
req_comp$ = 400
x$ = 408
y$ = 416
stbi__convert_format PROC				; COMDAT

; 1218 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1219 :     int i, j;
; 1220 :     unsigned char* good;
; 1221 : 
; 1222 :     if (req_comp == img_n) return data;

  0002d	8b 85 88 01 00
	00		 mov	 eax, DWORD PTR img_n$[rbp]
  00033	39 85 90 01 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  00039	75 0c		 jne	 SHORT $LN43@stbi__conv
  0003b	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR data$[rbp]
  00042	e9 ff 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1223 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  00047	83 bd 90 01 00
	00 01		 cmp	 DWORD PTR req_comp$[rbp], 1
  0004e	7c 09		 jl	 SHORT $LN59@stbi__conv
  00050	83 bd 90 01 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  00057	7e 1c		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00059	41 b8 c7 04 00
	00		 mov	 r8d, 1223		; 000004c7H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1224 : 
; 1225 :     good = (unsigned char*)stbi__malloc_mad3(req_comp, x, y, 0);

  00075	45 33 c9	 xor	 r9d, r9d
  00078	44 8b 85 a0 01
	00 00		 mov	 r8d, DWORD PTR y$[rbp]
  0007f	8b 95 98 01 00
	00		 mov	 edx, DWORD PTR x$[rbp]
  00085	8b 8d 90 01 00
	00		 mov	 ecx, DWORD PTR req_comp$[rbp]
  0008b	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00090	48 89 45 48	 mov	 QWORD PTR good$[rbp], rax

; 1226 :     if (good == NULL) {

  00094	48 83 7d 48 00	 cmp	 QWORD PTR good$[rbp], 0
  00099	75 41		 jne	 SHORT $LN44@stbi__conv

; 1227 :         STBI_FREE(data);

  0009b	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1228 :         return stbi__errpuc("outofmem", "Out of memory");

  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000af	e8 00 00 00 00	 call	 stbi__err
  000b4	85 c0		 test	 eax, eax
  000b6	74 0d		 je	 SHORT $LN61@stbi__conv
  000b8	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv81[rbp], 0
  000c3	eb 0b		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000c5	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv81[rbp], 0
$LN62@stbi__conv:
  000d0	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv81[rbp]
  000d7	e9 6a 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1229 :     }
; 1230 : 
; 1231 :     for (j = 0; j < (int)y; ++j) {

  000dc	c7 45 24 00 00
	00 00		 mov	 DWORD PTR j$[rbp], 0
  000e3	eb 08		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000e5	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  000e8	ff c0		 inc	 eax
  000ea	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN4@stbi__conv:
  000ed	8b 85 a0 01 00
	00		 mov	 eax, DWORD PTR y$[rbp]
  000f3	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  000f6	0f 8d 39 09 00
	00		 jge	 $LN3@stbi__conv

; 1232 :         unsigned char* src = data + j * x * img_n;

  000fc	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  000ff	0f af 85 98 01
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  00106	0f af 85 88 01
	00 00		 imul	 eax, DWORD PTR img_n$[rbp]
  0010d	8b c0		 mov	 eax, eax
  0010f	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00116	48 03 c8	 add	 rcx, rax
  00119	48 8b c1	 mov	 rax, rcx
  0011c	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax

; 1233 :         unsigned char* dest = good + j * x * req_comp;

  00120	8b 45 24	 mov	 eax, DWORD PTR j$[rbp]
  00123	0f af 85 98 01
	00 00		 imul	 eax, DWORD PTR x$[rbp]
  0012a	0f af 85 90 01
	00 00		 imul	 eax, DWORD PTR req_comp$[rbp]
  00131	8b c0		 mov	 eax, eax
  00133	48 8b 4d 48	 mov	 rcx, QWORD PTR good$[rbp]
  00137	48 03 c8	 add	 rcx, rax
  0013a	48 8b c1	 mov	 rax, rcx
  0013d	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax

; 1234 : 
; 1235 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1236 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1237 :         // convert source image with img_n components to one with req_comp components;
; 1238 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1239 :         switch (STBI__COMBO(img_n, req_comp)) {

  00144	8b 85 90 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0014a	8b 8d 88 01 00
	00		 mov	 ecx, DWORD PTR img_n$[rbp]
  00150	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  00153	89 85 54 01 00
	00		 mov	 DWORD PTR tv94[rbp], eax
  00159	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv94[rbp]
  0015f	83 e8 0a	 sub	 eax, 10
  00162	89 85 54 01 00
	00		 mov	 DWORD PTR tv94[rbp], eax
  00168	83 bd 54 01 00
	00 19		 cmp	 DWORD PTR tv94[rbp], 25
  0016f	0f 87 51 08 00
	00		 ja	 $LN57@stbi__conv
  00175	48 63 85 54 01
	00 00		 movsxd	 rax, DWORD PTR tv94[rbp]
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00183	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  0018a	48 03 c1	 add	 rax, rcx
  0018d	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1240 :             STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 255; } break;

  0018f	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00195	ff c8		 dec	 eax
  00197	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0019a	eb 25		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0019c	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0019f	ff c8		 dec	 eax
  001a1	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  001a4	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  001a8	48 ff c0	 inc	 rax
  001ab	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  001af	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  001b6	48 83 c0 02	 add	 rax, 2
  001ba	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN9@stbi__conv:
  001c1	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  001c5	7c 3b		 jl	 SHORT $LN8@stbi__conv
  001c7	b8 01 00 00 00	 mov	 eax, 1
  001cc	48 6b c0 00	 imul	 rax, rax, 0
  001d0	b9 01 00 00 00	 mov	 ecx, 1
  001d5	48 6b c9 00	 imul	 rcx, rcx, 0
  001d9	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  001e0	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  001e4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001ec	b8 01 00 00 00	 mov	 eax, 1
  001f1	48 6b c0 01	 imul	 rax, rax, 1
  001f5	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR dest$2[rbp]
  001fc	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00200	eb 9a		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  00202	e9 29 08 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1241 :             STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

  00207	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0020d	ff c8		 dec	 eax
  0020f	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00212	eb 25		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  00214	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00217	ff c8		 dec	 eax
  00219	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0021c	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00220	48 ff c0	 inc	 rax
  00223	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00227	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  0022e	48 83 c0 03	 add	 rax, 3
  00232	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN12@stbi__conv:
  00239	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0023d	7c 7a		 jl	 SHORT $LN11@stbi__conv
  0023f	b8 01 00 00 00	 mov	 eax, 1
  00244	48 6b c0 00	 imul	 rax, rax, 0
  00248	b9 01 00 00 00	 mov	 ecx, 1
  0024d	48 6b c9 02	 imul	 rcx, rcx, 2
  00251	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00258	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0025c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00261	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00264	b8 01 00 00 00	 mov	 eax, 1
  00269	48 6b c0 02	 imul	 rax, rax, 2
  0026d	b9 01 00 00 00	 mov	 ecx, 1
  00272	48 6b c9 01	 imul	 rcx, rcx, 1
  00276	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0027d	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00284	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00289	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0028c	b8 01 00 00 00	 mov	 eax, 1
  00291	48 6b c0 01	 imul	 rax, rax, 1
  00295	b9 01 00 00 00	 mov	 ecx, 1
  0029a	48 6b c9 00	 imul	 rcx, rcx, 0
  0029e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  002a5	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  002ac	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002b1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002b4	e9 5b ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  002b9	e9 72 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1242 :             STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 255; } break;

  002be	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  002c4	ff c8		 dec	 eax
  002c6	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  002c9	eb 25		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002cb	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  002ce	ff c8		 dec	 eax
  002d0	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  002d3	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  002d7	48 ff c0	 inc	 rax
  002da	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  002de	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  002e5	48 83 c0 04	 add	 rax, 4
  002e9	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN15@stbi__conv:
  002f0	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  002f4	0f 8c 8e 00 00
	00		 jl	 $LN14@stbi__conv
  002fa	b8 01 00 00 00	 mov	 eax, 1
  002ff	48 6b c0 00	 imul	 rax, rax, 0
  00303	b9 01 00 00 00	 mov	 ecx, 1
  00308	48 6b c9 02	 imul	 rcx, rcx, 2
  0030c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00313	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00317	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0031c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	48 6b c0 02	 imul	 rax, rax, 2
  00328	b9 01 00 00 00	 mov	 ecx, 1
  0032d	48 6b c9 01	 imul	 rcx, rcx, 1
  00331	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00338	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0033f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00344	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00347	b8 01 00 00 00	 mov	 eax, 1
  0034c	48 6b c0 01	 imul	 rax, rax, 1
  00350	b9 01 00 00 00	 mov	 ecx, 1
  00355	48 6b c9 00	 imul	 rcx, rcx, 0
  00359	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00360	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00367	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0036c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0036f	b8 01 00 00 00	 mov	 eax, 1
  00374	48 6b c0 03	 imul	 rax, rax, 3
  00378	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR dest$2[rbp]
  0037f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00383	e9 43 ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  00388	e9 a3 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1243 :             STBI__CASE(2, 1) { dest[0] = src[0]; } break;

  0038d	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00393	ff c8		 dec	 eax
  00395	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00398	eb 25		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0039a	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0039d	ff c8		 dec	 eax
  0039f	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  003a2	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  003a6	48 83 c0 02	 add	 rax, 2
  003aa	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  003ae	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  003b5	48 ff c0	 inc	 rax
  003b8	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN18@stbi__conv:
  003bf	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  003c3	7c 27		 jl	 SHORT $LN17@stbi__conv
  003c5	b8 01 00 00 00	 mov	 eax, 1
  003ca	48 6b c0 00	 imul	 rax, rax, 0
  003ce	b9 01 00 00 00	 mov	 ecx, 1
  003d3	48 6b c9 00	 imul	 rcx, rcx, 0
  003d7	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  003de	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  003e2	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  003e7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003ea	eb ae		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003ec	e9 3f 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1244 :             STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

  003f1	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  003f7	ff c8		 dec	 eax
  003f9	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  003fc	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003fe	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00401	ff c8		 dec	 eax
  00403	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00406	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  0040a	48 83 c0 02	 add	 rax, 2
  0040e	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00412	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00419	48 83 c0 03	 add	 rax, 3
  0041d	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN21@stbi__conv:
  00424	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  00428	7c 7a		 jl	 SHORT $LN20@stbi__conv
  0042a	b8 01 00 00 00	 mov	 eax, 1
  0042f	48 6b c0 00	 imul	 rax, rax, 0
  00433	b9 01 00 00 00	 mov	 ecx, 1
  00438	48 6b c9 02	 imul	 rcx, rcx, 2
  0043c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00443	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00447	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0044c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0044f	b8 01 00 00 00	 mov	 eax, 1
  00454	48 6b c0 02	 imul	 rax, rax, 2
  00458	b9 01 00 00 00	 mov	 ecx, 1
  0045d	48 6b c9 01	 imul	 rcx, rcx, 1
  00461	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00468	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0046f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00474	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	48 6b c0 01	 imul	 rax, rax, 1
  00480	b9 01 00 00 00	 mov	 ecx, 1
  00485	48 6b c9 00	 imul	 rcx, rcx, 0
  00489	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00490	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00497	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0049c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0049f	e9 5a ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  004a4	e9 87 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1245 :             STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;

  004a9	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  004af	ff c8		 dec	 eax
  004b1	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  004b4	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  004b6	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  004b9	ff c8		 dec	 eax
  004bb	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  004be	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  004c2	48 83 c0 02	 add	 rax, 2
  004c6	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  004ca	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  004d1	48 83 c0 04	 add	 rax, 4
  004d5	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN24@stbi__conv:
  004dc	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  004e0	0f 8c 9f 00 00
	00		 jl	 $LN23@stbi__conv
  004e6	b8 01 00 00 00	 mov	 eax, 1
  004eb	48 6b c0 00	 imul	 rax, rax, 0
  004ef	b9 01 00 00 00	 mov	 ecx, 1
  004f4	48 6b c9 02	 imul	 rcx, rcx, 2
  004f8	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  004ff	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00503	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00508	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0050b	b8 01 00 00 00	 mov	 eax, 1
  00510	48 6b c0 02	 imul	 rax, rax, 2
  00514	b9 01 00 00 00	 mov	 ecx, 1
  00519	48 6b c9 01	 imul	 rcx, rcx, 1
  0051d	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00524	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  0052b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00530	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00533	b8 01 00 00 00	 mov	 eax, 1
  00538	48 6b c0 01	 imul	 rax, rax, 1
  0053c	b9 01 00 00 00	 mov	 ecx, 1
  00541	48 6b c9 00	 imul	 rcx, rcx, 0
  00545	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0054c	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR dest$2[rbp]
  00553	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00558	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0055b	b8 01 00 00 00	 mov	 eax, 1
  00560	48 6b c0 01	 imul	 rax, rax, 1
  00564	b9 01 00 00 00	 mov	 ecx, 1
  00569	48 6b c9 03	 imul	 rcx, rcx, 3
  0056d	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00574	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00578	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0057d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00580	e9 31 ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00585	e9 a6 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1246 :             STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 255; } break;

  0058a	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00590	ff c8		 dec	 eax
  00592	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00595	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  00597	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0059a	ff c8		 dec	 eax
  0059c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0059f	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  005a3	48 83 c0 03	 add	 rax, 3
  005a7	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  005ab	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  005b2	48 83 c0 04	 add	 rax, 4
  005b6	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN27@stbi__conv:
  005bd	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  005c1	0f 8c 88 00 00
	00		 jl	 $LN26@stbi__conv
  005c7	b8 01 00 00 00	 mov	 eax, 1
  005cc	48 6b c0 00	 imul	 rax, rax, 0
  005d0	b9 01 00 00 00	 mov	 ecx, 1
  005d5	48 6b c9 00	 imul	 rcx, rcx, 0
  005d9	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  005e0	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  005e4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005ec	b8 01 00 00 00	 mov	 eax, 1
  005f1	48 6b c0 01	 imul	 rax, rax, 1
  005f5	b9 01 00 00 00	 mov	 ecx, 1
  005fa	48 6b c9 01	 imul	 rcx, rcx, 1
  005fe	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00605	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00609	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0060e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00611	b8 01 00 00 00	 mov	 eax, 1
  00616	48 6b c0 02	 imul	 rax, rax, 2
  0061a	b9 01 00 00 00	 mov	 ecx, 1
  0061f	48 6b c9 02	 imul	 rcx, rcx, 2
  00623	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0062a	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0062e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00633	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00636	b8 01 00 00 00	 mov	 eax, 1
  0063b	48 6b c0 03	 imul	 rax, rax, 3
  0063f	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR dest$2[rbp]
  00646	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0064a	e9 48 ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  0064f	e9 dc 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1247 :             STBI__CASE(3, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;

  00654	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0065a	ff c8		 dec	 eax
  0065c	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0065f	eb 25		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  00661	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00664	ff c8		 dec	 eax
  00666	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00669	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  0066d	48 83 c0 03	 add	 rax, 3
  00671	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00675	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  0067c	48 ff c0	 inc	 rax
  0067f	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN30@stbi__conv:
  00686	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0068a	7c 64		 jl	 SHORT $LN29@stbi__conv
  0068c	b8 01 00 00 00	 mov	 eax, 1
  00691	48 6b c0 02	 imul	 rax, rax, 2
  00695	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  00699	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0069d	b9 01 00 00 00	 mov	 ecx, 1
  006a2	48 6b c9 01	 imul	 rcx, rcx, 1
  006a6	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  006aa	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006ae	ba 01 00 00 00	 mov	 edx, 1
  006b3	48 6b d2 00	 imul	 rdx, rdx, 0
  006b7	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  006bb	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  006c0	89 95 54 01 00
	00		 mov	 DWORD PTR tv258[rbp], edx
  006c6	44 8b c0	 mov	 r8d, eax
  006c9	8b d1		 mov	 edx, ecx
  006cb	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv258[rbp]
  006d1	8b c8		 mov	 ecx, eax
  006d3	e8 00 00 00 00	 call	 stbi__compute_y
  006d8	b9 01 00 00 00	 mov	 ecx, 1
  006dd	48 6b c9 00	 imul	 rcx, rcx, 0
  006e1	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  006e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006eb	e9 71 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006f0	e9 3b 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1248 :             STBI__CASE(3, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = 255; } break;

  006f5	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  006fb	ff c8		 dec	 eax
  006fd	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00700	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  00702	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00705	ff c8		 dec	 eax
  00707	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0070a	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  0070e	48 83 c0 03	 add	 rax, 3
  00712	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00716	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  0071d	48 83 c0 02	 add	 rax, 2
  00721	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN33@stbi__conv:
  00728	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0072c	7c 78		 jl	 SHORT $LN32@stbi__conv
  0072e	b8 01 00 00 00	 mov	 eax, 1
  00733	48 6b c0 02	 imul	 rax, rax, 2
  00737	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  0073b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0073f	b9 01 00 00 00	 mov	 ecx, 1
  00744	48 6b c9 01	 imul	 rcx, rcx, 1
  00748	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  0074c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00750	ba 01 00 00 00	 mov	 edx, 1
  00755	48 6b d2 00	 imul	 rdx, rdx, 0
  00759	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0075d	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00762	89 95 54 01 00
	00		 mov	 DWORD PTR tv278[rbp], edx
  00768	44 8b c0	 mov	 r8d, eax
  0076b	8b d1		 mov	 edx, ecx
  0076d	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv278[rbp]
  00773	8b c8		 mov	 ecx, eax
  00775	e8 00 00 00 00	 call	 stbi__compute_y
  0077a	b9 01 00 00 00	 mov	 ecx, 1
  0077f	48 6b c9 00	 imul	 rcx, rcx, 0
  00783	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0078a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0078d	b8 01 00 00 00	 mov	 eax, 1
  00792	48 6b c0 01	 imul	 rax, rax, 1
  00796	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR dest$2[rbp]
  0079d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  007a1	e9 5c ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  007a6	e9 85 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1249 :             STBI__CASE(4, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;

  007ab	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  007b1	ff c8		 dec	 eax
  007b3	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  007b6	eb 25		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  007b8	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  007bb	ff c8		 dec	 eax
  007bd	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  007c0	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  007c4	48 83 c0 04	 add	 rax, 4
  007c8	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  007cc	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  007d3	48 ff c0	 inc	 rax
  007d6	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN36@stbi__conv:
  007dd	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  007e1	7c 64		 jl	 SHORT $LN35@stbi__conv
  007e3	b8 01 00 00 00	 mov	 eax, 1
  007e8	48 6b c0 02	 imul	 rax, rax, 2
  007ec	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  007f0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007f4	b9 01 00 00 00	 mov	 ecx, 1
  007f9	48 6b c9 01	 imul	 rcx, rcx, 1
  007fd	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  00801	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00805	ba 01 00 00 00	 mov	 edx, 1
  0080a	48 6b d2 00	 imul	 rdx, rdx, 0
  0080e	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00812	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00817	89 95 54 01 00
	00		 mov	 DWORD PTR tv300[rbp], edx
  0081d	44 8b c0	 mov	 r8d, eax
  00820	8b d1		 mov	 edx, ecx
  00822	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv300[rbp]
  00828	8b c8		 mov	 ecx, eax
  0082a	e8 00 00 00 00	 call	 stbi__compute_y
  0082f	b9 01 00 00 00	 mov	 ecx, 1
  00834	48 6b c9 00	 imul	 rcx, rcx, 0
  00838	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0083f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00842	e9 71 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00847	e9 e4 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1250 :             STBI__CASE(4, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = src[3]; } break;

  0084c	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  00852	ff c8		 dec	 eax
  00854	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00857	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  00859	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0085c	ff c8		 dec	 eax
  0085e	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00861	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00865	48 83 c0 04	 add	 rax, 4
  00869	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  0086d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  00874	48 83 c0 02	 add	 rax, 2
  00878	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN39@stbi__conv:
  0087f	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  00883	0f 8c 89 00 00
	00		 jl	 $LN38@stbi__conv
  00889	b8 01 00 00 00	 mov	 eax, 1
  0088e	48 6b c0 02	 imul	 rax, rax, 2
  00892	48 8b 4d 68	 mov	 rcx, QWORD PTR src$1[rbp]
  00896	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0089a	b9 01 00 00 00	 mov	 ecx, 1
  0089f	48 6b c9 01	 imul	 rcx, rcx, 1
  008a3	48 8b 55 68	 mov	 rdx, QWORD PTR src$1[rbp]
  008a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  008ab	ba 01 00 00 00	 mov	 edx, 1
  008b0	48 6b d2 00	 imul	 rdx, rdx, 0
  008b4	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  008b8	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  008bd	89 95 54 01 00
	00		 mov	 DWORD PTR tv320[rbp], edx
  008c3	44 8b c0	 mov	 r8d, eax
  008c6	8b d1		 mov	 edx, ecx
  008c8	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv320[rbp]
  008ce	8b c8		 mov	 ecx, eax
  008d0	e8 00 00 00 00	 call	 stbi__compute_y
  008d5	b9 01 00 00 00	 mov	 ecx, 1
  008da	48 6b c9 00	 imul	 rcx, rcx, 0
  008de	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  008e5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008e8	b8 01 00 00 00	 mov	 eax, 1
  008ed	48 6b c0 03	 imul	 rax, rax, 3
  008f1	b9 01 00 00 00	 mov	 ecx, 1
  008f6	48 6b c9 01	 imul	 rcx, rcx, 1
  008fa	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00901	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00905	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0090a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0090d	e9 47 ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  00912	e9 19 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1251 :             STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;

  00917	8b 85 98 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  0091d	ff c8		 dec	 eax
  0091f	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  00922	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00924	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00927	ff c8		 dec	 eax
  00929	89 45 04	 mov	 DWORD PTR i$[rbp], eax
  0092c	48 8b 45 68	 mov	 rax, QWORD PTR src$1[rbp]
  00930	48 83 c0 04	 add	 rax, 4
  00934	48 89 45 68	 mov	 QWORD PTR src$1[rbp], rax
  00938	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR dest$2[rbp]
  0093f	48 83 c0 03	 add	 rax, 3
  00943	48 89 85 88 00
	00 00		 mov	 QWORD PTR dest$2[rbp], rax
$LN42@stbi__conv:
  0094a	83 7d 04 00	 cmp	 DWORD PTR i$[rbp], 0
  0094e	7c 74		 jl	 SHORT $LN41@stbi__conv
  00950	b8 01 00 00 00	 mov	 eax, 1
  00955	48 6b c0 00	 imul	 rax, rax, 0
  00959	b9 01 00 00 00	 mov	 ecx, 1
  0095e	48 6b c9 00	 imul	 rcx, rcx, 0
  00962	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  00969	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  0096d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00972	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00975	b8 01 00 00 00	 mov	 eax, 1
  0097a	48 6b c0 01	 imul	 rax, rax, 1
  0097e	b9 01 00 00 00	 mov	 ecx, 1
  00983	48 6b c9 01	 imul	 rcx, rcx, 1
  00987	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  0098e	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  00992	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00997	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0099a	b8 01 00 00 00	 mov	 eax, 1
  0099f	48 6b c0 02	 imul	 rax, rax, 2
  009a3	b9 01 00 00 00	 mov	 ecx, 1
  009a8	48 6b c9 02	 imul	 rcx, rcx, 2
  009ac	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR dest$2[rbp]
  009b3	4c 8b 45 68	 mov	 r8, QWORD PTR src$1[rbp]
  009b7	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  009bc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  009bf	e9 60 ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009c4	eb 6a		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1252 :         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

  009c6	33 c0		 xor	 eax, eax
  009c8	85 c0		 test	 eax, eax
  009ca	75 1c		 jne	 SHORT $LN63@stbi__conv
  009cc	41 b8 e4 04 00
	00		 mov	 r8d, 1252		; 000004e4H
  009d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  009d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  009e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009e6	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  009e8	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  009ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009f5	48 8b 4d 48	 mov	 rcx, QWORD PTR good$[rbp]
  009f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
  00a06	e8 00 00 00 00	 call	 stbi__err
  00a0b	85 c0		 test	 eax, eax
  00a0d	74 0d		 je	 SHORT $LN64@stbi__conv
  00a0f	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv353[rbp], 0
  00a1a	eb 0b		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  00a1c	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv353[rbp], 0
$LN65@stbi__conv:
  00a27	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv353[rbp]
  00a2e	eb 16		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1253 :         }
; 1254 : #undef STBI__CASE
; 1255 :     }

  00a30	e9 b0 f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1256 : 
; 1257 :     STBI_FREE(data);

  00a35	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00a3c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1258 :     return good;

  00a42	48 8b 45 48	 mov	 rax, QWORD PTR good$[rbp]
$LN1@stbi__conv:

; 1259 : }

  00a46	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  00a4d	5f		 pop	 rdi
  00a4e	5d		 pop	 rbp
  00a4f	c3		 ret	 0
$LN66@stbi__conv:
  00a50	00 00 00 00	 DD	 $LN45@stbi__conv
  00a54	00 00 00 00	 DD	 $LN46@stbi__conv
  00a58	00 00 00 00	 DD	 $LN47@stbi__conv
  00a5c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a60	00 00 00 00	 DD	 $LN57@stbi__conv
  00a64	00 00 00 00	 DD	 $LN57@stbi__conv
  00a68	00 00 00 00	 DD	 $LN57@stbi__conv
  00a6c	00 00 00 00	 DD	 $LN48@stbi__conv
  00a70	00 00 00 00	 DD	 $LN57@stbi__conv
  00a74	00 00 00 00	 DD	 $LN49@stbi__conv
  00a78	00 00 00 00	 DD	 $LN50@stbi__conv
  00a7c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a80	00 00 00 00	 DD	 $LN57@stbi__conv
  00a84	00 00 00 00	 DD	 $LN57@stbi__conv
  00a88	00 00 00 00	 DD	 $LN57@stbi__conv
  00a8c	00 00 00 00	 DD	 $LN52@stbi__conv
  00a90	00 00 00 00	 DD	 $LN53@stbi__conv
  00a94	00 00 00 00	 DD	 $LN57@stbi__conv
  00a98	00 00 00 00	 DD	 $LN51@stbi__conv
  00a9c	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa0	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa4	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa8	00 00 00 00	 DD	 $LN57@stbi__conv
  00aac	00 00 00 00	 DD	 $LN54@stbi__conv
  00ab0	00 00 00 00	 DD	 $LN55@stbi__conv
  00ab4	00 00 00 00	 DD	 $LN56@stbi__conv
stbi__convert_format ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__compute_y
_TEXT	SEGMENT
r$ = 224
g$ = 232
b$ = 240
stbi__compute_y PROC					; COMDAT

; 1209 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1210 :     return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);

  00027	6b 85 e0 00 00
	00 4d		 imul	 eax, DWORD PTR r$[rbp], 77 ; 0000004dH
  0002e	69 8d e8 00 00
	00 96 00 00 00	 imul	 ecx, DWORD PTR g$[rbp], 150 ; 00000096H
  00038	03 c1		 add	 eax, ecx
  0003a	6b 8d f0 00 00
	00 1d		 imul	 ecx, DWORD PTR b$[rbp], 29
  00041	03 c1		 add	 eax, ecx
  00043	c1 f8 08	 sar	 eax, 8

; 1211 : }

  00046	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004d	5f		 pop	 rdi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
stbi__compute_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get32le
_TEXT	SEGMENT
z$ = 4
s$ = 256
stbi__get32le PROC					; COMDAT

; 1185 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1186 :     stbi__uint32 z = stbi__get16le(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get16le
  0002b	89 45 04	 mov	 DWORD PTR z$[rbp], eax

; 1187 :     z += (stbi__uint32)stbi__get16le(s) << 16;

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__get16le
  0003a	c1 e0 10	 shl	 eax, 16
  0003d	8b 4d 04	 mov	 ecx, DWORD PTR z$[rbp]
  00040	03 c8		 add	 ecx, eax
  00042	8b c1		 mov	 eax, ecx
  00044	89 45 04	 mov	 DWORD PTR z$[rbp], eax

; 1188 :     return z;

  00047	8b 45 04	 mov	 eax, DWORD PTR z$[rbp]

; 1189 : }

  0004a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
stbi__get32le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get16le
_TEXT	SEGMENT
z$ = 4
s$ = 256
stbi__get16le PROC					; COMDAT

; 1177 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1178 :     int z = stbi__get8(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get8
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	89 45 04	 mov	 DWORD PTR z$[rbp], eax

; 1179 :     return z + (stbi__get8(s) << 8);

  00031	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00038	e8 00 00 00 00	 call	 stbi__get8
  0003d	0f b6 c0	 movzx	 eax, al
  00040	c1 e0 08	 shl	 eax, 8
  00043	8b 4d 04	 mov	 ecx, DWORD PTR z$[rbp]
  00046	03 c8		 add	 ecx, eax
  00048	8b c1		 mov	 eax, ecx

; 1180 : }

  0004a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
stbi__get16le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get32be
_TEXT	SEGMENT
z$ = 4
tv66 = 212
s$ = 256
stbi__get32be PROC					; COMDAT

; 1167 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1168 :     stbi__uint32 z = stbi__get16be(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get16be
  0002b	89 45 04	 mov	 DWORD PTR z$[rbp], eax

; 1169 :     return (z << 16) + stbi__get16be(s);

  0002e	8b 45 04	 mov	 eax, DWORD PTR z$[rbp]
  00031	c1 e0 10	 shl	 eax, 16
  00034	89 85 d4 00 00
	00		 mov	 DWORD PTR tv66[rbp], eax
  0003a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00041	e8 00 00 00 00	 call	 stbi__get16be
  00046	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv66[rbp]
  0004c	03 c8		 add	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx

; 1170 : }

  00050	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00057	5f		 pop	 rdi
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
stbi__get32be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get16be
_TEXT	SEGMENT
z$ = 4
tv67 = 212
s$ = 256
stbi__get16be PROC					; COMDAT

; 1157 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1158 :     int z = stbi__get8(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get8
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	89 45 04	 mov	 DWORD PTR z$[rbp], eax

; 1159 :     return (z << 8) + stbi__get8(s);

  00031	8b 45 04	 mov	 eax, DWORD PTR z$[rbp]
  00034	c1 e0 08	 shl	 eax, 8
  00037	89 85 d4 00 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  0003d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00044	e8 00 00 00 00	 call	 stbi__get8
  00049	0f b6 c0	 movzx	 eax, al
  0004c	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv67[rbp]
  00052	03 c8		 add	 ecx, eax
  00054	8b c1		 mov	 eax, ecx

; 1160 : }

  00056	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005d	5f		 pop	 rdi
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
stbi__get16be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__getn
_TEXT	SEGMENT
blen$1 = 4
res$2 = 36
count$3 = 68
tv87 = 276
s$ = 320
buffer$ = 328
n$ = 336
stbi__getn PROC						; COMDAT

; 1128 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1129 :     if (s->io.read) {

  00029	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00030	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00035	0f 84 e0 00 00
	00		 je	 $LN2@stbi__getn

; 1130 :         int blen = (int)(s->img_buffer_end - s->img_buffer);

  0003b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00042	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00049	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00050	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00057	48 2b c1	 sub	 rax, rcx
  0005a	89 45 04	 mov	 DWORD PTR blen$1[rbp], eax

; 1131 :         if (blen < n) {

  0005d	8b 85 50 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00063	39 45 04	 cmp	 DWORD PTR blen$1[rbp], eax
  00066	0f 8d af 00 00
	00		 jge	 $LN3@stbi__getn

; 1132 :             int res, count;
; 1133 : 
; 1134 :             memcpy(buffer, s->img_buffer, blen);

  0006c	48 63 45 04	 movsxd	 rax, DWORD PTR blen$1[rbp]
  00070	4c 8b c0	 mov	 r8, rax
  00073	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0007a	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  00081	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00088	e8 00 00 00 00	 call	 memcpy

; 1135 : 
; 1136 :             count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);

  0008d	8b 45 04	 mov	 eax, DWORD PTR blen$1[rbp]
  00090	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00096	2b c8		 sub	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	48 63 4d 04	 movsxd	 rcx, DWORD PTR blen$1[rbp]
  0009e	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	44 8b c0	 mov	 r8d, eax
  000ae	48 8b d1	 mov	 rdx, rcx
  000b1	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000b8	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000bc	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000c3	ff 50 10	 call	 QWORD PTR [rax+16]
  000c6	89 45 44	 mov	 DWORD PTR count$3[rbp], eax

; 1137 :             res = (count == (n - blen));

  000c9	8b 45 04	 mov	 eax, DWORD PTR blen$1[rbp]
  000cc	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  000d2	2b c8		 sub	 ecx, eax
  000d4	8b c1		 mov	 eax, ecx
  000d6	39 45 44	 cmp	 DWORD PTR count$3[rbp], eax
  000d9	75 0c		 jne	 SHORT $LN7@stbi__getn
  000db	c7 85 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv87[rbp], 1
  000e5	eb 0a		 jmp	 SHORT $LN8@stbi__getn
$LN7@stbi__getn:
  000e7	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv87[rbp], 0
$LN8@stbi__getn:
  000f1	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv87[rbp]
  000f7	89 45 24	 mov	 DWORD PTR res$2[rbp], eax

; 1138 :             s->img_buffer = s->img_buffer_end;

  000fa	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00101	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00108	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0010f	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1139 :             return res;

  00116	8b 45 24	 mov	 eax, DWORD PTR res$2[rbp]
  00119	eb 77		 jmp	 SHORT $LN1@stbi__getn
$LN3@stbi__getn:
$LN2@stbi__getn:

; 1140 :         }
; 1141 :     }
; 1142 : 
; 1143 :     if (s->img_buffer + n <= s->img_buffer_end) {

  0011b	48 63 85 50 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00122	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00129	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  00130	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00137	48 3b 81 c8 00
	00 00		 cmp	 rax, QWORD PTR [rcx+200]
  0013e	77 50		 ja	 SHORT $LN4@stbi__getn

; 1144 :         memcpy(buffer, s->img_buffer, n);

  00140	48 63 85 50 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00147	4c 8b c0	 mov	 r8, rax
  0014a	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00151	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  00158	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  0015f	e8 00 00 00 00	 call	 memcpy

; 1145 :         s->img_buffer += n;

  00164	48 63 85 50 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  0016b	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00172	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  00179	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00180	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1146 :         return 1;

  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	eb 04		 jmp	 SHORT $LN1@stbi__getn

; 1147 :     }

  0018e	eb 02		 jmp	 SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1148 :     else
; 1149 :         return 0;

  00190	33 c0		 xor	 eax, eax
$LN5@stbi__getn:
$LN1@stbi__getn:

; 1150 : }

  00192	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00199	5f		 pop	 rdi
  0019a	5d		 pop	 rbp
  0019b	c3		 ret	 0
stbi__getn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__skip
_TEXT	SEGMENT
blen$1 = 4
s$ = 256
n$ = 264
stbi__skip PROC						; COMDAT

; 1106 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1107 :     if (n == 0) return;  // already there!

  00023	83 bd 08 01 00
	00 00		 cmp	 DWORD PTR n$[rbp], 0
  0002a	75 05		 jne	 SHORT $LN2@stbi__skip
  0002c	e9 ca 00 00 00	 jmp	 $LN1@stbi__skip
$LN2@stbi__skip:

; 1108 :     if (n < 0) {

  00031	83 bd 08 01 00
	00 00		 cmp	 DWORD PTR n$[rbp], 0
  00038	7d 21		 jge	 SHORT $LN3@stbi__skip

; 1109 :         s->img_buffer = s->img_buffer_end;

  0003a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00041	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00048	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0004f	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1110 :         return;

  00056	e9 a0 00 00 00	 jmp	 $LN1@stbi__skip
$LN3@stbi__skip:

; 1111 :     }
; 1112 :     if (s->io.read) {

  0005b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00062	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00067	74 6f		 je	 SHORT $LN4@stbi__skip

; 1113 :         int blen = (int)(s->img_buffer_end - s->img_buffer);

  00069	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00070	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00077	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  0007e	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00085	48 2b c1	 sub	 rax, rcx
  00088	89 45 04	 mov	 DWORD PTR blen$1[rbp], eax

; 1114 :         if (blen < n) {

  0008b	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00091	39 45 04	 cmp	 DWORD PTR blen$1[rbp], eax
  00094	7d 42		 jge	 SHORT $LN5@stbi__skip

; 1115 :             s->img_buffer = s->img_buffer_end;

  00096	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0009d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a4	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000ab	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1116 :             (s->io.skip)(s->io_user_data, n - blen);

  000b2	8b 45 04	 mov	 eax, DWORD PTR blen$1[rbp]
  000b5	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  000bb	2b c8		 sub	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	8b d0		 mov	 edx, eax
  000c1	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000c8	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000cc	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000d3	ff 50 18	 call	 QWORD PTR [rax+24]

; 1117 :             return;

  000d6	eb 23		 jmp	 SHORT $LN1@stbi__skip
$LN5@stbi__skip:
$LN4@stbi__skip:

; 1118 :         }
; 1119 :     }
; 1120 :     s->img_buffer += n;

  000d8	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000df	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000e6	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  000ed	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN1@stbi__skip:

; 1121 : }

  000fb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00102	5f		 pop	 rdi
  00103	5d		 pop	 rbp
  00104	c3		 ret	 0
stbi__skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__at_eof
_TEXT	SEGMENT
tv76 = 192
s$ = 240
stbi__at_eof PROC					; COMDAT

; 1090 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1091 :     if (s->io.read) {

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00026	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002b	74 31		 je	 SHORT $LN2@stbi__at_e

; 1092 :         if (!(s->io.eof)(s->io_user_data)) return 0;

  0002d	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00034	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00038	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0003f	ff 50 20	 call	 QWORD PTR [rax+32]
  00042	85 c0		 test	 eax, eax
  00044	75 04		 jne	 SHORT $LN3@stbi__at_e
  00046	33 c0		 xor	 eax, eax
  00048	eb 4e		 jmp	 SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1093 :         // if feof() is true, check if buffer = end
; 1094 :         // special case: we've only got the special 0 character at the end
; 1095 :         if (s->read_from_callbacks == 0) return 1;

  0004a	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00051	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00055	75 07		 jne	 SHORT $LN4@stbi__at_e
  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	eb 3a		 jmp	 SHORT $LN1@stbi__at_e
$LN4@stbi__at_e:
$LN2@stbi__at_e:

; 1096 :     }
; 1097 : 
; 1098 :     return s->img_buffer >= s->img_buffer_end;

  0005e	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00065	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00073	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0007a	72 0c		 jb	 SHORT $LN6@stbi__at_e
  0007c	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv76[rbp], 1
  00086	eb 0a		 jmp	 SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
  00088	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv76[rbp], 0
$LN7@stbi__at_e:
  00092	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv76[rbp]
$LN1@stbi__at_e:

; 1099 : }

  00098	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0009f	5f		 pop	 rdi
  000a0	5d		 pop	 rbp
  000a1	c3		 ret	 0
stbi__at_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__get8
_TEXT	SEGMENT
tv81 = 192
tv72 = 192
s$ = 240
stbi__get8 PROC						; COMDAT

; 1076 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1077 :     if (s->img_buffer < s->img_buffer_end)

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00026	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00034	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0003b	73 3f		 jae	 SHORT $LN2@stbi__get8

; 1078 :         return *s->img_buffer++;

  0003d	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00044	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	88 85 c0 00 00
	00		 mov	 BYTE PTR tv72[rbp], al
  00054	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0005b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00062	48 ff c0	 inc	 rax
  00065	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00073	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv72[rbp]
  0007a	eb 5a		 jmp	 SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1079 :     if (s->read_from_callbacks) {

  0007c	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00083	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00087	74 4b		 je	 SHORT $LN3@stbi__get8

; 1080 :         stbi__refill_buffer(s);

  00089	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00090	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1081 :         return *s->img_buffer++;

  00095	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0009c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a6	88 85 c0 00 00
	00		 mov	 BYTE PTR tv81[rbp], al
  000ac	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000b3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ba	48 ff c0	 inc	 rax
  000bd	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000cb	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv81[rbp]
  000d2	eb 02		 jmp	 SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1082 :     }
; 1083 :     return 0;

  000d4	32 c0		 xor	 al, al
$LN1@stbi__get8:

; 1084 : }

  000d6	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000dd	5f		 pop	 rdi
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
stbi__get8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__loadf_main
_TEXT	SEGMENT
data$ = 8
ri$4 = 40
hdr_data$5 = 88
tv89 = 292
tv129 = 296
__$ArrayPad$ = 304
s$ = 352
x$ = 360
y$ = 368
comp$ = 376
req_comp$ = 384
stbi__loadf_main PROC					; COMDAT

; 922  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR [rsp+408]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 30 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 923  :     unsigned char* data;
; 924  : #ifndef STBI_NO_HDR
; 925  :     if (stbi__hdr_test(s)) {

  00058	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__hdr_test
  00064	85 c0		 test	 eax, eax
  00066	74 70		 je	 SHORT $LN2@stbi__load

; 926  :         stbi__result_info ri;
; 927  :         float* hdr_data = stbi__hdr_load(s, x, y, comp, req_comp, &ri);

  00068	48 8d 45 28	 lea	 rax, QWORD PTR ri$4[rbp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00077	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007b	4c 8b 8d 78 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00082	4c 8b 85 70 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00089	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00090	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00097	e8 00 00 00 00	 call	 stbi__hdr_load
  0009c	48 89 45 58	 mov	 QWORD PTR hdr_data$5[rbp], rax

; 928  :         if (hdr_data)

  000a0	48 83 7d 58 00	 cmp	 QWORD PTR hdr_data$5[rbp], 0
  000a5	74 28		 je	 SHORT $LN3@stbi__load

; 929  :             stbi__float_postprocess(hdr_data, x, y, comp, req_comp);

  000a7	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000ad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b1	4c 8b 8d 78 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000b8	4c 8b 85 70 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000bf	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000c6	48 8b 4d 58	 mov	 rcx, QWORD PTR hdr_data$5[rbp]
  000ca	e8 00 00 00 00	 call	 stbi__float_postprocess
$LN3@stbi__load:

; 930  :         return hdr_data;

  000cf	48 8b 45 58	 mov	 rax, QWORD PTR hdr_data$5[rbp]
  000d3	e9 b0 00 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 931  :     }
; 932  : #endif
; 933  :     data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

  000d8	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	4c 8b 8d 78 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000e9	4c 8b 85 70 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000f0	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000f7	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000fe	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit
  00103	48 89 45 08	 mov	 QWORD PTR data$[rbp], rax

; 934  :     if (data)

  00107	48 83 7d 08 00	 cmp	 QWORD PTR data$[rbp], 0
  0010c	74 4b		 je	 SHORT $LN4@stbi__load

; 935  :         return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

  0010e	83 bd 80 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00115	74 0e		 je	 SHORT $LN6@stbi__load
  00117	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0011d	89 85 24 01 00
	00		 mov	 DWORD PTR tv89[rbp], eax
  00123	eb 0f		 jmp	 SHORT $LN7@stbi__load
$LN6@stbi__load:
  00125	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  0012c	8b 00		 mov	 eax, DWORD PTR [rax]
  0012e	89 85 24 01 00
	00		 mov	 DWORD PTR tv89[rbp], eax
$LN7@stbi__load:
  00134	44 8b 8d 24 01
	00 00		 mov	 r9d, DWORD PTR tv89[rbp]
  0013b	48 8b 85 70 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00142	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00145	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  0014c	8b 10		 mov	 edx, DWORD PTR [rax]
  0014e	48 8b 4d 08	 mov	 rcx, QWORD PTR data$[rbp]
  00152	e8 00 00 00 00	 call	 stbi__ldr_to_hdr
  00157	eb 2f		 jmp	 SHORT $LN1@stbi__load
$LN4@stbi__load:

; 936  :     return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  00160	e8 00 00 00 00	 call	 stbi__err
  00165	85 c0		 test	 eax, eax
  00167	74 0d		 je	 SHORT $LN8@stbi__load
  00169	48 c7 85 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv129[rbp], 0
  00174	eb 0b		 jmp	 SHORT $LN9@stbi__load
$LN8@stbi__load:
  00176	48 c7 85 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv129[rbp], 0
$LN9@stbi__load:
  00181	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR tv129[rbp]
$LN1@stbi__load:

; 937  : }

  00188	48 8b f8	 mov	 rdi, rax
  0018b	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__loadf_main$rtcFrameData
  00196	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0019b	48 8b c7	 mov	 rax, rdi
  0019e	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001a5	48 33 cd	 xor	 rcx, rbp
  001a8	e8 00 00 00 00	 call	 __security_check_cookie
  001ad	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  001b4	5f		 pop	 rdi
  001b5	5d		 pop	 rbp
  001b6	c3		 ret	 0
stbi__loadf_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__fopen
_TEXT	SEGMENT
f$ = 8
__$ArrayPad$ = 216
filename$ = 256
mode$ = 264
stbi__fopen PROC					; COMDAT

; 789  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001d	b9 0a 00 00 00	 mov	 ecx, 10
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00038	48 33 c5	 xor	 rax, rbp
  0003b	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00049	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 790  :     FILE* f;
; 791  : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 792  :     wchar_t wMode[64];
; 793  :     wchar_t wFilename[1024];
; 794  :     if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename) / sizeof(*wFilename)))
; 795  :         return 0;
; 796  : 
; 797  :     if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode) / sizeof(*wMode)))
; 798  :         return 0;
; 799  : 
; 800  : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 801  :     if (0 != _wfopen_s(&f, wFilename, wMode))
; 802  :         f = 0;
; 803  : #else
; 804  :     f = _wfopen(wFilename, wMode);
; 805  : #endif
; 806  : 
; 807  : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 808  :     if (0 != fopen_s(&f, filename, mode))

  0004e	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR mode$[rbp]
  00055	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR filename$[rbp]
  0005c	48 8d 4d 08	 lea	 rcx, QWORD PTR f$[rbp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen_s
  00066	85 c0		 test	 eax, eax
  00068	74 08		 je	 SHORT $LN2@stbi__fope

; 809  :         f = 0;

  0006a	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR f$[rbp], 0
$LN2@stbi__fope:

; 810  : #else
; 811  :     f = fopen(filename, mode);
; 812  : #endif
; 813  :     return f;

  00072	48 8b 45 08	 mov	 rax, QWORD PTR f$[rbp]

; 814  : }

  00076	48 8b f8	 mov	 rdi, rax
  00079	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__fopen$rtcFrameData
  00084	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00089	48 8b c7	 mov	 rax, rdi
  0008c	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00093	48 33 cd	 xor	 rcx, rbp
  00096	e8 00 00 00 00	 call	 __security_check_cookie
  0009b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a2	5f		 pop	 rdi
  000a3	5d		 pop	 rbp
  000a4	c3		 ret	 0
stbi__fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__float_postprocess
_TEXT	SEGMENT
channels$1 = 4
tv81 = 212
tv77 = 212
result$ = 256
x$ = 264
y$ = 272
comp$ = 280
req_comp$ = 288
stbi__float_postprocess PROC				; COMDAT

; 766  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 767  :     if (stbi__vertically_flip_on_load && result != NULL) {

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  00033	8b c0		 mov	 eax, eax
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00044	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00048	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  0004c	74 25		 je	 SHORT $LN4@stbi__floa
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  00053	8b c0		 mov	 eax, eax
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0005b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00064	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00068	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  0006b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv77[rbp], eax
  00071	eb 0c		 jmp	 SHORT $LN5@stbi__floa
$LN4@stbi__floa:
  00073	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00079	89 85 d4 00 00
	00		 mov	 DWORD PTR tv77[rbp], eax
$LN5@stbi__floa:
  0007f	83 bd d4 00 00
	00 00		 cmp	 DWORD PTR tv77[rbp], 0
  00086	74 63		 je	 SHORT $LN2@stbi__floa
  00088	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR result$[rbp], 0
  00090	74 59		 je	 SHORT $LN2@stbi__floa

; 768  :         int channels = req_comp ? req_comp : *comp;

  00092	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00099	74 0e		 je	 SHORT $LN6@stbi__floa
  0009b	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000a1	89 85 d4 00 00
	00		 mov	 DWORD PTR tv81[rbp], eax
  000a7	eb 0f		 jmp	 SHORT $LN7@stbi__floa
$LN6@stbi__floa:
  000a9	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  000b0	8b 00		 mov	 eax, DWORD PTR [rax]
  000b2	89 85 d4 00 00
	00		 mov	 DWORD PTR tv81[rbp], eax
$LN7@stbi__floa:
  000b8	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv81[rbp]
  000be	89 45 04	 mov	 DWORD PTR channels$1[rbp], eax

; 769  :         stbi__vertical_flip(result, *x, *y, channels * sizeof(float));

  000c1	48 63 45 04	 movsxd	 rax, DWORD PTR channels$1[rbp]
  000c5	48 c1 e0 02	 shl	 rax, 2
  000c9	44 8b c8	 mov	 r9d, eax
  000cc	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  000d3	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000d6	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  000dd	8b 10		 mov	 edx, DWORD PTR [rax]
  000df	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR result$[rbp]
  000e6	e8 00 00 00 00	 call	 stbi__vertical_flip
$LN2@stbi__floa:

; 770  :     }
; 771  : }

  000eb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000f2	5f		 pop	 rdi
  000f3	5d		 pop	 rbp
  000f4	c3		 ret	 0
stbi__float_postprocess ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__load_and_postprocess_16bit
_TEXT	SEGMENT
ri$ = 8
result$ = 56
channels$4 = 84
tv135 = 292
tv132 = 292
tv82 = 292
__$ArrayPad$ = 296
s$ = 336
x$ = 344
y$ = 352
comp$ = 360
req_comp$ = 368
stbi__load_and_postprocess_16bit PROC			; COMDAT

; 738  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00022	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00027	b9 1e 00 00 00	 mov	 ecx, 30
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR [rsp+408]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 28 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 739  :     stbi__result_info ri;
; 740  :     void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

  00058	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  00060	48 8d 45 08	 lea	 rax, QWORD PTR ri$[rbp]
  00064	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00069	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0006f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00073	4c 8b 8d 68 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0007a	4c 8b 85 60 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00081	48 8b 95 58 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00088	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0008f	e8 00 00 00 00	 call	 stbi__load_main
  00094	48 89 45 38	 mov	 QWORD PTR result$[rbp], rax

; 741  : 
; 742  :     if (result == NULL)

  00098	48 83 7d 38 00	 cmp	 QWORD PTR result$[rbp], 0
  0009d	75 07		 jne	 SHORT $LN2@stbi__load

; 743  :         return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	e9 35 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 744  : 
; 745  :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 746  :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  000a6	83 7d 08 08	 cmp	 DWORD PTR ri$[rbp], 8
  000aa	74 22		 je	 SHORT $LN6@stbi__load
  000ac	83 7d 08 10	 cmp	 DWORD PTR ri$[rbp], 16
  000b0	74 1c		 je	 SHORT $LN6@stbi__load
  000b2	41 b8 ea 02 00
	00		 mov	 r8d, 746		; 000002eaH
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cc	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 747  : 
; 748  :     if (ri.bits_per_channel != 16) {

  000ce	83 7d 08 10	 cmp	 DWORD PTR ri$[rbp], 16
  000d2	74 54		 je	 SHORT $LN3@stbi__load

; 749  :         result = stbi__convert_8_to_16((stbi_uc*)result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000d4	83 bd 70 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  000db	75 11		 jne	 SHORT $LN7@stbi__load
  000dd	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  000e4	8b 00		 mov	 eax, DWORD PTR [rax]
  000e6	89 85 24 01 00
	00		 mov	 DWORD PTR tv82[rbp], eax
  000ec	eb 0c		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ee	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000f4	89 85 24 01 00
	00		 mov	 DWORD PTR tv82[rbp], eax
$LN8@stbi__load:
  000fa	44 8b 8d 24 01
	00 00		 mov	 r9d, DWORD PTR tv82[rbp]
  00101	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00108	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0010b	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00112	8b 10		 mov	 edx, DWORD PTR [rax]
  00114	48 8b 4d 38	 mov	 rcx, QWORD PTR result$[rbp]
  00118	e8 00 00 00 00	 call	 stbi__convert_8_to_16
  0011d	48 89 45 38	 mov	 QWORD PTR result$[rbp], rax

; 750  :         ri.bits_per_channel = 16;

  00121	c7 45 08 10 00
	00 00		 mov	 DWORD PTR ri$[rbp], 16
$LN3@stbi__load:

; 751  :     }
; 752  : 
; 753  :     // @TODO: move stbi__convert_format16 to here
; 754  :     // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 755  : 
; 756  :     if (stbi__vertically_flip_on_load) {

  00128	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  0012d	8b c0		 mov	 eax, eax
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00135	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0013e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00142	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00146	74 25		 je	 SHORT $LN9@stbi__load
  00148	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  0014d	8b c0		 mov	 eax, eax
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00155	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0015e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00162	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00165	89 85 24 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  0016b	eb 0c		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  0016d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00173	89 85 24 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
$LN10@stbi__load:
  00179	83 bd 24 01 00
	00 00		 cmp	 DWORD PTR tv132[rbp], 0
  00180	74 55		 je	 SHORT $LN4@stbi__load

; 757  :         int channels = req_comp ? req_comp : *comp;

  00182	83 bd 70 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00189	74 0e		 je	 SHORT $LN11@stbi__load
  0018b	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00191	89 85 24 01 00
	00		 mov	 DWORD PTR tv135[rbp], eax
  00197	eb 0f		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00199	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  001a0	8b 00		 mov	 eax, DWORD PTR [rax]
  001a2	89 85 24 01 00
	00		 mov	 DWORD PTR tv135[rbp], eax
$LN12@stbi__load:
  001a8	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tv135[rbp]
  001ae	89 45 54	 mov	 DWORD PTR channels$4[rbp], eax

; 758  :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

  001b1	48 63 45 54	 movsxd	 rax, DWORD PTR channels$4[rbp]
  001b5	48 d1 e0	 shl	 rax, 1
  001b8	44 8b c8	 mov	 r9d, eax
  001bb	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  001c2	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  001c5	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  001cc	8b 10		 mov	 edx, DWORD PTR [rax]
  001ce	48 8b 4d 38	 mov	 rcx, QWORD PTR result$[rbp]
  001d2	e8 00 00 00 00	 call	 stbi__vertical_flip
$LN4@stbi__load:

; 759  :     }
; 760  : 
; 761  :     return (stbi__uint16*)result;

  001d7	48 8b 45 38	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__load:

; 762  : }

  001db	48 8b f8	 mov	 rdi, rax
  001de	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_and_postprocess_16bit$rtcFrameData
  001e9	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001ee	48 8b c7	 mov	 rax, rdi
  001f1	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001f8	48 33 cd	 xor	 rcx, rbp
  001fb	e8 00 00 00 00	 call	 __security_check_cookie
  00200	48 8d a5 38 01
	00 00		 lea	 rsp, QWORD PTR [rbp+312]
  00207	5f		 pop	 rdi
  00208	5d		 pop	 rbp
  00209	c3		 ret	 0
stbi__load_and_postprocess_16bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__load_and_postprocess_8bit
_TEXT	SEGMENT
ri$ = 8
result$ = 56
channels$4 = 84
tv135 = 292
tv132 = 292
tv82 = 292
__$ArrayPad$ = 296
s$ = 336
x$ = 344
y$ = 352
comp$ = 360
req_comp$ = 368
stbi__load_and_postprocess_8bit PROC			; COMDAT

; 712  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00022	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00027	b9 1e 00 00 00	 mov	 ecx, 30
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR [rsp+408]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 28 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 713  :     stbi__result_info ri;
; 714  :     void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

  00058	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  00060	48 8d 45 08	 lea	 rax, QWORD PTR ri$[rbp]
  00064	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00069	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0006f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00073	4c 8b 8d 68 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0007a	4c 8b 85 60 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00081	48 8b 95 58 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00088	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0008f	e8 00 00 00 00	 call	 stbi__load_main
  00094	48 89 45 38	 mov	 QWORD PTR result$[rbp], rax

; 715  : 
; 716  :     if (result == NULL)

  00098	48 83 7d 38 00	 cmp	 QWORD PTR result$[rbp], 0
  0009d	75 07		 jne	 SHORT $LN2@stbi__load

; 717  :         return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	e9 2f 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 718  : 
; 719  :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 720  :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  000a6	83 7d 08 08	 cmp	 DWORD PTR ri$[rbp], 8
  000aa	74 22		 je	 SHORT $LN6@stbi__load
  000ac	83 7d 08 10	 cmp	 DWORD PTR ri$[rbp], 16
  000b0	74 1c		 je	 SHORT $LN6@stbi__load
  000b2	41 b8 d0 02 00
	00		 mov	 r8d, 720		; 000002d0H
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cc	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 721  : 
; 722  :     if (ri.bits_per_channel != 8) {

  000ce	83 7d 08 08	 cmp	 DWORD PTR ri$[rbp], 8
  000d2	74 54		 je	 SHORT $LN3@stbi__load

; 723  :         result = stbi__convert_16_to_8((stbi__uint16*)result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000d4	83 bd 70 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  000db	75 11		 jne	 SHORT $LN7@stbi__load
  000dd	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  000e4	8b 00		 mov	 eax, DWORD PTR [rax]
  000e6	89 85 24 01 00
	00		 mov	 DWORD PTR tv82[rbp], eax
  000ec	eb 0c		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ee	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000f4	89 85 24 01 00
	00		 mov	 DWORD PTR tv82[rbp], eax
$LN8@stbi__load:
  000fa	44 8b 8d 24 01
	00 00		 mov	 r9d, DWORD PTR tv82[rbp]
  00101	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00108	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0010b	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00112	8b 10		 mov	 edx, DWORD PTR [rax]
  00114	48 8b 4d 38	 mov	 rcx, QWORD PTR result$[rbp]
  00118	e8 00 00 00 00	 call	 stbi__convert_16_to_8
  0011d	48 89 45 38	 mov	 QWORD PTR result$[rbp], rax

; 724  :         ri.bits_per_channel = 8;

  00121	c7 45 08 08 00
	00 00		 mov	 DWORD PTR ri$[rbp], 8
$LN3@stbi__load:

; 725  :     }
; 726  : 
; 727  :     // @TODO: move stbi__convert_format to here
; 728  : 
; 729  :     if (stbi__vertically_flip_on_load) {

  00128	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  0012d	8b c0		 mov	 eax, eax
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00135	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0013e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00142	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00146	74 25		 je	 SHORT $LN9@stbi__load
  00148	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  0014d	8b c0		 mov	 eax, eax
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00155	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0015e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00162	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00165	89 85 24 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  0016b	eb 0c		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  0016d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00173	89 85 24 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
$LN10@stbi__load:
  00179	83 bd 24 01 00
	00 00		 cmp	 DWORD PTR tv132[rbp], 0
  00180	74 4f		 je	 SHORT $LN4@stbi__load

; 730  :         int channels = req_comp ? req_comp : *comp;

  00182	83 bd 70 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00189	74 0e		 je	 SHORT $LN11@stbi__load
  0018b	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00191	89 85 24 01 00
	00		 mov	 DWORD PTR tv135[rbp], eax
  00197	eb 0f		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00199	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  001a0	8b 00		 mov	 eax, DWORD PTR [rax]
  001a2	89 85 24 01 00
	00		 mov	 DWORD PTR tv135[rbp], eax
$LN12@stbi__load:
  001a8	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tv135[rbp]
  001ae	89 45 54	 mov	 DWORD PTR channels$4[rbp], eax

; 731  :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

  001b1	44 8b 4d 54	 mov	 r9d, DWORD PTR channels$4[rbp]
  001b5	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  001bc	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  001bf	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  001c6	8b 10		 mov	 edx, DWORD PTR [rax]
  001c8	48 8b 4d 38	 mov	 rcx, QWORD PTR result$[rbp]
  001cc	e8 00 00 00 00	 call	 stbi__vertical_flip
$LN4@stbi__load:

; 732  :     }
; 733  : 
; 734  :     return (unsigned char*)result;

  001d1	48 8b 45 38	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__load:

; 735  : }

  001d5	48 8b f8	 mov	 rdi, rax
  001d8	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_and_postprocess_8bit$rtcFrameData
  001e3	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001e8	48 8b c7	 mov	 rax, rdi
  001eb	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001f2	48 33 cd	 xor	 rcx, rbp
  001f5	e8 00 00 00 00	 call	 __security_check_cookie
  001fa	48 8d a5 38 01
	00 00		 lea	 rsp, QWORD PTR [rbp+312]
  00201	5f		 pop	 rdi
  00202	5d		 pop	 rbp
  00203	c3		 ret	 0
stbi__load_and_postprocess_8bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__vertical_flip_slices
_TEXT	SEGMENT
slice$ = 4
slice_size$ = 36
bytes$ = 72
image$ = 320
w$ = 328
h$ = 336
z$ = 344
bytes_per_pixel$ = 352
stbi__vertical_flip_slices PROC				; COMDAT

; 699  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 700  :     int slice;
; 701  :     int slice_size = w * h * bytes_per_pixel;

  0002d	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00033	0f af 85 50 01
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  0003a	0f af 85 60 01
	00 00		 imul	 eax, DWORD PTR bytes_per_pixel$[rbp]
  00041	89 45 24	 mov	 DWORD PTR slice_size$[rbp], eax

; 702  : 
; 703  :     stbi_uc* bytes = (stbi_uc*)image;

  00044	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR image$[rbp]
  0004b	48 89 45 48	 mov	 QWORD PTR bytes$[rbp], rax

; 704  :     for (slice = 0; slice < z; ++slice) {

  0004f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR slice$[rbp], 0
  00056	eb 08		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  00058	8b 45 04	 mov	 eax, DWORD PTR slice$[rbp]
  0005b	ff c0		 inc	 eax
  0005d	89 45 04	 mov	 DWORD PTR slice$[rbp], eax
$LN4@stbi__vert:
  00060	8b 85 58 01 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  00066	39 45 04	 cmp	 DWORD PTR slice$[rbp], eax
  00069	7d 31		 jge	 SHORT $LN3@stbi__vert

; 705  :         stbi__vertical_flip(bytes, w, h, bytes_per_pixel);

  0006b	44 8b 8d 60 01
	00 00		 mov	 r9d, DWORD PTR bytes_per_pixel$[rbp]
  00072	44 8b 85 50 01
	00 00		 mov	 r8d, DWORD PTR h$[rbp]
  00079	8b 95 48 01 00
	00		 mov	 edx, DWORD PTR w$[rbp]
  0007f	48 8b 4d 48	 mov	 rcx, QWORD PTR bytes$[rbp]
  00083	e8 00 00 00 00	 call	 stbi__vertical_flip

; 706  :         bytes += slice_size;

  00088	48 63 45 24	 movsxd	 rax, DWORD PTR slice_size$[rbp]
  0008c	48 8b 4d 48	 mov	 rcx, QWORD PTR bytes$[rbp]
  00090	48 03 c8	 add	 rcx, rax
  00093	48 8b c1	 mov	 rax, rcx
  00096	48 89 45 48	 mov	 QWORD PTR bytes$[rbp], rax

; 707  :     }

  0009a	eb bc		 jmp	 SHORT $LN2@stbi__vert
$LN3@stbi__vert:

; 708  : }

  0009c	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000a3	5f		 pop	 rdi
  000a4	5d		 pop	 rbp
  000a5	c3		 ret	 0
stbi__vertical_flip_slices ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__vertical_flip
_TEXT	SEGMENT
row$ = 4
bytes_per_row$ = 40
temp$ = 80
bytes$ = 2152
row0$4 = 2184
row1$5 = 2216
bytes_left$6 = 2248
bytes_copy$7 = 2280
tv80 = 3256
__$ArrayPad$ = 3264
image$ = 3312
w$ = 3320
h$ = 3328
bytes_per_pixel$ = 3336
stbi__vertical_flip PROC				; COMDAT

; 674  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec f8 0c
	00 00		 sub	 rsp, 3320		; 00000cf8H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00026	b9 46 02 00 00	 mov	 ecx, 582		; 00000246H
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 18
	0d 00 00	 mov	 rcx, QWORD PTR [rsp+3352]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 c0 0c
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 675  :     int row;
; 676  :     size_t bytes_per_row = (size_t)w * bytes_per_pixel;

  00057	48 63 85 f8 0c
	00 00		 movsxd	 rax, DWORD PTR w$[rbp]
  0005e	48 63 8d 08 0d
	00 00		 movsxd	 rcx, DWORD PTR bytes_per_pixel$[rbp]
  00065	48 0f af c1	 imul	 rax, rcx
  00069	48 89 45 28	 mov	 QWORD PTR bytes_per_row$[rbp], rax

; 677  :     stbi_uc temp[2048];
; 678  :     stbi_uc* bytes = (stbi_uc*)image;

  0006d	48 8b 85 f0 0c
	00 00		 mov	 rax, QWORD PTR image$[rbp]
  00074	48 89 85 68 08
	00 00		 mov	 QWORD PTR bytes$[rbp], rax

; 679  : 
; 680  :     for (row = 0; row < (h >> 1); row++) {

  0007b	c7 45 04 00 00
	00 00		 mov	 DWORD PTR row$[rbp], 0
  00082	eb 08		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  00084	8b 45 04	 mov	 eax, DWORD PTR row$[rbp]
  00087	ff c0		 inc	 eax
  00089	89 45 04	 mov	 DWORD PTR row$[rbp], eax
$LN4@stbi__vert:
  0008c	8b 85 00 0d 00
	00		 mov	 eax, DWORD PTR h$[rbp]
  00092	d1 f8		 sar	 eax, 1
  00094	39 45 04	 cmp	 DWORD PTR row$[rbp], eax
  00097	0f 8d 39 01 00
	00		 jge	 $LN3@stbi__vert

; 681  :         stbi_uc* row0 = bytes + row * bytes_per_row;

  0009d	48 63 45 04	 movsxd	 rax, DWORD PTR row$[rbp]
  000a1	48 0f af 45 28	 imul	 rax, QWORD PTR bytes_per_row$[rbp]
  000a6	48 8b 8d 68 08
	00 00		 mov	 rcx, QWORD PTR bytes$[rbp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 85 88 08
	00 00		 mov	 QWORD PTR row0$4[rbp], rax

; 682  :         stbi_uc* row1 = bytes + (h - row - 1) * bytes_per_row;

  000ba	8b 45 04	 mov	 eax, DWORD PTR row$[rbp]
  000bd	8b 8d 00 0d 00
	00		 mov	 ecx, DWORD PTR h$[rbp]
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	ff c8		 dec	 eax
  000c9	48 98		 cdqe
  000cb	48 0f af 45 28	 imul	 rax, QWORD PTR bytes_per_row$[rbp]
  000d0	48 8b 8d 68 08
	00 00		 mov	 rcx, QWORD PTR bytes$[rbp]
  000d7	48 03 c8	 add	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 85 a8 08
	00 00		 mov	 QWORD PTR row1$5[rbp], rax

; 683  :         // swap row0 with row1
; 684  :         size_t bytes_left = bytes_per_row;

  000e4	48 8b 45 28	 mov	 rax, QWORD PTR bytes_per_row$[rbp]
  000e8	48 89 85 c8 08
	00 00		 mov	 QWORD PTR bytes_left$6[rbp], rax
$LN5@stbi__vert:

; 685  :         while (bytes_left) {

  000ef	48 83 bd c8 08
	00 00 00	 cmp	 QWORD PTR bytes_left$6[rbp], 0
  000f7	0f 84 d4 00 00
	00		 je	 $LN6@stbi__vert

; 686  :             size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

  000fd	48 81 bd c8 08
	00 00 00 08 00
	00		 cmp	 QWORD PTR bytes_left$6[rbp], 2048 ; 00000800H
  00108	73 10		 jae	 SHORT $LN8@stbi__vert
  0010a	48 8b 85 c8 08
	00 00		 mov	 rax, QWORD PTR bytes_left$6[rbp]
  00111	48 89 85 b8 0c
	00 00		 mov	 QWORD PTR tv80[rbp], rax
  00118	eb 0b		 jmp	 SHORT $LN9@stbi__vert
$LN8@stbi__vert:
  0011a	48 c7 85 b8 0c
	00 00 00 08 00
	00		 mov	 QWORD PTR tv80[rbp], 2048 ; 00000800H
$LN9@stbi__vert:
  00125	48 8b 85 b8 0c
	00 00		 mov	 rax, QWORD PTR tv80[rbp]
  0012c	48 89 85 e8 08
	00 00		 mov	 QWORD PTR bytes_copy$7[rbp], rax

; 687  :             memcpy(temp, row0, bytes_copy);

  00133	4c 8b 85 e8 08
	00 00		 mov	 r8, QWORD PTR bytes_copy$7[rbp]
  0013a	48 8b 95 88 08
	00 00		 mov	 rdx, QWORD PTR row0$4[rbp]
  00141	48 8d 4d 50	 lea	 rcx, QWORD PTR temp$[rbp]
  00145	e8 00 00 00 00	 call	 memcpy

; 688  :             memcpy(row0, row1, bytes_copy);

  0014a	4c 8b 85 e8 08
	00 00		 mov	 r8, QWORD PTR bytes_copy$7[rbp]
  00151	48 8b 95 a8 08
	00 00		 mov	 rdx, QWORD PTR row1$5[rbp]
  00158	48 8b 8d 88 08
	00 00		 mov	 rcx, QWORD PTR row0$4[rbp]
  0015f	e8 00 00 00 00	 call	 memcpy

; 689  :             memcpy(row1, temp, bytes_copy);

  00164	4c 8b 85 e8 08
	00 00		 mov	 r8, QWORD PTR bytes_copy$7[rbp]
  0016b	48 8d 55 50	 lea	 rdx, QWORD PTR temp$[rbp]
  0016f	48 8b 8d a8 08
	00 00		 mov	 rcx, QWORD PTR row1$5[rbp]
  00176	e8 00 00 00 00	 call	 memcpy

; 690  :             row0 += bytes_copy;

  0017b	48 8b 85 e8 08
	00 00		 mov	 rax, QWORD PTR bytes_copy$7[rbp]
  00182	48 8b 8d 88 08
	00 00		 mov	 rcx, QWORD PTR row0$4[rbp]
  00189	48 03 c8	 add	 rcx, rax
  0018c	48 8b c1	 mov	 rax, rcx
  0018f	48 89 85 88 08
	00 00		 mov	 QWORD PTR row0$4[rbp], rax

; 691  :             row1 += bytes_copy;

  00196	48 8b 85 e8 08
	00 00		 mov	 rax, QWORD PTR bytes_copy$7[rbp]
  0019d	48 8b 8d a8 08
	00 00		 mov	 rcx, QWORD PTR row1$5[rbp]
  001a4	48 03 c8	 add	 rcx, rax
  001a7	48 8b c1	 mov	 rax, rcx
  001aa	48 89 85 a8 08
	00 00		 mov	 QWORD PTR row1$5[rbp], rax

; 692  :             bytes_left -= bytes_copy;

  001b1	48 8b 85 e8 08
	00 00		 mov	 rax, QWORD PTR bytes_copy$7[rbp]
  001b8	48 8b 8d c8 08
	00 00		 mov	 rcx, QWORD PTR bytes_left$6[rbp]
  001bf	48 2b c8	 sub	 rcx, rax
  001c2	48 8b c1	 mov	 rax, rcx
  001c5	48 89 85 c8 08
	00 00		 mov	 QWORD PTR bytes_left$6[rbp], rax

; 693  :         }

  001cc	e9 1e ff ff ff	 jmp	 $LN5@stbi__vert
$LN6@stbi__vert:

; 694  :     }

  001d1	e9 ae fe ff ff	 jmp	 $LN2@stbi__vert
$LN3@stbi__vert:

; 695  : }

  001d6	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__vertical_flip$rtcFrameData
  001e1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001e6	48 8b 8d c0 0c
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001ed	48 33 cd	 xor	 rcx, rbp
  001f0	e8 00 00 00 00	 call	 __security_check_cookie
  001f5	48 8d a5 d8 0c
	00 00		 lea	 rsp, QWORD PTR [rbp+3288]
  001fc	5f		 pop	 rdi
  001fd	5d		 pop	 rbp
  001fe	c3		 ret	 0
stbi__vertical_flip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__convert_8_to_16
_TEXT	SEGMENT
i$ = 4
img_len$ = 36
enlarged$ = 72
tv74 = 280
orig$ = 320
w$ = 328
h$ = 336
channels$ = 344
stbi__convert_8_to_16 PROC				; COMDAT

; 658  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 659  :     int i;
; 660  :     int img_len = w * h * channels;

  0002d	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00033	0f af 85 50 01
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  0003a	0f af 85 58 01
	00 00		 imul	 eax, DWORD PTR channels$[rbp]
  00041	89 45 24	 mov	 DWORD PTR img_len$[rbp], eax

; 661  :     stbi__uint16* enlarged;
; 662  : 
; 663  :     enlarged = (stbi__uint16*)stbi__malloc(img_len * 2);

  00044	8b 45 24	 mov	 eax, DWORD PTR img_len$[rbp]
  00047	d1 e0		 shl	 eax, 1
  00049	48 98		 cdqe
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 stbi__malloc
  00053	48 89 45 48	 mov	 QWORD PTR enlarged$[rbp], rax

; 664  :     if (enlarged == NULL) return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");

  00057	48 83 7d 48 00	 cmp	 QWORD PTR enlarged$[rbp], 0
  0005c	75 31		 jne	 SHORT $LN5@stbi__conv
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00065	e8 00 00 00 00	 call	 stbi__err
  0006a	85 c0		 test	 eax, eax
  0006c	74 0d		 je	 SHORT $LN7@stbi__conv
  0006e	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv74[rbp], 0
  00079	eb 0b		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  0007b	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv74[rbp], 0
$LN8@stbi__conv:
  00086	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv74[rbp]
  0008d	eb 5b		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 665  : 
; 666  :     for (i = 0; i < img_len; ++i)

  0008f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00096	eb 08		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00098	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0009b	ff c0		 inc	 eax
  0009d	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__conv:
  000a0	8b 45 24	 mov	 eax, DWORD PTR img_len$[rbp]
  000a3	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000a6	7d 31		 jge	 SHORT $LN3@stbi__conv

; 667  :         enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

  000a8	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000ac	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  000b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b7	c1 e0 08	 shl	 eax, 8
  000ba	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  000be	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR orig$[rbp]
  000c5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c9	03 c1		 add	 eax, ecx
  000cb	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  000cf	48 8b 55 48	 mov	 rdx, QWORD PTR enlarged$[rbp]
  000d3	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  000d7	eb bf		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 668  : 
; 669  :     STBI_FREE(orig);

  000d9	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 670  :     return enlarged;

  000e6	48 8b 45 48	 mov	 rax, QWORD PTR enlarged$[rbp]
$LN1@stbi__conv:

; 671  : }

  000ea	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000f1	5f		 pop	 rdi
  000f2	5d		 pop	 rbp
  000f3	c3		 ret	 0
stbi__convert_8_to_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__convert_16_to_8
_TEXT	SEGMENT
i$ = 4
img_len$ = 36
reduced$ = 72
tv73 = 280
orig$ = 320
w$ = 328
h$ = 336
channels$ = 344
stbi__convert_16_to_8 PROC				; COMDAT

; 642  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 643  :     int i;
; 644  :     int img_len = w * h * channels;

  0002d	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00033	0f af 85 50 01
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  0003a	0f af 85 58 01
	00 00		 imul	 eax, DWORD PTR channels$[rbp]
  00041	89 45 24	 mov	 DWORD PTR img_len$[rbp], eax

; 645  :     stbi_uc* reduced;
; 646  : 
; 647  :     reduced = (stbi_uc*)stbi__malloc(img_len);

  00044	48 63 45 24	 movsxd	 rax, DWORD PTR img_len$[rbp]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 stbi__malloc
  00050	48 89 45 48	 mov	 QWORD PTR reduced$[rbp], rax

; 648  :     if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

  00054	48 83 7d 48 00	 cmp	 QWORD PTR reduced$[rbp], 0
  00059	75 31		 jne	 SHORT $LN5@stbi__conv
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00062	e8 00 00 00 00	 call	 stbi__err
  00067	85 c0		 test	 eax, eax
  00069	74 0d		 je	 SHORT $LN7@stbi__conv
  0006b	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv73[rbp], 0
  00076	eb 0b		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  00078	48 c7 85 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv73[rbp], 0
$LN8@stbi__conv:
  00083	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv73[rbp]
  0008a	eb 4e		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 649  : 
; 650  :     for (i = 0; i < img_len; ++i)

  0008c	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00093	eb 08		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00095	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00098	ff c0		 inc	 eax
  0009a	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__conv:
  0009d	8b 45 24	 mov	 eax, DWORD PTR img_len$[rbp]
  000a0	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000a3	7d 24		 jge	 SHORT $LN3@stbi__conv

; 651  :         reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

  000a5	48 63 45 04	 movsxd	 rax, DWORD PTR i$[rbp]
  000a9	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  000b0	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000b4	c1 f8 08	 sar	 eax, 8
  000b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bc	48 63 4d 04	 movsxd	 rcx, DWORD PTR i$[rbp]
  000c0	48 8b 55 48	 mov	 rdx, QWORD PTR reduced$[rbp]
  000c4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000c7	eb cc		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 652  : 
; 653  :     STBI_FREE(orig);

  000c9	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR orig$[rbp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 654  :     return reduced;

  000d6	48 8b 45 48	 mov	 rax, QWORD PTR reduced$[rbp]
$LN1@stbi__conv:

; 655  : }

  000da	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000e1	5f		 pop	 rdi
  000e2	5d		 pop	 rbp
  000e3	c3		 ret	 0
stbi__convert_16_to_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__load_main
_TEXT	SEGMENT
hdr$1 = 8
tv185 = 212
tv203 = 216
s$ = 256
x$ = 264
y$ = 272
comp$ = 280
req_comp$ = 288
ri$ = 296
bpc$ = 304
stbi__load_main PROC					; COMDAT

; 589  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 590  :     memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

  0002e	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00034	33 d2		 xor	 edx, edx
  00036	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR ri$[rbp]
  0003d	e8 00 00 00 00	 call	 memset

; 591  :     ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

  00042	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00049	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 592  :     ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

  0004f	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00056	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 593  :     ri->num_channels = 0;

  0005d	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00064	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 594  : 
; 595  :     // test the formats with a very explicit header first (at least a FOURCC
; 596  :     // or distinctive magic number first)
; 597  : #ifndef STBI_NO_PNG
; 598  :     if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp, ri);

  0006b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00072	e8 00 00 00 00	 call	 stbi__png_test
  00077	85 c0		 test	 eax, eax
  00079	74 3c		 je	 SHORT $LN2@stbi__load
  0007b	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00082	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00087	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0008d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00091	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00098	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0009f	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000a6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ad	e8 00 00 00 00	 call	 stbi__png_load
  000b2	e9 e4 02 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 599  : #endif
; 600  : #ifndef STBI_NO_BMP
; 601  :     if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp, ri);

  000b7	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000be	e8 00 00 00 00	 call	 stbi__bmp_test
  000c3	85 c0		 test	 eax, eax
  000c5	74 3c		 je	 SHORT $LN3@stbi__load
  000c7	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  000ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d3	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000d9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000dd	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000e4	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000eb	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000f2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f9	e8 00 00 00 00	 call	 stbi__bmp_load
  000fe	e9 98 02 00 00	 jmp	 $LN1@stbi__load
$LN3@stbi__load:

; 602  : #endif
; 603  : #ifndef STBI_NO_GIF
; 604  :     if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp, ri);

  00103	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0010a	e8 00 00 00 00	 call	 stbi__gif_test
  0010f	85 c0		 test	 eax, eax
  00111	74 3c		 je	 SHORT $LN4@stbi__load
  00113	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  0011a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011f	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00125	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00129	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00130	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00137	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0013e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00145	e8 00 00 00 00	 call	 stbi__gif_load
  0014a	e9 4c 02 00 00	 jmp	 $LN1@stbi__load
$LN4@stbi__load:

; 605  : #endif
; 606  : #ifndef STBI_NO_PSD
; 607  :     if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);

  0014f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00156	e8 00 00 00 00	 call	 stbi__psd_test
  0015b	85 c0		 test	 eax, eax
  0015d	74 46		 je	 SHORT $LN5@stbi__load
  0015f	8b 85 30 01 00
	00		 mov	 eax, DWORD PTR bpc$[rbp]
  00165	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00169	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00170	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00175	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0017b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017f	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00186	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0018d	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00194	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0019b	e8 00 00 00 00	 call	 stbi__psd_load
  001a0	e9 f6 01 00 00	 jmp	 $LN1@stbi__load
$LN5@stbi__load:

; 608  : #else
; 609  :     STBI_NOTUSED(bpc);
; 610  : #endif
; 611  : #ifndef STBI_NO_PIC
; 612  :     if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp, ri);

  001a5	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001ac	e8 00 00 00 00	 call	 stbi__pic_test
  001b1	85 c0		 test	 eax, eax
  001b3	74 3c		 je	 SHORT $LN6@stbi__load
  001b5	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  001bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c1	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  001c7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001cb	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  001d2	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  001d9	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  001e0	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001e7	e8 00 00 00 00	 call	 stbi__pic_load
  001ec	e9 aa 01 00 00	 jmp	 $LN1@stbi__load
$LN6@stbi__load:

; 613  : #endif
; 614  : 
; 615  :     // then the formats that can end up attempting to load with just 1 or 2
; 616  :     // bytes matching expectations; these are prone to false positives, so
; 617  :     // try them later
; 618  : #ifndef STBI_NO_JPEG
; 619  :     if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp, ri);

  001f1	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001f8	e8 00 00 00 00	 call	 stbi__jpeg_test
  001fd	85 c0		 test	 eax, eax
  001ff	74 3c		 je	 SHORT $LN7@stbi__load
  00201	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00208	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020d	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00213	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00217	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0021e	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00225	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0022c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00233	e8 00 00 00 00	 call	 stbi__jpeg_load
  00238	e9 5e 01 00 00	 jmp	 $LN1@stbi__load
$LN7@stbi__load:

; 620  : #endif
; 621  : #ifndef STBI_NO_PNM
; 622  :     if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp, ri);

  0023d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00244	e8 00 00 00 00	 call	 stbi__pnm_test
  00249	85 c0		 test	 eax, eax
  0024b	74 3c		 je	 SHORT $LN8@stbi__load
  0024d	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00254	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00259	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0025f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00263	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0026a	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00271	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00278	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0027f	e8 00 00 00 00	 call	 stbi__pnm_load
  00284	e9 12 01 00 00	 jmp	 $LN1@stbi__load
$LN8@stbi__load:

; 623  : #endif
; 624  : 
; 625  : #ifndef STBI_NO_HDR
; 626  :     if (stbi__hdr_test(s)) {

  00289	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00290	e8 00 00 00 00	 call	 stbi__hdr_test
  00295	85 c0		 test	 eax, eax
  00297	0f 84 86 00 00
	00		 je	 $LN9@stbi__load

; 627  :         float* hdr = stbi__hdr_load(s, x, y, comp, req_comp, ri);

  0029d	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  002a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a9	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  002af	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002b3	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  002ba	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  002c1	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  002c8	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  002cf	e8 00 00 00 00	 call	 stbi__hdr_load
  002d4	48 89 45 08	 mov	 QWORD PTR hdr$1[rbp], rax

; 628  :         return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

  002d8	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  002df	74 0e		 je	 SHORT $LN12@stbi__load
  002e1	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  002e7	89 85 d4 00 00
	00		 mov	 DWORD PTR tv185[rbp], eax
  002ed	eb 0f		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:
  002ef	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  002f6	8b 00		 mov	 eax, DWORD PTR [rax]
  002f8	89 85 d4 00 00
	00		 mov	 DWORD PTR tv185[rbp], eax
$LN13@stbi__load:
  002fe	44 8b 8d d4 00
	00 00		 mov	 r9d, DWORD PTR tv185[rbp]
  00305	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  0030c	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0030f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00316	8b 10		 mov	 edx, DWORD PTR [rax]
  00318	48 8b 4d 08	 mov	 rcx, QWORD PTR hdr$1[rbp]
  0031c	e8 00 00 00 00	 call	 stbi__hdr_to_ldr
  00321	eb 78		 jmp	 SHORT $LN1@stbi__load
$LN9@stbi__load:

; 629  :     }
; 630  : #endif
; 631  : 
; 632  : #ifndef STBI_NO_TGA
; 633  :     // test tga last because it's a crappy test!
; 634  :     if (stbi__tga_test(s))

  00323	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0032a	e8 00 00 00 00	 call	 stbi__tga_test
  0032f	85 c0		 test	 eax, eax
  00331	74 39		 je	 SHORT $LN10@stbi__load

; 635  :         return stbi__tga_load(s, x, y, comp, req_comp, ri);

  00333	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  0033a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0033f	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00345	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00349	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00350	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00357	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0035e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00365	e8 00 00 00 00	 call	 stbi__tga_load
  0036a	eb 2f		 jmp	 SHORT $LN1@stbi__load
$LN10@stbi__load:

; 636  : #endif
; 637  : 
; 638  :     return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

  0036c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  00373	e8 00 00 00 00	 call	 stbi__err
  00378	85 c0		 test	 eax, eax
  0037a	74 0d		 je	 SHORT $LN14@stbi__load
  0037c	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv203[rbp], 0
  00387	eb 0b		 jmp	 SHORT $LN15@stbi__load
$LN14@stbi__load:
  00389	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv203[rbp], 0
$LN15@stbi__load:
  00394	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv203[rbp]
$LN1@stbi__load:

; 639  : }

  0039b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  003a2	5f		 pop	 rdi
  003a3	5d		 pop	 rbp
  003a4	c3		 ret	 0
stbi__load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_to_ldr
_TEXT	SEGMENT
i$ = 4
k$ = 36
n$ = 68
output$ = 104
z$1 = 132
z$2 = 164
tv93 = 376
tv75 = 376
data$ = 416
x$ = 424
y$ = 432
comp$ = 440
stbi__hdr_to_ldr PROC					; COMDAT

; 1347 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1348 :     int i, k, n;
; 1349 :     stbi_uc* output;
; 1350 :     if (!data) return NULL;

  0002d	48 83 bd a0 01
	00 00 00	 cmp	 QWORD PTR data$[rbp], 0
  00035	75 07		 jne	 SHORT $LN8@stbi__hdr_
  00037	33 c0		 xor	 eax, eax
  00039	e9 3c 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1351 :     output = (stbi_uc*)stbi__malloc_mad3(x, y, comp, 0);

  0003e	45 33 c9	 xor	 r9d, r9d
  00041	44 8b 85 b8 01
	00 00		 mov	 r8d, DWORD PTR comp$[rbp]
  00048	8b 95 b0 01 00
	00		 mov	 edx, DWORD PTR y$[rbp]
  0004e	8b 8d a8 01 00
	00		 mov	 ecx, DWORD PTR x$[rbp]
  00054	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00059	48 89 45 68	 mov	 QWORD PTR output$[rbp], rax

; 1352 :     if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

  0005d	48 83 7d 68 00	 cmp	 QWORD PTR output$[rbp], 0
  00062	75 41		 jne	 SHORT $LN9@stbi__hdr_
  00064	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00078	e8 00 00 00 00	 call	 stbi__err
  0007d	85 c0		 test	 eax, eax
  0007f	74 0d		 je	 SHORT $LN18@stbi__hdr_
  00081	48 c7 85 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
  0008c	eb 0b		 jmp	 SHORT $LN19@stbi__hdr_
$LN18@stbi__hdr_:
  0008e	48 c7 85 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv75[rbp], 0
$LN19@stbi__hdr_:
  00099	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR tv75[rbp]
  000a0	e9 d5 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN9@stbi__hdr_:

; 1353 :     // compute number of non-alpha components
; 1354 :     if (comp & 1) n = comp; else n = comp - 1;

  000a5	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	74 0b		 je	 SHORT $LN10@stbi__hdr_
  000b2	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000b8	89 45 44	 mov	 DWORD PTR n$[rbp], eax
  000bb	eb 0b		 jmp	 SHORT $LN11@stbi__hdr_
$LN10@stbi__hdr_:
  000bd	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000c3	ff c8		 dec	 eax
  000c5	89 45 44	 mov	 DWORD PTR n$[rbp], eax
$LN11@stbi__hdr_:

; 1355 :     for (i = 0; i < x * y; ++i) {

  000c8	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  000cf	eb 08		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  000d1	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000d4	ff c0		 inc	 eax
  000d6	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__hdr_:
  000d9	8b 85 a8 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  000df	0f af 85 b0 01
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  000e6	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000e9	0f 8d 7a 01 00
	00		 jge	 $LN3@stbi__hdr_

; 1356 :         for (k = 0; k < n; ++k) {

  000ef	c7 45 24 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0
  000f6	eb 08		 jmp	 SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
  000f8	8b 45 24	 mov	 eax, DWORD PTR k$[rbp]
  000fb	ff c0		 inc	 eax
  000fd	89 45 24	 mov	 DWORD PTR k$[rbp], eax
$LN7@stbi__hdr_:
  00100	8b 45 44	 mov	 eax, DWORD PTR n$[rbp]
  00103	39 45 24	 cmp	 DWORD PTR k$[rbp], eax
  00106	0f 8d bf 00 00
	00		 jge	 $LN6@stbi__hdr_

; 1357 :             float z = (float)pow(data[i * comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

  0010c	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR stbi__h2l_gamma_i
  00114	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00117	0f af 85 b8 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  0011e	03 45 24	 add	 eax, DWORD PTR k$[rbp]
  00121	48 98		 cdqe
  00123	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0012a	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [rcx+rax*4]
  0012f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR stbi__h2l_scale_i
  00137	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  0013b	f2 0f 11 8d 78
	01 00 00	 movsd	 QWORD PTR tv93[rbp], xmm1
  00143	0f 28 c8	 movaps	 xmm1, xmm0
  00146	f2 0f 10 85 78
	01 00 00	 movsd	 xmm0, QWORD PTR tv93[rbp]
  0014e	e8 00 00 00 00	 call	 pow
  00153	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00157	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0015f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00167	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR z$1[rbp], xmm0

; 1358 :             if (z < 0) z = 0;

  0016f	0f 57 c0	 xorps	 xmm0, xmm0
  00172	0f 2f 85 84 00
	00 00		 comiss	 xmm0, DWORD PTR z$1[rbp]
  00179	76 0b		 jbe	 SHORT $LN12@stbi__hdr_
  0017b	0f 57 c0	 xorps	 xmm0, xmm0
  0017e	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR z$1[rbp], xmm0
$LN12@stbi__hdr_:

; 1359 :             if (z > 255) z = 255;

  00186	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR z$1[rbp]
  0018e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00195	76 10		 jbe	 SHORT $LN13@stbi__hdr_
  00197	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0019f	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR z$1[rbp], xmm0
$LN13@stbi__hdr_:

; 1360 :             output[i * comp + k] = (stbi_uc)stbi__float2int(z);

  001a7	f3 0f 2c 85 84
	00 00 00	 cvttss2si eax, DWORD PTR z$1[rbp]
  001af	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  001b2	0f af 8d b8 01
	00 00		 imul	 ecx, DWORD PTR comp$[rbp]
  001b9	03 4d 24	 add	 ecx, DWORD PTR k$[rbp]
  001bc	48 63 c9	 movsxd	 rcx, ecx
  001bf	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  001c3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1361 :         }

  001c6	e9 2d ff ff ff	 jmp	 $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1362 :         if (k < comp) {

  001cb	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  001d1	39 45 24	 cmp	 DWORD PTR k$[rbp], eax
  001d4	0f 8d 8a 00 00
	00		 jge	 $LN14@stbi__hdr_

; 1363 :             float z = data[i * comp + k] * 255 + 0.5f;

  001da	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001dd	0f af 85 b8 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  001e4	03 45 24	 add	 eax, DWORD PTR k$[rbp]
  001e7	48 98		 cdqe
  001e9	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001f0	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  001f5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001fd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00205	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR z$2[rbp], xmm0

; 1364 :             if (z < 0) z = 0;

  0020d	0f 57 c0	 xorps	 xmm0, xmm0
  00210	0f 2f 85 a4 00
	00 00		 comiss	 xmm0, DWORD PTR z$2[rbp]
  00217	76 0b		 jbe	 SHORT $LN15@stbi__hdr_
  00219	0f 57 c0	 xorps	 xmm0, xmm0
  0021c	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR z$2[rbp], xmm0
$LN15@stbi__hdr_:

; 1365 :             if (z > 255) z = 255;

  00224	f3 0f 10 85 a4
	00 00 00	 movss	 xmm0, DWORD PTR z$2[rbp]
  0022c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00233	76 10		 jbe	 SHORT $LN16@stbi__hdr_
  00235	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0023d	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR z$2[rbp], xmm0
$LN16@stbi__hdr_:

; 1366 :             output[i * comp + k] = (stbi_uc)stbi__float2int(z);

  00245	f3 0f 2c 85 a4
	00 00 00	 cvttss2si eax, DWORD PTR z$2[rbp]
  0024d	8b 4d 04	 mov	 ecx, DWORD PTR i$[rbp]
  00250	0f af 8d b8 01
	00 00		 imul	 ecx, DWORD PTR comp$[rbp]
  00257	03 4d 24	 add	 ecx, DWORD PTR k$[rbp]
  0025a	48 63 c9	 movsxd	 rcx, ecx
  0025d	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  00261	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@stbi__hdr_:

; 1367 :         }
; 1368 :     }

  00264	e9 68 fe ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1369 :     STBI_FREE(data);

  00269	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1370 :     return output;

  00276	48 8b 45 68	 mov	 rax, QWORD PTR output$[rbp]
$LN1@stbi__hdr_:

; 1371 : }

  0027a	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  00281	5f		 pop	 rdi
  00282	5d		 pop	 rbp
  00283	c3		 ret	 0
stbi__hdr_to_ldr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__ldr_to_hdr
_TEXT	SEGMENT
i$ = 4
k$ = 36
n$ = 68
output$ = 104
tv133 = 312
tv76 = 312
data$ = 352
x$ = 360
y$ = 368
comp$ = 376
stbi__ldr_to_hdr PROC					; COMDAT

; 1321 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1322 :     int i, k, n;
; 1323 :     float* output;
; 1324 :     if (!data) return NULL;

  0002d	48 83 bd 60 01
	00 00 00	 cmp	 QWORD PTR data$[rbp], 0
  00035	75 07		 jne	 SHORT $LN11@stbi__ldr_
  00037	33 c0		 xor	 eax, eax
  00039	e9 d0 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN11@stbi__ldr_:

; 1325 :     output = (float*)stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00046	41 b9 04 00 00
	00		 mov	 r9d, 4
  0004c	44 8b 85 78 01
	00 00		 mov	 r8d, DWORD PTR comp$[rbp]
  00053	8b 95 70 01 00
	00		 mov	 edx, DWORD PTR y$[rbp]
  00059	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR x$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__malloc_mad4
  00064	48 89 45 68	 mov	 QWORD PTR output$[rbp], rax

; 1326 :     if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

  00068	48 83 7d 68 00	 cmp	 QWORD PTR output$[rbp], 0
  0006d	75 41		 jne	 SHORT $LN12@stbi__ldr_
  0006f	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00083	e8 00 00 00 00	 call	 stbi__err
  00088	85 c0		 test	 eax, eax
  0008a	74 0d		 je	 SHORT $LN17@stbi__ldr_
  0008c	48 c7 85 38 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv76[rbp], 0
  00097	eb 0b		 jmp	 SHORT $LN18@stbi__ldr_
$LN17@stbi__ldr_:
  00099	48 c7 85 38 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv76[rbp], 0
$LN18@stbi__ldr_:
  000a4	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR tv76[rbp]
  000ab	e9 5e 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN12@stbi__ldr_:

; 1327 :     // compute number of non-alpha components
; 1328 :     if (comp & 1) n = comp; else n = comp - 1;

  000b0	8b 85 78 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000b6	83 e0 01	 and	 eax, 1
  000b9	85 c0		 test	 eax, eax
  000bb	74 0b		 je	 SHORT $LN13@stbi__ldr_
  000bd	8b 85 78 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000c3	89 45 44	 mov	 DWORD PTR n$[rbp], eax
  000c6	eb 0b		 jmp	 SHORT $LN14@stbi__ldr_
$LN13@stbi__ldr_:
  000c8	8b 85 78 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  000ce	ff c8		 dec	 eax
  000d0	89 45 44	 mov	 DWORD PTR n$[rbp], eax
$LN14@stbi__ldr_:

; 1329 :     for (i = 0; i < x * y; ++i) {

  000d3	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  000da	eb 08		 jmp	 SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
  000dc	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  000df	ff c0		 inc	 eax
  000e1	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__ldr_:
  000e4	8b 85 68 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  000ea	0f af 85 70 01
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  000f1	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  000f4	0f 8d 95 00 00
	00		 jge	 $LN3@stbi__ldr_

; 1330 :         for (k = 0; k < n; ++k) {

  000fa	c7 45 24 00 00
	00 00		 mov	 DWORD PTR k$[rbp], 0
  00101	eb 08		 jmp	 SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
  00103	8b 45 24	 mov	 eax, DWORD PTR k$[rbp]
  00106	ff c0		 inc	 eax
  00108	89 45 24	 mov	 DWORD PTR k$[rbp], eax
$LN7@stbi__ldr_:
  0010b	8b 45 44	 mov	 eax, DWORD PTR n$[rbp]
  0010e	39 45 24	 cmp	 DWORD PTR k$[rbp], eax
  00111	7d 77		 jge	 SHORT $LN6@stbi__ldr_

; 1331 :             output[i * comp + k] = (float)(pow(data[i * comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

  00113	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR stbi__l2h_gamma
  0011b	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  0011e	0f af 85 78 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  00125	03 45 24	 add	 eax, DWORD PTR k$[rbp]
  00128	48 98		 cdqe
  0012a	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00131	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00135	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00139	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00141	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00145	f2 0f 11 8d 38
	01 00 00	 movsd	 QWORD PTR tv133[rbp], xmm1
  0014d	0f 28 c8	 movaps	 xmm1, xmm0
  00150	f2 0f 10 85 38
	01 00 00	 movsd	 xmm0, QWORD PTR tv133[rbp]
  00158	e8 00 00 00 00	 call	 pow
  0015d	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR stbi__l2h_scale
  00165	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00169	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0016d	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  00170	0f af 85 78 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  00177	03 45 24	 add	 eax, DWORD PTR k$[rbp]
  0017a	48 98		 cdqe
  0017c	48 8b 4d 68	 mov	 rcx, QWORD PTR output$[rbp]
  00180	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1332 :         }

  00185	e9 79 ff ff ff	 jmp	 $LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1333 :     }

  0018a	e9 4d ff ff ff	 jmp	 $LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1334 :     if (n < comp) {

  0018f	8b 85 78 01 00
	00		 mov	 eax, DWORD PTR comp$[rbp]
  00195	39 45 44	 cmp	 DWORD PTR n$[rbp], eax
  00198	7d 63		 jge	 SHORT $LN15@stbi__ldr_

; 1335 :         for (i = 0; i < x * y; ++i) {

  0019a	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  001a1	eb 08		 jmp	 SHORT $LN10@stbi__ldr_
$LN8@stbi__ldr_:
  001a3	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001a6	ff c0		 inc	 eax
  001a8	89 45 04	 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__ldr_:
  001ab	8b 85 68 01 00
	00		 mov	 eax, DWORD PTR x$[rbp]
  001b1	0f af 85 70 01
	00 00		 imul	 eax, DWORD PTR y$[rbp]
  001b8	39 45 04	 cmp	 DWORD PTR i$[rbp], eax
  001bb	7d 40		 jge	 SHORT $LN9@stbi__ldr_

; 1336 :             output[i * comp + n] = data[i * comp + n] / 255.0f;

  001bd	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001c0	0f af 85 78 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  001c7	03 45 44	 add	 eax, DWORD PTR n$[rbp]
  001ca	48 98		 cdqe
  001cc	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001db	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  001e3	8b 45 04	 mov	 eax, DWORD PTR i$[rbp]
  001e6	0f af 85 78 01
	00 00		 imul	 eax, DWORD PTR comp$[rbp]
  001ed	03 45 44	 add	 eax, DWORD PTR n$[rbp]
  001f0	48 98		 cdqe
  001f2	48 8b 4d 68	 mov	 rcx, QWORD PTR output$[rbp]
  001f6	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1337 :         }

  001fb	eb a6		 jmp	 SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:
$LN15@stbi__ldr_:

; 1338 :     }
; 1339 :     STBI_FREE(data);

  001fd	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1340 :     return output;

  0020a	48 8b 45 68	 mov	 rax, QWORD PTR output$[rbp]
$LN1@stbi__ldr_:

; 1341 : }

  0020e	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  00215	5f		 pop	 rdi
  00216	5d		 pop	 rbp
  00217	c3		 ret	 0
stbi__ldr_to_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__mul2shorts_valid
_TEXT	SEGMENT
tv87 = 192
tv82 = 192
tv75 = 192
tv73 = 192
tv91 = 196
tv86 = 196
tv79 = 196
tv72 = 196
a$ = 240
b$ = 248
stbi__mul2shorts_valid PROC				; COMDAT

; 530  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 531  :     if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow

  00024	0f bf 85 f8 00
	00 00		 movsx	 eax, WORD PTR b$[rbp]
  0002b	85 c0		 test	 eax, eax
  0002d	74 0c		 je	 SHORT $LN3@stbi__mul2
  0002f	0f bf 85 f8 00
	00 00		 movsx	 eax, WORD PTR b$[rbp]
  00036	83 f8 ff	 cmp	 eax, -1
  00039	75 0a		 jne	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	e9 28 01 00 00	 jmp	 $LN1@stbi__mul2
$LN2@stbi__mul2:

; 532  :     if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX / b; // product is positive, so similar to mul2sizes_valid

  00045	0f bf 85 f0 00
	00 00		 movsx	 eax, WORD PTR a$[rbp]
  0004c	85 c0		 test	 eax, eax
  0004e	7c 0c		 jl	 SHORT $LN9@stbi__mul2
  00050	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
  0005a	eb 0a		 jmp	 SHORT $LN10@stbi__mul2
$LN9@stbi__mul2:
  0005c	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
$LN10@stbi__mul2:
  00066	0f bf 85 f8 00
	00 00		 movsx	 eax, WORD PTR b$[rbp]
  0006d	85 c0		 test	 eax, eax
  0006f	7c 0c		 jl	 SHORT $LN7@stbi__mul2
  00071	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv72[rbp], 1
  0007b	eb 0a		 jmp	 SHORT $LN8@stbi__mul2
$LN7@stbi__mul2:
  0007d	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv72[rbp], 0
$LN8@stbi__mul2:
  00087	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  0008d	39 85 c0 00 00
	00		 cmp	 DWORD PTR tv73[rbp], eax
  00093	75 47		 jne	 SHORT $LN4@stbi__mul2
  00095	0f bf 85 f0 00
	00 00		 movsx	 eax, WORD PTR a$[rbp]
  0009c	89 85 c0 00 00
	00		 mov	 DWORD PTR tv75[rbp], eax
  000a2	0f bf 8d f8 00
	00 00		 movsx	 ecx, WORD PTR b$[rbp]
  000a9	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000ae	99		 cdq
  000af	f7 f9		 idiv	 ecx
  000b1	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv75[rbp]
  000b7	3b c8		 cmp	 ecx, eax
  000b9	7f 0c		 jg	 SHORT $LN11@stbi__mul2
  000bb	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv79[rbp], 1
  000c5	eb 0a		 jmp	 SHORT $LN12@stbi__mul2
$LN11@stbi__mul2:
  000c7	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv79[rbp], 0
$LN12@stbi__mul2:
  000d1	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv79[rbp]
  000d7	e9 91 00 00 00	 jmp	 $LN1@stbi__mul2
$LN4@stbi__mul2:

; 533  :     if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN

  000dc	0f bf 85 f8 00
	00 00		 movsx	 eax, WORD PTR b$[rbp]
  000e3	85 c0		 test	 eax, eax
  000e5	7d 44		 jge	 SHORT $LN5@stbi__mul2
  000e7	0f bf 85 f0 00
	00 00		 movsx	 eax, WORD PTR a$[rbp]
  000ee	89 85 c0 00 00
	00		 mov	 DWORD PTR tv82[rbp], eax
  000f4	0f bf 8d f8 00
	00 00		 movsx	 ecx, WORD PTR b$[rbp]
  000fb	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  00100	99		 cdq
  00101	f7 f9		 idiv	 ecx
  00103	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv82[rbp]
  00109	3b c8		 cmp	 ecx, eax
  0010b	7f 0c		 jg	 SHORT $LN13@stbi__mul2
  0010d	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv86[rbp], 1
  00117	eb 0a		 jmp	 SHORT $LN14@stbi__mul2
$LN13@stbi__mul2:
  00119	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv86[rbp], 0
$LN14@stbi__mul2:
  00123	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv86[rbp]
  00129	eb 42		 jmp	 SHORT $LN1@stbi__mul2
$LN5@stbi__mul2:

; 534  :     return a >= SHRT_MIN / b;

  0012b	0f bf 85 f0 00
	00 00		 movsx	 eax, WORD PTR a$[rbp]
  00132	89 85 c0 00 00
	00		 mov	 DWORD PTR tv87[rbp], eax
  00138	0f bf 8d f8 00
	00 00		 movsx	 ecx, WORD PTR b$[rbp]
  0013f	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  00144	99		 cdq
  00145	f7 f9		 idiv	 ecx
  00147	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv87[rbp]
  0014d	3b c8		 cmp	 ecx, eax
  0014f	7c 0c		 jl	 SHORT $LN15@stbi__mul2
  00151	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv91[rbp], 1
  0015b	eb 0a		 jmp	 SHORT $LN16@stbi__mul2
$LN15@stbi__mul2:
  0015d	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv91[rbp], 0
$LN16@stbi__mul2:
  00167	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv91[rbp]
$LN1@stbi__mul2:

; 535  : }

  0016d	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00174	5f		 pop	 rdi
  00175	5d		 pop	 rbp
  00176	c3		 ret	 0
stbi__mul2shorts_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__addints_valid
_TEXT	SEGMENT
tv76 = 192
tv73 = 192
tv67 = 192
tv66 = 196
a$ = 240
b$ = 248
stbi__addints_valid PROC				; COMDAT

; 522  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 523  :     if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

  00022	83 bd f0 00 00
	00 00		 cmp	 DWORD PTR a$[rbp], 0
  00029	7c 0c		 jl	 SHORT $LN7@stbi__addi
  0002b	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
  00035	eb 0a		 jmp	 SHORT $LN8@stbi__addi
$LN7@stbi__addi:
  00037	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN8@stbi__addi:
  00041	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR b$[rbp], 0
  00048	7c 0c		 jl	 SHORT $LN5@stbi__addi
  0004a	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv66[rbp], 1
  00054	eb 0a		 jmp	 SHORT $LN6@stbi__addi
$LN5@stbi__addi:
  00056	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv66[rbp], 0
$LN6@stbi__addi:
  00060	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv66[rbp]
  00066	39 85 c0 00 00
	00		 cmp	 DWORD PTR tv67[rbp], eax
  0006c	74 07		 je	 SHORT $LN2@stbi__addi
  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	eb 72		 jmp	 SHORT $LN1@stbi__addi
$LN2@stbi__addi:

; 524  :     if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.

  00075	83 bd f0 00 00
	00 00		 cmp	 DWORD PTR a$[rbp], 0
  0007c	7d 3a		 jge	 SHORT $LN3@stbi__addi
  0007e	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR b$[rbp], 0
  00085	7d 31		 jge	 SHORT $LN3@stbi__addi
  00087	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0008c	2b 85 f8 00 00
	00		 sub	 eax, DWORD PTR b$[rbp]
  00092	39 85 f0 00 00
	00		 cmp	 DWORD PTR a$[rbp], eax
  00098	7c 0c		 jl	 SHORT $LN9@stbi__addi
  0009a	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
  000a4	eb 0a		 jmp	 SHORT $LN10@stbi__addi
$LN9@stbi__addi:
  000a6	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
$LN10@stbi__addi:
  000b0	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv73[rbp]
  000b6	eb 2f		 jmp	 SHORT $LN1@stbi__addi
$LN3@stbi__addi:

; 525  :     return a <= INT_MAX - b;

  000b8	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000bd	2b 85 f8 00 00
	00		 sub	 eax, DWORD PTR b$[rbp]
  000c3	39 85 f0 00 00
	00		 cmp	 DWORD PTR a$[rbp], eax
  000c9	7f 0c		 jg	 SHORT $LN11@stbi__addi
  000cb	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv76[rbp], 1
  000d5	eb 0a		 jmp	 SHORT $LN12@stbi__addi
$LN11@stbi__addi:
  000d7	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv76[rbp], 0
$LN12@stbi__addi:
  000e1	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv76[rbp]
$LN1@stbi__addi:

; 526  : }

  000e7	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000ee	5f		 pop	 rdi
  000ef	5d		 pop	 rbp
  000f0	c3		 ret	 0
stbi__addints_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__malloc_mad4
_TEXT	SEGMENT
a$ = 224
b$ = 232
c$ = 240
d$ = 248
add$ = 256
stbi__malloc_mad4 PROC					; COMDAT

; 514  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 515  :     if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

  0002c	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR add$[rbp]
  00032	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00036	44 8b 8d f8 00
	00 00		 mov	 r9d, DWORD PTR d$[rbp]
  0003d	44 8b 85 f0 00
	00 00		 mov	 r8d, DWORD PTR c$[rbp]
  00044	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  0004a	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00050	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00055	85 c0		 test	 eax, eax
  00057	75 04		 jne	 SHORT $LN2@stbi__mall
  00059	33 c0		 xor	 eax, eax
  0005b	eb 2b		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 516  :     return stbi__malloc(a * b * c * d + add);

  0005d	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00063	0f af 85 e8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  0006a	0f af 85 f0 00
	00 00		 imul	 eax, DWORD PTR c$[rbp]
  00071	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR d$[rbp]
  00078	03 85 00 01 00
	00		 add	 eax, DWORD PTR add$[rbp]
  0007e	48 98		 cdqe
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 517  : }

  00088	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
stbi__malloc_mad4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__malloc_mad3
_TEXT	SEGMENT
a$ = 224
b$ = 232
c$ = 240
add$ = 248
stbi__malloc_mad3 PROC					; COMDAT

; 507  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 508  :     if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

  0002c	44 8b 8d f8 00
	00 00		 mov	 r9d, DWORD PTR add$[rbp]
  00033	44 8b 85 f0 00
	00 00		 mov	 r8d, DWORD PTR c$[rbp]
  0003a	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  00040	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00046	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  0004b	85 c0		 test	 eax, eax
  0004d	75 04		 jne	 SHORT $LN2@stbi__mall
  0004f	33 c0		 xor	 eax, eax
  00051	eb 24		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 509  :     return stbi__malloc(a * b * c + add);

  00053	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00059	0f af 85 e8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  00060	0f af 85 f0 00
	00 00		 imul	 eax, DWORD PTR c$[rbp]
  00067	03 85 f8 00 00
	00		 add	 eax, DWORD PTR add$[rbp]
  0006d	48 98		 cdqe
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 510  : }

  00077	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0007e	5f		 pop	 rdi
  0007f	5d		 pop	 rbp
  00080	c3		 ret	 0
stbi__malloc_mad3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__malloc_mad2
_TEXT	SEGMENT
a$ = 224
b$ = 232
add$ = 240
stbi__malloc_mad2 PROC					; COMDAT

; 500  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 501  :     if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

  00027	44 8b 85 f0 00
	00 00		 mov	 r8d, DWORD PTR add$[rbp]
  0002e	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  00034	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  0003a	e8 00 00 00 00	 call	 stbi__mad2sizes_valid
  0003f	85 c0		 test	 eax, eax
  00041	75 04		 jne	 SHORT $LN2@stbi__mall
  00043	33 c0		 xor	 eax, eax
  00045	eb 1d		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 502  :     return stbi__malloc(a * b + add);

  00047	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0004d	0f af 85 e8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  00054	03 85 f0 00 00
	00		 add	 eax, DWORD PTR add$[rbp]
  0005a	48 98		 cdqe
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 503  : }

  00064	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
stbi__malloc_mad2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__mad4sizes_valid
_TEXT	SEGMENT
tv86 = 192
a$ = 240
b$ = 248
c$ = 256
d$ = 264
add$ = 272
stbi__mad4sizes_valid PROC				; COMDAT

; 491  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 492  :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&

  0002c	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  00032	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00038	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  0003d	85 c0		 test	 eax, eax
  0003f	74 7b		 je	 SHORT $LN3@stbi__mad4
  00041	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00047	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  0004e	8b 95 00 01 00
	00		 mov	 edx, DWORD PTR c$[rbp]
  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  0005b	85 c0		 test	 eax, eax
  0005d	74 5d		 je	 SHORT $LN3@stbi__mad4
  0005f	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00065	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  0006c	0f af 85 00 01
	00 00		 imul	 eax, DWORD PTR c$[rbp]
  00073	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR d$[rbp]
  00079	8b c8		 mov	 ecx, eax
  0007b	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00080	85 c0		 test	 eax, eax
  00082	74 38		 je	 SHORT $LN3@stbi__mad4
  00084	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0008a	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  00091	0f af 85 00 01
	00 00		 imul	 eax, DWORD PTR c$[rbp]
  00098	0f af 85 08 01
	00 00		 imul	 eax, DWORD PTR d$[rbp]
  0009f	8b 95 10 01 00
	00		 mov	 edx, DWORD PTR add$[rbp]
  000a5	8b c8		 mov	 ecx, eax
  000a7	e8 00 00 00 00	 call	 stbi__addsizes_valid
  000ac	85 c0		 test	 eax, eax
  000ae	74 0c		 je	 SHORT $LN3@stbi__mad4
  000b0	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv86[rbp], 1
  000ba	eb 0a		 jmp	 SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
  000bc	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv86[rbp], 0
$LN4@stbi__mad4:
  000c6	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv86[rbp]

; 493  :         stbi__mul2sizes_valid(a * b * c, d) && stbi__addsizes_valid(a * b * c * d, add);
; 494  : }

  000cc	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000d3	5f		 pop	 rdi
  000d4	5d		 pop	 rbp
  000d5	c3		 ret	 0
stbi__mad4sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__mad3sizes_valid
_TEXT	SEGMENT
tv79 = 192
a$ = 240
b$ = 248
c$ = 256
add$ = 264
stbi__mad3sizes_valid PROC				; COMDAT

; 483  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 484  :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&

  0002c	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  00032	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00038	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  0003d	85 c0		 test	 eax, eax
  0003f	74 4f		 je	 SHORT $LN3@stbi__mad3
  00041	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00047	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  0004e	8b 95 00 01 00
	00		 mov	 edx, DWORD PTR c$[rbp]
  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  0005b	85 c0		 test	 eax, eax
  0005d	74 31		 je	 SHORT $LN3@stbi__mad3
  0005f	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00065	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  0006c	0f af 85 00 01
	00 00		 imul	 eax, DWORD PTR c$[rbp]
  00073	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR add$[rbp]
  00079	8b c8		 mov	 ecx, eax
  0007b	e8 00 00 00 00	 call	 stbi__addsizes_valid
  00080	85 c0		 test	 eax, eax
  00082	74 0c		 je	 SHORT $LN3@stbi__mad3
  00084	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv79[rbp], 1
  0008e	eb 0a		 jmp	 SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
  00090	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv79[rbp], 0
$LN4@stbi__mad3:
  0009a	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv79[rbp]

; 485  :         stbi__addsizes_valid(a * b * c, add);
; 486  : }

  000a0	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000a7	5f		 pop	 rdi
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
stbi__mad3sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__mad2sizes_valid
_TEXT	SEGMENT
tv73 = 192
a$ = 240
b$ = 248
add$ = 256
stbi__mad2sizes_valid PROC				; COMDAT

; 476  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 477  :     return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a * b, add);

  00027	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR b$[rbp]
  0002d	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00033	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00038	85 c0		 test	 eax, eax
  0003a	74 2a		 je	 SHORT $LN3@stbi__mad2
  0003c	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00042	0f af 85 f8 00
	00 00		 imul	 eax, DWORD PTR b$[rbp]
  00049	8b 95 00 01 00
	00		 mov	 edx, DWORD PTR add$[rbp]
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 stbi__addsizes_valid
  00056	85 c0		 test	 eax, eax
  00058	74 0c		 je	 SHORT $LN3@stbi__mad2
  0005a	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
  00064	eb 0a		 jmp	 SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
  00066	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
$LN4@stbi__mad2:
  00070	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv73[rbp]

; 478  : }

  00076	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0007d	5f		 pop	 rdi
  0007e	5d		 pop	 rbp
  0007f	c3		 ret	 0
stbi__mad2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__mul2sizes_valid
_TEXT	SEGMENT
tv69 = 192
a$ = 240
b$ = 248
stbi__mul2sizes_valid PROC				; COMDAT

; 466  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 467  :     if (a < 0 || b < 0) return 0;

  00022	83 bd f0 00 00
	00 00		 cmp	 DWORD PTR a$[rbp], 0
  00029	7c 09		 jl	 SHORT $LN3@stbi__mul2
  0002b	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR b$[rbp], 0
  00032	7d 04		 jge	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  00034	33 c0		 xor	 eax, eax
  00036	eb 40		 jmp	 SHORT $LN1@stbi__mul2
$LN2@stbi__mul2:

; 468  :     if (b == 0) return 1; // mul-by-0 is always safe

  00038	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR b$[rbp], 0
  0003f	75 07		 jne	 SHORT $LN4@stbi__mul2
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	eb 30		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 469  :     // portable way to check for no overflows in a*b
; 470  :     return a <= INT_MAX / b;

  00048	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0004d	99		 cdq
  0004e	f7 bd f8 00 00
	00		 idiv	 DWORD PTR b$[rbp]
  00054	39 85 f0 00 00
	00		 cmp	 DWORD PTR a$[rbp], eax
  0005a	7f 0c		 jg	 SHORT $LN6@stbi__mul2
  0005c	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv69[rbp], 1
  00066	eb 0a		 jmp	 SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
  00068	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv69[rbp], 0
$LN7@stbi__mul2:
  00072	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv69[rbp]
$LN1@stbi__mul2:

; 471  : }

  00078	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0007f	5f		 pop	 rdi
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
stbi__mul2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__addsizes_valid
_TEXT	SEGMENT
tv67 = 192
a$ = 240
b$ = 248
stbi__addsizes_valid PROC				; COMDAT

; 454  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 455  :     if (b < 0) return 0;

  00022	83 bd f8 00 00
	00 00		 cmp	 DWORD PTR b$[rbp], 0
  00029	7d 04		 jge	 SHORT $LN2@stbi__adds
  0002b	33 c0		 xor	 eax, eax
  0002d	eb 2f		 jmp	 SHORT $LN1@stbi__adds
$LN2@stbi__adds:

; 456  :     // now 0 <= b <= INT_MAX, hence also
; 457  :     // 0 <= INT_MAX - b <= INTMAX.
; 458  :     // And "a + b <= INT_MAX" (which might overflow) is the
; 459  :     // same as a <= INT_MAX - b (no overflow)
; 460  :     return a <= INT_MAX - b;

  0002f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00034	2b 85 f8 00 00
	00		 sub	 eax, DWORD PTR b$[rbp]
  0003a	39 85 f0 00 00
	00		 cmp	 DWORD PTR a$[rbp], eax
  00040	7f 0c		 jg	 SHORT $LN4@stbi__adds
  00042	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
  0004c	eb 0a		 jmp	 SHORT $LN5@stbi__adds
$LN4@stbi__adds:
  0004e	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN5@stbi__adds:
  00058	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
$LN1@stbi__adds:

; 461  : }

  0005e	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00065	5f		 pop	 rdi
  00066	5d		 pop	 rbp
  00067	c3		 ret	 0
stbi__addsizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__malloc
_TEXT	SEGMENT
size$ = 224
stbi__malloc PROC					; COMDAT

; 437  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 438  :     return STBI_MALLOC(size);

  0001f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR size$[rbp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 439  : }

  0002c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00033	5f		 pop	 rdi
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
stbi__malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__err
_TEXT	SEGMENT
str$ = 224
stbi__err PROC						; COMDAT

; 430  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 431  :     stbi__g_failure_reason = str;

  0001f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  00024	8b c0		 mov	 eax, eax
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00035	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00039	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  00040	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 432  :     return 0;

  00044	33 c0		 xor	 eax, eax

; 433  : }

  00046	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004d	5f		 pop	 rdi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
stbi__err ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_is16
_TEXT	SEGMENT
s$ = 224
stbi__pnm_is16 PROC					; COMDAT

; 7194 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7195 :     if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)

  0001f	45 33 c9	 xor	 r9d, r9d
  00022	45 33 c0	 xor	 r8d, r8d
  00025	33 d2		 xor	 edx, edx
  00027	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002e	e8 00 00 00 00	 call	 stbi__pnm_info
  00033	83 f8 10	 cmp	 eax, 16
  00036	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7196 :         return 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	eb 02		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7197 :     return 0;

  0003f	33 c0		 xor	 eax, eax
$LN1@stbi__pnm_:

; 7198 : }

  00041	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00048	5f		 pop	 rdi
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
stbi__pnm_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_info
_TEXT	SEGMENT
maxv$ = 4
dummy$ = 36
c$ = 68
p$ = 100
t$ = 132
tv81 = 340
__$ArrayPad$ = 344
s$ = 384
x$ = 392
y$ = 400
comp$ = 408
stbi__pnm_info PROC					; COMDAT

; 7151 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 58 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7152 :     int maxv, dummy;
; 7153 :     char c, p, t;
; 7154 : 
; 7155 :     if (!x) x = &dummy;

  00058	48 83 bd 88 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00060	75 0b		 jne	 SHORT $LN2@stbi__pnm_
  00062	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  00066	48 89 85 88 01
	00 00		 mov	 QWORD PTR x$[rbp], rax
$LN2@stbi__pnm_:

; 7156 :     if (!y) y = &dummy;

  0006d	48 83 bd 90 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00075	75 0b		 jne	 SHORT $LN3@stbi__pnm_
  00077	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  0007b	48 89 85 90 01
	00 00		 mov	 QWORD PTR y$[rbp], rax
$LN3@stbi__pnm_:

; 7157 :     if (!comp) comp = &dummy;

  00082	48 83 bd 98 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  0008a	75 0b		 jne	 SHORT $LN4@stbi__pnm_
  0008c	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  00090	48 89 85 98 01
	00 00		 mov	 QWORD PTR comp$[rbp], rax
$LN4@stbi__pnm_:

; 7158 : 
; 7159 :     stbi__rewind(s);

  00097	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009e	e8 00 00 00 00	 call	 stbi__rewind

; 7160 : 
; 7161 :     // Get identifier
; 7162 :     p = (char)stbi__get8(s);

  000a3	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000aa	e8 00 00 00 00	 call	 stbi__get8
  000af	88 45 64	 mov	 BYTE PTR p$[rbp], al

; 7163 :     t = (char)stbi__get8(s);

  000b2	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b9	e8 00 00 00 00	 call	 stbi__get8
  000be	88 85 84 00 00
	00		 mov	 BYTE PTR t$[rbp], al

; 7164 :     if (p != 'P' || (t != '5' && t != '6')) {

  000c4	0f be 45 64	 movsx	 eax, BYTE PTR p$[rbp]
  000c8	83 f8 50	 cmp	 eax, 80			; 00000050H
  000cb	75 18		 jne	 SHORT $LN6@stbi__pnm_
  000cd	0f be 85 84 00
	00 00		 movsx	 eax, BYTE PTR t$[rbp]
  000d4	83 f8 35	 cmp	 eax, 53			; 00000035H
  000d7	74 1f		 je	 SHORT $LN5@stbi__pnm_
  000d9	0f be 85 84 00
	00 00		 movsx	 eax, BYTE PTR t$[rbp]
  000e0	83 f8 36	 cmp	 eax, 54			; 00000036H
  000e3	74 13		 je	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7165 :         stbi__rewind(s);

  000e5	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ec	e8 00 00 00 00	 call	 stbi__rewind

; 7166 :         return 0;

  000f1	33 c0		 xor	 eax, eax
  000f3	e9 1c 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7167 :     }
; 7168 : 
; 7169 :     *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

  000f8	0f be 85 84 00
	00 00		 movsx	 eax, BYTE PTR t$[rbp]
  000ff	83 f8 36	 cmp	 eax, 54			; 00000036H
  00102	75 0c		 jne	 SHORT $LN14@stbi__pnm_
  00104	c7 85 54 01 00
	00 03 00 00 00	 mov	 DWORD PTR tv81[rbp], 3
  0010e	eb 0a		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  00110	c7 85 54 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv81[rbp], 1
$LN15@stbi__pnm_:
  0011a	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00121	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR tv81[rbp]
  00127	89 08		 mov	 DWORD PTR [rax], ecx

; 7170 : 
; 7171 :     c = (char)stbi__get8(s);

  00129	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00130	e8 00 00 00 00	 call	 stbi__get8
  00135	88 45 44	 mov	 BYTE PTR c$[rbp], al

; 7172 :     stbi__pnm_skip_whitespace(s, &c);

  00138	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  0013c	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00143	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7173 : 
; 7174 :     *x = stbi__pnm_getinteger(s, &c); // read width

  00148	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  0014c	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00153	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  00158	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  0015f	89 01		 mov	 DWORD PTR [rcx], eax

; 7175 :     if (*x == 0)

  00161	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00168	83 38 00	 cmp	 DWORD PTR [rax], 0
  0016b	75 11		 jne	 SHORT $LN7@stbi__pnm_

; 7176 :         return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  00174	e8 00 00 00 00	 call	 stbi__err
  00179	e9 96 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7177 :     stbi__pnm_skip_whitespace(s, &c);

  0017e	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  00182	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00189	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7178 : 
; 7179 :     *y = stbi__pnm_getinteger(s, &c); // read height

  0018e	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  00192	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00199	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  0019e	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  001a5	89 01		 mov	 DWORD PTR [rcx], eax

; 7180 :     if (*y == 0)

  001a7	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  001ae	83 38 00	 cmp	 DWORD PTR [rax], 0
  001b1	75 0e		 jne	 SHORT $LN8@stbi__pnm_

; 7181 :         return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  001ba	e8 00 00 00 00	 call	 stbi__err
  001bf	eb 53		 jmp	 SHORT $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7182 :     stbi__pnm_skip_whitespace(s, &c);

  001c1	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  001c5	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001cc	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7183 : 
; 7184 :     maxv = stbi__pnm_getinteger(s, &c);  // read max value

  001d1	48 8d 55 44	 lea	 rdx, QWORD PTR c$[rbp]
  001d5	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001dc	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  001e1	89 45 04	 mov	 DWORD PTR maxv$[rbp], eax

; 7185 :     if (maxv > 65535)

  001e4	81 7d 04 ff ff
	00 00		 cmp	 DWORD PTR maxv$[rbp], 65535 ; 0000ffffH
  001eb	7e 10		 jle	 SHORT $LN9@stbi__pnm_

; 7186 :         return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");

  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
  001f4	e8 00 00 00 00	 call	 stbi__err
  001f9	eb 19		 jmp	 SHORT $LN1@stbi__pnm_
  001fb	eb 17		 jmp	 SHORT $LN10@stbi__pnm_
$LN9@stbi__pnm_:

; 7187 :     else if (maxv > 255)

  001fd	81 7d 04 ff 00
	00 00		 cmp	 DWORD PTR maxv$[rbp], 255 ; 000000ffH
  00204	7e 09		 jle	 SHORT $LN11@stbi__pnm_

; 7188 :         return 16;

  00206	b8 10 00 00 00	 mov	 eax, 16
  0020b	eb 07		 jmp	 SHORT $LN1@stbi__pnm_
  0020d	eb 05		 jmp	 SHORT $LN12@stbi__pnm_
$LN11@stbi__pnm_:

; 7189 :     else
; 7190 :         return 8;

  0020f	b8 08 00 00 00	 mov	 eax, 8
$LN12@stbi__pnm_:
$LN10@stbi__pnm_:
$LN1@stbi__pnm_:

; 7191 : }

  00214	48 8b f8	 mov	 rdi, rax
  00217	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0021b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pnm_info$rtcFrameData
  00222	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00227	48 8b c7	 mov	 rax, rdi
  0022a	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00231	48 33 cd	 xor	 rcx, rbp
  00234	e8 00 00 00 00	 call	 __security_check_cookie
  00239	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  00240	5f		 pop	 rdi
  00241	5d		 pop	 rbp
  00242	c3		 ret	 0
stbi__pnm_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_load
_TEXT	SEGMENT
out$ = 8
tv160 = 212
tv172 = 216
tv154 = 216
tv138 = 216
tv86 = 216
tv80 = 216
s$ = 256
x$ = 264
y$ = 272
comp$ = 280
req_comp$ = 288
ri$ = 296
stbi__pnm_load PROC					; COMDAT

; 7075 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7076 :     stbi_uc* out;
; 7077 :     STBI_NOTUSED(ri);
; 7078 : 
; 7079 :     ri->bits_per_channel = stbi__pnm_info(s, (int*)&s->img_x, (int*)&s->img_y, (int*)&s->img_n);

  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00035	48 83 c0 08	 add	 rax, 8
  00039	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00040	48 83 c1 04	 add	 rcx, 4
  00044	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR s$[rbp]
  0004b	4c 8b c8	 mov	 r9, rax
  0004e	4c 8b c1	 mov	 r8, rcx
  00051	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00058	e8 00 00 00 00	 call	 stbi__pnm_info
  0005d	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR ri$[rbp]
  00064	89 01		 mov	 DWORD PTR [rcx], eax

; 7080 :     if (ri->bits_per_channel == 0)

  00066	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  0006d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00070	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7081 :         return 0;

  00072	33 c0		 xor	 eax, eax
  00074	e9 05 03 00 00	 jmp	 $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7082 : 
; 7083 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  00079	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00080	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00087	76 34		 jbe	 SHORT $LN3@stbi__pnm_
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00090	e8 00 00 00 00	 call	 stbi__err
  00095	85 c0		 test	 eax, eax
  00097	74 0d		 je	 SHORT $LN14@stbi__pnm_
  00099	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv80[rbp], 0
  000a4	eb 0b		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  000a6	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv80[rbp], 0
$LN15@stbi__pnm_:
  000b1	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv80[rbp]
  000b8	e9 c1 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 7084 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  000bd	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000c4	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000ca	76 34		 jbe	 SHORT $LN4@stbi__pnm_
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  000d3	e8 00 00 00 00	 call	 stbi__err
  000d8	85 c0		 test	 eax, eax
  000da	74 0d		 je	 SHORT $LN16@stbi__pnm_
  000dc	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv86[rbp], 0
  000e7	eb 0b		 jmp	 SHORT $LN17@stbi__pnm_
$LN16@stbi__pnm_:
  000e9	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv86[rbp], 0
$LN17@stbi__pnm_:
  000f4	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv86[rbp]
  000fb	e9 7e 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7085 : 
; 7086 :     *x = s->img_x;

  00100	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00107	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0010e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00110	89 08		 mov	 DWORD PTR [rax], ecx

; 7087 :     *y = s->img_y;

  00112	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00119	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00120	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00123	89 08		 mov	 DWORD PTR [rax], ecx

; 7088 :     if (comp) *comp = s->img_n;

  00125	48 83 bd 18 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  0012d	74 13		 je	 SHORT $LN5@stbi__pnm_
  0012f	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00136	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0013d	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00140	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__pnm_:

; 7089 : 
; 7090 :     if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))

  00142	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00149	8b 00		 mov	 eax, DWORD PTR [rax]
  0014b	99		 cdq
  0014c	83 e2 07	 and	 edx, 7
  0014f	03 c2		 add	 eax, edx
  00151	c1 f8 03	 sar	 eax, 3
  00154	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0015c	44 8b c8	 mov	 r9d, eax
  0015f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00166	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0016a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00171	8b 10		 mov	 edx, DWORD PTR [rax]
  00173	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0017a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0017d	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00182	85 c0		 test	 eax, eax
  00184	75 34		 jne	 SHORT $LN6@stbi__pnm_

; 7091 :         return stbi__errpuc("too large", "PNM too large");

  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0018d	e8 00 00 00 00	 call	 stbi__err
  00192	85 c0		 test	 eax, eax
  00194	74 0d		 je	 SHORT $LN18@stbi__pnm_
  00196	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv138[rbp], 0
  001a1	eb 0b		 jmp	 SHORT $LN19@stbi__pnm_
$LN18@stbi__pnm_:
  001a3	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv138[rbp], 0
$LN19@stbi__pnm_:
  001ae	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv138[rbp]
  001b5	e9 c4 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN6@stbi__pnm_:

; 7092 : 
; 7093 :     out = (stbi_uc*)stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);

  001ba	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  001c1	8b 00		 mov	 eax, DWORD PTR [rax]
  001c3	99		 cdq
  001c4	83 e2 07	 and	 edx, 7
  001c7	03 c2		 add	 eax, edx
  001c9	c1 f8 03	 sar	 eax, 3
  001cc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001d4	44 8b c8	 mov	 r9d, eax
  001d7	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  001de	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  001e2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  001e9	8b 10		 mov	 edx, DWORD PTR [rax]
  001eb	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  001f2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001f5	e8 00 00 00 00	 call	 stbi__malloc_mad4
  001fa	48 89 45 08	 mov	 QWORD PTR out$[rbp], rax

; 7094 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  001fe	48 83 7d 08 00	 cmp	 QWORD PTR out$[rbp], 0
  00203	75 34		 jne	 SHORT $LN7@stbi__pnm_
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0020c	e8 00 00 00 00	 call	 stbi__err
  00211	85 c0		 test	 eax, eax
  00213	74 0d		 je	 SHORT $LN20@stbi__pnm_
  00215	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv154[rbp], 0
  00220	eb 0b		 jmp	 SHORT $LN21@stbi__pnm_
$LN20@stbi__pnm_:
  00222	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv154[rbp], 0
$LN21@stbi__pnm_:
  0022d	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv154[rbp]
  00234	e9 45 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7095 :     if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {

  00239	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00240	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00247	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0024a	0f af 01	 imul	 eax, DWORD PTR [rcx]
  0024d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00254	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00258	89 85 d4 00 00
	00		 mov	 DWORD PTR tv160[rbp], eax
  0025e	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR ri$[rbp]
  00265	8b 01		 mov	 eax, DWORD PTR [rcx]
  00267	99		 cdq
  00268	83 e2 07	 and	 edx, 7
  0026b	03 c2		 add	 eax, edx
  0026d	c1 f8 03	 sar	 eax, 3
  00270	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv160[rbp]
  00276	0f af c8	 imul	 ecx, eax
  00279	8b c1		 mov	 eax, ecx
  0027b	44 8b c0	 mov	 r8d, eax
  0027e	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00282	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00289	e8 00 00 00 00	 call	 stbi__getn
  0028e	85 c0		 test	 eax, eax
  00290	75 3e		 jne	 SHORT $LN8@stbi__pnm_

; 7096 :         STBI_FREE(out);

  00292	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7097 :         return stbi__errpuc("bad PNM", "PNM file truncated");

  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IDKIDMGJ@bad?5PNM@
  002a3	e8 00 00 00 00	 call	 stbi__err
  002a8	85 c0		 test	 eax, eax
  002aa	74 0d		 je	 SHORT $LN22@stbi__pnm_
  002ac	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv172[rbp], 0
  002b7	eb 0b		 jmp	 SHORT $LN23@stbi__pnm_
$LN22@stbi__pnm_:
  002b9	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv172[rbp], 0
$LN23@stbi__pnm_:
  002c4	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv172[rbp]
  002cb	e9 ae 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7098 :     }
; 7099 : 
; 7100 :     if (req_comp && req_comp != s->img_n) {

  002d0	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  002d7	0f 84 9d 00 00
	00		 je	 $LN9@stbi__pnm_
  002dd	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  002e4	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002e7	39 85 20 01 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  002ed	0f 84 87 00 00
	00		 je	 $LN9@stbi__pnm_

; 7101 :         if (ri->bits_per_channel == 16) {

  002f3	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  002fa	83 38 10	 cmp	 DWORD PTR [rax], 16
  002fd	75 38		 jne	 SHORT $LN10@stbi__pnm_

; 7102 :             out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, s->img_n, req_comp, s->img_x, s->img_y);

  002ff	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00306	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00309	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0030d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00314	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00317	44 8b 85 20 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  0031e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00325	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00328	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  0032c	e8 00 00 00 00	 call	 stbi__convert_format16
  00331	48 89 45 08	 mov	 QWORD PTR out$[rbp], rax

; 7103 :         }

  00335	eb 36		 jmp	 SHORT $LN11@stbi__pnm_
$LN10@stbi__pnm_:

; 7104 :         else {
; 7105 :             out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

  00337	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0033e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00341	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00345	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0034c	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0034f	44 8b 85 20 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00356	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0035d	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00360	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00364	e8 00 00 00 00	 call	 stbi__convert_format
  00369	48 89 45 08	 mov	 QWORD PTR out$[rbp], rax
$LN11@stbi__pnm_:

; 7106 :         }
; 7107 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  0036d	48 83 7d 08 00	 cmp	 QWORD PTR out$[rbp], 0
  00372	75 06		 jne	 SHORT $LN12@stbi__pnm_
  00374	48 8b 45 08	 mov	 rax, QWORD PTR out$[rbp]
  00378	eb 04		 jmp	 SHORT $LN1@stbi__pnm_
$LN12@stbi__pnm_:
$LN9@stbi__pnm_:

; 7108 :     }
; 7109 :     return out;

  0037a	48 8b 45 08	 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__pnm_:

; 7110 : }

  0037e	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00385	5f		 pop	 rdi
  00386	5d		 pop	 rbp
  00387	c3		 ret	 0
stbi__pnm_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pnm_test
_TEXT	SEGMENT
p$ = 4
t$ = 36
s$ = 288
stbi__pnm_test PROC					; COMDAT

; 7063 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7064 :     char p, t;
; 7065 :     p = (char)stbi__get8(s);

  0001f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get8
  0002b	88 45 04	 mov	 BYTE PTR p$[rbp], al

; 7066 :     t = (char)stbi__get8(s);

  0002e	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__get8
  0003a	88 45 24	 mov	 BYTE PTR t$[rbp], al

; 7067 :     if (p != 'P' || (t != '5' && t != '6')) {

  0003d	0f be 45 04	 movsx	 eax, BYTE PTR p$[rbp]
  00041	83 f8 50	 cmp	 eax, 80			; 00000050H
  00044	75 12		 jne	 SHORT $LN3@stbi__pnm_
  00046	0f be 45 24	 movsx	 eax, BYTE PTR t$[rbp]
  0004a	83 f8 35	 cmp	 eax, 53			; 00000035H
  0004d	74 19		 je	 SHORT $LN2@stbi__pnm_
  0004f	0f be 45 24	 movsx	 eax, BYTE PTR t$[rbp]
  00053	83 f8 36	 cmp	 eax, 54			; 00000036H
  00056	74 10		 je	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7068 :         stbi__rewind(s);

  00058	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__rewind

; 7069 :         return 0;

  00064	33 c0		 xor	 eax, eax
  00066	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7070 :     }
; 7071 :     return 1;

  00068	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pnm_:

; 7072 : }

  0006d	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00074	5f		 pop	 rdi
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
stbi__pnm_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_info
_TEXT	SEGMENT
s$ = 224
x$ = 232
y$ = 240
comp$ = 248
stbi__gif_info PROC					; COMDAT

; 6643 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6644 :     return stbi__gif_info_raw(s, x, y, comp);

  0002e	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00035	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0003c	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00043	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004a	e8 00 00 00 00	 call	 stbi__gif_info_raw

; 6645 : }

  0004f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00056	5f		 pop	 rdi
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
stbi__gif_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__load_gif_main
_TEXT	SEGMENT
layers$4 = 4
u$5 = 40
out$6 = 72
two_back$7 = 104
g$8 = 144
stride$9 = 35092
out_size$10 = 35124
delays_size$11 = 35156
tmp$12 = 35192
new_delays$13 = 35224
tv209 = 36776
tv136 = 36776
__$ArrayPad$ = 36784
s$ = 36832
delays$ = 36840
x$ = 36848
y$ = 36856
z$ = 36864
comp$ = 36872
req_comp$ = 36880
stbi__load_gif_main PROC				; COMDAT

; 6526 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	b8 f8 8f 00 00	 mov	 eax, 36856		; 00008ff8H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00028	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002d	b9 72 22 00 00	 mov	 ecx, 8818		; 00002272H
  00032	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00037	f3 ab		 rep stosd
  00039	48 8b 8c 24 18
	90 00 00	 mov	 rcx, QWORD PTR [rsp+36888]
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00048	48 33 c5	 xor	 rax, rbp
  0004b	48 89 85 b0 8f
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00059	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6527 :     if (stbi__gif_test(s)) {

  0005e	48 8b 8d e0 8f
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00065	e8 00 00 00 00	 call	 stbi__gif_test
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 94 03 00
	00		 je	 $LN5@stbi__load

; 6528 :         int layers = 0;

  00072	c7 45 04 00 00
	00 00		 mov	 DWORD PTR layers$4[rbp], 0

; 6529 :         stbi_uc* u = 0;

  00079	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR u$5[rbp], 0

; 6530 :         stbi_uc* out = 0;

  00081	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR out$6[rbp], 0

; 6531 :         stbi_uc* two_back = 0;

  00089	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR two_back$7[rbp], 0

; 6532 :         stbi__gif g;
; 6533 :         int stride;
; 6534 :         int out_size = 0;

  00091	c7 85 34 89 00
	00 00 00 00 00	 mov	 DWORD PTR out_size$10[rbp], 0

; 6535 :         int delays_size = 0;

  0009b	c7 85 54 89 00
	00 00 00 00 00	 mov	 DWORD PTR delays_size$11[rbp], 0

; 6536 : 
; 6537 :         STBI_NOTUSED(out_size);
; 6538 :         STBI_NOTUSED(delays_size);
; 6539 : 
; 6540 :         memset(&g, 0, sizeof(g));

  000a5	41 b8 70 88 00
	00		 mov	 r8d, 34928		; 00008870H
  000ab	33 d2		 xor	 edx, edx
  000ad	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR g$8[rbp]
  000b4	e8 00 00 00 00	 call	 memset

; 6541 :         if (delays) {

  000b9	48 83 bd e8 8f
	00 00 00	 cmp	 QWORD PTR delays$[rbp], 0
  000c1	74 0e		 je	 SHORT $LN7@stbi__load

; 6542 :             *delays = 0;

  000c3	48 8b 85 e8 8f
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  000ca	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN7@stbi__load:
$LN4@stbi__load:

; 6543 :         }
; 6544 : 
; 6545 :         do {
; 6546 :             u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);

  000d1	48 8b 45 68	 mov	 rax, QWORD PTR two_back$7[rbp]
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	44 8b 8d 10 90
	00 00		 mov	 r9d, DWORD PTR req_comp$[rbp]
  000e1	4c 8b 85 08 90
	00 00		 mov	 r8, QWORD PTR comp$[rbp]
  000e8	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR g$8[rbp]
  000ef	48 8b 8d e0 8f
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f6	e8 00 00 00 00	 call	 stbi__gif_load_next
  000fb	48 89 45 28	 mov	 QWORD PTR u$5[rbp], rax

; 6547 :             if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

  000ff	48 8b 85 e0 8f
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00106	48 39 45 28	 cmp	 QWORD PTR u$5[rbp], rax
  0010a	75 08		 jne	 SHORT $LN8@stbi__load
  0010c	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR u$5[rbp], 0
$LN8@stbi__load:

; 6548 : 
; 6549 :             if (u) {

  00114	48 83 7d 28 00	 cmp	 QWORD PTR u$5[rbp], 0
  00119	0f 84 5f 02 00
	00		 je	 $LN9@stbi__load

; 6550 :                 *x = g.w;

  0011f	48 8b 85 f0 8f
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00126	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR g$8[rbp]
  0012c	89 08		 mov	 DWORD PTR [rax], ecx

; 6551 :                 *y = g.h;

  0012e	48 8b 85 f8 8f
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00135	8b 8d 94 00 00
	00		 mov	 ecx, DWORD PTR g$8[rbp+4]
  0013b	89 08		 mov	 DWORD PTR [rax], ecx

; 6552 :                 ++layers;

  0013d	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  00140	ff c0		 inc	 eax
  00142	89 45 04	 mov	 DWORD PTR layers$4[rbp], eax

; 6553 :                 stride = g.w * g.h * 4;

  00145	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR g$8[rbp]
  0014b	0f af 85 94 00
	00 00		 imul	 eax, DWORD PTR g$8[rbp+4]
  00152	c1 e0 02	 shl	 eax, 2
  00155	89 85 14 89 00
	00		 mov	 DWORD PTR stride$9[rbp], eax

; 6554 : 
; 6555 :                 if (out) {

  0015b	48 83 7d 48 00	 cmp	 QWORD PTR out$6[rbp], 0
  00160	0f 84 04 01 00
	00		 je	 $LN10@stbi__load

; 6556 :                     void* tmp = (stbi_uc*)STBI_REALLOC_SIZED(out, out_size, layers * stride);

  00166	8b 85 14 89 00
	00		 mov	 eax, DWORD PTR stride$9[rbp]
  0016c	f7 65 04	 mul	 DWORD PTR layers$4[rbp]
  0016f	8b c0		 mov	 eax, eax
  00171	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00178	48 0f 40 c1	 cmovo	 rax, rcx
  0017c	48 8b d0	 mov	 rdx, rax
  0017f	48 8b 4d 48	 mov	 rcx, QWORD PTR out$6[rbp]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00189	48 89 85 78 89
	00 00		 mov	 QWORD PTR tmp$12[rbp], rax

; 6557 :                     if (!tmp)

  00190	48 83 bd 78 89
	00 00 00	 cmp	 QWORD PTR tmp$12[rbp], 0
  00198	75 1e		 jne	 SHORT $LN12@stbi__load

; 6558 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  0019a	4c 8b 85 e8 8f
	00 00		 mov	 r8, QWORD PTR delays$[rbp]
  001a1	48 8b 55 48	 mov	 rdx, QWORD PTR out$6[rbp]
  001a5	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR g$8[rbp]
  001ac	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  001b1	e9 7f 02 00 00	 jmp	 $LN1@stbi__load
  001b6	eb 1b		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:

; 6559 :                     else {
; 6560 :                         out = (stbi_uc*)tmp;

  001b8	48 8b 85 78 89
	00 00		 mov	 rax, QWORD PTR tmp$12[rbp]
  001bf	48 89 45 48	 mov	 QWORD PTR out$6[rbp], rax

; 6561 :                         out_size = layers * stride;

  001c3	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  001c6	0f af 85 14 89
	00 00		 imul	 eax, DWORD PTR stride$9[rbp]
  001cd	89 85 34 89 00
	00		 mov	 DWORD PTR out_size$10[rbp], eax
$LN13@stbi__load:

; 6562 :                     }
; 6563 : 
; 6564 :                     if (delays) {

  001d3	48 83 bd e8 8f
	00 00 00	 cmp	 QWORD PTR delays$[rbp], 0
  001db	0f 84 84 00 00
	00		 je	 $LN14@stbi__load

; 6565 :                         int* new_delays = (int*)STBI_REALLOC_SIZED(*delays, delays_size, sizeof(int) * layers);

  001e1	48 63 45 04	 movsxd	 rax, DWORD PTR layers$4[rbp]
  001e5	48 89 85 a8 8f
	00 00		 mov	 QWORD PTR tv136[rbp], rax
  001ec	b8 04 00 00 00	 mov	 eax, 4
  001f1	48 8b 8d a8 8f
	00 00		 mov	 rcx, QWORD PTR tv136[rbp]
  001f8	48 f7 e1	 mul	 rcx
  001fb	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00202	48 0f 40 c1	 cmovo	 rax, rcx
  00206	48 8b d0	 mov	 rdx, rax
  00209	48 8b 85 e8 8f
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  00210	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00219	48 89 85 98 89
	00 00		 mov	 QWORD PTR new_delays$13[rbp], rax

; 6566 :                         if (!new_delays)

  00220	48 83 bd 98 89
	00 00 00	 cmp	 QWORD PTR new_delays$13[rbp], 0
  00228	75 1c		 jne	 SHORT $LN15@stbi__load

; 6567 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  0022a	4c 8b 85 e8 8f
	00 00		 mov	 r8, QWORD PTR delays$[rbp]
  00231	48 8b 55 48	 mov	 rdx, QWORD PTR out$6[rbp]
  00235	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR g$8[rbp]
  0023c	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  00241	e9 ef 01 00 00	 jmp	 $LN1@stbi__load
$LN15@stbi__load:

; 6568 :                         *delays = new_delays;

  00246	48 8b 85 e8 8f
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  0024d	48 8b 8d 98 89
	00 00		 mov	 rcx, QWORD PTR new_delays$13[rbp]
  00254	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6569 :                         delays_size = layers * sizeof(int);

  00257	48 63 45 04	 movsxd	 rax, DWORD PTR layers$4[rbp]
  0025b	48 c1 e0 02	 shl	 rax, 2
  0025f	89 85 54 89 00
	00		 mov	 DWORD PTR delays_size$11[rbp], eax
$LN14@stbi__load:

; 6570 :                     }
; 6571 :                 }

  00265	e9 a6 00 00 00	 jmp	 $LN11@stbi__load
$LN10@stbi__load:

; 6572 :                 else {
; 6573 :                     out = (stbi_uc*)stbi__malloc(layers * stride);

  0026a	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  0026d	0f af 85 14 89
	00 00		 imul	 eax, DWORD PTR stride$9[rbp]
  00274	48 98		 cdqe
  00276	48 8b c8	 mov	 rcx, rax
  00279	e8 00 00 00 00	 call	 stbi__malloc
  0027e	48 89 45 48	 mov	 QWORD PTR out$6[rbp], rax

; 6574 :                     if (!out)

  00282	48 83 7d 48 00	 cmp	 QWORD PTR out$6[rbp], 0
  00287	75 1c		 jne	 SHORT $LN16@stbi__load

; 6575 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  00289	4c 8b 85 e8 8f
	00 00		 mov	 r8, QWORD PTR delays$[rbp]
  00290	48 8b 55 48	 mov	 rdx, QWORD PTR out$6[rbp]
  00294	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR g$8[rbp]
  0029b	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  002a0	e9 90 01 00 00	 jmp	 $LN1@stbi__load
$LN16@stbi__load:

; 6576 :                     out_size = layers * stride;

  002a5	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  002a8	0f af 85 14 89
	00 00		 imul	 eax, DWORD PTR stride$9[rbp]
  002af	89 85 34 89 00
	00		 mov	 DWORD PTR out_size$10[rbp], eax

; 6577 :                     if (delays) {

  002b5	48 83 bd e8 8f
	00 00 00	 cmp	 QWORD PTR delays$[rbp], 0
  002bd	74 51		 je	 SHORT $LN17@stbi__load

; 6578 :                         *delays = (int*)stbi__malloc(layers * sizeof(int));

  002bf	48 63 45 04	 movsxd	 rax, DWORD PTR layers$4[rbp]
  002c3	48 c1 e0 02	 shl	 rax, 2
  002c7	48 8b c8	 mov	 rcx, rax
  002ca	e8 00 00 00 00	 call	 stbi__malloc
  002cf	48 8b 8d e8 8f
	00 00		 mov	 rcx, QWORD PTR delays$[rbp]
  002d6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 6579 :                         if (!*delays)

  002d9	48 8b 85 e8 8f
	00 00		 mov	 rax, QWORD PTR delays$[rbp]
  002e0	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002e4	75 1c		 jne	 SHORT $LN18@stbi__load

; 6580 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  002e6	4c 8b 85 e8 8f
	00 00		 mov	 r8, QWORD PTR delays$[rbp]
  002ed	48 8b 55 48	 mov	 rdx, QWORD PTR out$6[rbp]
  002f1	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR g$8[rbp]
  002f8	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  002fd	e9 33 01 00 00	 jmp	 $LN1@stbi__load
$LN18@stbi__load:

; 6581 :                         delays_size = layers * sizeof(int);

  00302	48 63 45 04	 movsxd	 rax, DWORD PTR layers$4[rbp]
  00306	48 c1 e0 02	 shl	 rax, 2
  0030a	89 85 54 89 00
	00		 mov	 DWORD PTR delays_size$11[rbp], eax
$LN17@stbi__load:
$LN11@stbi__load:

; 6582 :                     }
; 6583 :                 }
; 6584 :                 memcpy(out + ((layers - 1) * stride), u, stride);

  00310	48 63 85 14 89
	00 00		 movsxd	 rax, DWORD PTR stride$9[rbp]
  00317	8b 4d 04	 mov	 ecx, DWORD PTR layers$4[rbp]
  0031a	ff c9		 dec	 ecx
  0031c	0f af 8d 14 89
	00 00		 imul	 ecx, DWORD PTR stride$9[rbp]
  00323	48 63 c9	 movsxd	 rcx, ecx
  00326	48 8b 55 48	 mov	 rdx, QWORD PTR out$6[rbp]
  0032a	48 03 d1	 add	 rdx, rcx
  0032d	48 8b ca	 mov	 rcx, rdx
  00330	4c 8b c0	 mov	 r8, rax
  00333	48 8b 55 28	 mov	 rdx, QWORD PTR u$5[rbp]
  00337	e8 00 00 00 00	 call	 memcpy

; 6585 :                 if (layers >= 2) {

  0033c	83 7d 04 02	 cmp	 DWORD PTR layers$4[rbp], 2
  00340	7c 18		 jl	 SHORT $LN19@stbi__load

; 6586 :                     two_back = out - 2 * stride;

  00342	8b 85 14 89 00
	00		 mov	 eax, DWORD PTR stride$9[rbp]
  00348	d1 e0		 shl	 eax, 1
  0034a	48 98		 cdqe
  0034c	48 8b 4d 48	 mov	 rcx, QWORD PTR out$6[rbp]
  00350	48 2b c8	 sub	 rcx, rax
  00353	48 8b c1	 mov	 rax, rcx
  00356	48 89 45 68	 mov	 QWORD PTR two_back$7[rbp], rax
$LN19@stbi__load:

; 6587 :                 }
; 6588 : 
; 6589 :                 if (delays) {

  0035a	48 83 bd e8 8f
	00 00 00	 cmp	 QWORD PTR delays$[rbp], 0
  00362	74 1a		 je	 SHORT $LN20@stbi__load

; 6590 :                     (*delays)[layers - 1U] = g.delay;

  00364	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  00367	ff c8		 dec	 eax
  00369	8b c0		 mov	 eax, eax
  0036b	48 8b 8d e8 8f
	00 00		 mov	 rcx, QWORD PTR delays$[rbp]
  00372	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00375	8b 95 f8 88 00
	00		 mov	 edx, DWORD PTR g$8[rbp+34920]
  0037b	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN20@stbi__load:
$LN9@stbi__load:

; 6591 :                 }
; 6592 :             }
; 6593 :         } while (u != 0);

  0037e	48 83 7d 28 00	 cmp	 QWORD PTR u$5[rbp], 0
  00383	0f 85 48 fd ff
	ff		 jne	 $LN4@stbi__load

; 6594 : 
; 6595 :         // free temp buffer;
; 6596 :         STBI_FREE(g.out);

  00389	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR g$8[rbp+8]
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6597 :         STBI_FREE(g.history);

  00396	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR g$8[rbp+24]
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6598 :         STBI_FREE(g.background);

  003a3	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR g$8[rbp+16]
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6599 : 
; 6600 :         // do the final conversion after loading everything;
; 6601 :         if (req_comp && req_comp != 4)

  003b0	83 bd 10 90 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  003b7	74 39		 je	 SHORT $LN21@stbi__load
  003b9	83 bd 10 90 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  003c0	74 30		 je	 SHORT $LN21@stbi__load

; 6602 :             out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

  003c2	8b 45 04	 mov	 eax, DWORD PTR layers$4[rbp]
  003c5	0f af 85 90 00
	00 00		 imul	 eax, DWORD PTR g$8[rbp]
  003cc	8b 8d 94 00 00
	00		 mov	 ecx, DWORD PTR g$8[rbp+4]
  003d2	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  003d6	44 8b c8	 mov	 r9d, eax
  003d9	44 8b 85 10 90
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  003e0	ba 04 00 00 00	 mov	 edx, 4
  003e5	48 8b 4d 48	 mov	 rcx, QWORD PTR out$6[rbp]
  003e9	e8 00 00 00 00	 call	 stbi__convert_format
  003ee	48 89 45 48	 mov	 QWORD PTR out$6[rbp], rax
$LN21@stbi__load:

; 6603 : 
; 6604 :         *z = layers;

  003f2	48 8b 85 00 90
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  003f9	8b 4d 04	 mov	 ecx, DWORD PTR layers$4[rbp]
  003fc	89 08		 mov	 DWORD PTR [rax], ecx

; 6605 :         return out;

  003fe	48 8b 45 48	 mov	 rax, QWORD PTR out$6[rbp]
  00402	eb 31		 jmp	 SHORT $LN1@stbi__load

; 6606 :     }

  00404	eb 2f		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:

; 6607 :     else {
; 6608 :         return stbi__errpuc("not GIF", "Image was not as a gif type.");

  00406	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  0040d	e8 00 00 00 00	 call	 stbi__err
  00412	85 c0		 test	 eax, eax
  00414	74 0d		 je	 SHORT $LN23@stbi__load
  00416	48 c7 85 a8 8f
	00 00 00 00 00
	00		 mov	 QWORD PTR tv209[rbp], 0
  00421	eb 0b		 jmp	 SHORT $LN24@stbi__load
$LN23@stbi__load:
  00423	48 c7 85 a8 8f
	00 00 00 00 00
	00		 mov	 QWORD PTR tv209[rbp], 0
$LN24@stbi__load:
  0042e	48 8b 85 a8 8f
	00 00		 mov	 rax, QWORD PTR tv209[rbp]
$LN6@stbi__load:
$LN1@stbi__load:

; 6609 :     }
; 6610 : }

  00435	48 8b f8	 mov	 rdi, rax
  00438	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0043c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_gif_main$rtcFrameData
  00443	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00448	48 8b c7	 mov	 rax, rdi
  0044b	48 8b 8d b0 8f
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00452	48 33 cd	 xor	 rcx, rbp
  00455	e8 00 00 00 00	 call	 __security_check_cookie
  0045a	48 8d a5 c8 8f
	00 00		 lea	 rsp, QWORD PTR [rbp+36808]
  00461	5f		 pop	 rdi
  00462	5d		 pop	 rbp
  00463	c3		 ret	 0
stbi__load_gif_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_load
_TEXT	SEGMENT
u$ = 8
g$ = 48
__$ArrayPad$ = 36520
s$ = 36560
x$ = 36568
y$ = 36576
comp$ = 36584
req_comp$ = 36592
ri$ = 36600
stbi__gif_load PROC					; COMDAT

; 6613 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	b8 e8 8e 00 00	 mov	 eax, 36584		; 00008ee8H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00028	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002d	b9 2e 22 00 00	 mov	 ecx, 8750		; 0000222eH
  00032	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00037	f3 ab		 rep stosd
  00039	48 8b 8c 24 08
	8f 00 00	 mov	 rcx, QWORD PTR [rsp+36616]
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00048	48 33 c5	 xor	 rax, rbp
  0004b	48 89 85 a8 8e
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00059	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6614 :     stbi_uc* u = 0;

  0005e	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR u$[rbp], 0

; 6615 :     stbi__gif g;
; 6616 :     memset(&g, 0, sizeof(g));

  00066	41 b8 70 88 00
	00		 mov	 r8d, 34928		; 00008870H
  0006c	33 d2		 xor	 edx, edx
  0006e	48 8d 4d 30	 lea	 rcx, QWORD PTR g$[rbp]
  00072	e8 00 00 00 00	 call	 memset

; 6617 :     STBI_NOTUSED(ri);
; 6618 : 
; 6619 :     u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

  00077	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00080	44 8b 8d f0 8e
	00 00		 mov	 r9d, DWORD PTR req_comp$[rbp]
  00087	4c 8b 85 e8 8e
	00 00		 mov	 r8, QWORD PTR comp$[rbp]
  0008e	48 8d 55 30	 lea	 rdx, QWORD PTR g$[rbp]
  00092	48 8b 8d d0 8e
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00099	e8 00 00 00 00	 call	 stbi__gif_load_next
  0009e	48 89 45 08	 mov	 QWORD PTR u$[rbp], rax

; 6620 :     if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

  000a2	48 8b 85 d0 8e
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000a9	48 39 45 08	 cmp	 QWORD PTR u$[rbp], rax
  000ad	75 08		 jne	 SHORT $LN2@stbi__gif_
  000af	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR u$[rbp], 0
$LN2@stbi__gif_:

; 6621 :     if (u) {

  000b7	48 83 7d 08 00	 cmp	 QWORD PTR u$[rbp], 0
  000bc	74 50		 je	 SHORT $LN3@stbi__gif_

; 6622 :         *x = g.w;

  000be	48 8b 85 d8 8e
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  000c5	8b 4d 30	 mov	 ecx, DWORD PTR g$[rbp]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx

; 6623 :         *y = g.h;

  000ca	48 8b 85 e0 8e
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  000d1	8b 4d 34	 mov	 ecx, DWORD PTR g$[rbp+4]
  000d4	89 08		 mov	 DWORD PTR [rax], ecx

; 6624 : 
; 6625 :         // moved conversion to after successful load so that the same
; 6626 :         // can be done for multiple frames.
; 6627 :         if (req_comp && req_comp != 4)

  000d6	83 bd f0 8e 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  000dd	74 2d		 je	 SHORT $LN5@stbi__gif_
  000df	83 bd f0 8e 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  000e6	74 24		 je	 SHORT $LN5@stbi__gif_

; 6628 :             u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

  000e8	8b 45 34	 mov	 eax, DWORD PTR g$[rbp+4]
  000eb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ef	44 8b 4d 30	 mov	 r9d, DWORD PTR g$[rbp]
  000f3	44 8b 85 f0 8e
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  000fa	ba 04 00 00 00	 mov	 edx, 4
  000ff	48 8b 4d 08	 mov	 rcx, QWORD PTR u$[rbp]
  00103	e8 00 00 00 00	 call	 stbi__convert_format
  00108	48 89 45 08	 mov	 QWORD PTR u$[rbp], rax
$LN5@stbi__gif_:

; 6629 :     }

  0010c	eb 11		 jmp	 SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:

; 6630 :     else if (g.out) {

  0010e	48 83 7d 38 00	 cmp	 QWORD PTR g$[rbp+8], 0
  00113	74 0a		 je	 SHORT $LN6@stbi__gif_

; 6631 :         // if there was an error and we allocated an image buffer, free it!
; 6632 :         STBI_FREE(g.out);

  00115	48 8b 4d 38	 mov	 rcx, QWORD PTR g$[rbp+8]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@stbi__gif_:
$LN4@stbi__gif_:

; 6633 :     }
; 6634 : 
; 6635 :     // free buffers needed for multiple frame loading;
; 6636 :     STBI_FREE(g.history);

  0011f	48 8b 4d 48	 mov	 rcx, QWORD PTR g$[rbp+24]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6637 :     STBI_FREE(g.background);

  00129	48 8b 4d 40	 mov	 rcx, QWORD PTR g$[rbp+16]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6638 : 
; 6639 :     return u;

  00133	48 8b 45 08	 mov	 rax, QWORD PTR u$[rbp]

; 6640 : }

  00137	48 8b f8	 mov	 rdi, rax
  0013a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__gif_load$rtcFrameData
  00145	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0014a	48 8b c7	 mov	 rax, rdi
  0014d	48 8b 8d a8 8e
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00154	48 33 cd	 xor	 rcx, rbp
  00157	e8 00 00 00 00	 call	 __security_check_cookie
  0015c	48 8d a5 b8 8e
	00 00		 lea	 rsp, QWORD PTR [rbp+36536]
  00163	5f		 pop	 rdi
  00164	5d		 pop	 rbp
  00165	c3		 ret	 0
stbi__gif_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__gif_test
_TEXT	SEGMENT
r$ = 4
s$ = 256
stbi__gif_test PROC					; COMDAT

; 6140 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6141 :     int r = stbi__gif_test_raw(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__gif_test_raw
  0002b	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 6142 :     stbi__rewind(s);

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__rewind

; 6143 :     return r;

  0003a	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 6144 : }

  0003d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
stbi__gif_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_info
_TEXT	SEGMENT
act_comp$ = 4
num_packets$ = 36
chained$ = 68
dummy$ = 100
packets$ = 136
packet$5 = 200
tv152 = 404
__$ArrayPad$ = 408
s$ = 448
x$ = 456
y$ = 464
comp$ = 472
stbi__pic_info PROC					; COMDAT

; 6992 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+488]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 98 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6993 :     int act_comp = 0, num_packets = 0, chained, dummy;

  00058	c7 45 04 00 00
	00 00		 mov	 DWORD PTR act_comp$[rbp], 0
  0005f	c7 45 24 00 00
	00 00		 mov	 DWORD PTR num_packets$[rbp], 0

; 6994 :     stbi__pic_packet packets[10];
; 6995 : 
; 6996 :     if (!x) x = &dummy;

  00066	48 83 bd c8 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  0006e	75 0b		 jne	 SHORT $LN5@stbi__pic_
  00070	48 8d 45 64	 lea	 rax, QWORD PTR dummy$[rbp]
  00074	48 89 85 c8 01
	00 00		 mov	 QWORD PTR x$[rbp], rax
$LN5@stbi__pic_:

; 6997 :     if (!y) y = &dummy;

  0007b	48 83 bd d0 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00083	75 0b		 jne	 SHORT $LN6@stbi__pic_
  00085	48 8d 45 64	 lea	 rax, QWORD PTR dummy$[rbp]
  00089	48 89 85 d0 01
	00 00		 mov	 QWORD PTR y$[rbp], rax
$LN6@stbi__pic_:

; 6998 :     if (!comp) comp = &dummy;

  00090	48 83 bd d8 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  00098	75 0b		 jne	 SHORT $LN7@stbi__pic_
  0009a	48 8d 45 64	 lea	 rax, QWORD PTR dummy$[rbp]
  0009e	48 89 85 d8 01
	00 00		 mov	 QWORD PTR comp$[rbp], rax
$LN7@stbi__pic_:

; 6999 : 
; 7000 :     if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {

  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
  000ac	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b3	e8 00 00 00 00	 call	 stbi__pic_is4
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN8@stbi__pic_

; 7001 :         stbi__rewind(s);

  000bc	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c3	e8 00 00 00 00	 call	 stbi__rewind

; 7002 :         return 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 bd 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 7003 :     }
; 7004 : 
; 7005 :     stbi__skip(s, 88);

  000cf	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  000d4	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000db	e8 00 00 00 00	 call	 stbi__skip

; 7006 : 
; 7007 :     *x = stbi__get16be(s);

  000e0	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000e7	e8 00 00 00 00	 call	 stbi__get16be
  000ec	48 8b 8d c8 01
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  000f3	89 01		 mov	 DWORD PTR [rcx], eax

; 7008 :     *y = stbi__get16be(s);

  000f5	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000fc	e8 00 00 00 00	 call	 stbi__get16be
  00101	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  00108	89 01		 mov	 DWORD PTR [rcx], eax

; 7009 :     if (stbi__at_eof(s)) {

  0010a	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00111	e8 00 00 00 00	 call	 stbi__at_eof
  00116	85 c0		 test	 eax, eax
  00118	74 13		 je	 SHORT $LN9@stbi__pic_

; 7010 :         stbi__rewind(s);

  0011a	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00121	e8 00 00 00 00	 call	 stbi__rewind

; 7011 :         return 0;

  00126	33 c0		 xor	 eax, eax
  00128	e9 5f 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 7012 :     }
; 7013 :     if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {

  0012d	48 8b 85 c8 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00134	83 38 00	 cmp	 DWORD PTR [rax], 0
  00137	74 2d		 je	 SHORT $LN10@stbi__pic_
  00139	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  0013e	99		 cdq
  0013f	48 8b 8d c8 01
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00146	f7 39		 idiv	 DWORD PTR [rcx]
  00148	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  0014f	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00151	7d 13		 jge	 SHORT $LN10@stbi__pic_

; 7014 :         stbi__rewind(s);

  00153	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0015a	e8 00 00 00 00	 call	 stbi__rewind

; 7015 :         return 0;

  0015f	33 c0		 xor	 eax, eax
  00161	e9 26 01 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 7016 :     }
; 7017 : 
; 7018 :     stbi__skip(s, 8);

  00166	ba 08 00 00 00	 mov	 edx, 8
  0016b	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00172	e8 00 00 00 00	 call	 stbi__skip
$LN4@stbi__pic_:

; 7019 : 
; 7020 :     do {
; 7021 :         stbi__pic_packet* packet;
; 7022 : 
; 7023 :         if (num_packets == sizeof(packets) / sizeof(packets[0]))

  00177	48 63 45 24	 movsxd	 rax, DWORD PTR num_packets$[rbp]
  0017b	48 83 f8 0a	 cmp	 rax, 10
  0017f	75 07		 jne	 SHORT $LN11@stbi__pic_

; 7024 :             return 0;

  00181	33 c0		 xor	 eax, eax
  00183	e9 04 01 00 00	 jmp	 $LN1@stbi__pic_
$LN11@stbi__pic_:

; 7025 : 
; 7026 :         packet = &packets[num_packets++];

  00188	48 63 45 24	 movsxd	 rax, DWORD PTR num_packets$[rbp]
  0018c	48 6b c0 03	 imul	 rax, rax, 3
  00190	48 8d 84 05 88
	00 00 00	 lea	 rax, QWORD PTR packets$[rbp+rax]
  00198	48 89 85 c8 00
	00 00		 mov	 QWORD PTR packet$5[rbp], rax
  0019f	8b 45 24	 mov	 eax, DWORD PTR num_packets$[rbp]
  001a2	ff c0		 inc	 eax
  001a4	89 45 24	 mov	 DWORD PTR num_packets$[rbp], eax

; 7027 :         chained = stbi__get8(s);

  001a7	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001ae	e8 00 00 00 00	 call	 stbi__get8
  001b3	0f b6 c0	 movzx	 eax, al
  001b6	89 45 44	 mov	 DWORD PTR chained$[rbp], eax

; 7028 :         packet->size = stbi__get8(s);

  001b9	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001c0	e8 00 00 00 00	 call	 stbi__get8
  001c5	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$5[rbp]
  001cc	88 01		 mov	 BYTE PTR [rcx], al

; 7029 :         packet->type = stbi__get8(s);

  001ce	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001d5	e8 00 00 00 00	 call	 stbi__get8
  001da	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$5[rbp]
  001e1	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 7030 :         packet->channel = stbi__get8(s);

  001e4	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001eb	e8 00 00 00 00	 call	 stbi__get8
  001f0	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR packet$5[rbp]
  001f7	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 7031 :         act_comp |= packet->channel;

  001fa	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR packet$5[rbp]
  00201	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00205	8b 4d 04	 mov	 ecx, DWORD PTR act_comp$[rbp]
  00208	0b c8		 or	 ecx, eax
  0020a	8b c1		 mov	 eax, ecx
  0020c	89 45 04	 mov	 DWORD PTR act_comp$[rbp], eax

; 7032 : 
; 7033 :         if (stbi__at_eof(s)) {

  0020f	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00216	e8 00 00 00 00	 call	 stbi__at_eof
  0021b	85 c0		 test	 eax, eax
  0021d	74 10		 je	 SHORT $LN12@stbi__pic_

; 7034 :             stbi__rewind(s);

  0021f	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00226	e8 00 00 00 00	 call	 stbi__rewind

; 7035 :             return 0;

  0022b	33 c0		 xor	 eax, eax
  0022d	eb 5d		 jmp	 SHORT $LN1@stbi__pic_
$LN12@stbi__pic_:

; 7036 :         }
; 7037 :         if (packet->size != 8) {

  0022f	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR packet$5[rbp]
  00236	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00239	83 f8 08	 cmp	 eax, 8
  0023c	74 10		 je	 SHORT $LN13@stbi__pic_

; 7038 :             stbi__rewind(s);

  0023e	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00245	e8 00 00 00 00	 call	 stbi__rewind

; 7039 :             return 0;

  0024a	33 c0		 xor	 eax, eax
  0024c	eb 3e		 jmp	 SHORT $LN1@stbi__pic_
$LN13@stbi__pic_:

; 7040 :         }
; 7041 :     } while (chained);

  0024e	83 7d 44 00	 cmp	 DWORD PTR chained$[rbp], 0
  00252	0f 85 1f ff ff
	ff		 jne	 $LN4@stbi__pic_

; 7042 : 
; 7043 :     *comp = (act_comp & 0x10 ? 4 : 3);

  00258	8b 45 04	 mov	 eax, DWORD PTR act_comp$[rbp]
  0025b	83 e0 10	 and	 eax, 16
  0025e	85 c0		 test	 eax, eax
  00260	74 0c		 je	 SHORT $LN15@stbi__pic_
  00262	c7 85 94 01 00
	00 04 00 00 00	 mov	 DWORD PTR tv152[rbp], 4
  0026c	eb 0a		 jmp	 SHORT $LN16@stbi__pic_
$LN15@stbi__pic_:
  0026e	c7 85 94 01 00
	00 03 00 00 00	 mov	 DWORD PTR tv152[rbp], 3
$LN16@stbi__pic_:
  00278	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  0027f	8b 8d 94 01 00
	00		 mov	 ecx, DWORD PTR tv152[rbp]
  00285	89 08		 mov	 DWORD PTR [rax], ecx

; 7044 : 
; 7045 :     return 1;

  00287	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 7046 : }

  0028c	48 8b f8	 mov	 rdi, rax
  0028f	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00293	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_info$rtcFrameData
  0029a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0029f	48 8b c7	 mov	 rax, rdi
  002a2	48 8b 8d 98 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  002a9	48 33 cd	 xor	 rcx, rbp
  002ac	e8 00 00 00 00	 call	 __security_check_cookie
  002b1	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  002b8	5f		 pop	 rdi
  002b9	5d		 pop	 rbp
  002ba	c3		 ret	 0
stbi__pic_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_load
_TEXT	SEGMENT
result$ = 8
i$ = 36
x$ = 68
y$ = 100
internal_comp$ = 132
tv143 = 344
tv130 = 344
tv88 = 344
tv81 = 344
tv76 = 344
__$ArrayPad$ = 352
s$ = 400
px$ = 408
py$ = 416
comp$ = 424
req_comp$ = 432
ri$ = 440
stbi__pic_load PROC					; COMDAT

; 6050 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+456]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 60 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6051 :     stbi_uc* result;
; 6052 :     int i, x, y, internal_comp;
; 6053 :     STBI_NOTUSED(ri);
; 6054 : 
; 6055 :     if (!comp) comp = &internal_comp;

  00058	48 83 bd a8 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  00060	75 0e		 jne	 SHORT $LN5@stbi__pic_
  00062	48 8d 85 84 00
	00 00		 lea	 rax, QWORD PTR internal_comp$[rbp]
  00069	48 89 85 a8 01
	00 00		 mov	 QWORD PTR comp$[rbp], rax
$LN5@stbi__pic_:

; 6056 : 
; 6057 :     for (i = 0; i < 92; ++i)

  00070	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00077	eb 08		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00079	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0007c	ff c0		 inc	 eax
  0007e	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__pic_:
  00081	83 7d 24 5c	 cmp	 DWORD PTR i$[rbp], 92	; 0000005cH
  00085	7d 0e		 jge	 SHORT $LN3@stbi__pic_

; 6058 :         stbi__get8(s);

  00087	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0008e	e8 00 00 00 00	 call	 stbi__get8
  00093	eb e4		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6059 : 
; 6060 :     x = stbi__get16be(s);

  00095	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009c	e8 00 00 00 00	 call	 stbi__get16be
  000a1	89 45 44	 mov	 DWORD PTR x$[rbp], eax

; 6061 :     y = stbi__get16be(s);

  000a4	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ab	e8 00 00 00 00	 call	 stbi__get16be
  000b0	89 45 64	 mov	 DWORD PTR y$[rbp], eax

; 6062 : 
; 6063 :     if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  000b3	81 7d 64 00 00
	00 01		 cmp	 DWORD PTR y$[rbp], 16777216 ; 01000000H
  000ba	7e 34		 jle	 SHORT $LN6@stbi__pic_
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  000c3	e8 00 00 00 00	 call	 stbi__err
  000c8	85 c0		 test	 eax, eax
  000ca	74 0d		 je	 SHORT $LN14@stbi__pic_
  000cc	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv76[rbp], 0
  000d7	eb 0b		 jmp	 SHORT $LN15@stbi__pic_
$LN14@stbi__pic_:
  000d9	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv76[rbp], 0
$LN15@stbi__pic_:
  000e4	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv76[rbp]
  000eb	e9 f3 01 00 00	 jmp	 $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6064 :     if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  000f0	81 7d 44 00 00
	00 01		 cmp	 DWORD PTR x$[rbp], 16777216 ; 01000000H
  000f7	7e 34		 jle	 SHORT $LN7@stbi__pic_
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00100	e8 00 00 00 00	 call	 stbi__err
  00105	85 c0		 test	 eax, eax
  00107	74 0d		 je	 SHORT $LN16@stbi__pic_
  00109	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv81[rbp], 0
  00114	eb 0b		 jmp	 SHORT $LN17@stbi__pic_
$LN16@stbi__pic_:
  00116	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv81[rbp], 0
$LN17@stbi__pic_:
  00121	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv81[rbp]
  00128	e9 b6 01 00 00	 jmp	 $LN1@stbi__pic_
$LN7@stbi__pic_:

; 6065 : 
; 6066 :     if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");

  0012d	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00134	e8 00 00 00 00	 call	 stbi__at_eof
  00139	85 c0		 test	 eax, eax
  0013b	74 34		 je	 SHORT $LN8@stbi__pic_
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00144	e8 00 00 00 00	 call	 stbi__err
  00149	85 c0		 test	 eax, eax
  0014b	74 0d		 je	 SHORT $LN18@stbi__pic_
  0014d	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv88[rbp], 0
  00158	eb 0b		 jmp	 SHORT $LN19@stbi__pic_
$LN18@stbi__pic_:
  0015a	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv88[rbp], 0
$LN19@stbi__pic_:
  00165	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv88[rbp]
  0016c	e9 72 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 6067 :     if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

  00171	45 33 c9	 xor	 r9d, r9d
  00174	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017a	8b 55 64	 mov	 edx, DWORD PTR y$[rbp]
  0017d	8b 4d 44	 mov	 ecx, DWORD PTR x$[rbp]
  00180	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00185	85 c0		 test	 eax, eax
  00187	75 34		 jne	 SHORT $LN9@stbi__pic_
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00190	e8 00 00 00 00	 call	 stbi__err
  00195	85 c0		 test	 eax, eax
  00197	74 0d		 je	 SHORT $LN20@stbi__pic_
  00199	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv130[rbp], 0
  001a4	eb 0b		 jmp	 SHORT $LN21@stbi__pic_
$LN20@stbi__pic_:
  001a6	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv130[rbp], 0
$LN21@stbi__pic_:
  001b1	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv130[rbp]
  001b8	e9 26 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 6068 : 
; 6069 :     stbi__get32be(s); //skip `ratio'

  001bd	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001c4	e8 00 00 00 00	 call	 stbi__get32be

; 6070 :     stbi__get16be(s); //skip `fields'

  001c9	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001d0	e8 00 00 00 00	 call	 stbi__get16be

; 6071 :     stbi__get16be(s); //skip `pad'

  001d5	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001dc	e8 00 00 00 00	 call	 stbi__get16be

; 6072 : 
; 6073 :     // intermediate buffer is RGBA
; 6074 :     result = (stbi_uc*)stbi__malloc_mad3(x, y, 4, 0);

  001e1	45 33 c9	 xor	 r9d, r9d
  001e4	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ea	8b 55 64	 mov	 edx, DWORD PTR y$[rbp]
  001ed	8b 4d 44	 mov	 ecx, DWORD PTR x$[rbp]
  001f0	e8 00 00 00 00	 call	 stbi__malloc_mad3
  001f5	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 6075 :     if (!result) return stbi__errpuc("outofmem", "Out of memory");

  001f9	48 83 7d 08 00	 cmp	 QWORD PTR result$[rbp], 0
  001fe	75 34		 jne	 SHORT $LN10@stbi__pic_
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00207	e8 00 00 00 00	 call	 stbi__err
  0020c	85 c0		 test	 eax, eax
  0020e	74 0d		 je	 SHORT $LN22@stbi__pic_
  00210	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv143[rbp], 0
  0021b	eb 0b		 jmp	 SHORT $LN23@stbi__pic_
$LN22@stbi__pic_:
  0021d	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv143[rbp], 0
$LN23@stbi__pic_:
  00228	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv143[rbp]
  0022f	e9 af 00 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 6076 :     memset(result, 0xff, x * y * 4);

  00234	8b 45 44	 mov	 eax, DWORD PTR x$[rbp]
  00237	0f af 45 64	 imul	 eax, DWORD PTR y$[rbp]
  0023b	c1 e0 02	 shl	 eax, 2
  0023e	48 98		 cdqe
  00240	4c 8b c0	 mov	 r8, rax
  00243	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00248	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  0024c	e8 00 00 00 00	 call	 memset

; 6077 : 
; 6078 :     if (!stbi__pic_load_core(s, x, y, comp, result)) {

  00251	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	4c 8b 8d a8 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00261	44 8b 45 64	 mov	 r8d, DWORD PTR y$[rbp]
  00265	8b 55 44	 mov	 edx, DWORD PTR x$[rbp]
  00268	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0026f	e8 00 00 00 00	 call	 stbi__pic_load_core
  00274	48 85 c0	 test	 rax, rax
  00277	75 12		 jne	 SHORT $LN11@stbi__pic_

; 6079 :         STBI_FREE(result);

  00279	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6080 :         result = 0;

  00283	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR result$[rbp], 0
$LN11@stbi__pic_:

; 6081 :     }
; 6082 :     *px = x;

  0028b	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR px$[rbp]
  00292	8b 4d 44	 mov	 ecx, DWORD PTR x$[rbp]
  00295	89 08		 mov	 DWORD PTR [rax], ecx

; 6083 :     *py = y;

  00297	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR py$[rbp]
  0029e	8b 4d 64	 mov	 ecx, DWORD PTR y$[rbp]
  002a1	89 08		 mov	 DWORD PTR [rax], ecx

; 6084 :     if (req_comp == 0) req_comp = *comp;

  002a3	83 bd b0 01 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  002aa	75 0f		 jne	 SHORT $LN12@stbi__pic_
  002ac	48 8b 85 a8 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  002b3	8b 00		 mov	 eax, DWORD PTR [rax]
  002b5	89 85 b0 01 00
	00		 mov	 DWORD PTR req_comp$[rbp], eax
$LN12@stbi__pic_:

; 6085 :     result = stbi__convert_format(result, 4, req_comp, x, y);

  002bb	8b 45 64	 mov	 eax, DWORD PTR y$[rbp]
  002be	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002c2	44 8b 4d 44	 mov	 r9d, DWORD PTR x$[rbp]
  002c6	44 8b 85 b0 01
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  002cd	ba 04 00 00 00	 mov	 edx, 4
  002d2	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  002d6	e8 00 00 00 00	 call	 stbi__convert_format
  002db	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 6086 : 
; 6087 :     return result;

  002df	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__pic_:

; 6088 : }

  002e3	48 8b f8	 mov	 rdi, rax
  002e6	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_load$rtcFrameData
  002f1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  002f6	48 8b c7	 mov	 rax, rdi
  002f9	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00300	48 33 cd	 xor	 rcx, rbp
  00303	e8 00 00 00 00	 call	 __security_check_cookie
  00308	48 8d a5 78 01
	00 00		 lea	 rsp, QWORD PTR [rbp+376]
  0030f	5f		 pop	 rdi
  00310	5d		 pop	 rbp
  00311	c3		 ret	 0
stbi__pic_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__pic_test
_TEXT	SEGMENT
r$ = 4
s$ = 256
stbi__pic_test PROC					; COMDAT

; 6091 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6092 :     int r = stbi__pic_test_core(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__pic_test_core
  0002b	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 6093 :     stbi__rewind(s);

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__rewind

; 6094 :     return r;

  0003a	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 6095 : }

  0003d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
stbi__pic_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_info
_TEXT	SEGMENT
buffer$ = 16
token$ = 1064
valid$ = 1092
dummy$ = 1124
__$ArrayPad$ = 1720
s$ = 1760
x$ = 1768
y$ = 1776
comp$ = 1784
stbi__hdr_info PROC					; COMDAT

; 6858 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 06
	00 00		 sub	 rsp, 1768		; 000006e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 22 01 00 00	 mov	 ecx, 290		; 00000122H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 08
	07 00 00	 mov	 rcx, QWORD PTR [rsp+1800]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6859 :     char buffer[STBI__HDR_BUFLEN];
; 6860 :     char* token;
; 6861 :     int valid = 0;

  00058	c7 85 44 04 00
	00 00 00 00 00	 mov	 DWORD PTR valid$[rbp], 0

; 6862 :     int dummy;
; 6863 : 
; 6864 :     if (!x) x = &dummy;

  00062	48 83 bd e8 06
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  0006a	75 0e		 jne	 SHORT $LN7@stbi__hdr_
  0006c	48 8d 85 64 04
	00 00		 lea	 rax, QWORD PTR dummy$[rbp]
  00073	48 89 85 e8 06
	00 00		 mov	 QWORD PTR x$[rbp], rax
$LN7@stbi__hdr_:

; 6865 :     if (!y) y = &dummy;

  0007a	48 83 bd f0 06
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00082	75 0e		 jne	 SHORT $LN8@stbi__hdr_
  00084	48 8d 85 64 04
	00 00		 lea	 rax, QWORD PTR dummy$[rbp]
  0008b	48 89 85 f0 06
	00 00		 mov	 QWORD PTR y$[rbp], rax
$LN8@stbi__hdr_:

; 6866 :     if (!comp) comp = &dummy;

  00092	48 83 bd f8 06
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  0009a	75 0e		 jne	 SHORT $LN9@stbi__hdr_
  0009c	48 8d 85 64 04
	00 00		 lea	 rax, QWORD PTR dummy$[rbp]
  000a3	48 89 85 f8 06
	00 00		 mov	 QWORD PTR comp$[rbp], rax
$LN9@stbi__hdr_:

; 6867 : 
; 6868 :     if (stbi__hdr_test(s) == 0) {

  000aa	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b1	e8 00 00 00 00	 call	 stbi__hdr_test
  000b6	85 c0		 test	 eax, eax
  000b8	75 13		 jne	 SHORT $LN10@stbi__hdr_

; 6869 :         stbi__rewind(s);

  000ba	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c1	e8 00 00 00 00	 call	 stbi__rewind

; 6870 :         return 0;

  000c6	33 c0		 xor	 eax, eax
  000c8	e9 7f 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN10@stbi__hdr_:
$LN2@stbi__hdr_:

; 6871 :     }
; 6872 : 
; 6873 :     for (;;) {
; 6874 :         token = stbi__hdr_gettoken(s, buffer);

  000cd	48 8d 55 10	 lea	 rdx, QWORD PTR buffer$[rbp]
  000d1	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d8	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  000dd	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6875 :         if (token[0] == 0) break;

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  000f4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000f8	85 c0		 test	 eax, eax
  000fa	75 02		 jne	 SHORT $LN11@stbi__hdr_
  000fc	eb 23		 jmp	 SHORT $LN3@stbi__hdr_
$LN11@stbi__hdr_:

; 6876 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
  00105	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  0010c	e8 00 00 00 00	 call	 strcmp
  00111	85 c0		 test	 eax, eax
  00113	75 0a		 jne	 SHORT $LN12@stbi__hdr_
  00115	c7 85 44 04 00
	00 01 00 00 00	 mov	 DWORD PTR valid$[rbp], 1
$LN12@stbi__hdr_:

; 6877 :     }

  0011f	eb ac		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6878 : 
; 6879 :     if (!valid) {

  00121	83 bd 44 04 00
	00 00		 cmp	 DWORD PTR valid$[rbp], 0
  00128	75 13		 jne	 SHORT $LN13@stbi__hdr_

; 6880 :         stbi__rewind(s);

  0012a	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00131	e8 00 00 00 00	 call	 stbi__rewind

; 6881 :         return 0;

  00136	33 c0		 xor	 eax, eax
  00138	e9 0f 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN13@stbi__hdr_:

; 6882 :     }
; 6883 :     token = stbi__hdr_gettoken(s, buffer);

  0013d	48 8d 55 10	 lea	 rdx, QWORD PTR buffer$[rbp]
  00141	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00148	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  0014d	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6884 :     if (strncmp(token, "-Y ", 3)) {

  00154	41 b8 03 00 00
	00		 mov	 r8d, 3
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
  00161	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0016e	85 c0		 test	 eax, eax
  00170	74 13		 je	 SHORT $LN14@stbi__hdr_

; 6885 :         stbi__rewind(s);

  00172	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00179	e8 00 00 00 00	 call	 stbi__rewind

; 6886 :         return 0;

  0017e	33 c0		 xor	 eax, eax
  00180	e9 c7 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN14@stbi__hdr_:

; 6887 :     }
; 6888 :     token += 3;

  00185	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  0018c	48 83 c0 03	 add	 rax, 3
  00190	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6889 :     *y = (int)strtol(token, &token, 10);

  00197	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0019d	48 8d 95 28 04
	00 00		 lea	 rdx, QWORD PTR token$[rbp]
  001a4	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  001b1	48 8b 8d f0 06
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  001b8	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__hdr_:

; 6890 :     while (*token == ' ') ++token;

  001ba	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  001c1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001c4	83 f8 20	 cmp	 eax, 32			; 00000020H
  001c7	75 13		 jne	 SHORT $LN6@stbi__hdr_
  001c9	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  001d0	48 ff c0	 inc	 rax
  001d3	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax
  001da	eb de		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 6891 :     if (strncmp(token, "+X ", 3)) {

  001dc	41 b8 03 00 00
	00		 mov	 r8d, 3
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
  001e9	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  001f6	85 c0		 test	 eax, eax
  001f8	74 10		 je	 SHORT $LN15@stbi__hdr_

; 6892 :         stbi__rewind(s);

  001fa	48 8b 8d e0 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00201	e8 00 00 00 00	 call	 stbi__rewind

; 6893 :         return 0;

  00206	33 c0		 xor	 eax, eax
  00208	eb 42		 jmp	 SHORT $LN1@stbi__hdr_
$LN15@stbi__hdr_:

; 6894 :     }
; 6895 :     token += 3;

  0020a	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  00211	48 83 c0 03	 add	 rax, 3
  00215	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6896 :     *x = (int)strtol(token, NULL, 10);

  0021c	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00222	33 d2		 xor	 edx, edx
  00224	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00231	48 8b 8d e8 06
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00238	89 01		 mov	 DWORD PTR [rcx], eax

; 6897 :     *comp = 3;

  0023a	48 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00241	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 6898 :     return 1;

  00247	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 6899 : }

  0024c	48 8b f8	 mov	 rdi, rax
  0024f	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__hdr_info$rtcFrameData
  0025a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0025f	48 8b c7	 mov	 rax, rdi
  00262	48 8b 8d b8 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00269	48 33 cd	 xor	 rcx, rbp
  0026c	e8 00 00 00 00	 call	 __security_check_cookie
  00271	48 8d a5 c8 06
	00 00		 lea	 rsp, QWORD PTR [rbp+1736]
  00278	5f		 pop	 rdi
  00279	5d		 pop	 rbp
  0027a	c3		 ret	 0
stbi__hdr_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_load
_TEXT	SEGMENT
buffer$ = 16
token$ = 1064
valid$ = 1092
width$ = 1124
height$ = 1156
scanline$ = 1192
hdr_data$ = 1224
len$ = 1252
count$ = 1284
value$ = 1316
i$ = 1348
j$ = 1380
k$ = 1412
c1$ = 1444
c2$ = 1476
z$ = 1508
headerToken$ = 1544
rgbe$7 = 1572
rgbe$8 = 1604
nleft$9 = 1636
tv309 = 2424
tv290 = 2424
tv267 = 2424
tv256 = 2424
tv194 = 2424
tv183 = 2424
tv170 = 2424
tv165 = 2424
tv155 = 2424
tv138 = 2424
tv94 = 2424
tv78 = 2424
__$ArrayPad$ = 2432
s$ = 2480
x$ = 2488
y$ = 2496
comp$ = 2504
req_comp$ = 2512
ri$ = 2520
stbi__hdr_load PROC					; COMDAT

; 6725 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec c8 09
	00 00		 sub	 rsp, 2504		; 000009c8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 a6 01 00 00	 mov	 ecx, 422		; 000001a6H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 e8
	09 00 00	 mov	 rcx, QWORD PTR [rsp+2536]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 80 09
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6726 :     char buffer[STBI__HDR_BUFLEN];
; 6727 :     char* token;
; 6728 :     int valid = 0;

  00058	c7 85 44 04 00
	00 00 00 00 00	 mov	 DWORD PTR valid$[rbp], 0

; 6729 :     int width, height;
; 6730 :     stbi_uc* scanline;
; 6731 :     float* hdr_data;
; 6732 :     int len;
; 6733 :     unsigned char count, value;
; 6734 :     int i, j, k, c1, c2, z;
; 6735 :     const char* headerToken;
; 6736 :     STBI_NOTUSED(ri);
; 6737 : 
; 6738 :     // Check identifier
; 6739 :     headerToken = stbi__hdr_gettoken(s, buffer);

  00062	48 8d 55 10	 lea	 rdx, QWORD PTR buffer$[rbp]
  00066	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006d	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  00072	48 89 85 08 06
	00 00		 mov	 QWORD PTR headerToken$[rbp], rax

; 6740 :     if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
  00080	48 8b 8d 08 06
	00 00		 mov	 rcx, QWORD PTR headerToken$[rbp]
  00087	e8 00 00 00 00	 call	 strcmp
  0008c	85 c0		 test	 eax, eax
  0008e	74 4b		 je	 SHORT $LN30@stbi__hdr_
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
  00097	48 8b 8d 08 06
	00 00		 mov	 rcx, QWORD PTR headerToken$[rbp]
  0009e	e8 00 00 00 00	 call	 strcmp
  000a3	85 c0		 test	 eax, eax
  000a5	74 34		 je	 SHORT $LN30@stbi__hdr_

; 6741 :         return stbi__errpf("not HDR", "Corrupt HDR image");

  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07NCIOKENI@not?5HDR@
  000ae	e8 00 00 00 00	 call	 stbi__err
  000b3	85 c0		 test	 eax, eax
  000b5	74 0d		 je	 SHORT $LN58@stbi__hdr_
  000b7	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv78[rbp], 0
  000c2	eb 0b		 jmp	 SHORT $LN59@stbi__hdr_
$LN58@stbi__hdr_:
  000c4	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv78[rbp], 0
$LN59@stbi__hdr_:
  000cf	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv78[rbp]
  000d6	e9 46 09 00 00	 jmp	 $LN1@stbi__hdr_
$LN30@stbi__hdr_:
$LN2@stbi__hdr_:

; 6742 : 
; 6743 :     // Parse header
; 6744 :     for (;;) {
; 6745 :         token = stbi__hdr_gettoken(s, buffer);

  000db	48 8d 55 10	 lea	 rdx, QWORD PTR buffer$[rbp]
  000df	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000e6	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  000eb	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6746 :         if (token[0] == 0) break;

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	48 6b c0 00	 imul	 rax, rax, 0
  000fb	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  00102	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00106	85 c0		 test	 eax, eax
  00108	75 02		 jne	 SHORT $LN31@stbi__hdr_
  0010a	eb 23		 jmp	 SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 6747 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
  00113	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  0011a	e8 00 00 00 00	 call	 strcmp
  0011f	85 c0		 test	 eax, eax
  00121	75 0a		 jne	 SHORT $LN32@stbi__hdr_
  00123	c7 85 44 04 00
	00 01 00 00 00	 mov	 DWORD PTR valid$[rbp], 1
$LN32@stbi__hdr_:

; 6748 :     }

  0012d	eb ac		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6749 : 
; 6750 :     if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

  0012f	83 bd 44 04 00
	00 00		 cmp	 DWORD PTR valid$[rbp], 0
  00136	75 34		 jne	 SHORT $LN33@stbi__hdr_
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@NKJFFLKL@unsupported?5format@
  0013f	e8 00 00 00 00	 call	 stbi__err
  00144	85 c0		 test	 eax, eax
  00146	74 0d		 je	 SHORT $LN60@stbi__hdr_
  00148	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv94[rbp], 0
  00153	eb 0b		 jmp	 SHORT $LN61@stbi__hdr_
$LN60@stbi__hdr_:
  00155	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv94[rbp], 0
$LN61@stbi__hdr_:
  00160	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv94[rbp]
  00167	e9 b5 08 00 00	 jmp	 $LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 6751 : 
; 6752 :     // Parse width and height
; 6753 :     // can't use sscanf() if we're not using stdio!
; 6754 :     token = stbi__hdr_gettoken(s, buffer);

  0016c	48 8d 55 10	 lea	 rdx, QWORD PTR buffer$[rbp]
  00170	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00177	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  0017c	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6755 :     if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  00183	41 b8 03 00 00
	00		 mov	 r8d, 3
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
  00190	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0019d	85 c0		 test	 eax, eax
  0019f	74 34		 je	 SHORT $LN34@stbi__hdr_
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
  001a8	e8 00 00 00 00	 call	 stbi__err
  001ad	85 c0		 test	 eax, eax
  001af	74 0d		 je	 SHORT $LN62@stbi__hdr_
  001b1	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv138[rbp], 0
  001bc	eb 0b		 jmp	 SHORT $LN63@stbi__hdr_
$LN62@stbi__hdr_:
  001be	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv138[rbp], 0
$LN63@stbi__hdr_:
  001c9	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv138[rbp]
  001d0	e9 4c 08 00 00	 jmp	 $LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 6756 :     token += 3;

  001d5	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  001dc	48 83 c0 03	 add	 rax, 3
  001e0	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6757 :     height = (int)strtol(token, &token, 10);

  001e7	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001ed	48 8d 95 28 04
	00 00		 lea	 rdx, QWORD PTR token$[rbp]
  001f4	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00201	89 85 84 04 00
	00		 mov	 DWORD PTR height$[rbp], eax
$LN5@stbi__hdr_:

; 6758 :     while (*token == ' ') ++token;

  00207	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  0020e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00211	83 f8 20	 cmp	 eax, 32			; 00000020H
  00214	75 13		 jne	 SHORT $LN6@stbi__hdr_
  00216	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  0021d	48 ff c0	 inc	 rax
  00220	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax
  00227	eb de		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 6759 :     if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  00229	41 b8 03 00 00
	00		 mov	 r8d, 3
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
  00236	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00243	85 c0		 test	 eax, eax
  00245	74 34		 je	 SHORT $LN35@stbi__hdr_
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
  0024e	e8 00 00 00 00	 call	 stbi__err
  00253	85 c0		 test	 eax, eax
  00255	74 0d		 je	 SHORT $LN64@stbi__hdr_
  00257	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv155[rbp], 0
  00262	eb 0b		 jmp	 SHORT $LN65@stbi__hdr_
$LN64@stbi__hdr_:
  00264	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv155[rbp], 0
$LN65@stbi__hdr_:
  0026f	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv155[rbp]
  00276	e9 a6 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 6760 :     token += 3;

  0027b	48 8b 85 28 04
	00 00		 mov	 rax, QWORD PTR token$[rbp]
  00282	48 83 c0 03	 add	 rax, 3
  00286	48 89 85 28 04
	00 00		 mov	 QWORD PTR token$[rbp], rax

; 6761 :     width = (int)strtol(token, NULL, 10);

  0028d	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00293	33 d2		 xor	 edx, edx
  00295	48 8b 8d 28 04
	00 00		 mov	 rcx, QWORD PTR token$[rbp]
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  002a2	89 85 64 04 00
	00		 mov	 DWORD PTR width$[rbp], eax

; 6762 : 
; 6763 :     if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large", "Very large image (corrupt?)");

  002a8	81 bd 84 04 00
	00 00 00 00 01	 cmp	 DWORD PTR height$[rbp], 16777216 ; 01000000H
  002b2	7e 34		 jle	 SHORT $LN36@stbi__hdr_
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  002bb	e8 00 00 00 00	 call	 stbi__err
  002c0	85 c0		 test	 eax, eax
  002c2	74 0d		 je	 SHORT $LN66@stbi__hdr_
  002c4	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv165[rbp], 0
  002cf	eb 0b		 jmp	 SHORT $LN67@stbi__hdr_
$LN66@stbi__hdr_:
  002d1	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv165[rbp], 0
$LN67@stbi__hdr_:
  002dc	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv165[rbp]
  002e3	e9 39 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN36@stbi__hdr_:

; 6764 :     if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large", "Very large image (corrupt?)");

  002e8	81 bd 64 04 00
	00 00 00 00 01	 cmp	 DWORD PTR width$[rbp], 16777216 ; 01000000H
  002f2	7e 34		 jle	 SHORT $LN37@stbi__hdr_
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  002fb	e8 00 00 00 00	 call	 stbi__err
  00300	85 c0		 test	 eax, eax
  00302	74 0d		 je	 SHORT $LN68@stbi__hdr_
  00304	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv170[rbp], 0
  0030f	eb 0b		 jmp	 SHORT $LN69@stbi__hdr_
$LN68@stbi__hdr_:
  00311	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv170[rbp], 0
$LN69@stbi__hdr_:
  0031c	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv170[rbp]
  00323	e9 f9 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN37@stbi__hdr_:

; 6765 : 
; 6766 :     *x = width;

  00328	48 8b 85 b8 09
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  0032f	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR width$[rbp]
  00335	89 08		 mov	 DWORD PTR [rax], ecx

; 6767 :     *y = height;

  00337	48 8b 85 c0 09
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  0033e	8b 8d 84 04 00
	00		 mov	 ecx, DWORD PTR height$[rbp]
  00344	89 08		 mov	 DWORD PTR [rax], ecx

; 6768 : 
; 6769 :     if (comp) *comp = 3;

  00346	48 83 bd c8 09
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  0034e	74 0d		 je	 SHORT $LN38@stbi__hdr_
  00350	48 8b 85 c8 09
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00357	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN38@stbi__hdr_:

; 6770 :     if (req_comp == 0) req_comp = 3;

  0035d	83 bd d0 09 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00364	75 0a		 jne	 SHORT $LN39@stbi__hdr_
  00366	c7 85 d0 09 00
	00 03 00 00 00	 mov	 DWORD PTR req_comp$[rbp], 3
$LN39@stbi__hdr_:

; 6771 : 
; 6772 :     if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))

  00370	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00378	41 b9 04 00 00
	00		 mov	 r9d, 4
  0037e	44 8b 85 d0 09
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00385	8b 95 84 04 00
	00		 mov	 edx, DWORD PTR height$[rbp]
  0038b	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR width$[rbp]
  00391	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00396	85 c0		 test	 eax, eax
  00398	75 34		 jne	 SHORT $LN40@stbi__hdr_

; 6773 :         return stbi__errpf("too large", "HDR image is too large");

  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  003a1	e8 00 00 00 00	 call	 stbi__err
  003a6	85 c0		 test	 eax, eax
  003a8	74 0d		 je	 SHORT $LN70@stbi__hdr_
  003aa	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv183[rbp], 0
  003b5	eb 0b		 jmp	 SHORT $LN71@stbi__hdr_
$LN70@stbi__hdr_:
  003b7	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv183[rbp], 0
$LN71@stbi__hdr_:
  003c2	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv183[rbp]
  003c9	e9 53 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN40@stbi__hdr_:

; 6774 : 
; 6775 :     // Read data
; 6776 :     hdr_data = (float*)stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);

  003ce	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  003d6	41 b9 04 00 00
	00		 mov	 r9d, 4
  003dc	44 8b 85 d0 09
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  003e3	8b 95 84 04 00
	00		 mov	 edx, DWORD PTR height$[rbp]
  003e9	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR width$[rbp]
  003ef	e8 00 00 00 00	 call	 stbi__malloc_mad4
  003f4	48 89 85 c8 04
	00 00		 mov	 QWORD PTR hdr_data$[rbp], rax

; 6777 :     if (!hdr_data)

  003fb	48 83 bd c8 04
	00 00 00	 cmp	 QWORD PTR hdr_data$[rbp], 0
  00403	75 34		 jne	 SHORT $LN41@stbi__hdr_

; 6778 :         return stbi__errpf("outofmem", "Out of memory");

  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0040c	e8 00 00 00 00	 call	 stbi__err
  00411	85 c0		 test	 eax, eax
  00413	74 0d		 je	 SHORT $LN72@stbi__hdr_
  00415	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv194[rbp], 0
  00420	eb 0b		 jmp	 SHORT $LN73@stbi__hdr_
$LN72@stbi__hdr_:
  00422	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv194[rbp], 0
$LN73@stbi__hdr_:
  0042d	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv194[rbp]
  00434	e9 e8 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN41@stbi__hdr_:

; 6779 : 
; 6780 :     // Load image data
; 6781 :     // image data is stored as some number of sca
; 6782 :     if (width < 8 || width >= 32768) {

  00439	83 bd 64 04 00
	00 08		 cmp	 DWORD PTR width$[rbp], 8
  00440	7c 10		 jl	 SHORT $LN44@stbi__hdr_
  00442	81 bd 64 04 00
	00 00 80 00 00	 cmp	 DWORD PTR width$[rbp], 32768 ; 00008000H
  0044c	0f 8c c7 00 00
	00		 jl	 $LN42@stbi__hdr_
$LN44@stbi__hdr_:

; 6783 :         // Read flat data
; 6784 :         for (j = 0; j < height; ++j) {

  00452	c7 85 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  0045c	eb 0e		 jmp	 SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
  0045e	8b 85 64 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  00464	ff c0		 inc	 eax
  00466	89 85 64 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN9@stbi__hdr_:
  0046c	8b 85 84 04 00
	00		 mov	 eax, DWORD PTR height$[rbp]
  00472	39 85 64 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  00478	0f 8d 96 00 00
	00		 jge	 $LN8@stbi__hdr_

; 6785 :             for (i = 0; i < width; ++i) {

  0047e	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00488	eb 0e		 jmp	 SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
  0048a	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00490	ff c0		 inc	 eax
  00492	89 85 44 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN12@stbi__hdr_:
  00498	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  0049e	39 85 44 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  004a4	7d 69		 jge	 SHORT $LN11@stbi__hdr_
$main_decode_loop$82:

; 6786 :                 stbi_uc rgbe[4];
; 6787 :             main_decode_loop:
; 6788 :                 stbi__getn(s, rgbe, 4);

  004a6	41 b8 04 00 00
	00		 mov	 r8d, 4
  004ac	48 8d 95 24 06
	00 00		 lea	 rdx, QWORD PTR rgbe$7[rbp]
  004b3	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004ba	e8 00 00 00 00	 call	 stbi__getn

; 6789 :                 stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

  004bf	8b 85 64 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  004c5	0f af 85 64 04
	00 00		 imul	 eax, DWORD PTR width$[rbp]
  004cc	0f af 85 d0 09
	00 00		 imul	 eax, DWORD PTR req_comp$[rbp]
  004d3	48 98		 cdqe
  004d5	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  004dc	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  004e0	8b 8d 44 05 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  004e6	0f af 8d d0 09
	00 00		 imul	 ecx, DWORD PTR req_comp$[rbp]
  004ed	48 63 c9	 movsxd	 rcx, ecx
  004f0	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  004f4	44 8b 85 d0 09
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  004fb	48 8d 95 24 06
	00 00		 lea	 rdx, QWORD PTR rgbe$7[rbp]
  00502	48 8b c8	 mov	 rcx, rax
  00505	e8 00 00 00 00	 call	 stbi__hdr_convert

; 6790 :             }

  0050a	e9 7b ff ff ff	 jmp	 $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 6791 :         }

  0050f	e9 4a ff ff ff	 jmp	 $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 6792 :     }

  00514	e9 01 05 00 00	 jmp	 $LN43@stbi__hdr_
$LN42@stbi__hdr_:

; 6793 :     else {
; 6794 :         // Read RLE-encoded data
; 6795 :         scanline = NULL;

  00519	48 c7 85 a8 04
	00 00 00 00 00
	00		 mov	 QWORD PTR scanline$[rbp], 0

; 6796 : 
; 6797 :         for (j = 0; j < height; ++j) {

  00524	c7 85 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  0052e	eb 0e		 jmp	 SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
  00530	8b 85 64 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  00536	ff c0		 inc	 eax
  00538	89 85 64 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN15@stbi__hdr_:
  0053e	8b 85 84 04 00
	00		 mov	 eax, DWORD PTR height$[rbp]
  00544	39 85 64 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  0054a	0f 8d b3 04 00
	00		 jge	 $LN14@stbi__hdr_

; 6798 :             c1 = stbi__get8(s);

  00550	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00557	e8 00 00 00 00	 call	 stbi__get8
  0055c	0f b6 c0	 movzx	 eax, al
  0055f	89 85 a4 05 00
	00		 mov	 DWORD PTR c1$[rbp], eax

; 6799 :             c2 = stbi__get8(s);

  00565	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0056c	e8 00 00 00 00	 call	 stbi__get8
  00571	0f b6 c0	 movzx	 eax, al
  00574	89 85 c4 05 00
	00		 mov	 DWORD PTR c2$[rbp], eax

; 6800 :             len = stbi__get8(s);

  0057a	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00581	e8 00 00 00 00	 call	 stbi__get8
  00586	0f b6 c0	 movzx	 eax, al
  00589	89 85 e4 04 00
	00		 mov	 DWORD PTR len$[rbp], eax

; 6801 :             if (c1 != 2 || c2 != 2 || (len & 0x80)) {

  0058f	83 bd a4 05 00
	00 02		 cmp	 DWORD PTR c1$[rbp], 2
  00596	75 1c		 jne	 SHORT $LN46@stbi__hdr_
  00598	83 bd c4 05 00
	00 02		 cmp	 DWORD PTR c2$[rbp], 2
  0059f	75 13		 jne	 SHORT $LN46@stbi__hdr_
  005a1	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR len$[rbp]
  005a7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005ac	85 c0		 test	 eax, eax
  005ae	0f 84 a1 00 00
	00		 je	 $LN45@stbi__hdr_
$LN46@stbi__hdr_:

; 6802 :                 // not run-length encoded, so we have to actually use THIS data as a decoded
; 6803 :                 // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 6804 :                 stbi_uc rgbe[4];
; 6805 :                 rgbe[0] = (stbi_uc)c1;

  005b4	b8 01 00 00 00	 mov	 eax, 1
  005b9	48 6b c0 00	 imul	 rax, rax, 0
  005bd	0f b6 8d a4 05
	00 00		 movzx	 ecx, BYTE PTR c1$[rbp]
  005c4	88 8c 05 44 06
	00 00		 mov	 BYTE PTR rgbe$8[rbp+rax], cl

; 6806 :                 rgbe[1] = (stbi_uc)c2;

  005cb	b8 01 00 00 00	 mov	 eax, 1
  005d0	48 6b c0 01	 imul	 rax, rax, 1
  005d4	0f b6 8d c4 05
	00 00		 movzx	 ecx, BYTE PTR c2$[rbp]
  005db	88 8c 05 44 06
	00 00		 mov	 BYTE PTR rgbe$8[rbp+rax], cl

; 6807 :                 rgbe[2] = (stbi_uc)len;

  005e2	b8 01 00 00 00	 mov	 eax, 1
  005e7	48 6b c0 02	 imul	 rax, rax, 2
  005eb	0f b6 8d e4 04
	00 00		 movzx	 ecx, BYTE PTR len$[rbp]
  005f2	88 8c 05 44 06
	00 00		 mov	 BYTE PTR rgbe$8[rbp+rax], cl

; 6808 :                 rgbe[3] = (stbi_uc)stbi__get8(s);

  005f9	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00600	e8 00 00 00 00	 call	 stbi__get8
  00605	b9 01 00 00 00	 mov	 ecx, 1
  0060a	48 6b c9 03	 imul	 rcx, rcx, 3
  0060e	88 84 0d 44 06
	00 00		 mov	 BYTE PTR rgbe$8[rbp+rcx], al

; 6809 :                 stbi__hdr_convert(hdr_data, rgbe, req_comp);

  00615	44 8b 85 d0 09
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  0061c	48 8d 95 44 06
	00 00		 lea	 rdx, QWORD PTR rgbe$8[rbp]
  00623	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  0062a	e8 00 00 00 00	 call	 stbi__hdr_convert

; 6810 :                 i = 1;

  0062f	c7 85 44 05 00
	00 01 00 00 00	 mov	 DWORD PTR i$[rbp], 1

; 6811 :                 j = 0;

  00639	c7 85 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0

; 6812 :                 STBI_FREE(scanline);

  00643	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  0064a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6813 :                 goto main_decode_loop; // yes, this makes no sense

  00650	e9 51 fe ff ff	 jmp	 $main_decode_loop$82
$LN45@stbi__hdr_:

; 6814 :             }
; 6815 :             len <<= 8;

  00655	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR len$[rbp]
  0065b	c1 e0 08	 shl	 eax, 8
  0065e	89 85 e4 04 00
	00		 mov	 DWORD PTR len$[rbp], eax

; 6816 :             len |= stbi__get8(s);

  00664	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0066b	e8 00 00 00 00	 call	 stbi__get8
  00670	0f b6 c0	 movzx	 eax, al
  00673	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR len$[rbp]
  00679	0b c8		 or	 ecx, eax
  0067b	8b c1		 mov	 eax, ecx
  0067d	89 85 e4 04 00
	00		 mov	 DWORD PTR len$[rbp], eax

; 6817 :             if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

  00683	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  00689	39 85 e4 04 00
	00		 cmp	 DWORD PTR len$[rbp], eax
  0068f	74 4e		 je	 SHORT $LN47@stbi__hdr_
  00691	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  00698	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0069e	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  006a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  006ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
  006b2	e8 00 00 00 00	 call	 stbi__err
  006b7	85 c0		 test	 eax, eax
  006b9	74 0d		 je	 SHORT $LN74@stbi__hdr_
  006bb	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv256[rbp], 0
  006c6	eb 0b		 jmp	 SHORT $LN75@stbi__hdr_
$LN74@stbi__hdr_:
  006c8	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv256[rbp], 0
$LN75@stbi__hdr_:
  006d3	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv256[rbp]
  006da	e9 42 03 00 00	 jmp	 $LN1@stbi__hdr_
$LN47@stbi__hdr_:

; 6818 :             if (scanline == NULL) {

  006df	48 83 bd a8 04
	00 00 00	 cmp	 QWORD PTR scanline$[rbp], 0
  006e7	75 65		 jne	 SHORT $LN48@stbi__hdr_

; 6819 :                 scanline = (stbi_uc*)stbi__malloc_mad2(width, 4, 0);

  006e9	45 33 c0	 xor	 r8d, r8d
  006ec	ba 04 00 00 00	 mov	 edx, 4
  006f1	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR width$[rbp]
  006f7	e8 00 00 00 00	 call	 stbi__malloc_mad2
  006fc	48 89 85 a8 04
	00 00		 mov	 QWORD PTR scanline$[rbp], rax

; 6820 :                 if (!scanline) {

  00703	48 83 bd a8 04
	00 00 00	 cmp	 QWORD PTR scanline$[rbp], 0
  0070b	75 41		 jne	 SHORT $LN49@stbi__hdr_

; 6821 :                     STBI_FREE(hdr_data);

  0070d	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  00714	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6822 :                     return stbi__errpf("outofmem", "Out of memory");

  0071a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00721	e8 00 00 00 00	 call	 stbi__err
  00726	85 c0		 test	 eax, eax
  00728	74 0d		 je	 SHORT $LN76@stbi__hdr_
  0072a	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv267[rbp], 0
  00735	eb 0b		 jmp	 SHORT $LN77@stbi__hdr_
$LN76@stbi__hdr_:
  00737	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv267[rbp], 0
$LN77@stbi__hdr_:
  00742	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv267[rbp]
  00749	e9 d3 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN49@stbi__hdr_:
$LN48@stbi__hdr_:

; 6823 :                 }
; 6824 :             }
; 6825 : 
; 6826 :             for (k = 0; k < 4; ++k) {

  0074e	c7 85 84 05 00
	00 00 00 00 00	 mov	 DWORD PTR k$[rbp], 0
  00758	eb 0e		 jmp	 SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
  0075a	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00760	ff c0		 inc	 eax
  00762	89 85 84 05 00
	00		 mov	 DWORD PTR k$[rbp], eax
$LN18@stbi__hdr_:
  00768	83 bd 84 05 00
	00 04		 cmp	 DWORD PTR k$[rbp], 4
  0076f	0f 8d 10 02 00
	00		 jge	 $LN17@stbi__hdr_

; 6827 :                 int nleft;
; 6828 :                 i = 0;

  00775	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
$LN19@stbi__hdr_:

; 6829 :                 while ((nleft = width - i) > 0) {

  0077f	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00785	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR width$[rbp]
  0078b	2b c8		 sub	 ecx, eax
  0078d	8b c1		 mov	 eax, ecx
  0078f	89 85 64 06 00
	00		 mov	 DWORD PTR nleft$9[rbp], eax
  00795	83 bd 64 06 00
	00 00		 cmp	 DWORD PTR nleft$9[rbp], 0
  0079c	0f 8e de 01 00
	00		 jle	 $LN20@stbi__hdr_

; 6830 :                     count = stbi__get8(s);

  007a2	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  007a9	e8 00 00 00 00	 call	 stbi__get8
  007ae	88 85 04 05 00
	00		 mov	 BYTE PTR count$[rbp], al

; 6831 :                     if (count > 128) {

  007b4	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  007bb	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  007c0	0f 8e ec 00 00
	00		 jle	 $LN50@stbi__hdr_

; 6832 :                         // Run
; 6833 :                         value = stbi__get8(s);

  007c6	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  007cd	e8 00 00 00 00	 call	 stbi__get8
  007d2	88 85 24 05 00
	00		 mov	 BYTE PTR value$[rbp], al

; 6834 :                         count -= 128;

  007d8	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  007df	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  007e4	88 85 04 05 00
	00		 mov	 BYTE PTR count$[rbp], al

; 6835 :                         if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  007ea	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  007f1	85 c0		 test	 eax, eax
  007f3	74 0f		 je	 SHORT $LN53@stbi__hdr_
  007f5	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  007fc	3b 85 64 06 00
	00		 cmp	 eax, DWORD PTR nleft$9[rbp]
  00802	7e 4e		 jle	 SHORT $LN52@stbi__hdr_
$LN53@stbi__hdr_:
  00804	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  0080b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00811	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  00818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0081e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  00825	e8 00 00 00 00	 call	 stbi__err
  0082a	85 c0		 test	 eax, eax
  0082c	74 0d		 je	 SHORT $LN78@stbi__hdr_
  0082e	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv290[rbp], 0
  00839	eb 0b		 jmp	 SHORT $LN79@stbi__hdr_
$LN78@stbi__hdr_:
  0083b	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv290[rbp], 0
$LN79@stbi__hdr_:
  00846	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv290[rbp]
  0084d	e9 cf 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN52@stbi__hdr_:

; 6836 :                         for (z = 0; z < count; ++z)

  00852	c7 85 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR z$[rbp], 0
  0085c	eb 0e		 jmp	 SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
  0085e	8b 85 e4 05 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  00864	ff c0		 inc	 eax
  00866	89 85 e4 05 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN23@stbi__hdr_:
  0086c	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  00873	39 85 e4 05 00
	00		 cmp	 DWORD PTR z$[rbp], eax
  00879	7d 32		 jge	 SHORT $LN22@stbi__hdr_

; 6837 :                             scanline[i++ * 4 + k] = value;

  0087b	8b 85 84 05 00
	00		 mov	 eax, DWORD PTR k$[rbp]
  00881	8b 8d 44 05 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  00887	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  0088a	48 98		 cdqe
  0088c	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  00893	0f b6 95 24 05
	00 00		 movzx	 edx, BYTE PTR value$[rbp]
  0089a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0089d	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  008a3	ff c0		 inc	 eax
  008a5	89 85 44 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
  008ab	eb b1		 jmp	 SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 6838 :                     }

  008ad	e9 c9 00 00 00	 jmp	 $LN51@stbi__hdr_
$LN50@stbi__hdr_:

; 6839 :                     else {
; 6840 :                         // Dump
; 6841 :                         if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  008b2	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  008b9	85 c0		 test	 eax, eax
  008bb	74 0f		 je	 SHORT $LN55@stbi__hdr_
  008bd	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  008c4	3b 85 64 06 00
	00		 cmp	 eax, DWORD PTR nleft$9[rbp]
  008ca	7e 4e		 jle	 SHORT $LN54@stbi__hdr_
$LN55@stbi__hdr_:
  008cc	48 8b 8d c8 04
	00 00		 mov	 rcx, QWORD PTR hdr_data$[rbp]
  008d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  008d9	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  008e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  008e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  008ed	e8 00 00 00 00	 call	 stbi__err
  008f2	85 c0		 test	 eax, eax
  008f4	74 0d		 je	 SHORT $LN80@stbi__hdr_
  008f6	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv309[rbp], 0
  00901	eb 0b		 jmp	 SHORT $LN81@stbi__hdr_
$LN80@stbi__hdr_:
  00903	48 c7 85 78 09
	00 00 00 00 00
	00		 mov	 QWORD PTR tv309[rbp], 0
$LN81@stbi__hdr_:
  0090e	48 8b 85 78 09
	00 00		 mov	 rax, QWORD PTR tv309[rbp]
  00915	e9 07 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN54@stbi__hdr_:

; 6842 :                         for (z = 0; z < count; ++z)

  0091a	c7 85 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR z$[rbp], 0
  00924	eb 0e		 jmp	 SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
  00926	8b 85 e4 05 00
	00		 mov	 eax, DWORD PTR z$[rbp]
  0092c	ff c0		 inc	 eax
  0092e	89 85 e4 05 00
	00		 mov	 DWORD PTR z$[rbp], eax
$LN26@stbi__hdr_:
  00934	0f b6 85 04 05
	00 00		 movzx	 eax, BYTE PTR count$[rbp]
  0093b	39 85 e4 05 00
	00		 cmp	 DWORD PTR z$[rbp], eax
  00941	7d 38		 jge	 SHORT $LN25@stbi__hdr_

; 6843 :                             scanline[i++ * 4 + k] = stbi__get8(s);

  00943	48 8b 8d b0 09
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0094a	e8 00 00 00 00	 call	 stbi__get8
  0094f	8b 8d 84 05 00
	00		 mov	 ecx, DWORD PTR k$[rbp]
  00955	8b 95 44 05 00
	00		 mov	 edx, DWORD PTR i$[rbp]
  0095b	8d 0c 91	 lea	 ecx, DWORD PTR [rcx+rdx*4]
  0095e	48 63 c9	 movsxd	 rcx, ecx
  00961	48 8b 95 a8 04
	00 00		 mov	 rdx, QWORD PTR scanline$[rbp]
  00968	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0096b	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00971	ff c0		 inc	 eax
  00973	89 85 44 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
  00979	eb ab		 jmp	 SHORT $LN24@stbi__hdr_
$LN25@stbi__hdr_:
$LN51@stbi__hdr_:

; 6844 :                     }
; 6845 :                 }

  0097b	e9 ff fd ff ff	 jmp	 $LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 6846 :             }

  00980	e9 d5 fd ff ff	 jmp	 $LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 6847 :             for (i = 0; i < width; ++i)

  00985	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  0098f	eb 0e		 jmp	 SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
  00991	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00997	ff c0		 inc	 eax
  00999	89 85 44 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN29@stbi__hdr_:
  0099f	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  009a5	39 85 44 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  009ab	7d 51		 jge	 SHORT $LN28@stbi__hdr_

; 6848 :                 stbi__hdr_convert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);

  009ad	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  009b3	c1 e0 02	 shl	 eax, 2
  009b6	48 98		 cdqe
  009b8	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  009bf	48 03 c8	 add	 rcx, rax
  009c2	48 8b c1	 mov	 rax, rcx
  009c5	8b 8d 64 05 00
	00		 mov	 ecx, DWORD PTR j$[rbp]
  009cb	0f af 8d 64 04
	00 00		 imul	 ecx, DWORD PTR width$[rbp]
  009d2	03 8d 44 05 00
	00		 add	 ecx, DWORD PTR i$[rbp]
  009d8	0f af 8d d0 09
	00 00		 imul	 ecx, DWORD PTR req_comp$[rbp]
  009df	48 63 c9	 movsxd	 rcx, ecx
  009e2	48 8b 95 c8 04
	00 00		 mov	 rdx, QWORD PTR hdr_data$[rbp]
  009e9	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  009ed	44 8b 85 d0 09
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  009f4	48 8b d0	 mov	 rdx, rax
  009f7	e8 00 00 00 00	 call	 stbi__hdr_convert
  009fc	eb 93		 jmp	 SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 6849 :         }

  009fe	e9 2d fb ff ff	 jmp	 $LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 6850 :         if (scanline)

  00a03	48 83 bd a8 04
	00 00 00	 cmp	 QWORD PTR scanline$[rbp], 0
  00a0b	74 0d		 je	 SHORT $LN56@stbi__hdr_

; 6851 :             STBI_FREE(scanline);

  00a0d	48 8b 8d a8 04
	00 00		 mov	 rcx, QWORD PTR scanline$[rbp]
  00a14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN56@stbi__hdr_:
$LN43@stbi__hdr_:

; 6852 :     }
; 6853 : 
; 6854 :     return hdr_data;

  00a1a	48 8b 85 c8 04
	00 00		 mov	 rax, QWORD PTR hdr_data$[rbp]
$LN1@stbi__hdr_:

; 6855 : }

  00a21	48 8b f8	 mov	 rdi, rax
  00a24	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00a28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__hdr_load$rtcFrameData
  00a2f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00a34	48 8b c7	 mov	 rax, rdi
  00a37	48 8b 8d 80 09
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00a3e	48 33 cd	 xor	 rcx, rbp
  00a41	e8 00 00 00 00	 call	 __security_check_cookie
  00a46	48 8d a5 98 09
	00 00		 lea	 rsp, QWORD PTR [rbp+2456]
  00a4d	5f		 pop	 rdi
  00a4e	5d		 pop	 rbp
  00a4f	c3		 ret	 0
stbi__hdr_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__hdr_test
_TEXT	SEGMENT
r$ = 4
s$ = 256
stbi__hdr_test PROC					; COMDAT

; 6663 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6664 :     int r = stbi__hdr_test_core(s, "#?RADIANCE\n");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
  00026	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002d	e8 00 00 00 00	 call	 stbi__hdr_test_core
  00032	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 6665 :     stbi__rewind(s);

  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__rewind

; 6666 :     if (!r) {

  00041	83 7d 04 00	 cmp	 DWORD PTR r$[rbp], 0
  00045	75 22		 jne	 SHORT $LN2@stbi__hdr_

; 6667 :         r = stbi__hdr_test_core(s, "#?RGBE\n");

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
  0004e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00055	e8 00 00 00 00	 call	 stbi__hdr_test_core
  0005a	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 6668 :         stbi__rewind(s);

  0005d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00064	e8 00 00 00 00	 call	 stbi__rewind
$LN2@stbi__hdr_:

; 6669 :     }
; 6670 :     return r;

  00069	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 6671 : }

  0006c	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00073	5f		 pop	 rdi
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
stbi__hdr_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__psd_is16
_TEXT	SEGMENT
channelCount$ = 4
depth$ = 36
s$ = 288
stbi__psd_is16 PROC					; COMDAT

; 6963 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6964 :     int channelCount, depth;
; 6965 :     if (stbi__get32be(s) != 0x38425053) {

  0001f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get32be
  0002b	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00030	74 13		 je	 SHORT $LN2@stbi__psd_

; 6966 :         stbi__rewind(s);

  00032	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00039	e8 00 00 00 00	 call	 stbi__rewind

; 6967 :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 9f 00 00 00	 jmp	 $LN1@stbi__psd_
$LN2@stbi__psd_:

; 6968 :     }
; 6969 :     if (stbi__get16be(s) != 1) {

  00045	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0004c	e8 00 00 00 00	 call	 stbi__get16be
  00051	83 f8 01	 cmp	 eax, 1
  00054	74 10		 je	 SHORT $LN3@stbi__psd_

; 6970 :         stbi__rewind(s);

  00056	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005d	e8 00 00 00 00	 call	 stbi__rewind

; 6971 :         return 0;

  00062	33 c0		 xor	 eax, eax
  00064	eb 7e		 jmp	 SHORT $LN1@stbi__psd_
$LN3@stbi__psd_:

; 6972 :     }
; 6973 :     stbi__skip(s, 6);

  00066	ba 06 00 00 00	 mov	 edx, 6
  0006b	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00072	e8 00 00 00 00	 call	 stbi__skip

; 6974 :     channelCount = stbi__get16be(s);

  00077	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0007e	e8 00 00 00 00	 call	 stbi__get16be
  00083	89 45 04	 mov	 DWORD PTR channelCount$[rbp], eax

; 6975 :     if (channelCount < 0 || channelCount > 16) {

  00086	83 7d 04 00	 cmp	 DWORD PTR channelCount$[rbp], 0
  0008a	7c 06		 jl	 SHORT $LN5@stbi__psd_
  0008c	83 7d 04 10	 cmp	 DWORD PTR channelCount$[rbp], 16
  00090	7e 10		 jle	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 6976 :         stbi__rewind(s);

  00092	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00099	e8 00 00 00 00	 call	 stbi__rewind

; 6977 :         return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	eb 42		 jmp	 SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 6978 :     }
; 6979 :     STBI_NOTUSED(stbi__get32be(s));

  000a2	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a9	e8 00 00 00 00	 call	 stbi__get32be

; 6980 :     STBI_NOTUSED(stbi__get32be(s));

  000ae	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b5	e8 00 00 00 00	 call	 stbi__get32be

; 6981 :     depth = stbi__get16be(s);

  000ba	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c1	e8 00 00 00 00	 call	 stbi__get16be
  000c6	89 45 24	 mov	 DWORD PTR depth$[rbp], eax

; 6982 :     if (depth != 16) {

  000c9	83 7d 24 10	 cmp	 DWORD PTR depth$[rbp], 16
  000cd	74 10		 je	 SHORT $LN6@stbi__psd_

; 6983 :         stbi__rewind(s);

  000cf	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d6	e8 00 00 00 00	 call	 stbi__rewind

; 6984 :         return 0;

  000db	33 c0		 xor	 eax, eax
  000dd	eb 05		 jmp	 SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 6985 :     }
; 6986 :     return 1;

  000df	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 6987 : }

  000e4	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000eb	5f		 pop	 rdi
  000ec	5d		 pop	 rbp
  000ed	c3		 ret	 0
stbi__psd_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__psd_info
_TEXT	SEGMENT
channelCount$ = 4
dummy$ = 36
depth$ = 68
__$ArrayPad$ = 280
s$ = 320
x$ = 328
y$ = 336
comp$ = 344
stbi__psd_info PROC					; COMDAT

; 6928 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 1a 00 00 00	 mov	 ecx, 26
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 18 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6929 :     int channelCount, dummy, depth;
; 6930 :     if (!x) x = &dummy;

  00058	48 83 bd 48 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00060	75 0b		 jne	 SHORT $LN2@stbi__psd_
  00062	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  00066	48 89 85 48 01
	00 00		 mov	 QWORD PTR x$[rbp], rax
$LN2@stbi__psd_:

; 6931 :     if (!y) y = &dummy;

  0006d	48 83 bd 50 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00075	75 0b		 jne	 SHORT $LN3@stbi__psd_
  00077	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  0007b	48 89 85 50 01
	00 00		 mov	 QWORD PTR y$[rbp], rax
$LN3@stbi__psd_:

; 6932 :     if (!comp) comp = &dummy;

  00082	48 83 bd 58 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  0008a	75 0b		 jne	 SHORT $LN4@stbi__psd_
  0008c	48 8d 45 24	 lea	 rax, QWORD PTR dummy$[rbp]
  00090	48 89 85 58 01
	00 00		 mov	 QWORD PTR comp$[rbp], rax
$LN4@stbi__psd_:

; 6933 :     if (stbi__get32be(s) != 0x38425053) {

  00097	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009e	e8 00 00 00 00	 call	 stbi__get32be
  000a3	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  000a8	74 13		 je	 SHORT $LN5@stbi__psd_

; 6934 :         stbi__rewind(s);

  000aa	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b1	e8 00 00 00 00	 call	 stbi__rewind

; 6935 :         return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 eb 00 00 00	 jmp	 $LN1@stbi__psd_
$LN5@stbi__psd_:

; 6936 :     }
; 6937 :     if (stbi__get16be(s) != 1) {

  000bd	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c4	e8 00 00 00 00	 call	 stbi__get16be
  000c9	83 f8 01	 cmp	 eax, 1
  000cc	74 13		 je	 SHORT $LN6@stbi__psd_

; 6938 :         stbi__rewind(s);

  000ce	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d5	e8 00 00 00 00	 call	 stbi__rewind

; 6939 :         return 0;

  000da	33 c0		 xor	 eax, eax
  000dc	e9 c7 00 00 00	 jmp	 $LN1@stbi__psd_
$LN6@stbi__psd_:

; 6940 :     }
; 6941 :     stbi__skip(s, 6);

  000e1	ba 06 00 00 00	 mov	 edx, 6
  000e6	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ed	e8 00 00 00 00	 call	 stbi__skip

; 6942 :     channelCount = stbi__get16be(s);

  000f2	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f9	e8 00 00 00 00	 call	 stbi__get16be
  000fe	89 45 04	 mov	 DWORD PTR channelCount$[rbp], eax

; 6943 :     if (channelCount < 0 || channelCount > 16) {

  00101	83 7d 04 00	 cmp	 DWORD PTR channelCount$[rbp], 0
  00105	7c 06		 jl	 SHORT $LN8@stbi__psd_
  00107	83 7d 04 10	 cmp	 DWORD PTR channelCount$[rbp], 16
  0010b	7e 13		 jle	 SHORT $LN7@stbi__psd_
$LN8@stbi__psd_:

; 6944 :         stbi__rewind(s);

  0010d	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00114	e8 00 00 00 00	 call	 stbi__rewind

; 6945 :         return 0;

  00119	33 c0		 xor	 eax, eax
  0011b	e9 88 00 00 00	 jmp	 $LN1@stbi__psd_
$LN7@stbi__psd_:

; 6946 :     }
; 6947 :     *y = stbi__get32be(s);

  00120	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00127	e8 00 00 00 00	 call	 stbi__get32be
  0012c	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR y$[rbp]
  00133	89 01		 mov	 DWORD PTR [rcx], eax

; 6948 :     *x = stbi__get32be(s);

  00135	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0013c	e8 00 00 00 00	 call	 stbi__get32be
  00141	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR x$[rbp]
  00148	89 01		 mov	 DWORD PTR [rcx], eax

; 6949 :     depth = stbi__get16be(s);

  0014a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00151	e8 00 00 00 00	 call	 stbi__get16be
  00156	89 45 44	 mov	 DWORD PTR depth$[rbp], eax

; 6950 :     if (depth != 8 && depth != 16) {

  00159	83 7d 44 08	 cmp	 DWORD PTR depth$[rbp], 8
  0015d	74 16		 je	 SHORT $LN9@stbi__psd_
  0015f	83 7d 44 10	 cmp	 DWORD PTR depth$[rbp], 16
  00163	74 10		 je	 SHORT $LN9@stbi__psd_

; 6951 :         stbi__rewind(s);

  00165	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0016c	e8 00 00 00 00	 call	 stbi__rewind

; 6952 :         return 0;

  00171	33 c0		 xor	 eax, eax
  00173	eb 33		 jmp	 SHORT $LN1@stbi__psd_
$LN9@stbi__psd_:

; 6953 :     }
; 6954 :     if (stbi__get16be(s) != 3) {

  00175	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0017c	e8 00 00 00 00	 call	 stbi__get16be
  00181	83 f8 03	 cmp	 eax, 3
  00184	74 10		 je	 SHORT $LN10@stbi__psd_

; 6955 :         stbi__rewind(s);

  00186	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0018d	e8 00 00 00 00	 call	 stbi__rewind

; 6956 :         return 0;

  00192	33 c0		 xor	 eax, eax
  00194	eb 12		 jmp	 SHORT $LN1@stbi__psd_
$LN10@stbi__psd_:

; 6957 :     }
; 6958 :     *comp = 4;

  00196	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  0019d	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 6959 :     return 1;

  001a3	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 6960 : }

  001a8	48 8b f8	 mov	 rdi, rax
  001ab	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__psd_info$rtcFrameData
  001b6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001bb	48 8b c7	 mov	 rax, rdi
  001be	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001c5	48 33 cd	 xor	 rcx, rbp
  001c8	e8 00 00 00 00	 call	 __security_check_cookie
  001cd	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  001d4	5f		 pop	 rdi
  001d5	5d		 pop	 rbp
  001d6	c3		 ret	 0
stbi__psd_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__psd_load
_TEXT	SEGMENT
pixelCount$ = 4
channelCount$ = 36
compression$ = 68
channel$ = 100
i$ = 132
bitdepth$ = 164
w$ = 196
h$ = 228
out$ = 264
p$1 = 296
q$2 = 328
val$3 = 356
p$4 = 392
val$5 = 420
q$6 = 456
p$7 = 488
pixel$8 = 520
a$9 = 548
ra$10 = 580
inv_a$11 = 612
pixel$12 = 648
a$13 = 676
ra$14 = 708
inv_a$15 = 740
tv241 = 1140
tv233 = 1140
tv212 = 1140
tv223 = 1144
tv196 = 1144
tv177 = 1144
tv167 = 1144
tv148 = 1144
tv141 = 1144
tv133 = 1144
tv128 = 1144
tv87 = 1144
tv77 = 1144
tv70 = 1144
s$ = 1184
x$ = 1192
y$ = 1200
comp$ = 1208
req_comp$ = 1216
ri$ = 1224
bpc$ = 1232
stbi__psd_load PROC					; COMDAT

; 5668 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec b8 04
	00 00		 sub	 rsp, 1208		; 000004b8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5669 :     int pixelCount;
; 5670 :     int channelCount, compression;
; 5671 :     int channel, i;
; 5672 :     int bitdepth;
; 5673 :     int w, h;
; 5674 :     stbi_uc* out;
; 5675 :     STBI_NOTUSED(ri);
; 5676 : 
; 5677 :     // Check identifier
; 5678 :     if (stbi__get32be(s) != 0x38425053)   // "8BPS"

  0002e	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__get32be
  0003a	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0003f	74 34		 je	 SHORT $LN32@stbi__psd_

; 5679 :         return stbi__errpuc("not PSD", "Corrupt PSD image");

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07ECNCNLIK@not?5PSD@
  00048	e8 00 00 00 00	 call	 stbi__err
  0004d	85 c0		 test	 eax, eax
  0004f	74 0d		 je	 SHORT $LN69@stbi__psd_
  00051	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv70[rbp], 0
  0005c	eb 0b		 jmp	 SHORT $LN70@stbi__psd_
$LN69@stbi__psd_:
  0005e	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv70[rbp], 0
$LN70@stbi__psd_:
  00069	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv70[rbp]
  00070	e9 b1 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN32@stbi__psd_:

; 5680 : 
; 5681 :     // Check file type version.
; 5682 :     if (stbi__get16be(s) != 1)

  00075	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0007c	e8 00 00 00 00	 call	 stbi__get16be
  00081	83 f8 01	 cmp	 eax, 1
  00084	74 34		 je	 SHORT $LN33@stbi__psd_

; 5683 :         return stbi__errpuc("wrong version", "Unsupported version of PSD image");

  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CHBCDKKC@wrong?5version@
  0008d	e8 00 00 00 00	 call	 stbi__err
  00092	85 c0		 test	 eax, eax
  00094	74 0d		 je	 SHORT $LN71@stbi__psd_
  00096	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv77[rbp], 0
  000a1	eb 0b		 jmp	 SHORT $LN72@stbi__psd_
$LN71@stbi__psd_:
  000a3	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv77[rbp], 0
$LN72@stbi__psd_:
  000ae	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv77[rbp]
  000b5	e9 6c 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN33@stbi__psd_:

; 5684 : 
; 5685 :     // Skip 6 reserved bytes.
; 5686 :     stbi__skip(s, 6);

  000ba	ba 06 00 00 00	 mov	 edx, 6
  000bf	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c6	e8 00 00 00 00	 call	 stbi__skip

; 5687 : 
; 5688 :     // Read the number of channels (R, G, B, A, etc).
; 5689 :     channelCount = stbi__get16be(s);

  000cb	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d2	e8 00 00 00 00	 call	 stbi__get16be
  000d7	89 45 24	 mov	 DWORD PTR channelCount$[rbp], eax

; 5690 :     if (channelCount < 0 || channelCount > 16)

  000da	83 7d 24 00	 cmp	 DWORD PTR channelCount$[rbp], 0
  000de	7c 06		 jl	 SHORT $LN35@stbi__psd_
  000e0	83 7d 24 10	 cmp	 DWORD PTR channelCount$[rbp], 16
  000e4	7e 34		 jle	 SHORT $LN34@stbi__psd_
$LN35@stbi__psd_:

; 5691 :         return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
  000ed	e8 00 00 00 00	 call	 stbi__err
  000f2	85 c0		 test	 eax, eax
  000f4	74 0d		 je	 SHORT $LN73@stbi__psd_
  000f6	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv87[rbp], 0
  00101	eb 0b		 jmp	 SHORT $LN74@stbi__psd_
$LN73@stbi__psd_:
  00103	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv87[rbp], 0
$LN74@stbi__psd_:
  0010e	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv87[rbp]
  00115	e9 0c 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN34@stbi__psd_:

; 5692 : 
; 5693 :     // Read the rows and columns of the image.
; 5694 :     h = stbi__get32be(s);

  0011a	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00121	e8 00 00 00 00	 call	 stbi__get32be
  00126	89 85 e4 00 00
	00		 mov	 DWORD PTR h$[rbp], eax

; 5695 :     w = stbi__get32be(s);

  0012c	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00133	e8 00 00 00 00	 call	 stbi__get32be
  00138	89 85 c4 00 00
	00		 mov	 DWORD PTR w$[rbp], eax

; 5696 : 
; 5697 :     if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  0013e	81 bd e4 00 00
	00 00 00 00 01	 cmp	 DWORD PTR h$[rbp], 16777216 ; 01000000H
  00148	7e 34		 jle	 SHORT $LN36@stbi__psd_
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00151	e8 00 00 00 00	 call	 stbi__err
  00156	85 c0		 test	 eax, eax
  00158	74 0d		 je	 SHORT $LN75@stbi__psd_
  0015a	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv128[rbp], 0
  00165	eb 0b		 jmp	 SHORT $LN76@stbi__psd_
$LN75@stbi__psd_:
  00167	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv128[rbp], 0
$LN76@stbi__psd_:
  00172	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv128[rbp]
  00179	e9 a8 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN36@stbi__psd_:

; 5698 :     if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  0017e	81 bd c4 00 00
	00 00 00 00 01	 cmp	 DWORD PTR w$[rbp], 16777216 ; 01000000H
  00188	7e 34		 jle	 SHORT $LN37@stbi__psd_
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00191	e8 00 00 00 00	 call	 stbi__err
  00196	85 c0		 test	 eax, eax
  00198	74 0d		 je	 SHORT $LN77@stbi__psd_
  0019a	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv133[rbp], 0
  001a5	eb 0b		 jmp	 SHORT $LN78@stbi__psd_
$LN77@stbi__psd_:
  001a7	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv133[rbp], 0
$LN78@stbi__psd_:
  001b2	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv133[rbp]
  001b9	e9 68 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN37@stbi__psd_:

; 5699 : 
; 5700 :     // Make sure the depth is 8 bits.
; 5701 :     bitdepth = stbi__get16be(s);

  001be	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001c5	e8 00 00 00 00	 call	 stbi__get16be
  001ca	89 85 a4 00 00
	00		 mov	 DWORD PTR bitdepth$[rbp], eax

; 5702 :     if (bitdepth != 8 && bitdepth != 16)

  001d0	83 bd a4 00 00
	00 08		 cmp	 DWORD PTR bitdepth$[rbp], 8
  001d7	74 3d		 je	 SHORT $LN38@stbi__psd_
  001d9	83 bd a4 00 00
	00 10		 cmp	 DWORD PTR bitdepth$[rbp], 16
  001e0	74 34		 je	 SHORT $LN38@stbi__psd_

; 5703 :         return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
  001e9	e8 00 00 00 00	 call	 stbi__err
  001ee	85 c0		 test	 eax, eax
  001f0	74 0d		 je	 SHORT $LN79@stbi__psd_
  001f2	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv141[rbp], 0
  001fd	eb 0b		 jmp	 SHORT $LN80@stbi__psd_
$LN79@stbi__psd_:
  001ff	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv141[rbp], 0
$LN80@stbi__psd_:
  0020a	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv141[rbp]
  00211	e9 10 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN38@stbi__psd_:

; 5704 : 
; 5705 :     // Make sure the color mode is RGB.
; 5706 :     // Valid options are:
; 5707 :     //   0: Bitmap
; 5708 :     //   1: Grayscale
; 5709 :     //   2: Indexed color
; 5710 :     //   3: RGB color
; 5711 :     //   4: CMYK color
; 5712 :     //   7: Multichannel
; 5713 :     //   8: Duotone
; 5714 :     //   9: Lab color
; 5715 :     if (stbi__get16be(s) != 3)

  00216	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0021d	e8 00 00 00 00	 call	 stbi__get16be
  00222	83 f8 03	 cmp	 eax, 3
  00225	74 34		 je	 SHORT $LN39@stbi__psd_

; 5716 :         return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IOGGBMNK@wrong?5color?5format@
  0022e	e8 00 00 00 00	 call	 stbi__err
  00233	85 c0		 test	 eax, eax
  00235	74 0d		 je	 SHORT $LN81@stbi__psd_
  00237	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv148[rbp], 0
  00242	eb 0b		 jmp	 SHORT $LN82@stbi__psd_
$LN81@stbi__psd_:
  00244	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv148[rbp], 0
$LN82@stbi__psd_:
  0024f	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv148[rbp]
  00256	e9 cb 09 00 00	 jmp	 $LN1@stbi__psd_
$LN39@stbi__psd_:

; 5717 : 
; 5718 :     // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 5719 :     stbi__skip(s, stbi__get32be(s));

  0025b	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00262	e8 00 00 00 00	 call	 stbi__get32be
  00267	8b d0		 mov	 edx, eax
  00269	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00270	e8 00 00 00 00	 call	 stbi__skip

; 5720 : 
; 5721 :     // Skip the image resources.  (resolution, pen tool paths, etc)
; 5722 :     stbi__skip(s, stbi__get32be(s));

  00275	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0027c	e8 00 00 00 00	 call	 stbi__get32be
  00281	8b d0		 mov	 edx, eax
  00283	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0028a	e8 00 00 00 00	 call	 stbi__skip

; 5723 : 
; 5724 :     // Skip the reserved data.
; 5725 :     stbi__skip(s, stbi__get32be(s));

  0028f	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00296	e8 00 00 00 00	 call	 stbi__get32be
  0029b	8b d0		 mov	 edx, eax
  0029d	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  002a4	e8 00 00 00 00	 call	 stbi__skip

; 5726 : 
; 5727 :     // Find out if the data is compressed.
; 5728 :     // Known values:
; 5729 :     //   0: no compression
; 5730 :     //   1: RLE compressed
; 5731 :     compression = stbi__get16be(s);

  002a9	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  002b0	e8 00 00 00 00	 call	 stbi__get16be
  002b5	89 45 44	 mov	 DWORD PTR compression$[rbp], eax

; 5732 :     if (compression > 1)

  002b8	83 7d 44 01	 cmp	 DWORD PTR compression$[rbp], 1
  002bc	7e 34		 jle	 SHORT $LN40@stbi__psd_

; 5733 :         return stbi__errpuc("bad compression", "PSD has an unknown compression format");

  002be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@
  002c5	e8 00 00 00 00	 call	 stbi__err
  002ca	85 c0		 test	 eax, eax
  002cc	74 0d		 je	 SHORT $LN83@stbi__psd_
  002ce	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv167[rbp], 0
  002d9	eb 0b		 jmp	 SHORT $LN84@stbi__psd_
$LN83@stbi__psd_:
  002db	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv167[rbp], 0
$LN84@stbi__psd_:
  002e6	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv167[rbp]
  002ed	e9 34 09 00 00	 jmp	 $LN1@stbi__psd_
$LN40@stbi__psd_:

; 5734 : 
; 5735 :     // Check size
; 5736 :     if (!stbi__mad3sizes_valid(4, w, h, 0))

  002f2	45 33 c9	 xor	 r9d, r9d
  002f5	44 8b 85 e4 00
	00 00		 mov	 r8d, DWORD PTR h$[rbp]
  002fc	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR w$[rbp]
  00302	b9 04 00 00 00	 mov	 ecx, 4
  00307	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  0030c	85 c0		 test	 eax, eax
  0030e	75 34		 jne	 SHORT $LN41@stbi__psd_

; 5737 :         return stbi__errpuc("too large", "Corrupt PSD");

  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00317	e8 00 00 00 00	 call	 stbi__err
  0031c	85 c0		 test	 eax, eax
  0031e	74 0d		 je	 SHORT $LN85@stbi__psd_
  00320	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv177[rbp], 0
  0032b	eb 0b		 jmp	 SHORT $LN86@stbi__psd_
$LN85@stbi__psd_:
  0032d	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv177[rbp], 0
$LN86@stbi__psd_:
  00338	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv177[rbp]
  0033f	e9 e2 08 00 00	 jmp	 $LN1@stbi__psd_
$LN41@stbi__psd_:

; 5738 : 
; 5739 :     // Create the destination image.
; 5740 : 
; 5741 :     if (!compression && bitdepth == 16 && bpc == 16) {

  00344	83 7d 44 00	 cmp	 DWORD PTR compression$[rbp], 0
  00348	75 42		 jne	 SHORT $LN42@stbi__psd_
  0034a	83 bd a4 00 00
	00 10		 cmp	 DWORD PTR bitdepth$[rbp], 16
  00351	75 39		 jne	 SHORT $LN42@stbi__psd_
  00353	83 bd d0 04 00
	00 10		 cmp	 DWORD PTR bpc$[rbp], 16
  0035a	75 30		 jne	 SHORT $LN42@stbi__psd_

; 5742 :         out = (stbi_uc*)stbi__malloc_mad3(8, w, h, 0);

  0035c	45 33 c9	 xor	 r9d, r9d
  0035f	44 8b 85 e4 00
	00 00		 mov	 r8d, DWORD PTR h$[rbp]
  00366	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR w$[rbp]
  0036c	b9 08 00 00 00	 mov	 ecx, 8
  00371	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00376	48 89 85 08 01
	00 00		 mov	 QWORD PTR out$[rbp], rax

; 5743 :         ri->bits_per_channel = 16;

  0037d	48 8b 85 c8 04
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00384	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 5744 :     }

  0038a	eb 21		 jmp	 SHORT $LN43@stbi__psd_
$LN42@stbi__psd_:

; 5745 :     else
; 5746 :         out = (stbi_uc*)stbi__malloc(4 * w * h);

  0038c	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  00392	c1 e0 02	 shl	 eax, 2
  00395	0f af 85 e4 00
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  0039c	48 98		 cdqe
  0039e	48 8b c8	 mov	 rcx, rax
  003a1	e8 00 00 00 00	 call	 stbi__malloc
  003a6	48 89 85 08 01
	00 00		 mov	 QWORD PTR out$[rbp], rax
$LN43@stbi__psd_:

; 5747 : 
; 5748 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  003ad	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR out$[rbp], 0
  003b5	75 34		 jne	 SHORT $LN44@stbi__psd_
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  003be	e8 00 00 00 00	 call	 stbi__err
  003c3	85 c0		 test	 eax, eax
  003c5	74 0d		 je	 SHORT $LN87@stbi__psd_
  003c7	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv196[rbp], 0
  003d2	eb 0b		 jmp	 SHORT $LN88@stbi__psd_
$LN87@stbi__psd_:
  003d4	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv196[rbp], 0
$LN88@stbi__psd_:
  003df	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv196[rbp]
  003e6	e9 3b 08 00 00	 jmp	 $LN1@stbi__psd_
$LN44@stbi__psd_:

; 5749 :     pixelCount = w * h;

  003eb	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  003f1	0f af 85 e4 00
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  003f8	89 45 04	 mov	 DWORD PTR pixelCount$[rbp], eax

; 5750 : 
; 5751 :     // Initialize the data to zero.
; 5752 :     //memset( out, 0, pixelCount * 4 );
; 5753 : 
; 5754 :     // Finally, the image data.
; 5755 :     if (compression) {

  003fb	83 7d 44 00	 cmp	 DWORD PTR compression$[rbp], 0
  003ff	0f 84 22 01 00
	00		 je	 $LN45@stbi__psd_

; 5756 :         // RLE as used by .PSD and .TIFF
; 5757 :         // Loop until you get the number of unpacked bytes you are expecting:
; 5758 :         //     Read the next source byte into n.
; 5759 :         //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 5760 :         //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 5761 :         //     Else if n is 128, noop.
; 5762 :         // Endloop
; 5763 : 
; 5764 :         // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 5765 :         // which we're going to just skip.
; 5766 :         stbi__skip(s, h * channelCount * 2);

  00405	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR h$[rbp]
  0040b	0f af 45 24	 imul	 eax, DWORD PTR channelCount$[rbp]
  0040f	d1 e0		 shl	 eax, 1
  00411	8b d0		 mov	 edx, eax
  00413	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0041a	e8 00 00 00 00	 call	 stbi__skip

; 5767 : 
; 5768 :         // Read the RLE data by channel.
; 5769 :         for (channel = 0; channel < 4; channel++) {

  0041f	c7 45 64 00 00
	00 00		 mov	 DWORD PTR channel$[rbp], 0
  00426	eb 08		 jmp	 SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
  00428	8b 45 64	 mov	 eax, DWORD PTR channel$[rbp]
  0042b	ff c0		 inc	 eax
  0042d	89 45 64	 mov	 DWORD PTR channel$[rbp], eax
$LN4@stbi__psd_:
  00430	83 7d 64 04	 cmp	 DWORD PTR channel$[rbp], 4
  00434	0f 8d e8 00 00
	00		 jge	 $LN3@stbi__psd_

; 5770 :             stbi_uc* p;
; 5771 : 
; 5772 :             p = out + channel;

  0043a	48 63 45 64	 movsxd	 rax, DWORD PTR channel$[rbp]
  0043e	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00445	48 03 c8	 add	 rcx, rax
  00448	48 8b c1	 mov	 rax, rcx
  0044b	48 89 85 28 01
	00 00		 mov	 QWORD PTR p$1[rbp], rax

; 5773 :             if (channel >= channelCount) {

  00452	8b 45 24	 mov	 eax, DWORD PTR channelCount$[rbp]
  00455	39 45 64	 cmp	 DWORD PTR channel$[rbp], eax
  00458	7c 67		 jl	 SHORT $LN47@stbi__psd_

; 5774 :                 // Fill this channel with default data.
; 5775 :                 for (i = 0; i < pixelCount; i++, p += 4)

  0045a	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00464	eb 20		 jmp	 SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
  00466	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  0046c	ff c0		 inc	 eax
  0046e	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  00474	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR p$1[rbp]
  0047b	48 83 c0 04	 add	 rax, 4
  0047f	48 89 85 28 01
	00 00		 mov	 QWORD PTR p$1[rbp], rax
$LN7@stbi__psd_:
  00486	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  00489	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  0048f	7d 2e		 jge	 SHORT $LN6@stbi__psd_

; 5776 :                     *p = (channel == 3 ? 255 : 0);

  00491	83 7d 64 03	 cmp	 DWORD PTR channel$[rbp], 3
  00495	75 0c		 jne	 SHORT $LN89@stbi__psd_
  00497	c7 85 74 04 00
	00 ff 00 00 00	 mov	 DWORD PTR tv212[rbp], 255 ; 000000ffH
  004a1	eb 0a		 jmp	 SHORT $LN90@stbi__psd_
$LN89@stbi__psd_:
  004a3	c7 85 74 04 00
	00 00 00 00 00	 mov	 DWORD PTR tv212[rbp], 0
$LN90@stbi__psd_:
  004ad	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR p$1[rbp]
  004b4	0f b6 8d 74 04
	00 00		 movzx	 ecx, BYTE PTR tv212[rbp]
  004bb	88 08		 mov	 BYTE PTR [rax], cl
  004bd	eb a7		 jmp	 SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 5777 :             }

  004bf	eb 5c		 jmp	 SHORT $LN48@stbi__psd_
$LN47@stbi__psd_:

; 5778 :             else {
; 5779 :                 // Read the RLE data.
; 5780 :                 if (!stbi__psd_decode_rle(s, p, pixelCount)) {

  004c1	44 8b 45 04	 mov	 r8d, DWORD PTR pixelCount$[rbp]
  004c5	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR p$1[rbp]
  004cc	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004d3	e8 00 00 00 00	 call	 stbi__psd_decode_rle
  004d8	85 c0		 test	 eax, eax
  004da	75 41		 jne	 SHORT $LN49@stbi__psd_

; 5781 :                     STBI_FREE(out);

  004dc	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  004e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5782 :                     return stbi__errpuc("corrupt", "bad RLE data");

  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  004f0	e8 00 00 00 00	 call	 stbi__err
  004f5	85 c0		 test	 eax, eax
  004f7	74 0d		 je	 SHORT $LN91@stbi__psd_
  004f9	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv223[rbp], 0
  00504	eb 0b		 jmp	 SHORT $LN92@stbi__psd_
$LN91@stbi__psd_:
  00506	48 c7 85 78 04
	00 00 00 00 00
	00		 mov	 QWORD PTR tv223[rbp], 0
$LN92@stbi__psd_:
  00511	48 8b 85 78 04
	00 00		 mov	 rax, QWORD PTR tv223[rbp]
  00518	e9 09 07 00 00	 jmp	 $LN1@stbi__psd_
$LN49@stbi__psd_:
$LN48@stbi__psd_:

; 5783 :                 }
; 5784 :             }
; 5785 :         }

  0051d	e9 06 ff ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 5786 :     }

  00522	e9 9c 02 00 00	 jmp	 $LN46@stbi__psd_
$LN45@stbi__psd_:

; 5787 :     else {
; 5788 :         // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 5789 :         // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 5790 : 
; 5791 :         // Read the data by channel.
; 5792 :         for (channel = 0; channel < 4; channel++) {

  00527	c7 45 64 00 00
	00 00		 mov	 DWORD PTR channel$[rbp], 0
  0052e	eb 08		 jmp	 SHORT $LN10@stbi__psd_
$LN8@stbi__psd_:
  00530	8b 45 64	 mov	 eax, DWORD PTR channel$[rbp]
  00533	ff c0		 inc	 eax
  00535	89 45 64	 mov	 DWORD PTR channel$[rbp], eax
$LN10@stbi__psd_:
  00538	83 7d 64 04	 cmp	 DWORD PTR channel$[rbp], 4
  0053c	0f 8d 81 02 00
	00		 jge	 $LN9@stbi__psd_

; 5793 :             if (channel >= channelCount) {

  00542	8b 45 24	 mov	 eax, DWORD PTR channelCount$[rbp]
  00545	39 45 64	 cmp	 DWORD PTR channel$[rbp], eax
  00548	0f 8c 38 01 00
	00		 jl	 $LN50@stbi__psd_

; 5794 :                 // Fill this channel with default data.
; 5795 :                 if (bitdepth == 16 && bpc == 16) {

  0054e	83 bd a4 00 00
	00 10		 cmp	 DWORD PTR bitdepth$[rbp], 16
  00555	0f 85 9c 00 00
	00		 jne	 $LN52@stbi__psd_
  0055b	83 bd d0 04 00
	00 10		 cmp	 DWORD PTR bpc$[rbp], 16
  00562	0f 85 8f 00 00
	00		 jne	 $LN52@stbi__psd_

; 5796 :                     stbi__uint16* q = ((stbi__uint16*)out) + channel;

  00568	48 63 45 64	 movsxd	 rax, DWORD PTR channel$[rbp]
  0056c	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00573	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00577	48 89 85 48 01
	00 00		 mov	 QWORD PTR q$2[rbp], rax

; 5797 :                     stbi__uint16 val = channel == 3 ? 65535 : 0;

  0057e	83 7d 64 03	 cmp	 DWORD PTR channel$[rbp], 3
  00582	75 0c		 jne	 SHORT $LN93@stbi__psd_
  00584	c7 85 74 04 00
	00 ff ff 00 00	 mov	 DWORD PTR tv233[rbp], 65535 ; 0000ffffH
  0058e	eb 0a		 jmp	 SHORT $LN94@stbi__psd_
$LN93@stbi__psd_:
  00590	c7 85 74 04 00
	00 00 00 00 00	 mov	 DWORD PTR tv233[rbp], 0
$LN94@stbi__psd_:
  0059a	0f b7 85 74 04
	00 00		 movzx	 eax, WORD PTR tv233[rbp]
  005a1	66 89 85 64 01
	00 00		 mov	 WORD PTR val$3[rbp], ax

; 5798 :                     for (i = 0; i < pixelCount; i++, q += 4)

  005a8	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  005b2	eb 20		 jmp	 SHORT $LN13@stbi__psd_
$LN11@stbi__psd_:
  005b4	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  005ba	ff c0		 inc	 eax
  005bc	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  005c2	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR q$2[rbp]
  005c9	48 83 c0 08	 add	 rax, 8
  005cd	48 89 85 48 01
	00 00		 mov	 QWORD PTR q$2[rbp], rax
$LN13@stbi__psd_:
  005d4	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  005d7	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  005dd	7d 13		 jge	 SHORT $LN12@stbi__psd_

; 5799 :                         *q = val;

  005df	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR q$2[rbp]
  005e6	0f b7 8d 64 01
	00 00		 movzx	 ecx, WORD PTR val$3[rbp]
  005ed	66 89 08	 mov	 WORD PTR [rax], cx
  005f0	eb c2		 jmp	 SHORT $LN11@stbi__psd_
$LN12@stbi__psd_:

; 5800 :                 }

  005f2	e9 8a 00 00 00	 jmp	 $LN53@stbi__psd_
$LN52@stbi__psd_:

; 5801 :                 else {
; 5802 :                     stbi_uc* p = out + channel;

  005f7	48 63 45 64	 movsxd	 rax, DWORD PTR channel$[rbp]
  005fb	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00602	48 03 c8	 add	 rcx, rax
  00605	48 8b c1	 mov	 rax, rcx
  00608	48 89 85 88 01
	00 00		 mov	 QWORD PTR p$4[rbp], rax

; 5803 :                     stbi_uc val = channel == 3 ? 255 : 0;

  0060f	83 7d 64 03	 cmp	 DWORD PTR channel$[rbp], 3
  00613	75 0c		 jne	 SHORT $LN95@stbi__psd_
  00615	c7 85 74 04 00
	00 ff 00 00 00	 mov	 DWORD PTR tv241[rbp], 255 ; 000000ffH
  0061f	eb 0a		 jmp	 SHORT $LN96@stbi__psd_
$LN95@stbi__psd_:
  00621	c7 85 74 04 00
	00 00 00 00 00	 mov	 DWORD PTR tv241[rbp], 0
$LN96@stbi__psd_:
  0062b	0f b6 85 74 04
	00 00		 movzx	 eax, BYTE PTR tv241[rbp]
  00632	88 85 a4 01 00
	00		 mov	 BYTE PTR val$5[rbp], al

; 5804 :                     for (i = 0; i < pixelCount; i++, p += 4)

  00638	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00642	eb 20		 jmp	 SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
  00644	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  0064a	ff c0		 inc	 eax
  0064c	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  00652	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$4[rbp]
  00659	48 83 c0 04	 add	 rax, 4
  0065d	48 89 85 88 01
	00 00		 mov	 QWORD PTR p$4[rbp], rax
$LN16@stbi__psd_:
  00664	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  00667	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  0066d	7d 12		 jge	 SHORT $LN15@stbi__psd_

; 5805 :                         *p = val;

  0066f	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR p$4[rbp]
  00676	0f b6 8d a4 01
	00 00		 movzx	 ecx, BYTE PTR val$5[rbp]
  0067d	88 08		 mov	 BYTE PTR [rax], cl
  0067f	eb c3		 jmp	 SHORT $LN14@stbi__psd_
$LN15@stbi__psd_:
$LN53@stbi__psd_:

; 5806 :                 }
; 5807 :             }

  00681	e9 38 01 00 00	 jmp	 $LN51@stbi__psd_
$LN50@stbi__psd_:

; 5808 :             else {
; 5809 :                 if (ri->bits_per_channel == 16) {    // output bpc

  00686	48 8b 85 c8 04
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  0068d	83 38 10	 cmp	 DWORD PTR [rax], 16
  00690	75 6a		 jne	 SHORT $LN54@stbi__psd_

; 5810 :                     stbi__uint16* q = ((stbi__uint16*)out) + channel;

  00692	48 63 45 64	 movsxd	 rax, DWORD PTR channel$[rbp]
  00696	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  0069d	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  006a1	48 89 85 c8 01
	00 00		 mov	 QWORD PTR q$6[rbp], rax

; 5811 :                     for (i = 0; i < pixelCount; i++, q += 4)

  006a8	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  006b2	eb 20		 jmp	 SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
  006b4	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  006ba	ff c0		 inc	 eax
  006bc	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  006c2	48 8b 85 c8 01
	00 00		 mov	 rax, QWORD PTR q$6[rbp]
  006c9	48 83 c0 08	 add	 rax, 8
  006cd	48 89 85 c8 01
	00 00		 mov	 QWORD PTR q$6[rbp], rax
$LN19@stbi__psd_:
  006d4	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  006d7	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  006dd	7d 18		 jge	 SHORT $LN18@stbi__psd_

; 5812 :                         *q = (stbi__uint16)stbi__get16be(s);

  006df	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  006e6	e8 00 00 00 00	 call	 stbi__get16be
  006eb	48 8b 8d c8 01
	00 00		 mov	 rcx, QWORD PTR q$6[rbp]
  006f2	66 89 01	 mov	 WORD PTR [rcx], ax
  006f5	eb bd		 jmp	 SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 5813 :                 }

  006f7	e9 c2 00 00 00	 jmp	 $LN55@stbi__psd_
$LN54@stbi__psd_:

; 5814 :                 else {
; 5815 :                     stbi_uc* p = out + channel;

  006fc	48 63 45 64	 movsxd	 rax, DWORD PTR channel$[rbp]
  00700	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00707	48 03 c8	 add	 rcx, rax
  0070a	48 8b c1	 mov	 rax, rcx
  0070d	48 89 85 e8 01
	00 00		 mov	 QWORD PTR p$7[rbp], rax

; 5816 :                     if (bitdepth == 16) {  // input bpc

  00714	83 bd a4 00 00
	00 10		 cmp	 DWORD PTR bitdepth$[rbp], 16
  0071b	75 53		 jne	 SHORT $LN56@stbi__psd_

; 5817 :                         for (i = 0; i < pixelCount; i++, p += 4)

  0071d	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00727	eb 20		 jmp	 SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
  00729	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  0072f	ff c0		 inc	 eax
  00731	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  00737	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR p$7[rbp]
  0073e	48 83 c0 04	 add	 rax, 4
  00742	48 89 85 e8 01
	00 00		 mov	 QWORD PTR p$7[rbp], rax
$LN22@stbi__psd_:
  00749	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  0074c	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00752	7d 1a		 jge	 SHORT $LN21@stbi__psd_

; 5818 :                             *p = (stbi_uc)(stbi__get16be(s) >> 8);

  00754	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0075b	e8 00 00 00 00	 call	 stbi__get16be
  00760	c1 f8 08	 sar	 eax, 8
  00763	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR p$7[rbp]
  0076a	88 01		 mov	 BYTE PTR [rcx], al
  0076c	eb bb		 jmp	 SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 5819 :                     }

  0076e	eb 4e		 jmp	 SHORT $LN57@stbi__psd_
$LN56@stbi__psd_:

; 5820 :                     else {
; 5821 :                         for (i = 0; i < pixelCount; i++, p += 4)

  00770	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  0077a	eb 20		 jmp	 SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
  0077c	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00782	ff c0		 inc	 eax
  00784	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
  0078a	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR p$7[rbp]
  00791	48 83 c0 04	 add	 rax, 4
  00795	48 89 85 e8 01
	00 00		 mov	 QWORD PTR p$7[rbp], rax
$LN25@stbi__psd_:
  0079c	8b 45 04	 mov	 eax, DWORD PTR pixelCount$[rbp]
  0079f	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  007a5	7d 17		 jge	 SHORT $LN24@stbi__psd_

; 5822 :                             *p = stbi__get8(s);

  007a7	48 8b 8d a0 04
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  007ae	e8 00 00 00 00	 call	 stbi__get8
  007b3	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR p$7[rbp]
  007ba	88 01		 mov	 BYTE PTR [rcx], al
  007bc	eb be		 jmp	 SHORT $LN23@stbi__psd_
$LN24@stbi__psd_:
$LN57@stbi__psd_:
$LN55@stbi__psd_:
$LN51@stbi__psd_:

; 5823 :                     }
; 5824 :                 }
; 5825 :             }
; 5826 :         }

  007be	e9 6d fd ff ff	 jmp	 $LN8@stbi__psd_
$LN9@stbi__psd_:
$LN46@stbi__psd_:

; 5827 :     }
; 5828 : 
; 5829 :     // remove weird white matte from PSD
; 5830 :     if (channelCount >= 4) {

  007c3	83 7d 24 04	 cmp	 DWORD PTR channelCount$[rbp], 4
  007c7	0f 8c 82 03 00
	00		 jl	 $LN58@stbi__psd_

; 5831 :         if (ri->bits_per_channel == 16) {

  007cd	48 8b 85 c8 04
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  007d4	83 38 10	 cmp	 DWORD PTR [rax], 16
  007d7	0f 85 bc 01 00
	00		 jne	 $LN59@stbi__psd_

; 5832 :             for (i = 0; i < w * h; ++i) {

  007dd	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  007e7	eb 0e		 jmp	 SHORT $LN28@stbi__psd_
$LN26@stbi__psd_:
  007e9	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  007ef	ff c0		 inc	 eax
  007f1	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN28@stbi__psd_:
  007f7	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  007fd	0f af 85 e4 00
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  00804	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  0080a	0f 8d 84 01 00
	00		 jge	 $LN27@stbi__psd_

; 5833 :                 stbi__uint16* pixel = (stbi__uint16*)out + 4 * i;

  00810	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00816	c1 e0 02	 shl	 eax, 2
  00819	48 98		 cdqe
  0081b	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00822	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00826	48 89 85 08 02
	00 00		 mov	 QWORD PTR pixel$8[rbp], rax

; 5834 :                 if (pixel[3] != 0 && pixel[3] != 65535) {

  0082d	b8 02 00 00 00	 mov	 eax, 2
  00832	48 6b c0 03	 imul	 rax, rax, 3
  00836	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  0083d	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00841	85 c0		 test	 eax, eax
  00843	0f 84 46 01 00
	00		 je	 $LN61@stbi__psd_
  00849	b8 02 00 00 00	 mov	 eax, 2
  0084e	48 6b c0 03	 imul	 rax, rax, 3
  00852	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  00859	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0085d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00862	0f 84 27 01 00
	00		 je	 $LN61@stbi__psd_

; 5835 :                     float a = pixel[3] / 65535.0f;

  00868	b8 02 00 00 00	 mov	 eax, 2
  0086d	48 6b c0 03	 imul	 rax, rax, 3
  00871	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  00878	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0087c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00880	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@477fff00
  00888	f3 0f 11 85 24
	02 00 00	 movss	 DWORD PTR a$9[rbp], xmm0

; 5836 :                     float ra = 1.0f / a;

  00890	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00898	f3 0f 5e 85 24
	02 00 00	 divss	 xmm0, DWORD PTR a$9[rbp]
  008a0	f3 0f 11 85 44
	02 00 00	 movss	 DWORD PTR ra$10[rbp], xmm0

; 5837 :                     float inv_a = 65535.0f * (1 - ra);

  008a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008b0	f3 0f 5c 85 44
	02 00 00	 subss	 xmm0, DWORD PTR ra$10[rbp]
  008b8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@477fff00
  008c0	f3 0f 59 c8	 mulss	 xmm1, xmm0
  008c4	0f 28 c1	 movaps	 xmm0, xmm1
  008c7	f3 0f 11 85 64
	02 00 00	 movss	 DWORD PTR inv_a$11[rbp], xmm0

; 5838 :                     pixel[0] = (stbi__uint16)(pixel[0] * ra + inv_a);

  008cf	b8 02 00 00 00	 mov	 eax, 2
  008d4	48 6b c0 00	 imul	 rax, rax, 0
  008d8	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  008df	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008e7	f3 0f 59 85 44
	02 00 00	 mulss	 xmm0, DWORD PTR ra$10[rbp]
  008ef	f3 0f 58 85 64
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rbp]
  008f7	f3 0f 2c c0	 cvttss2si eax, xmm0
  008fb	b9 02 00 00 00	 mov	 ecx, 2
  00900	48 6b c9 00	 imul	 rcx, rcx, 0
  00904	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR pixel$8[rbp]
  0090b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 5839 :                     pixel[1] = (stbi__uint16)(pixel[1] * ra + inv_a);

  0090f	b8 02 00 00 00	 mov	 eax, 2
  00914	48 6b c0 01	 imul	 rax, rax, 1
  00918	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  0091f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00923	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00927	f3 0f 59 85 44
	02 00 00	 mulss	 xmm0, DWORD PTR ra$10[rbp]
  0092f	f3 0f 58 85 64
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rbp]
  00937	f3 0f 2c c0	 cvttss2si eax, xmm0
  0093b	b9 02 00 00 00	 mov	 ecx, 2
  00940	48 6b c9 01	 imul	 rcx, rcx, 1
  00944	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR pixel$8[rbp]
  0094b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 5840 :                     pixel[2] = (stbi__uint16)(pixel[2] * ra + inv_a);

  0094f	b8 02 00 00 00	 mov	 eax, 2
  00954	48 6b c0 02	 imul	 rax, rax, 2
  00958	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR pixel$8[rbp]
  0095f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00963	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00967	f3 0f 59 85 44
	02 00 00	 mulss	 xmm0, DWORD PTR ra$10[rbp]
  0096f	f3 0f 58 85 64
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rbp]
  00977	f3 0f 2c c0	 cvttss2si eax, xmm0
  0097b	b9 02 00 00 00	 mov	 ecx, 2
  00980	48 6b c9 02	 imul	 rcx, rcx, 2
  00984	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR pixel$8[rbp]
  0098b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN61@stbi__psd_:

; 5841 :                 }
; 5842 :             }

  0098f	e9 55 fe ff ff	 jmp	 $LN26@stbi__psd_
$LN27@stbi__psd_:

; 5843 :         }

  00994	e9 b6 01 00 00	 jmp	 $LN60@stbi__psd_
$LN59@stbi__psd_:

; 5844 :         else {
; 5845 :             for (i = 0; i < w * h; ++i) {

  00999	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  009a3	eb 0e		 jmp	 SHORT $LN31@stbi__psd_
$LN29@stbi__psd_:
  009a5	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  009ab	ff c0		 inc	 eax
  009ad	89 85 84 00 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN31@stbi__psd_:
  009b3	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR w$[rbp]
  009b9	0f af 85 e4 00
	00 00		 imul	 eax, DWORD PTR h$[rbp]
  009c0	39 85 84 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  009c6	0f 8d 83 01 00
	00		 jge	 $LN30@stbi__psd_

; 5846 :                 unsigned char* pixel = out + 4 * i;

  009cc	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  009d2	c1 e0 02	 shl	 eax, 2
  009d5	48 98		 cdqe
  009d7	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  009de	48 03 c8	 add	 rcx, rax
  009e1	48 8b c1	 mov	 rax, rcx
  009e4	48 89 85 88 02
	00 00		 mov	 QWORD PTR pixel$12[rbp], rax

; 5847 :                 if (pixel[3] != 0 && pixel[3] != 255) {

  009eb	b8 01 00 00 00	 mov	 eax, 1
  009f0	48 6b c0 03	 imul	 rax, rax, 3
  009f4	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  009fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009ff	85 c0		 test	 eax, eax
  00a01	0f 84 43 01 00
	00		 je	 $LN62@stbi__psd_
  00a07	b8 01 00 00 00	 mov	 eax, 1
  00a0c	48 6b c0 03	 imul	 rax, rax, 3
  00a10	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  00a17	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a1b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00a20	0f 84 24 01 00
	00		 je	 $LN62@stbi__psd_

; 5848 :                     float a = pixel[3] / 255.0f;

  00a26	b8 01 00 00 00	 mov	 eax, 1
  00a2b	48 6b c0 03	 imul	 rax, rax, 3
  00a2f	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  00a36	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a3a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a3e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  00a46	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR a$13[rbp], xmm0

; 5849 :                     float ra = 1.0f / a;

  00a4e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a56	f3 0f 5e 85 a4
	02 00 00	 divss	 xmm0, DWORD PTR a$13[rbp]
  00a5e	f3 0f 11 85 c4
	02 00 00	 movss	 DWORD PTR ra$14[rbp], xmm0

; 5850 :                     float inv_a = 255.0f * (1 - ra);

  00a66	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a6e	f3 0f 5c 85 c4
	02 00 00	 subss	 xmm0, DWORD PTR ra$14[rbp]
  00a76	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@437f0000
  00a7e	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00a82	0f 28 c1	 movaps	 xmm0, xmm1
  00a85	f3 0f 11 85 e4
	02 00 00	 movss	 DWORD PTR inv_a$15[rbp], xmm0

; 5851 :                     pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);

  00a8d	b8 01 00 00 00	 mov	 eax, 1
  00a92	48 6b c0 00	 imul	 rax, rax, 0
  00a96	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  00a9d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00aa1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00aa5	f3 0f 59 85 c4
	02 00 00	 mulss	 xmm0, DWORD PTR ra$14[rbp]
  00aad	f3 0f 58 85 e4
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rbp]
  00ab5	f3 0f 2c c0	 cvttss2si eax, xmm0
  00ab9	b9 01 00 00 00	 mov	 ecx, 1
  00abe	48 6b c9 00	 imul	 rcx, rcx, 0
  00ac2	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR pixel$12[rbp]
  00ac9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5852 :                     pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);

  00acc	b8 01 00 00 00	 mov	 eax, 1
  00ad1	48 6b c0 01	 imul	 rax, rax, 1
  00ad5	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  00adc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ae0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ae4	f3 0f 59 85 c4
	02 00 00	 mulss	 xmm0, DWORD PTR ra$14[rbp]
  00aec	f3 0f 58 85 e4
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rbp]
  00af4	f3 0f 2c c0	 cvttss2si eax, xmm0
  00af8	b9 01 00 00 00	 mov	 ecx, 1
  00afd	48 6b c9 01	 imul	 rcx, rcx, 1
  00b01	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR pixel$12[rbp]
  00b08	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5853 :                     pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);

  00b0b	b8 01 00 00 00	 mov	 eax, 1
  00b10	48 6b c0 02	 imul	 rax, rax, 2
  00b14	48 8b 8d 88 02
	00 00		 mov	 rcx, QWORD PTR pixel$12[rbp]
  00b1b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b1f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b23	f3 0f 59 85 c4
	02 00 00	 mulss	 xmm0, DWORD PTR ra$14[rbp]
  00b2b	f3 0f 58 85 e4
	02 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rbp]
  00b33	f3 0f 2c c0	 cvttss2si eax, xmm0
  00b37	b9 01 00 00 00	 mov	 ecx, 1
  00b3c	48 6b c9 02	 imul	 rcx, rcx, 2
  00b40	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR pixel$12[rbp]
  00b47	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN62@stbi__psd_:

; 5854 :                 }
; 5855 :             }

  00b4a	e9 56 fe ff ff	 jmp	 $LN29@stbi__psd_
$LN30@stbi__psd_:
$LN60@stbi__psd_:
$LN58@stbi__psd_:

; 5856 :         }
; 5857 :     }
; 5858 : 
; 5859 :     // convert to desired output format
; 5860 :     if (req_comp && req_comp != 4) {

  00b4f	83 bd c0 04 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00b56	0f 84 8e 00 00
	00		 je	 $LN63@stbi__psd_
  00b5c	83 bd c0 04 00
	00 04		 cmp	 DWORD PTR req_comp$[rbp], 4
  00b63	0f 84 81 00 00
	00		 je	 $LN63@stbi__psd_

; 5861 :         if (ri->bits_per_channel == 16)

  00b69	48 8b 85 c8 04
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  00b70	83 38 10	 cmp	 DWORD PTR [rax], 16
  00b73	75 32		 jne	 SHORT $LN64@stbi__psd_

; 5862 :             out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, 4, req_comp, w, h);

  00b75	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR h$[rbp]
  00b7b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b7f	44 8b 8d c4 00
	00 00		 mov	 r9d, DWORD PTR w$[rbp]
  00b86	44 8b 85 c0 04
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00b8d	ba 04 00 00 00	 mov	 edx, 4
  00b92	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00b99	e8 00 00 00 00	 call	 stbi__convert_format16
  00b9e	48 89 85 08 01
	00 00		 mov	 QWORD PTR out$[rbp], rax
  00ba5	eb 30		 jmp	 SHORT $LN65@stbi__psd_
$LN64@stbi__psd_:

; 5863 :         else
; 5864 :             out = stbi__convert_format(out, 4, req_comp, w, h);

  00ba7	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR h$[rbp]
  00bad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bb1	44 8b 8d c4 00
	00 00		 mov	 r9d, DWORD PTR w$[rbp]
  00bb8	44 8b 85 c0 04
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00bbf	ba 04 00 00 00	 mov	 edx, 4
  00bc4	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR out$[rbp]
  00bcb	e8 00 00 00 00	 call	 stbi__convert_format
  00bd0	48 89 85 08 01
	00 00		 mov	 QWORD PTR out$[rbp], rax
$LN65@stbi__psd_:

; 5865 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  00bd7	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR out$[rbp], 0
  00bdf	75 09		 jne	 SHORT $LN66@stbi__psd_
  00be1	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
  00be8	eb 3c		 jmp	 SHORT $LN1@stbi__psd_
$LN66@stbi__psd_:
$LN63@stbi__psd_:

; 5866 :     }
; 5867 : 
; 5868 :     if (comp) *comp = 4;

  00bea	48 83 bd b8 04
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  00bf2	74 0d		 je	 SHORT $LN67@stbi__psd_
  00bf4	48 8b 85 b8 04
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00bfb	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN67@stbi__psd_:

; 5869 :     *y = h;

  00c01	48 8b 85 b0 04
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  00c08	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR h$[rbp]
  00c0e	89 08		 mov	 DWORD PTR [rax], ecx

; 5870 :     *x = w;

  00c10	48 8b 85 a8 04
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00c17	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR w$[rbp]
  00c1d	89 08		 mov	 DWORD PTR [rax], ecx

; 5871 : 
; 5872 :     return out;

  00c1f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__psd_:

; 5873 : }

  00c26	48 8d a5 88 04
	00 00		 lea	 rsp, QWORD PTR [rbp+1160]
  00c2d	5f		 pop	 rdi
  00c2e	5d		 pop	 rbp
  00c2f	c3		 ret	 0
stbi__psd_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__psd_test
_TEXT	SEGMENT
r$ = 4
tv67 = 212
s$ = 256
stbi__psd_test PROC					; COMDAT

; 5621 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5622 :     int r = (stbi__get32be(s) == 0x38425053);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__get32be
  0002b	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00030	75 0c		 jne	 SHORT $LN3@stbi__psd_
  00032	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
  0003c	eb 0a		 jmp	 SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
  0003e	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN4@stbi__psd_:
  00048	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
  0004e	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 5623 :     stbi__rewind(s);

  00051	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00058	e8 00 00 00 00	 call	 stbi__rewind

; 5624 :     return r;

  0005d	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 5625 : }

  00060	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00067	5f		 pop	 rdi
  00068	5d		 pop	 rbp
  00069	c3		 ret	 0
stbi__psd_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__tga_info
_TEXT	SEGMENT
tga_w$ = 4
tga_h$ = 36
tga_comp$ = 68
tga_image_type$ = 100
tga_bits_per_pixel$ = 132
tga_colormap_bpp$ = 164
sz$ = 196
tga_colormap_type$ = 228
tv153 = 436
s$ = 480
x$ = 488
y$ = 496
comp$ = 504
stbi__tga_info PROC					; COMDAT

; 5286 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5287 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5288 :     int sz, tga_colormap_type;
; 5289 :     stbi__get8(s);                   // discard Offset

  0002e	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__get8

; 5290 :     tga_colormap_type = stbi__get8(s); // colormap type

  0003a	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00041	e8 00 00 00 00	 call	 stbi__get8
  00046	0f b6 c0	 movzx	 eax, al
  00049	89 85 e4 00 00
	00		 mov	 DWORD PTR tga_colormap_type$[rbp], eax

; 5291 :     if (tga_colormap_type > 1) {

  0004f	83 bd e4 00 00
	00 01		 cmp	 DWORD PTR tga_colormap_type$[rbp], 1
  00056	7e 13		 jle	 SHORT $LN2@stbi__tga_

; 5292 :         stbi__rewind(s);

  00058	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__rewind

; 5293 :         return 0;      // only RGB or indexed allowed

  00064	33 c0		 xor	 eax, eax
  00066	e9 53 02 00 00	 jmp	 $LN1@stbi__tga_
$LN2@stbi__tga_:

; 5294 :     }
; 5295 :     tga_image_type = stbi__get8(s); // image type

  0006b	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00072	e8 00 00 00 00	 call	 stbi__get8
  00077	0f b6 c0	 movzx	 eax, al
  0007a	89 45 64	 mov	 DWORD PTR tga_image_type$[rbp], eax

; 5296 :     if (tga_colormap_type == 1) { // colormapped (paletted) image

  0007d	83 bd e4 00 00
	00 01		 cmp	 DWORD PTR tga_colormap_type$[rbp], 1
  00084	0f 85 a4 00 00
	00		 jne	 $LN3@stbi__tga_

; 5297 :         if (tga_image_type != 1 && tga_image_type != 9) {

  0008a	83 7d 64 01	 cmp	 DWORD PTR tga_image_type$[rbp], 1
  0008e	74 19		 je	 SHORT $LN5@stbi__tga_
  00090	83 7d 64 09	 cmp	 DWORD PTR tga_image_type$[rbp], 9
  00094	74 13		 je	 SHORT $LN5@stbi__tga_

; 5298 :             stbi__rewind(s);

  00096	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009d	e8 00 00 00 00	 call	 stbi__rewind

; 5299 :             return 0;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 15 02 00 00	 jmp	 $LN1@stbi__tga_
$LN5@stbi__tga_:

; 5300 :         }
; 5301 :         stbi__skip(s, 4);       // skip index of first colormap entry and number of entries

  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000b5	e8 00 00 00 00	 call	 stbi__skip

; 5302 :         sz = stbi__get8(s);    //   check bits per palette color entry

  000ba	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c1	e8 00 00 00 00	 call	 stbi__get8
  000c6	0f b6 c0	 movzx	 eax, al
  000c9	89 85 c4 00 00
	00		 mov	 DWORD PTR sz$[rbp], eax

; 5303 :         if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {

  000cf	83 bd c4 00 00
	00 08		 cmp	 DWORD PTR sz$[rbp], 8
  000d6	74 37		 je	 SHORT $LN6@stbi__tga_
  000d8	83 bd c4 00 00
	00 0f		 cmp	 DWORD PTR sz$[rbp], 15
  000df	74 2e		 je	 SHORT $LN6@stbi__tga_
  000e1	83 bd c4 00 00
	00 10		 cmp	 DWORD PTR sz$[rbp], 16
  000e8	74 25		 je	 SHORT $LN6@stbi__tga_
  000ea	83 bd c4 00 00
	00 18		 cmp	 DWORD PTR sz$[rbp], 24
  000f1	74 1c		 je	 SHORT $LN6@stbi__tga_
  000f3	83 bd c4 00 00
	00 20		 cmp	 DWORD PTR sz$[rbp], 32	; 00000020H
  000fa	74 13		 je	 SHORT $LN6@stbi__tga_

; 5304 :             stbi__rewind(s);

  000fc	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00103	e8 00 00 00 00	 call	 stbi__rewind

; 5305 :             return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 af 01 00 00	 jmp	 $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5306 :         }
; 5307 :         stbi__skip(s, 4);       // skip image x and y origin

  0010f	ba 04 00 00 00	 mov	 edx, 4
  00114	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0011b	e8 00 00 00 00	 call	 stbi__skip

; 5308 :         tga_colormap_bpp = sz;

  00120	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00126	89 85 a4 00 00
	00		 mov	 DWORD PTR tga_colormap_bpp$[rbp], eax

; 5309 :     }

  0012c	eb 46		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5310 :     else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5311 :         if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {

  0012e	83 7d 64 02	 cmp	 DWORD PTR tga_image_type$[rbp], 2
  00132	74 25		 je	 SHORT $LN7@stbi__tga_
  00134	83 7d 64 03	 cmp	 DWORD PTR tga_image_type$[rbp], 3
  00138	74 1f		 je	 SHORT $LN7@stbi__tga_
  0013a	83 7d 64 0a	 cmp	 DWORD PTR tga_image_type$[rbp], 10
  0013e	74 19		 je	 SHORT $LN7@stbi__tga_
  00140	83 7d 64 0b	 cmp	 DWORD PTR tga_image_type$[rbp], 11
  00144	74 13		 je	 SHORT $LN7@stbi__tga_

; 5312 :             stbi__rewind(s);

  00146	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0014d	e8 00 00 00 00	 call	 stbi__rewind

; 5313 :             return 0; // only RGB or grey allowed, +/- RLE

  00152	33 c0		 xor	 eax, eax
  00154	e9 65 01 00 00	 jmp	 $LN1@stbi__tga_
$LN7@stbi__tga_:

; 5314 :         }
; 5315 :         stbi__skip(s, 9); // skip colormap specification and image x/y origin

  00159	ba 09 00 00 00	 mov	 edx, 9
  0015e	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00165	e8 00 00 00 00	 call	 stbi__skip

; 5316 :         tga_colormap_bpp = 0;

  0016a	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tga_colormap_bpp$[rbp], 0
$LN4@stbi__tga_:

; 5317 :     }
; 5318 :     tga_w = stbi__get16le(s);

  00174	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0017b	e8 00 00 00 00	 call	 stbi__get16le
  00180	89 45 04	 mov	 DWORD PTR tga_w$[rbp], eax

; 5319 :     if (tga_w < 1) {

  00183	83 7d 04 01	 cmp	 DWORD PTR tga_w$[rbp], 1
  00187	7d 13		 jge	 SHORT $LN8@stbi__tga_

; 5320 :         stbi__rewind(s);

  00189	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00190	e8 00 00 00 00	 call	 stbi__rewind

; 5321 :         return 0;   // test width

  00195	33 c0		 xor	 eax, eax
  00197	e9 22 01 00 00	 jmp	 $LN1@stbi__tga_
$LN8@stbi__tga_:

; 5322 :     }
; 5323 :     tga_h = stbi__get16le(s);

  0019c	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001a3	e8 00 00 00 00	 call	 stbi__get16le
  001a8	89 45 24	 mov	 DWORD PTR tga_h$[rbp], eax

; 5324 :     if (tga_h < 1) {

  001ab	83 7d 24 01	 cmp	 DWORD PTR tga_h$[rbp], 1
  001af	7d 13		 jge	 SHORT $LN9@stbi__tga_

; 5325 :         stbi__rewind(s);

  001b1	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001b8	e8 00 00 00 00	 call	 stbi__rewind

; 5326 :         return 0;   // test height

  001bd	33 c0		 xor	 eax, eax
  001bf	e9 fa 00 00 00	 jmp	 $LN1@stbi__tga_
$LN9@stbi__tga_:

; 5327 :     }
; 5328 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel

  001c4	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001cb	e8 00 00 00 00	 call	 stbi__get8
  001d0	0f b6 c0	 movzx	 eax, al
  001d3	89 85 84 00 00
	00		 mov	 DWORD PTR tga_bits_per_pixel$[rbp], eax

; 5329 :     stbi__get8(s); // ignore alpha bits

  001d9	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  001e0	e8 00 00 00 00	 call	 stbi__get8

; 5330 :     if (tga_colormap_bpp != 0) {

  001e5	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR tga_colormap_bpp$[rbp], 0
  001ec	74 3a		 je	 SHORT $LN10@stbi__tga_

; 5331 :         if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

  001ee	83 bd 84 00 00
	00 08		 cmp	 DWORD PTR tga_bits_per_pixel$[rbp], 8
  001f5	74 1c		 je	 SHORT $LN12@stbi__tga_
  001f7	83 bd 84 00 00
	00 10		 cmp	 DWORD PTR tga_bits_per_pixel$[rbp], 16
  001fe	74 13		 je	 SHORT $LN12@stbi__tga_

; 5332 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5333 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5334 :             stbi__rewind(s);

  00200	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00207	e8 00 00 00 00	 call	 stbi__rewind

; 5335 :             return 0;

  0020c	33 c0		 xor	 eax, eax
  0020e	e9 ab 00 00 00	 jmp	 $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5336 :         }
; 5337 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

  00213	45 33 c0	 xor	 r8d, r8d
  00216	33 d2		 xor	 edx, edx
  00218	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR tga_colormap_bpp$[rbp]
  0021e	e8 00 00 00 00	 call	 stbi__tga_get_comp
  00223	89 45 44	 mov	 DWORD PTR tga_comp$[rbp], eax

; 5338 :     }

  00226	eb 39		 jmp	 SHORT $LN11@stbi__tga_
$LN10@stbi__tga_:

; 5339 :     else {
; 5340 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

  00228	83 7d 64 03	 cmp	 DWORD PTR tga_image_type$[rbp], 3
  0022c	74 12		 je	 SHORT $LN18@stbi__tga_
  0022e	83 7d 64 0b	 cmp	 DWORD PTR tga_image_type$[rbp], 11
  00232	74 0c		 je	 SHORT $LN18@stbi__tga_
  00234	c7 85 b4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv153[rbp], 0
  0023e	eb 0a		 jmp	 SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
  00240	c7 85 b4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv153[rbp], 1
$LN19@stbi__tga_:
  0024a	45 33 c0	 xor	 r8d, r8d
  0024d	8b 95 b4 01 00
	00		 mov	 edx, DWORD PTR tv153[rbp]
  00253	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rbp]
  00259	e8 00 00 00 00	 call	 stbi__tga_get_comp
  0025e	89 45 44	 mov	 DWORD PTR tga_comp$[rbp], eax
$LN11@stbi__tga_:

; 5341 :     }
; 5342 :     if (!tga_comp) {

  00261	83 7d 44 00	 cmp	 DWORD PTR tga_comp$[rbp], 0
  00265	75 10		 jne	 SHORT $LN13@stbi__tga_

; 5343 :         stbi__rewind(s);

  00267	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0026e	e8 00 00 00 00	 call	 stbi__rewind

; 5344 :         return 0;

  00273	33 c0		 xor	 eax, eax
  00275	eb 47		 jmp	 SHORT $LN1@stbi__tga_
$LN13@stbi__tga_:

; 5345 :     }
; 5346 :     if (x) *x = tga_w;

  00277	48 83 bd e8 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  0027f	74 0c		 je	 SHORT $LN14@stbi__tga_
  00281	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00288	8b 4d 04	 mov	 ecx, DWORD PTR tga_w$[rbp]
  0028b	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@stbi__tga_:

; 5347 :     if (y) *y = tga_h;

  0028d	48 83 bd f0 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  00295	74 0c		 je	 SHORT $LN15@stbi__tga_
  00297	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  0029e	8b 4d 24	 mov	 ecx, DWORD PTR tga_h$[rbp]
  002a1	89 08		 mov	 DWORD PTR [rax], ecx
$LN15@stbi__tga_:

; 5348 :     if (comp) *comp = tga_comp;

  002a3	48 83 bd f8 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  002ab	74 0c		 je	 SHORT $LN16@stbi__tga_
  002ad	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  002b4	8b 4d 44	 mov	 ecx, DWORD PTR tga_comp$[rbp]
  002b7	89 08		 mov	 DWORD PTR [rax], ecx
$LN16@stbi__tga_:

; 5349 :     return 1;                   // seems to have passed everything

  002b9	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__tga_:

; 5350 : }

  002be	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  002c5	5f		 pop	 rdi
  002c6	5d		 pop	 rbp
  002c7	c3		 ret	 0
stbi__tga_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__tga_load
_TEXT	SEGMENT
tga_offset$ = 4
tga_indexed$ = 36
tga_image_type$ = 68
tga_is_RLE$ = 100
tga_palette_start$ = 132
tga_palette_len$ = 164
tga_palette_bits$ = 196
tga_x_origin$ = 228
tga_y_origin$ = 260
tga_width$ = 292
tga_height$ = 324
tga_bits_per_pixel$ = 356
tga_comp$ = 388
tga_rgb16$ = 420
tga_inverted$ = 452
tga_data$ = 488
tga_palette$ = 520
i$ = 548
j$ = 580
raw_data$ = 612
RLE_count$ = 644
RLE_repeating$ = 676
read_next_pixel$ = 708
row$5 = 740
tga_row$6 = 776
pal_entry$7 = 808
RLE_cmd$8 = 836
pal_idx$9 = 868
index1$10 = 900
index2$11 = 932
temp$12 = 964
tga_pixel$13 = 1000
temp$14 = 1028
tv296 = 1620
tv192 = 1620
tv153 = 1620
tv275 = 1624
tv219 = 1624
tv207 = 1624
tv181 = 1624
tv171 = 1624
tv160 = 1624
tv139 = 1624
tv134 = 1624
__$ArrayPad$ = 1632
s$ = 1680
x$ = 1688
y$ = 1696
comp$ = 1704
req_comp$ = 1712
ri$ = 1720
stbi__tga_load PROC					; COMDAT

; 5405 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec a8 06
	00 00		 sub	 rsp, 1704		; 000006a8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 0e 01 00 00	 mov	 ecx, 270		; 0000010eH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 c8
	06 00 00	 mov	 rcx, QWORD PTR [rsp+1736]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 60 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5406 :     //   read in the TGA header stuff
; 5407 :     int tga_offset = stbi__get8(s);

  00058	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__get8
  00064	0f b6 c0	 movzx	 eax, al
  00067	89 45 04	 mov	 DWORD PTR tga_offset$[rbp], eax

; 5408 :     int tga_indexed = stbi__get8(s);

  0006a	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00071	e8 00 00 00 00	 call	 stbi__get8
  00076	0f b6 c0	 movzx	 eax, al
  00079	89 45 24	 mov	 DWORD PTR tga_indexed$[rbp], eax

; 5409 :     int tga_image_type = stbi__get8(s);

  0007c	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00083	e8 00 00 00 00	 call	 stbi__get8
  00088	0f b6 c0	 movzx	 eax, al
  0008b	89 45 44	 mov	 DWORD PTR tga_image_type$[rbp], eax

; 5410 :     int tga_is_RLE = 0;

  0008e	c7 45 64 00 00
	00 00		 mov	 DWORD PTR tga_is_RLE$[rbp], 0

; 5411 :     int tga_palette_start = stbi__get16le(s);

  00095	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0009c	e8 00 00 00 00	 call	 stbi__get16le
  000a1	89 85 84 00 00
	00		 mov	 DWORD PTR tga_palette_start$[rbp], eax

; 5412 :     int tga_palette_len = stbi__get16le(s);

  000a7	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ae	e8 00 00 00 00	 call	 stbi__get16le
  000b3	89 85 a4 00 00
	00		 mov	 DWORD PTR tga_palette_len$[rbp], eax

; 5413 :     int tga_palette_bits = stbi__get8(s);

  000b9	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c0	e8 00 00 00 00	 call	 stbi__get8
  000c5	0f b6 c0	 movzx	 eax, al
  000c8	89 85 c4 00 00
	00		 mov	 DWORD PTR tga_palette_bits$[rbp], eax

; 5414 :     int tga_x_origin = stbi__get16le(s);

  000ce	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d5	e8 00 00 00 00	 call	 stbi__get16le
  000da	89 85 e4 00 00
	00		 mov	 DWORD PTR tga_x_origin$[rbp], eax

; 5415 :     int tga_y_origin = stbi__get16le(s);

  000e0	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000e7	e8 00 00 00 00	 call	 stbi__get16le
  000ec	89 85 04 01 00
	00		 mov	 DWORD PTR tga_y_origin$[rbp], eax

; 5416 :     int tga_width = stbi__get16le(s);

  000f2	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f9	e8 00 00 00 00	 call	 stbi__get16le
  000fe	89 85 24 01 00
	00		 mov	 DWORD PTR tga_width$[rbp], eax

; 5417 :     int tga_height = stbi__get16le(s);

  00104	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0010b	e8 00 00 00 00	 call	 stbi__get16le
  00110	89 85 44 01 00
	00		 mov	 DWORD PTR tga_height$[rbp], eax

; 5418 :     int tga_bits_per_pixel = stbi__get8(s);

  00116	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0011d	e8 00 00 00 00	 call	 stbi__get8
  00122	0f b6 c0	 movzx	 eax, al
  00125	89 85 64 01 00
	00		 mov	 DWORD PTR tga_bits_per_pixel$[rbp], eax

; 5419 :     int tga_comp, tga_rgb16 = 0;

  0012b	c7 85 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tga_rgb16$[rbp], 0

; 5420 :     int tga_inverted = stbi__get8(s);

  00135	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0013c	e8 00 00 00 00	 call	 stbi__get8
  00141	0f b6 c0	 movzx	 eax, al
  00144	89 85 c4 01 00
	00		 mov	 DWORD PTR tga_inverted$[rbp], eax

; 5421 :     // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5422 :     //   image data
; 5423 :     unsigned char* tga_data;
; 5424 :     unsigned char* tga_palette = NULL;

  0014a	48 c7 85 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tga_palette$[rbp], 0

; 5425 :     int i, j;
; 5426 :     unsigned char raw_data[4] = { 0 };

  00155	48 8d 85 64 02
	00 00		 lea	 rax, QWORD PTR raw_data$[rbp]
  0015c	48 8b f8	 mov	 rdi, rax
  0015f	33 c0		 xor	 eax, eax
  00161	b9 04 00 00 00	 mov	 ecx, 4
  00166	f3 aa		 rep stosb

; 5427 :     int RLE_count = 0;

  00168	c7 85 84 02 00
	00 00 00 00 00	 mov	 DWORD PTR RLE_count$[rbp], 0

; 5428 :     int RLE_repeating = 0;

  00172	c7 85 a4 02 00
	00 00 00 00 00	 mov	 DWORD PTR RLE_repeating$[rbp], 0

; 5429 :     int read_next_pixel = 1;

  0017c	c7 85 c4 02 00
	00 01 00 00 00	 mov	 DWORD PTR read_next_pixel$[rbp], 1

; 5430 :     STBI_NOTUSED(ri);
; 5431 :     STBI_NOTUSED(tga_x_origin); // @TODO
; 5432 :     STBI_NOTUSED(tga_y_origin); // @TODO
; 5433 : 
; 5434 :     if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  00186	81 bd 44 01 00
	00 00 00 00 01	 cmp	 DWORD PTR tga_height$[rbp], 16777216 ; 01000000H
  00190	7e 34		 jle	 SHORT $LN29@stbi__tga_
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00199	e8 00 00 00 00	 call	 stbi__err
  0019e	85 c0		 test	 eax, eax
  001a0	74 0d		 je	 SHORT $LN62@stbi__tga_
  001a2	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv134[rbp], 0
  001ad	eb 0b		 jmp	 SHORT $LN63@stbi__tga_
$LN62@stbi__tga_:
  001af	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv134[rbp], 0
$LN63@stbi__tga_:
  001ba	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv134[rbp]
  001c1	e9 c4 09 00 00	 jmp	 $LN1@stbi__tga_
$LN29@stbi__tga_:

; 5435 :     if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  001c6	81 bd 24 01 00
	00 00 00 00 01	 cmp	 DWORD PTR tga_width$[rbp], 16777216 ; 01000000H
  001d0	7e 34		 jle	 SHORT $LN30@stbi__tga_
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  001d9	e8 00 00 00 00	 call	 stbi__err
  001de	85 c0		 test	 eax, eax
  001e0	74 0d		 je	 SHORT $LN64@stbi__tga_
  001e2	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv139[rbp], 0
  001ed	eb 0b		 jmp	 SHORT $LN65@stbi__tga_
$LN64@stbi__tga_:
  001ef	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv139[rbp], 0
$LN65@stbi__tga_:
  001fa	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv139[rbp]
  00201	e9 84 09 00 00	 jmp	 $LN1@stbi__tga_
$LN30@stbi__tga_:

; 5436 : 
; 5437 :     //   do a tiny bit of precessing
; 5438 :     if (tga_image_type >= 8)

  00206	83 7d 44 08	 cmp	 DWORD PTR tga_image_type$[rbp], 8
  0020a	7c 10		 jl	 SHORT $LN31@stbi__tga_

; 5439 :     {
; 5440 :         tga_image_type -= 8;

  0020c	8b 45 44	 mov	 eax, DWORD PTR tga_image_type$[rbp]
  0020f	83 e8 08	 sub	 eax, 8
  00212	89 45 44	 mov	 DWORD PTR tga_image_type$[rbp], eax

; 5441 :         tga_is_RLE = 1;

  00215	c7 45 64 01 00
	00 00		 mov	 DWORD PTR tga_is_RLE$[rbp], 1
$LN31@stbi__tga_:

; 5442 :     }
; 5443 :     tga_inverted = 1 - ((tga_inverted >> 5) & 1);

  0021c	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR tga_inverted$[rbp]
  00222	c1 f8 05	 sar	 eax, 5
  00225	83 e0 01	 and	 eax, 1
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	2b c8		 sub	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	89 85 c4 01 00
	00		 mov	 DWORD PTR tga_inverted$[rbp], eax

; 5444 : 
; 5445 :     //   If I'm paletted, then I'll use the number of bits from the palette
; 5446 :     if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

  00237	83 7d 24 00	 cmp	 DWORD PTR tga_indexed$[rbp], 0
  0023b	74 1c		 je	 SHORT $LN32@stbi__tga_
  0023d	4c 8d 85 a4 01
	00 00		 lea	 r8, QWORD PTR tga_rgb16$[rbp]
  00244	33 d2		 xor	 edx, edx
  00246	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR tga_palette_bits$[rbp]
  0024c	e8 00 00 00 00	 call	 stbi__tga_get_comp
  00251	89 85 84 01 00
	00		 mov	 DWORD PTR tga_comp$[rbp], eax
  00257	eb 3a		 jmp	 SHORT $LN33@stbi__tga_
$LN32@stbi__tga_:

; 5447 :     else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

  00259	83 7d 44 03	 cmp	 DWORD PTR tga_image_type$[rbp], 3
  0025d	75 0c		 jne	 SHORT $LN66@stbi__tga_
  0025f	c7 85 54 06 00
	00 01 00 00 00	 mov	 DWORD PTR tv153[rbp], 1
  00269	eb 0a		 jmp	 SHORT $LN67@stbi__tga_
$LN66@stbi__tga_:
  0026b	c7 85 54 06 00
	00 00 00 00 00	 mov	 DWORD PTR tv153[rbp], 0
$LN67@stbi__tga_:
  00275	4c 8d 85 a4 01
	00 00		 lea	 r8, QWORD PTR tga_rgb16$[rbp]
  0027c	8b 95 54 06 00
	00		 mov	 edx, DWORD PTR tv153[rbp]
  00282	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rbp]
  00288	e8 00 00 00 00	 call	 stbi__tga_get_comp
  0028d	89 85 84 01 00
	00		 mov	 DWORD PTR tga_comp$[rbp], eax
$LN33@stbi__tga_:

; 5448 : 
; 5449 :     if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

  00293	83 bd 84 01 00
	00 00		 cmp	 DWORD PTR tga_comp$[rbp], 0
  0029a	75 34		 jne	 SHORT $LN34@stbi__tga_

; 5450 :         return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  002a3	e8 00 00 00 00	 call	 stbi__err
  002a8	85 c0		 test	 eax, eax
  002aa	74 0d		 je	 SHORT $LN68@stbi__tga_
  002ac	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv160[rbp], 0
  002b7	eb 0b		 jmp	 SHORT $LN69@stbi__tga_
$LN68@stbi__tga_:
  002b9	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv160[rbp], 0
$LN69@stbi__tga_:
  002c4	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv160[rbp]
  002cb	e9 ba 08 00 00	 jmp	 $LN1@stbi__tga_
$LN34@stbi__tga_:

; 5451 : 
; 5452 :     //   tga info
; 5453 :     *x = tga_width;

  002d0	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  002d7	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tga_width$[rbp]
  002dd	89 08		 mov	 DWORD PTR [rax], ecx

; 5454 :     *y = tga_height;

  002df	48 8b 85 a0 06
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  002e6	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR tga_height$[rbp]
  002ec	89 08		 mov	 DWORD PTR [rax], ecx

; 5455 :     if (comp) *comp = tga_comp;

  002ee	48 83 bd a8 06
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  002f6	74 0f		 je	 SHORT $LN35@stbi__tga_
  002f8	48 8b 85 a8 06
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  002ff	8b 8d 84 01 00
	00		 mov	 ecx, DWORD PTR tga_comp$[rbp]
  00305	89 08		 mov	 DWORD PTR [rax], ecx
$LN35@stbi__tga_:

; 5456 : 
; 5457 :     if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

  00307	45 33 c9	 xor	 r9d, r9d
  0030a	44 8b 85 84 01
	00 00		 mov	 r8d, DWORD PTR tga_comp$[rbp]
  00311	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR tga_height$[rbp]
  00317	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tga_width$[rbp]
  0031d	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00322	85 c0		 test	 eax, eax
  00324	75 34		 jne	 SHORT $LN36@stbi__tga_

; 5458 :         return stbi__errpuc("too large", "Corrupt TGA");

  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0032d	e8 00 00 00 00	 call	 stbi__err
  00332	85 c0		 test	 eax, eax
  00334	74 0d		 je	 SHORT $LN70@stbi__tga_
  00336	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv171[rbp], 0
  00341	eb 0b		 jmp	 SHORT $LN71@stbi__tga_
$LN70@stbi__tga_:
  00343	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv171[rbp], 0
$LN71@stbi__tga_:
  0034e	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv171[rbp]
  00355	e9 30 08 00 00	 jmp	 $LN1@stbi__tga_
$LN36@stbi__tga_:

; 5459 : 
; 5460 :     tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

  0035a	45 33 c9	 xor	 r9d, r9d
  0035d	44 8b 85 84 01
	00 00		 mov	 r8d, DWORD PTR tga_comp$[rbp]
  00364	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR tga_height$[rbp]
  0036a	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tga_width$[rbp]
  00370	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00375	48 89 85 e8 01
	00 00		 mov	 QWORD PTR tga_data$[rbp], rax

; 5461 :     if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

  0037c	48 83 bd e8 01
	00 00 00	 cmp	 QWORD PTR tga_data$[rbp], 0
  00384	75 34		 jne	 SHORT $LN37@stbi__tga_
  00386	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0038d	e8 00 00 00 00	 call	 stbi__err
  00392	85 c0		 test	 eax, eax
  00394	74 0d		 je	 SHORT $LN72@stbi__tga_
  00396	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv181[rbp], 0
  003a1	eb 0b		 jmp	 SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
  003a3	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv181[rbp], 0
$LN73@stbi__tga_:
  003ae	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv181[rbp]
  003b5	e9 d0 07 00 00	 jmp	 $LN1@stbi__tga_
$LN37@stbi__tga_:

; 5462 : 
; 5463 :     // skip to the data's starting position (offset usually = 0)
; 5464 :     stbi__skip(s, tga_offset);

  003ba	8b 55 04	 mov	 edx, DWORD PTR tga_offset$[rbp]
  003bd	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  003c4	e8 00 00 00 00	 call	 stbi__skip

; 5465 : 
; 5466 :     if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {

  003c9	83 7d 24 00	 cmp	 DWORD PTR tga_indexed$[rbp], 0
  003cd	0f 85 d5 00 00
	00		 jne	 $LN38@stbi__tga_
  003d3	83 7d 64 00	 cmp	 DWORD PTR tga_is_RLE$[rbp], 0
  003d7	0f 85 cb 00 00
	00		 jne	 $LN38@stbi__tga_
  003dd	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tga_rgb16$[rbp], 0
  003e4	0f 85 be 00 00
	00		 jne	 $LN38@stbi__tga_

; 5467 :         for (i = 0; i < tga_height; ++i) {

  003ea	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  003f4	eb 0e		 jmp	 SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
  003f6	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  003fc	ff c0		 inc	 eax
  003fe	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__tga_:
  00404	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR tga_height$[rbp]
  0040a	39 85 24 02 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00410	0f 8d 8d 00 00
	00		 jge	 $LN3@stbi__tga_

; 5468 :             int row = tga_inverted ? tga_height - i - 1 : i;

  00416	83 bd c4 01 00
	00 00		 cmp	 DWORD PTR tga_inverted$[rbp], 0
  0041d	74 1a		 je	 SHORT $LN74@stbi__tga_
  0041f	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00425	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR tga_height$[rbp]
  0042b	2b c8		 sub	 ecx, eax
  0042d	8b c1		 mov	 eax, ecx
  0042f	ff c8		 dec	 eax
  00431	89 85 54 06 00
	00		 mov	 DWORD PTR tv192[rbp], eax
  00437	eb 0c		 jmp	 SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
  00439	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  0043f	89 85 54 06 00
	00		 mov	 DWORD PTR tv192[rbp], eax
$LN75@stbi__tga_:
  00445	8b 85 54 06 00
	00		 mov	 eax, DWORD PTR tv192[rbp]
  0044b	89 85 e4 02 00
	00		 mov	 DWORD PTR row$5[rbp], eax

; 5469 :             stbi_uc* tga_row = tga_data + row * tga_width * tga_comp;

  00451	8b 85 e4 02 00
	00		 mov	 eax, DWORD PTR row$5[rbp]
  00457	0f af 85 24 01
	00 00		 imul	 eax, DWORD PTR tga_width$[rbp]
  0045e	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  00465	48 98		 cdqe
  00467	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  0046e	48 03 c8	 add	 rcx, rax
  00471	48 8b c1	 mov	 rax, rcx
  00474	48 89 85 08 03
	00 00		 mov	 QWORD PTR tga_row$6[rbp], rax

; 5470 :             stbi__getn(s, tga_row, tga_width * tga_comp);

  0047b	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tga_width$[rbp]
  00481	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  00488	44 8b c0	 mov	 r8d, eax
  0048b	48 8b 95 08 03
	00 00		 mov	 rdx, QWORD PTR tga_row$6[rbp]
  00492	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00499	e8 00 00 00 00	 call	 stbi__getn

; 5471 :         }

  0049e	e9 53 ff ff ff	 jmp	 $LN2@stbi__tga_
$LN3@stbi__tga_:

; 5472 :     }

  004a3	e9 87 05 00 00	 jmp	 $LN39@stbi__tga_
$LN38@stbi__tga_:

; 5473 :     else {
; 5474 :         //   do I need to load a palette?
; 5475 :         if (tga_indexed)

  004a8	83 7d 24 00	 cmp	 DWORD PTR tga_indexed$[rbp], 0
  004ac	0f 84 d1 01 00
	00		 je	 $LN40@stbi__tga_

; 5476 :         {
; 5477 :             if (tga_palette_len == 0) {  /* you have to have at least one entry! */

  004b2	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR tga_palette_len$[rbp], 0
  004b9	75 41		 jne	 SHORT $LN41@stbi__tga_

; 5478 :                 STBI_FREE(tga_data);

  004bb	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5479 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  004c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ILLOCNCO@bad?5palette@
  004cf	e8 00 00 00 00	 call	 stbi__err
  004d4	85 c0		 test	 eax, eax
  004d6	74 0d		 je	 SHORT $LN76@stbi__tga_
  004d8	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv207[rbp], 0
  004e3	eb 0b		 jmp	 SHORT $LN77@stbi__tga_
$LN76@stbi__tga_:
  004e5	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv207[rbp], 0
$LN77@stbi__tga_:
  004f0	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv207[rbp]
  004f7	e9 8e 06 00 00	 jmp	 $LN1@stbi__tga_
$LN41@stbi__tga_:

; 5480 :             }
; 5481 : 
; 5482 :             //   any data to skip? (offset usually = 0)
; 5483 :             stbi__skip(s, tga_palette_start);

  004fc	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR tga_palette_start$[rbp]
  00502	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00509	e8 00 00 00 00	 call	 stbi__skip

; 5484 :             //   load the palette
; 5485 :             tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

  0050e	45 33 c0	 xor	 r8d, r8d
  00511	8b 95 84 01 00
	00		 mov	 edx, DWORD PTR tga_comp$[rbp]
  00517	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR tga_palette_len$[rbp]
  0051d	e8 00 00 00 00	 call	 stbi__malloc_mad2
  00522	48 89 85 08 02
	00 00		 mov	 QWORD PTR tga_palette$[rbp], rax

; 5486 :             if (!tga_palette) {

  00529	48 83 bd 08 02
	00 00 00	 cmp	 QWORD PTR tga_palette$[rbp], 0
  00531	75 41		 jne	 SHORT $LN42@stbi__tga_

; 5487 :                 STBI_FREE(tga_data);

  00533	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5488 :                 return stbi__errpuc("outofmem", "Out of memory");

  00540	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00547	e8 00 00 00 00	 call	 stbi__err
  0054c	85 c0		 test	 eax, eax
  0054e	74 0d		 je	 SHORT $LN78@stbi__tga_
  00550	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv219[rbp], 0
  0055b	eb 0b		 jmp	 SHORT $LN79@stbi__tga_
$LN78@stbi__tga_:
  0055d	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv219[rbp], 0
$LN79@stbi__tga_:
  00568	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv219[rbp]
  0056f	e9 16 06 00 00	 jmp	 $LN1@stbi__tga_
$LN42@stbi__tga_:

; 5489 :             }
; 5490 :             if (tga_rgb16) {

  00574	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tga_rgb16$[rbp], 0
  0057b	0f 84 8d 00 00
	00		 je	 $LN43@stbi__tga_

; 5491 :                 stbi_uc* pal_entry = tga_palette;

  00581	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR tga_palette$[rbp]
  00588	48 89 85 28 03
	00 00		 mov	 QWORD PTR pal_entry$7[rbp], rax

; 5492 :                 STBI_ASSERT(tga_comp == STBI_rgb);

  0058f	83 bd 84 01 00
	00 03		 cmp	 DWORD PTR tga_comp$[rbp], 3
  00596	74 1c		 je	 SHORT $LN80@stbi__tga_
  00598	41 b8 74 15 00
	00		 mov	 r8d, 5492		; 00001574H
  0059e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  005a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005b2	33 c0		 xor	 eax, eax
$LN80@stbi__tga_:

; 5493 :                 for (i = 0; i < tga_palette_len; ++i) {

  005b4	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  005be	eb 0e		 jmp	 SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
  005c0	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  005c6	ff c0		 inc	 eax
  005c8	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN7@stbi__tga_:
  005ce	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR tga_palette_len$[rbp]
  005d4	39 85 24 02 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  005da	7d 30		 jge	 SHORT $LN6@stbi__tga_

; 5494 :                     stbi__tga_read_rgb16(s, pal_entry);

  005dc	48 8b 95 28 03
	00 00		 mov	 rdx, QWORD PTR pal_entry$7[rbp]
  005e3	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005ea	e8 00 00 00 00	 call	 stbi__tga_read_rgb16

; 5495 :                     pal_entry += tga_comp;

  005ef	48 63 85 84 01
	00 00		 movsxd	 rax, DWORD PTR tga_comp$[rbp]
  005f6	48 8b 8d 28 03
	00 00		 mov	 rcx, QWORD PTR pal_entry$7[rbp]
  005fd	48 03 c8	 add	 rcx, rax
  00600	48 8b c1	 mov	 rax, rcx
  00603	48 89 85 28 03
	00 00		 mov	 QWORD PTR pal_entry$7[rbp], rax

; 5496 :                 }

  0060a	eb b4		 jmp	 SHORT $LN5@stbi__tga_
$LN6@stbi__tga_:

; 5497 :             }

  0060c	eb 75		 jmp	 SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:

; 5498 :             else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

  0060e	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR tga_palette_len$[rbp]
  00614	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  0061b	44 8b c0	 mov	 r8d, eax
  0061e	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR tga_palette$[rbp]
  00625	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0062c	e8 00 00 00 00	 call	 stbi__getn
  00631	85 c0		 test	 eax, eax
  00633	75 4e		 jne	 SHORT $LN45@stbi__tga_

; 5499 :                 STBI_FREE(tga_data);

  00635	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5500 :                 STBI_FREE(tga_palette);

  00642	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR tga_palette$[rbp]
  00649	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5501 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ILLOCNCO@bad?5palette@
  00656	e8 00 00 00 00	 call	 stbi__err
  0065b	85 c0		 test	 eax, eax
  0065d	74 0d		 je	 SHORT $LN81@stbi__tga_
  0065f	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv275[rbp], 0
  0066a	eb 0b		 jmp	 SHORT $LN82@stbi__tga_
$LN81@stbi__tga_:
  0066c	48 c7 85 58 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv275[rbp], 0
$LN82@stbi__tga_:
  00677	48 8b 85 58 06
	00 00		 mov	 rax, QWORD PTR tv275[rbp]
  0067e	e9 07 05 00 00	 jmp	 $LN1@stbi__tga_
$LN45@stbi__tga_:
$LN44@stbi__tga_:
$LN40@stbi__tga_:

; 5502 :             }
; 5503 :         }
; 5504 :         //   load the data
; 5505 :         for (i = 0; i < tga_width * tga_height; ++i)

  00683	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  0068d	eb 0e		 jmp	 SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
  0068f	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00695	ff c0		 inc	 eax
  00697	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__tga_:
  0069d	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tga_width$[rbp]
  006a3	0f af 85 44 01
	00 00		 imul	 eax, DWORD PTR tga_height$[rbp]
  006aa	39 85 24 02 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  006b0	0f 8d 46 02 00
	00		 jge	 $LN9@stbi__tga_

; 5506 :         {
; 5507 :             //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5508 :             if (tga_is_RLE)

  006b6	83 7d 64 00	 cmp	 DWORD PTR tga_is_RLE$[rbp], 0
  006ba	74 5f		 je	 SHORT $LN46@stbi__tga_

; 5509 :             {
; 5510 :                 if (RLE_count == 0)

  006bc	83 bd 84 02 00
	00 00		 cmp	 DWORD PTR RLE_count$[rbp], 0
  006c3	75 41		 jne	 SHORT $LN48@stbi__tga_

; 5511 :                 {
; 5512 :                     //   yep, get the next byte as a RLE command
; 5513 :                     int RLE_cmd = stbi__get8(s);

  006c5	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  006cc	e8 00 00 00 00	 call	 stbi__get8
  006d1	0f b6 c0	 movzx	 eax, al
  006d4	89 85 44 03 00
	00		 mov	 DWORD PTR RLE_cmd$8[rbp], eax

; 5514 :                     RLE_count = 1 + (RLE_cmd & 127);

  006da	8b 85 44 03 00
	00		 mov	 eax, DWORD PTR RLE_cmd$8[rbp]
  006e0	83 e0 7f	 and	 eax, 127		; 0000007fH
  006e3	ff c0		 inc	 eax
  006e5	89 85 84 02 00
	00		 mov	 DWORD PTR RLE_count$[rbp], eax

; 5515 :                     RLE_repeating = RLE_cmd >> 7;

  006eb	8b 85 44 03 00
	00		 mov	 eax, DWORD PTR RLE_cmd$8[rbp]
  006f1	c1 f8 07	 sar	 eax, 7
  006f4	89 85 a4 02 00
	00		 mov	 DWORD PTR RLE_repeating$[rbp], eax

; 5516 :                     read_next_pixel = 1;

  006fa	c7 85 c4 02 00
	00 01 00 00 00	 mov	 DWORD PTR read_next_pixel$[rbp], 1

; 5517 :                 }

  00704	eb 13		 jmp	 SHORT $LN49@stbi__tga_
$LN48@stbi__tga_:

; 5518 :                 else if (!RLE_repeating)

  00706	83 bd a4 02 00
	00 00		 cmp	 DWORD PTR RLE_repeating$[rbp], 0
  0070d	75 0a		 jne	 SHORT $LN50@stbi__tga_

; 5519 :                 {
; 5520 :                     read_next_pixel = 1;

  0070f	c7 85 c4 02 00
	00 01 00 00 00	 mov	 DWORD PTR read_next_pixel$[rbp], 1
$LN50@stbi__tga_:
$LN49@stbi__tga_:

; 5521 :                 }
; 5522 :             }

  00719	eb 0a		 jmp	 SHORT $LN47@stbi__tga_
$LN46@stbi__tga_:

; 5523 :             else
; 5524 :             {
; 5525 :                 read_next_pixel = 1;

  0071b	c7 85 c4 02 00
	00 01 00 00 00	 mov	 DWORD PTR read_next_pixel$[rbp], 1
$LN47@stbi__tga_:

; 5526 :             }
; 5527 :             //   OK, if I need to read a pixel, do it now
; 5528 :             if (read_next_pixel)

  00725	83 bd c4 02 00
	00 00		 cmp	 DWORD PTR read_next_pixel$[rbp], 0
  0072c	0f 84 5e 01 00
	00		 je	 $LN51@stbi__tga_

; 5529 :             {
; 5530 :                 //   load however much data we did have
; 5531 :                 if (tga_indexed)

  00732	83 7d 24 00	 cmp	 DWORD PTR tga_indexed$[rbp], 0
  00736	0f 84 c3 00 00
	00		 je	 $LN52@stbi__tga_

; 5532 :                 {
; 5533 :                     // read in index, then perform the lookup
; 5534 :                     int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

  0073c	83 bd 64 01 00
	00 08		 cmp	 DWORD PTR tga_bits_per_pixel$[rbp], 8
  00743	75 17		 jne	 SHORT $LN83@stbi__tga_
  00745	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0074c	e8 00 00 00 00	 call	 stbi__get8
  00751	0f b6 c0	 movzx	 eax, al
  00754	89 85 54 06 00
	00		 mov	 DWORD PTR tv296[rbp], eax
  0075a	eb 12		 jmp	 SHORT $LN84@stbi__tga_
$LN83@stbi__tga_:
  0075c	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00763	e8 00 00 00 00	 call	 stbi__get16le
  00768	89 85 54 06 00
	00		 mov	 DWORD PTR tv296[rbp], eax
$LN84@stbi__tga_:
  0076e	8b 85 54 06 00
	00		 mov	 eax, DWORD PTR tv296[rbp]
  00774	89 85 64 03 00
	00		 mov	 DWORD PTR pal_idx$9[rbp], eax

; 5535 :                     if (pal_idx >= tga_palette_len) {

  0077a	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR tga_palette_len$[rbp]
  00780	39 85 64 03 00
	00		 cmp	 DWORD PTR pal_idx$9[rbp], eax
  00786	7c 0a		 jl	 SHORT $LN54@stbi__tga_

; 5536 :                         // invalid index
; 5537 :                         pal_idx = 0;

  00788	c7 85 64 03 00
	00 00 00 00 00	 mov	 DWORD PTR pal_idx$9[rbp], 0
$LN54@stbi__tga_:

; 5538 :                     }
; 5539 :                     pal_idx *= tga_comp;

  00792	8b 85 64 03 00
	00		 mov	 eax, DWORD PTR pal_idx$9[rbp]
  00798	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  0079f	89 85 64 03 00
	00		 mov	 DWORD PTR pal_idx$9[rbp], eax

; 5540 :                     for (j = 0; j < tga_comp; ++j) {

  007a5	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  007af	eb 0e		 jmp	 SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
  007b1	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  007b7	ff c0		 inc	 eax
  007b9	89 85 44 02 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN13@stbi__tga_:
  007bf	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR tga_comp$[rbp]
  007c5	39 85 44 02 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  007cb	7d 2d		 jge	 SHORT $LN12@stbi__tga_

; 5541 :                         raw_data[j] = tga_palette[pal_idx + j];

  007cd	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  007d3	8b 8d 64 03 00
	00		 mov	 ecx, DWORD PTR pal_idx$9[rbp]
  007d9	03 c8		 add	 ecx, eax
  007db	8b c1		 mov	 eax, ecx
  007dd	48 98		 cdqe
  007df	48 63 8d 44 02
	00 00		 movsxd	 rcx, DWORD PTR j$[rbp]
  007e6	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR tga_palette$[rbp]
  007ed	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  007f1	88 84 0d 64 02
	00 00		 mov	 BYTE PTR raw_data$[rbp+rcx], al

; 5542 :                     }

  007f8	eb b7		 jmp	 SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:

; 5543 :                 }

  007fa	e9 87 00 00 00	 jmp	 $LN53@stbi__tga_
$LN52@stbi__tga_:

; 5544 :                 else if (tga_rgb16) {

  007ff	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tga_rgb16$[rbp], 0
  00806	74 3a		 je	 SHORT $LN55@stbi__tga_

; 5545 :                     STBI_ASSERT(tga_comp == STBI_rgb);

  00808	83 bd 84 01 00
	00 03		 cmp	 DWORD PTR tga_comp$[rbp], 3
  0080f	74 1c		 je	 SHORT $LN85@stbi__tga_
  00811	41 b8 a9 15 00
	00		 mov	 r8d, 5545		; 000015a9H
  00817	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KA@LPJPGBDN@?$AAD?$AA?3?$AA?2?$AAN?$AAi?$AAt?$AAl?$AAo?$AAa?$AAd?$AAI?$AAn?$AAd?$AAu?$AAs@
  0081e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
  00825	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0082b	33 c0		 xor	 eax, eax
$LN85@stbi__tga_:

; 5546 :                     stbi__tga_read_rgb16(s, raw_data);

  0082d	48 8d 95 64 02
	00 00		 lea	 rdx, QWORD PTR raw_data$[rbp]
  00834	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0083b	e8 00 00 00 00	 call	 stbi__tga_read_rgb16

; 5547 :                 }

  00840	eb 44		 jmp	 SHORT $LN56@stbi__tga_
$LN55@stbi__tga_:

; 5548 :                 else {
; 5549 :                     //   read in the data raw
; 5550 :                     for (j = 0; j < tga_comp; ++j) {

  00842	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  0084c	eb 0e		 jmp	 SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
  0084e	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  00854	ff c0		 inc	 eax
  00856	89 85 44 02 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN16@stbi__tga_:
  0085c	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR tga_comp$[rbp]
  00862	39 85 44 02 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  00868	7d 1c		 jge	 SHORT $LN15@stbi__tga_

; 5551 :                         raw_data[j] = stbi__get8(s);

  0086a	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00871	e8 00 00 00 00	 call	 stbi__get8
  00876	48 63 8d 44 02
	00 00		 movsxd	 rcx, DWORD PTR j$[rbp]
  0087d	88 84 0d 64 02
	00 00		 mov	 BYTE PTR raw_data$[rbp+rcx], al

; 5552 :                     }

  00884	eb c8		 jmp	 SHORT $LN14@stbi__tga_
$LN15@stbi__tga_:
$LN56@stbi__tga_:
$LN53@stbi__tga_:

; 5553 :                 }
; 5554 :                 //   clear the reading flag for the next pixel
; 5555 :                 read_next_pixel = 0;

  00886	c7 85 c4 02 00
	00 00 00 00 00	 mov	 DWORD PTR read_next_pixel$[rbp], 0
$LN51@stbi__tga_:

; 5556 :             } // end of reading a pixel
; 5557 : 
; 5558 :             // copy data
; 5559 :             for (j = 0; j < tga_comp; ++j)

  00890	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  0089a	eb 0e		 jmp	 SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
  0089c	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  008a2	ff c0		 inc	 eax
  008a4	89 85 44 02 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN19@stbi__tga_:
  008aa	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR tga_comp$[rbp]
  008b0	39 85 44 02 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  008b6	7d 31		 jge	 SHORT $LN18@stbi__tga_

; 5560 :                 tga_data[i * tga_comp + j] = raw_data[j];

  008b8	48 63 85 44 02
	00 00		 movsxd	 rax, DWORD PTR j$[rbp]
  008bf	8b 8d 24 02 00
	00		 mov	 ecx, DWORD PTR i$[rbp]
  008c5	0f af 8d 84 01
	00 00		 imul	 ecx, DWORD PTR tga_comp$[rbp]
  008cc	03 8d 44 02 00
	00		 add	 ecx, DWORD PTR j$[rbp]
  008d2	48 63 c9	 movsxd	 rcx, ecx
  008d5	48 8b 95 e8 01
	00 00		 mov	 rdx, QWORD PTR tga_data$[rbp]
  008dc	0f b6 84 05 64
	02 00 00	 movzx	 eax, BYTE PTR raw_data$[rbp+rax]
  008e4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008e7	eb b3		 jmp	 SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 5561 : 
; 5562 :             //   in case we're in RLE mode, keep counting down
; 5563 :             --RLE_count;

  008e9	8b 85 84 02 00
	00		 mov	 eax, DWORD PTR RLE_count$[rbp]
  008ef	ff c8		 dec	 eax
  008f1	89 85 84 02 00
	00		 mov	 DWORD PTR RLE_count$[rbp], eax

; 5564 :         }

  008f7	e9 93 fd ff ff	 jmp	 $LN8@stbi__tga_
$LN9@stbi__tga_:

; 5565 :         //   do I need to invert the image?
; 5566 :         if (tga_inverted)

  008fc	83 bd c4 01 00
	00 00		 cmp	 DWORD PTR tga_inverted$[rbp], 0
  00903	0f 84 0f 01 00
	00		 je	 $LN57@stbi__tga_

; 5567 :         {
; 5568 :             for (j = 0; j * 2 < tga_height; ++j)

  00909	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  00913	eb 0e		 jmp	 SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
  00915	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  0091b	ff c0		 inc	 eax
  0091d	89 85 44 02 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN22@stbi__tga_:
  00923	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  00929	d1 e0		 shl	 eax, 1
  0092b	3b 85 44 01 00
	00		 cmp	 eax, DWORD PTR tga_height$[rbp]
  00931	0f 8d e1 00 00
	00		 jge	 $LN21@stbi__tga_

; 5569 :             {
; 5570 :                 int index1 = j * tga_width * tga_comp;

  00937	8b 85 44 02 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  0093d	0f af 85 24 01
	00 00		 imul	 eax, DWORD PTR tga_width$[rbp]
  00944	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  0094b	89 85 84 03 00
	00		 mov	 DWORD PTR index1$10[rbp], eax

; 5571 :                 int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

  00951	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR tga_height$[rbp]
  00957	ff c8		 dec	 eax
  00959	2b 85 44 02 00
	00		 sub	 eax, DWORD PTR j$[rbp]
  0095f	0f af 85 24 01
	00 00		 imul	 eax, DWORD PTR tga_width$[rbp]
  00966	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  0096d	89 85 a4 03 00
	00		 mov	 DWORD PTR index2$11[rbp], eax

; 5572 :                 for (i = tga_width * tga_comp; i > 0; --i)

  00973	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tga_width$[rbp]
  00979	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR tga_comp$[rbp]
  00980	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
  00986	eb 0e		 jmp	 SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
  00988	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  0098e	ff c8		 dec	 eax
  00990	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN25@stbi__tga_:
  00996	83 bd 24 02 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  0099d	7e 74		 jle	 SHORT $LN24@stbi__tga_

; 5573 :                 {
; 5574 :                     unsigned char temp = tga_data[index1];

  0099f	48 63 85 84 03
	00 00		 movsxd	 rax, DWORD PTR index1$10[rbp]
  009a6	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  009ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009b1	88 85 c4 03 00
	00		 mov	 BYTE PTR temp$12[rbp], al

; 5575 :                     tga_data[index1] = tga_data[index2];

  009b7	48 63 85 a4 03
	00 00		 movsxd	 rax, DWORD PTR index2$11[rbp]
  009be	48 63 8d 84 03
	00 00		 movsxd	 rcx, DWORD PTR index1$10[rbp]
  009c5	48 8b 95 e8 01
	00 00		 mov	 rdx, QWORD PTR tga_data$[rbp]
  009cc	48 8b bd e8 01
	00 00		 mov	 rdi, QWORD PTR tga_data$[rbp]
  009d3	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  009d7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5576 :                     tga_data[index2] = temp;

  009da	48 63 85 a4 03
	00 00		 movsxd	 rax, DWORD PTR index2$11[rbp]
  009e1	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  009e8	0f b6 95 c4 03
	00 00		 movzx	 edx, BYTE PTR temp$12[rbp]
  009ef	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5577 :                     ++index1;

  009f2	8b 85 84 03 00
	00		 mov	 eax, DWORD PTR index1$10[rbp]
  009f8	ff c0		 inc	 eax
  009fa	89 85 84 03 00
	00		 mov	 DWORD PTR index1$10[rbp], eax

; 5578 :                     ++index2;

  00a00	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR index2$11[rbp]
  00a06	ff c0		 inc	 eax
  00a08	89 85 a4 03 00
	00		 mov	 DWORD PTR index2$11[rbp], eax

; 5579 :                 }

  00a0e	e9 75 ff ff ff	 jmp	 $LN23@stbi__tga_
$LN24@stbi__tga_:

; 5580 :             }

  00a13	e9 fd fe ff ff	 jmp	 $LN20@stbi__tga_
$LN21@stbi__tga_:
$LN57@stbi__tga_:

; 5581 :         }
; 5582 :         //   clear my palette, if I had one
; 5583 :         if (tga_palette != NULL)

  00a18	48 83 bd 08 02
	00 00 00	 cmp	 QWORD PTR tga_palette$[rbp], 0
  00a20	74 0d		 je	 SHORT $LN58@stbi__tga_

; 5584 :         {
; 5585 :             STBI_FREE(tga_palette);

  00a22	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR tga_palette$[rbp]
  00a29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN58@stbi__tga_:
$LN39@stbi__tga_:

; 5586 :         }
; 5587 :     }
; 5588 : 
; 5589 :     // swap RGB - if the source data was RGB16, it already is in the right order
; 5590 :     if (tga_comp >= 3 && !tga_rgb16)

  00a2f	83 bd 84 01 00
	00 03		 cmp	 DWORD PTR tga_comp$[rbp], 3
  00a36	0f 8c c5 00 00
	00		 jl	 $LN59@stbi__tga_
  00a3c	83 bd a4 01 00
	00 00		 cmp	 DWORD PTR tga_rgb16$[rbp], 0
  00a43	0f 85 b8 00 00
	00		 jne	 $LN59@stbi__tga_

; 5591 :     {
; 5592 :         unsigned char* tga_pixel = tga_data;

  00a49	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR tga_data$[rbp]
  00a50	48 89 85 e8 03
	00 00		 mov	 QWORD PTR tga_pixel$13[rbp], rax

; 5593 :         for (i = 0; i < tga_width * tga_height; ++i)

  00a57	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00a61	eb 0e		 jmp	 SHORT $LN28@stbi__tga_
$LN26@stbi__tga_:
  00a63	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00a69	ff c0		 inc	 eax
  00a6b	89 85 24 02 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN28@stbi__tga_:
  00a71	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR tga_width$[rbp]
  00a77	0f af 85 44 01
	00 00		 imul	 eax, DWORD PTR tga_height$[rbp]
  00a7e	39 85 24 02 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00a84	7d 7b		 jge	 SHORT $LN27@stbi__tga_

; 5594 :         {
; 5595 :             unsigned char temp = tga_pixel[0];

  00a86	b8 01 00 00 00	 mov	 eax, 1
  00a8b	48 6b c0 00	 imul	 rax, rax, 0
  00a8f	48 8b 8d e8 03
	00 00		 mov	 rcx, QWORD PTR tga_pixel$13[rbp]
  00a96	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a9a	88 85 04 04 00
	00		 mov	 BYTE PTR temp$14[rbp], al

; 5596 :             tga_pixel[0] = tga_pixel[2];

  00aa0	b8 01 00 00 00	 mov	 eax, 1
  00aa5	48 6b c0 02	 imul	 rax, rax, 2
  00aa9	b9 01 00 00 00	 mov	 ecx, 1
  00aae	48 6b c9 00	 imul	 rcx, rcx, 0
  00ab2	48 8b 95 e8 03
	00 00		 mov	 rdx, QWORD PTR tga_pixel$13[rbp]
  00ab9	48 8b bd e8 03
	00 00		 mov	 rdi, QWORD PTR tga_pixel$13[rbp]
  00ac0	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00ac4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5597 :             tga_pixel[2] = temp;

  00ac7	b8 01 00 00 00	 mov	 eax, 1
  00acc	48 6b c0 02	 imul	 rax, rax, 2
  00ad0	48 8b 8d e8 03
	00 00		 mov	 rcx, QWORD PTR tga_pixel$13[rbp]
  00ad7	0f b6 95 04 04
	00 00		 movzx	 edx, BYTE PTR temp$14[rbp]
  00ade	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5598 :             tga_pixel += tga_comp;

  00ae1	48 63 85 84 01
	00 00		 movsxd	 rax, DWORD PTR tga_comp$[rbp]
  00ae8	48 8b 8d e8 03
	00 00		 mov	 rcx, QWORD PTR tga_pixel$13[rbp]
  00aef	48 03 c8	 add	 rcx, rax
  00af2	48 8b c1	 mov	 rax, rcx
  00af5	48 89 85 e8 03
	00 00		 mov	 QWORD PTR tga_pixel$13[rbp], rax

; 5599 :         }

  00afc	e9 62 ff ff ff	 jmp	 $LN26@stbi__tga_
$LN27@stbi__tga_:
$LN59@stbi__tga_:

; 5600 :     }
; 5601 : 
; 5602 :     // convert to target component count
; 5603 :     if (req_comp && req_comp != tga_comp)

  00b01	83 bd b0 06 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  00b08	74 3f		 je	 SHORT $LN60@stbi__tga_
  00b0a	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR tga_comp$[rbp]
  00b10	39 85 b0 06 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  00b16	74 31		 je	 SHORT $LN60@stbi__tga_

; 5604 :         tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

  00b18	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR tga_height$[rbp]
  00b1e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b22	44 8b 8d 24 01
	00 00		 mov	 r9d, DWORD PTR tga_width$[rbp]
  00b29	44 8b 85 b0 06
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  00b30	8b 95 84 01 00
	00		 mov	 edx, DWORD PTR tga_comp$[rbp]
  00b36	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR tga_data$[rbp]
  00b3d	e8 00 00 00 00	 call	 stbi__convert_format
  00b42	48 89 85 e8 01
	00 00		 mov	 QWORD PTR tga_data$[rbp], rax
$LN60@stbi__tga_:

; 5605 : 
; 5606 :     //   the things I do to get rid of an error message, and yet keep
; 5607 :     //   Microsoft's C compilers happy... [8^(
; 5608 :     tga_palette_start = tga_palette_len = tga_palette_bits =

  00b49	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR tga_y_origin$[rbp], 0
  00b53	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR tga_y_origin$[rbp]
  00b59	89 85 e4 00 00
	00		 mov	 DWORD PTR tga_x_origin$[rbp], eax
  00b5f	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR tga_x_origin$[rbp]
  00b65	89 85 c4 00 00
	00		 mov	 DWORD PTR tga_palette_bits$[rbp], eax
  00b6b	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tga_palette_bits$[rbp]
  00b71	89 85 a4 00 00
	00		 mov	 DWORD PTR tga_palette_len$[rbp], eax
  00b77	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR tga_palette_len$[rbp]
  00b7d	89 85 84 00 00
	00		 mov	 DWORD PTR tga_palette_start$[rbp], eax

; 5609 :         tga_x_origin = tga_y_origin = 0;
; 5610 :     STBI_NOTUSED(tga_palette_start);
; 5611 :     //   OK, done
; 5612 :     return tga_data;

  00b83	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR tga_data$[rbp]
$LN1@stbi__tga_:

; 5613 : }

  00b8a	48 8b f8	 mov	 rdi, rax
  00b8d	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00b91	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__tga_load$rtcFrameData
  00b98	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00b9d	48 8b c7	 mov	 rax, rdi
  00ba0	48 8b 8d 60 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00ba7	48 33 cd	 xor	 rcx, rbp
  00baa	e8 00 00 00 00	 call	 __security_check_cookie
  00baf	48 8d a5 78 06
	00 00		 lea	 rsp, QWORD PTR [rbp+1656]
  00bb6	5f		 pop	 rdi
  00bb7	5d		 pop	 rbp
  00bb8	c3		 ret	 0
stbi__tga_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__tga_test
_TEXT	SEGMENT
res$ = 4
sz$ = 36
tga_color_type$ = 68
s$ = 320
stbi__tga_test PROC					; COMDAT

; 5353 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5354 :     int res = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR res$[rbp], 0

; 5355 :     int sz, tga_color_type;
; 5356 :     stbi__get8(s);      //   discard Offset

  00026	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002d	e8 00 00 00 00	 call	 stbi__get8

; 5357 :     tga_color_type = stbi__get8(s);   //   color type

  00032	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00039	e8 00 00 00 00	 call	 stbi__get8
  0003e	0f b6 c0	 movzx	 eax, al
  00041	89 45 44	 mov	 DWORD PTR tga_color_type$[rbp], eax

; 5358 :     if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed

  00044	83 7d 44 01	 cmp	 DWORD PTR tga_color_type$[rbp], 1
  00048	7e 05		 jle	 SHORT $LN2@stbi__tga_
  0004a	e9 23 01 00 00	 jmp	 $errorEnd$13
$LN2@stbi__tga_:

; 5359 :     sz = stbi__get8(s);   //   image type

  0004f	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00056	e8 00 00 00 00	 call	 stbi__get8
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	89 45 24	 mov	 DWORD PTR sz$[rbp], eax

; 5360 :     if (tga_color_type == 1) { // colormapped (paletted) image

  00061	83 7d 44 01	 cmp	 DWORD PTR tga_color_type$[rbp], 1
  00065	75 6a		 jne	 SHORT $LN3@stbi__tga_

; 5361 :         if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

  00067	83 7d 24 01	 cmp	 DWORD PTR sz$[rbp], 1
  0006b	74 0b		 je	 SHORT $LN5@stbi__tga_
  0006d	83 7d 24 09	 cmp	 DWORD PTR sz$[rbp], 9
  00071	74 05		 je	 SHORT $LN5@stbi__tga_
  00073	e9 fa 00 00 00	 jmp	 $errorEnd$13
$LN5@stbi__tga_:

; 5362 :         stbi__skip(s, 4);       // skip index of first colormap entry and number of entries

  00078	ba 04 00 00 00	 mov	 edx, 4
  0007d	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00084	e8 00 00 00 00	 call	 stbi__skip

; 5363 :         sz = stbi__get8(s);    //   check bits per palette color entry

  00089	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00090	e8 00 00 00 00	 call	 stbi__get8
  00095	0f b6 c0	 movzx	 eax, al
  00098	89 45 24	 mov	 DWORD PTR sz$[rbp], eax

; 5364 :         if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

  0009b	83 7d 24 08	 cmp	 DWORD PTR sz$[rbp], 8
  0009f	74 1d		 je	 SHORT $LN6@stbi__tga_
  000a1	83 7d 24 0f	 cmp	 DWORD PTR sz$[rbp], 15
  000a5	74 17		 je	 SHORT $LN6@stbi__tga_
  000a7	83 7d 24 10	 cmp	 DWORD PTR sz$[rbp], 16
  000ab	74 11		 je	 SHORT $LN6@stbi__tga_
  000ad	83 7d 24 18	 cmp	 DWORD PTR sz$[rbp], 24
  000b1	74 0b		 je	 SHORT $LN6@stbi__tga_
  000b3	83 7d 24 20	 cmp	 DWORD PTR sz$[rbp], 32	; 00000020H
  000b7	74 05		 je	 SHORT $LN6@stbi__tga_
  000b9	e9 b4 00 00 00	 jmp	 $errorEnd$13
$LN6@stbi__tga_:

; 5365 :         stbi__skip(s, 4);       // skip image x and y origin

  000be	ba 04 00 00 00	 mov	 edx, 4
  000c3	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ca	e8 00 00 00 00	 call	 stbi__skip

; 5366 :     }

  000cf	eb 2e		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5367 :     else { // "normal" image w/o colormap
; 5368 :         if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE

  000d1	83 7d 24 02	 cmp	 DWORD PTR sz$[rbp], 2
  000d5	74 17		 je	 SHORT $LN7@stbi__tga_
  000d7	83 7d 24 03	 cmp	 DWORD PTR sz$[rbp], 3
  000db	74 11		 je	 SHORT $LN7@stbi__tga_
  000dd	83 7d 24 0a	 cmp	 DWORD PTR sz$[rbp], 10
  000e1	74 0b		 je	 SHORT $LN7@stbi__tga_
  000e3	83 7d 24 0b	 cmp	 DWORD PTR sz$[rbp], 11
  000e7	74 05		 je	 SHORT $LN7@stbi__tga_
  000e9	e9 84 00 00 00	 jmp	 $errorEnd$13
$LN7@stbi__tga_:

; 5369 :         stbi__skip(s, 9); // skip colormap specification and image x/y origin

  000ee	ba 09 00 00 00	 mov	 edx, 9
  000f3	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000fa	e8 00 00 00 00	 call	 stbi__skip
$LN4@stbi__tga_:

; 5370 :     }
; 5371 :     if (stbi__get16le(s) < 1) goto errorEnd;      //   test width

  000ff	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00106	e8 00 00 00 00	 call	 stbi__get16le
  0010b	83 f8 01	 cmp	 eax, 1
  0010e	7d 02		 jge	 SHORT $LN8@stbi__tga_
  00110	eb 60		 jmp	 SHORT $errorEnd$13
$LN8@stbi__tga_:

; 5372 :     if (stbi__get16le(s) < 1) goto errorEnd;      //   test height

  00112	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00119	e8 00 00 00 00	 call	 stbi__get16le
  0011e	83 f8 01	 cmp	 eax, 1
  00121	7d 02		 jge	 SHORT $LN9@stbi__tga_
  00123	eb 4d		 jmp	 SHORT $errorEnd$13
$LN9@stbi__tga_:

; 5373 :     sz = stbi__get8(s);   //   bits per pixel

  00125	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0012c	e8 00 00 00 00	 call	 stbi__get8
  00131	0f b6 c0	 movzx	 eax, al
  00134	89 45 24	 mov	 DWORD PTR sz$[rbp], eax

; 5374 :     if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index

  00137	83 7d 44 01	 cmp	 DWORD PTR tga_color_type$[rbp], 1
  0013b	75 0e		 jne	 SHORT $LN10@stbi__tga_
  0013d	83 7d 24 08	 cmp	 DWORD PTR sz$[rbp], 8
  00141	74 08		 je	 SHORT $LN10@stbi__tga_
  00143	83 7d 24 10	 cmp	 DWORD PTR sz$[rbp], 16
  00147	74 02		 je	 SHORT $LN10@stbi__tga_
  00149	eb 27		 jmp	 SHORT $errorEnd$13
$LN10@stbi__tga_:

; 5375 :     if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

  0014b	83 7d 24 08	 cmp	 DWORD PTR sz$[rbp], 8
  0014f	74 1a		 je	 SHORT $LN11@stbi__tga_
  00151	83 7d 24 0f	 cmp	 DWORD PTR sz$[rbp], 15
  00155	74 14		 je	 SHORT $LN11@stbi__tga_
  00157	83 7d 24 10	 cmp	 DWORD PTR sz$[rbp], 16
  0015b	74 0e		 je	 SHORT $LN11@stbi__tga_
  0015d	83 7d 24 18	 cmp	 DWORD PTR sz$[rbp], 24
  00161	74 08		 je	 SHORT $LN11@stbi__tga_
  00163	83 7d 24 20	 cmp	 DWORD PTR sz$[rbp], 32	; 00000020H
  00167	74 02		 je	 SHORT $LN11@stbi__tga_
  00169	eb 07		 jmp	 SHORT $errorEnd$13
$LN11@stbi__tga_:

; 5376 : 
; 5377 :     res = 1; // if we got this far, everything's good and we can return 1 instead of 0

  0016b	c7 45 04 01 00
	00 00		 mov	 DWORD PTR res$[rbp], 1
$errorEnd$13:

; 5378 : 
; 5379 : errorEnd:
; 5380 :     stbi__rewind(s);

  00172	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00179	e8 00 00 00 00	 call	 stbi__rewind

; 5381 :     return res;

  0017e	8b 45 04	 mov	 eax, DWORD PTR res$[rbp]

; 5382 : }

  00181	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00188	5f		 pop	 rdi
  00189	5d		 pop	 rbp
  0018a	c3		 ret	 0
stbi__tga_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_info
_TEXT	SEGMENT
p$ = 8
info$ = 40
tv77 = 276
__$ArrayPad$ = 280
s$ = 320
x$ = 328
y$ = 336
comp$ = 344
stbi__bmp_info PROC					; COMDAT

; 6904 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 1a 00 00 00	 mov	 ecx, 26
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 18 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6905 :     void* p;
; 6906 :     stbi__bmp_data info;
; 6907 : 
; 6908 :     info.all_a = 255;

  00058	c7 45 44 ff 00
	00 00		 mov	 DWORD PTR info$[rbp+28], 255 ; 000000ffH

; 6909 :     p = stbi__bmp_parse_header(s, &info);

  0005f	48 8d 55 28	 lea	 rdx, QWORD PTR info$[rbp]
  00063	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__bmp_parse_header
  0006f	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax

; 6910 :     if (p == NULL) {

  00073	48 83 7d 08 00	 cmp	 QWORD PTR p$[rbp], 0
  00078	75 13		 jne	 SHORT $LN2@stbi__bmp_

; 6911 :         stbi__rewind(s);

  0007a	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00081	e8 00 00 00 00	 call	 stbi__rewind

; 6912 :         return 0;

  00086	33 c0		 xor	 eax, eax
  00088	e9 91 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 6913 :     }
; 6914 :     if (x) *x = s->img_x;

  0008d	48 83 bd 48 01
	00 00 00	 cmp	 QWORD PTR x$[rbp], 0
  00095	74 12		 je	 SHORT $LN3@stbi__bmp_
  00097	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  0009e	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000a5	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000a7	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@stbi__bmp_:

; 6915 :     if (y) *y = s->img_y;

  000a9	48 83 bd 50 01
	00 00 00	 cmp	 QWORD PTR y$[rbp], 0
  000b1	74 13		 je	 SHORT $LN4@stbi__bmp_
  000b3	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  000ba	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c1	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000c4	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__bmp_:

; 6916 :     if (comp) {

  000c6	48 83 bd 58 01
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  000ce	74 49		 je	 SHORT $LN5@stbi__bmp_

; 6917 :         if (info.bpp == 24 && info.ma == 0xff000000)

  000d0	83 7d 28 18	 cmp	 DWORD PTR info$[rbp], 24
  000d4	75 18		 jne	 SHORT $LN6@stbi__bmp_
  000d6	81 7d 40 00 00
	00 ff		 cmp	 DWORD PTR info$[rbp+24], -16777216 ; ff000000H
  000dd	75 0f		 jne	 SHORT $LN6@stbi__bmp_

; 6918 :             *comp = 3;

  000df	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  000e6	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
  000ec	eb 2b		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 6919 :         else
; 6920 :             *comp = info.ma ? 4 : 3;

  000ee	83 7d 40 00	 cmp	 DWORD PTR info$[rbp+24], 0
  000f2	74 0c		 je	 SHORT $LN9@stbi__bmp_
  000f4	c7 85 14 01 00
	00 04 00 00 00	 mov	 DWORD PTR tv77[rbp], 4
  000fe	eb 0a		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:
  00100	c7 85 14 01 00
	00 03 00 00 00	 mov	 DWORD PTR tv77[rbp], 3
$LN10@stbi__bmp_:
  0010a	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00111	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR tv77[rbp]
  00117	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 6921 :     }
; 6922 :     return 1;

  00119	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 6923 : }

  0011e	48 8b f8	 mov	 rdi, rax
  00121	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmp_info$rtcFrameData
  0012c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00131	48 8b c7	 mov	 rax, rdi
  00134	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0013b	48 33 cd	 xor	 rcx, rbp
  0013e	e8 00 00 00 00	 call	 __security_check_cookie
  00143	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0014a	5f		 pop	 rdi
  0014b	5d		 pop	 rbp
  0014c	c3		 ret	 0
stbi__bmp_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_load
_TEXT	SEGMENT
out$ = 8
mr$ = 36
mg$ = 68
mb$ = 100
ma$ = 132
all_a$ = 164
pal$ = 208
psize$ = 1252
i$ = 1284
j$ = 1316
width$ = 1348
flip_vertically$ = 1380
pad$ = 1412
target$ = 1444
info$ = 1480
bytes_read_so_far$5 = 1540
header_limit$6 = 1572
extra_data_limit$7 = 1604
z$8 = 1636
bit_offset$9 = 1668
v$10 = 1700
color$11 = 1732
v$12 = 1764
v2$13 = 1796
rshift$14 = 1828
gshift$15 = 1860
bshift$16 = 1892
ashift$17 = 1924
rcount$18 = 1956
gcount$19 = 1988
bcount$20 = 2020
acount$21 = 2052
z$22 = 2084
easy$23 = 2116
a$24 = 2148
bpp$25 = 2180
v$26 = 2212
a$27 = 2244
t$28 = 2276
p1$29 = 2312
p2$30 = 2344
tv562 = 3316
tv522 = 3316
tv505 = 3316
tv384 = 3316
tv257 = 3316
tv188 = 3316
tv70 = 3316
tv474 = 3320
tv445 = 3320
tv276 = 3320
tv223 = 3320
tv215 = 3320
tv203 = 3320
tv179 = 3320
tv172 = 3320
tv86 = 3320
tv80 = 3320
__$ArrayPad$ = 3328
s$ = 3376
x$ = 3384
y$ = 3392
comp$ = 3400
req_comp$ = 3408
ri$ = 3416
stbi__bmp_load PROC					; COMDAT

; 5056 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 0d
	00 00		 sub	 rsp, 3400		; 00000d48H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 56 02 00 00	 mov	 ecx, 598		; 00000256H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 68
	0d 00 00	 mov	 rcx, QWORD PTR [rsp+3432]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 00 0d
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5057 :     stbi_uc* out;
; 5058 :     unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;

  00058	c7 45 24 00 00
	00 00		 mov	 DWORD PTR mr$[rbp], 0
  0005f	c7 45 44 00 00
	00 00		 mov	 DWORD PTR mg$[rbp], 0
  00066	c7 45 64 00 00
	00 00		 mov	 DWORD PTR mb$[rbp], 0
  0006d	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR ma$[rbp], 0

; 5059 :     stbi_uc pal[256][4];
; 5060 :     int psize = 0, i, j, width;

  00077	c7 85 e4 04 00
	00 00 00 00 00	 mov	 DWORD PTR psize$[rbp], 0

; 5061 :     int flip_vertically, pad, target;
; 5062 :     stbi__bmp_data info;
; 5063 :     STBI_NOTUSED(ri);
; 5064 : 
; 5065 :     info.all_a = 255;

  00081	c7 85 e4 05 00
	00 ff 00 00 00	 mov	 DWORD PTR info$[rbp+28], 255 ; 000000ffH

; 5066 :     if (stbi__bmp_parse_header(s, &info) == NULL)

  0008b	48 8d 95 c8 05
	00 00		 lea	 rdx, QWORD PTR info$[rbp]
  00092	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00099	e8 00 00 00 00	 call	 stbi__bmp_parse_header
  0009e	48 85 c0	 test	 rax, rax
  000a1	75 07		 jne	 SHORT $LN35@stbi__bmp_

; 5067 :         return NULL; // error code already set

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 5c 12 00 00	 jmp	 $LN1@stbi__bmp_
$LN35@stbi__bmp_:

; 5068 : 
; 5069 :     flip_vertically = ((int)s->img_y) > 0;

  000aa	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  000b5	7e 0c		 jle	 SHORT $LN97@stbi__bmp_
  000b7	c7 85 f4 0c 00
	00 01 00 00 00	 mov	 DWORD PTR tv70[rbp], 1
  000c1	eb 0a		 jmp	 SHORT $LN98@stbi__bmp_
$LN97@stbi__bmp_:
  000c3	c7 85 f4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR tv70[rbp], 0
$LN98@stbi__bmp_:
  000cd	8b 85 f4 0c 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  000d3	89 85 64 05 00
	00		 mov	 DWORD PTR flip_vertically$[rbp], eax

; 5070 :     s->img_y = abs((int)s->img_y);

  000d9	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000e0	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000e3	e8 00 00 00 00	 call	 abs
  000e8	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000ef	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5071 : 
; 5072 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  000f2	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000f9	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00100	76 34		 jbe	 SHORT $LN36@stbi__bmp_
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00109	e8 00 00 00 00	 call	 stbi__err
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN99@stbi__bmp_
  00112	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv80[rbp], 0
  0011d	eb 0b		 jmp	 SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
  0011f	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv80[rbp], 0
$LN100@stbi__bmp_:
  0012a	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv80[rbp]
  00131	e9 d0 11 00 00	 jmp	 $LN1@stbi__bmp_
$LN36@stbi__bmp_:

; 5073 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

  00136	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0013d	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00143	76 34		 jbe	 SHORT $LN37@stbi__bmp_
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0014c	e8 00 00 00 00	 call	 stbi__err
  00151	85 c0		 test	 eax, eax
  00153	74 0d		 je	 SHORT $LN101@stbi__bmp_
  00155	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv86[rbp], 0
  00160	eb 0b		 jmp	 SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:
  00162	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv86[rbp], 0
$LN102@stbi__bmp_:
  0016d	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv86[rbp]
  00174	e9 8d 11 00 00	 jmp	 $LN1@stbi__bmp_
$LN37@stbi__bmp_:

; 5074 : 
; 5075 :     mr = info.mr;

  00179	8b 85 d4 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+12]
  0017f	89 45 24	 mov	 DWORD PTR mr$[rbp], eax

; 5076 :     mg = info.mg;

  00182	8b 85 d8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+16]
  00188	89 45 44	 mov	 DWORD PTR mg$[rbp], eax

; 5077 :     mb = info.mb;

  0018b	8b 85 dc 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+20]
  00191	89 45 64	 mov	 DWORD PTR mb$[rbp], eax

; 5078 :     ma = info.ma;

  00194	8b 85 e0 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+24]
  0019a	89 85 84 00 00
	00		 mov	 DWORD PTR ma$[rbp], eax

; 5079 :     all_a = info.all_a;

  001a0	8b 85 e4 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+28]
  001a6	89 85 a4 00 00
	00		 mov	 DWORD PTR all_a$[rbp], eax

; 5080 : 
; 5081 :     if (info.hsz == 12) {

  001ac	83 bd d0 05 00
	00 0c		 cmp	 DWORD PTR info$[rbp+8], 12
  001b3	75 2c		 jne	 SHORT $LN38@stbi__bmp_

; 5082 :         if (info.bpp < 24)

  001b5	83 bd c8 05 00
	00 18		 cmp	 DWORD PTR info$[rbp], 24
  001bc	7d 21		 jge	 SHORT $LN40@stbi__bmp_

; 5083 :             psize = (info.offset - info.extra_read - 24) / 3;

  001be	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+32]
  001c4	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  001ca	2b c8		 sub	 ecx, eax
  001cc	8b c1		 mov	 eax, ecx
  001ce	83 e8 18	 sub	 eax, 24
  001d1	99		 cdq
  001d2	b9 03 00 00 00	 mov	 ecx, 3
  001d7	f7 f9		 idiv	 ecx
  001d9	89 85 e4 04 00
	00		 mov	 DWORD PTR psize$[rbp], eax
$LN40@stbi__bmp_:

; 5084 :     }

  001df	eb 28		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:

; 5085 :     else {
; 5086 :         if (info.bpp < 16)

  001e1	83 bd c8 05 00
	00 10		 cmp	 DWORD PTR info$[rbp], 16
  001e8	7d 1f		 jge	 SHORT $LN41@stbi__bmp_

; 5087 :             psize = (info.offset - info.extra_read - info.hsz) >> 2;

  001ea	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+32]
  001f0	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  001f6	2b c8		 sub	 ecx, eax
  001f8	8b c1		 mov	 eax, ecx
  001fa	2b 85 d0 05 00
	00		 sub	 eax, DWORD PTR info$[rbp+8]
  00200	c1 f8 02	 sar	 eax, 2
  00203	89 85 e4 04 00
	00		 mov	 DWORD PTR psize$[rbp], eax
$LN41@stbi__bmp_:
$LN39@stbi__bmp_:

; 5088 :     }
; 5089 :     if (psize == 0) {

  00209	83 bd e4 04 00
	00 00		 cmp	 DWORD PTR psize$[rbp], 0
  00210	0f 85 0b 01 00
	00		 jne	 $LN42@stbi__bmp_

; 5090 :         // accept some number of extra bytes after the header, but if the offset points either to before
; 5091 :         // the header ends or implies a large amount of extra data, reject the file as malformed
; 5092 :         int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);

  00216	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0021d	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00224	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  0022b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00232	48 2b c1	 sub	 rax, rcx
  00235	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0023c	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  00242	89 85 04 06 00
	00		 mov	 DWORD PTR bytes_read_so_far$5[rbp], eax

; 5093 :         int header_limit = 1024; // max we actually read is below 256 bytes currently.

  00248	c7 85 24 06 00
	00 00 04 00 00	 mov	 DWORD PTR header_limit$6[rbp], 1024 ; 00000400H

; 5094 :         int extra_data_limit = 256 * 4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.

  00252	c7 85 44 06 00
	00 00 04 00 00	 mov	 DWORD PTR extra_data_limit$7[rbp], 1024 ; 00000400H

; 5095 :         if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {

  0025c	83 bd 04 06 00
	00 00		 cmp	 DWORD PTR bytes_read_so_far$5[rbp], 0
  00263	7e 0e		 jle	 SHORT $LN44@stbi__bmp_
  00265	8b 85 24 06 00
	00		 mov	 eax, DWORD PTR header_limit$6[rbp]
  0026b	39 85 04 06 00
	00		 cmp	 DWORD PTR bytes_read_so_far$5[rbp], eax
  00271	7e 34		 jle	 SHORT $LN43@stbi__bmp_
$LN44@stbi__bmp_:

; 5096 :             return stbi__errpuc("bad header", "Corrupt BMP");

  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PJHPAMCH@bad?5header@
  0027a	e8 00 00 00 00	 call	 stbi__err
  0027f	85 c0		 test	 eax, eax
  00281	74 0d		 je	 SHORT $LN103@stbi__bmp_
  00283	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv172[rbp], 0
  0028e	eb 0b		 jmp	 SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
  00290	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv172[rbp], 0
$LN104@stbi__bmp_:
  0029b	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv172[rbp]
  002a2	e9 5f 10 00 00	 jmp	 $LN1@stbi__bmp_
$LN43@stbi__bmp_:

; 5097 :         }
; 5098 :         // we established that bytes_read_so_far is positive and sensible.
; 5099 :         // the first half of this test rejects offsets that are either too small positives, or
; 5100 :         // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5101 :         // ensures the number computed in the second half of the test can't overflow.
; 5102 :         if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {

  002a7	8b 85 04 06 00
	00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rbp]
  002ad	39 85 cc 05 00
	00		 cmp	 DWORD PTR info$[rbp+4], eax
  002b3	7c 18		 jl	 SHORT $LN47@stbi__bmp_
  002b5	8b 85 04 06 00
	00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rbp]
  002bb	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  002c1	2b c8		 sub	 ecx, eax
  002c3	8b c1		 mov	 eax, ecx
  002c5	3b 85 44 06 00
	00		 cmp	 eax, DWORD PTR extra_data_limit$7[rbp]
  002cb	7e 36		 jle	 SHORT $LN45@stbi__bmp_
$LN47@stbi__bmp_:

; 5103 :             return stbi__errpuc("bad offset", "Corrupt BMP");

  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JDPIFELH@bad?5offset@
  002d4	e8 00 00 00 00	 call	 stbi__err
  002d9	85 c0		 test	 eax, eax
  002db	74 0d		 je	 SHORT $LN105@stbi__bmp_
  002dd	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv179[rbp], 0
  002e8	eb 0b		 jmp	 SHORT $LN106@stbi__bmp_
$LN105@stbi__bmp_:
  002ea	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv179[rbp], 0
$LN106@stbi__bmp_:
  002f5	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv179[rbp]
  002fc	e9 05 10 00 00	 jmp	 $LN1@stbi__bmp_

; 5104 :         }

  00301	eb 1e		 jmp	 SHORT $LN46@stbi__bmp_
$LN45@stbi__bmp_:

; 5105 :         else {
; 5106 :             stbi__skip(s, info.offset - bytes_read_so_far);

  00303	8b 85 04 06 00
	00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rbp]
  00309	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  0030f	2b c8		 sub	 ecx, eax
  00311	8b c1		 mov	 eax, ecx
  00313	8b d0		 mov	 edx, eax
  00315	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0031c	e8 00 00 00 00	 call	 stbi__skip
$LN46@stbi__bmp_:
$LN42@stbi__bmp_:

; 5107 :         }
; 5108 :     }
; 5109 : 
; 5110 :     if (info.bpp == 24 && ma == 0xff000000)

  00321	83 bd c8 05 00
	00 18		 cmp	 DWORD PTR info$[rbp], 24
  00328	75 1c		 jne	 SHORT $LN48@stbi__bmp_
  0032a	81 bd 84 00 00
	00 00 00 00 ff	 cmp	 DWORD PTR ma$[rbp], -16777216 ; ff000000H
  00334	75 10		 jne	 SHORT $LN48@stbi__bmp_

; 5111 :         s->img_n = 3;

  00336	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0033d	c7 40 08 03 00
	00 00		 mov	 DWORD PTR [rax+8], 3
  00344	eb 2f		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:

; 5112 :     else
; 5113 :         s->img_n = ma ? 4 : 3;

  00346	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR ma$[rbp], 0
  0034d	74 0c		 je	 SHORT $LN107@stbi__bmp_
  0034f	c7 85 f4 0c 00
	00 04 00 00 00	 mov	 DWORD PTR tv188[rbp], 4
  00359	eb 0a		 jmp	 SHORT $LN108@stbi__bmp_
$LN107@stbi__bmp_:
  0035b	c7 85 f4 0c 00
	00 03 00 00 00	 mov	 DWORD PTR tv188[rbp], 3
$LN108@stbi__bmp_:
  00365	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0036c	8b 8d f4 0c 00
	00		 mov	 ecx, DWORD PTR tv188[rbp]
  00372	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN49@stbi__bmp_:

; 5114 :     if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

  00375	83 bd 50 0d 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  0037c	74 17		 je	 SHORT $LN50@stbi__bmp_
  0037e	83 bd 50 0d 00
	00 03		 cmp	 DWORD PTR req_comp$[rbp], 3
  00385	7c 0e		 jl	 SHORT $LN50@stbi__bmp_

; 5115 :         target = req_comp;

  00387	8b 85 50 0d 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0038d	89 85 a4 05 00
	00		 mov	 DWORD PTR target$[rbp], eax
  00393	eb 10		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:

; 5116 :     else
; 5117 :         target = s->img_n; // if they want monochrome, we'll post-convert

  00395	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0039c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0039f	89 85 a4 05 00
	00		 mov	 DWORD PTR target$[rbp], eax
$LN51@stbi__bmp_:

; 5118 : 
; 5119 :     // sanity-check size
; 5120 :     if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

  003a5	45 33 c9	 xor	 r9d, r9d
  003a8	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  003af	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  003b3	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  003ba	8b 10		 mov	 edx, DWORD PTR [rax]
  003bc	8b 8d a4 05 00
	00		 mov	 ecx, DWORD PTR target$[rbp]
  003c2	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  003c7	85 c0		 test	 eax, eax
  003c9	75 34		 jne	 SHORT $LN52@stbi__bmp_

; 5121 :         return stbi__errpuc("too large", "Corrupt BMP");

  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  003d2	e8 00 00 00 00	 call	 stbi__err
  003d7	85 c0		 test	 eax, eax
  003d9	74 0d		 je	 SHORT $LN109@stbi__bmp_
  003db	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv203[rbp], 0
  003e6	eb 0b		 jmp	 SHORT $LN110@stbi__bmp_
$LN109@stbi__bmp_:
  003e8	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv203[rbp], 0
$LN110@stbi__bmp_:
  003f3	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv203[rbp]
  003fa	e9 07 0f 00 00	 jmp	 $LN1@stbi__bmp_
$LN52@stbi__bmp_:

; 5122 : 
; 5123 :     out = (stbi_uc*)stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

  003ff	45 33 c9	 xor	 r9d, r9d
  00402	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00409	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0040d	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00414	8b 10		 mov	 edx, DWORD PTR [rax]
  00416	8b 8d a4 05 00
	00		 mov	 ecx, DWORD PTR target$[rbp]
  0041c	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00421	48 89 45 08	 mov	 QWORD PTR out$[rbp], rax

; 5124 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  00425	48 83 7d 08 00	 cmp	 QWORD PTR out$[rbp], 0
  0042a	75 34		 jne	 SHORT $LN53@stbi__bmp_
  0042c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00433	e8 00 00 00 00	 call	 stbi__err
  00438	85 c0		 test	 eax, eax
  0043a	74 0d		 je	 SHORT $LN111@stbi__bmp_
  0043c	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv215[rbp], 0
  00447	eb 0b		 jmp	 SHORT $LN112@stbi__bmp_
$LN111@stbi__bmp_:
  00449	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv215[rbp], 0
$LN112@stbi__bmp_:
  00454	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv215[rbp]
  0045b	e9 a6 0e 00 00	 jmp	 $LN1@stbi__bmp_
$LN53@stbi__bmp_:

; 5125 :     if (info.bpp < 16) {

  00460	83 bd c8 05 00
	00 10		 cmp	 DWORD PTR info$[rbp], 16
  00467	0f 8d c8 06 00
	00		 jge	 $LN54@stbi__bmp_

; 5126 :         int z = 0;

  0046d	c7 85 64 06 00
	00 00 00 00 00	 mov	 DWORD PTR z$8[rbp], 0

; 5127 :         if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

  00477	83 bd e4 04 00
	00 00		 cmp	 DWORD PTR psize$[rbp], 0
  0047e	74 0c		 je	 SHORT $LN57@stbi__bmp_
  00480	81 bd e4 04 00
	00 00 01 00 00	 cmp	 DWORD PTR psize$[rbp], 256 ; 00000100H
  0048a	7e 3e		 jle	 SHORT $LN56@stbi__bmp_
$LN57@stbi__bmp_:
  0048c	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MALOAKCI@invalid@
  0049d	e8 00 00 00 00	 call	 stbi__err
  004a2	85 c0		 test	 eax, eax
  004a4	74 0d		 je	 SHORT $LN113@stbi__bmp_
  004a6	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv223[rbp], 0
  004b1	eb 0b		 jmp	 SHORT $LN114@stbi__bmp_
$LN113@stbi__bmp_:
  004b3	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv223[rbp], 0
$LN114@stbi__bmp_:
  004be	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv223[rbp]
  004c5	e9 3c 0e 00 00	 jmp	 $LN1@stbi__bmp_
$LN56@stbi__bmp_:

; 5128 :         for (i = 0; i < psize; ++i) {

  004ca	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  004d4	eb 0e		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  004d6	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  004dc	ff c0		 inc	 eax
  004de	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN4@stbi__bmp_:
  004e4	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR psize$[rbp]
  004ea	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  004f0	0f 8d ab 00 00
	00		 jge	 $LN3@stbi__bmp_

; 5129 :             pal[i][2] = stbi__get8(s);

  004f6	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  004fd	e8 00 00 00 00	 call	 stbi__get8
  00502	48 63 8d 04 05
	00 00		 movsxd	 rcx, DWORD PTR i$[rbp]
  00509	48 8d 8c 8d d0
	00 00 00	 lea	 rcx, QWORD PTR pal$[rbp+rcx*4]
  00511	ba 01 00 00 00	 mov	 edx, 1
  00516	48 6b d2 02	 imul	 rdx, rdx, 2
  0051a	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5130 :             pal[i][1] = stbi__get8(s);

  0051d	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00524	e8 00 00 00 00	 call	 stbi__get8
  00529	48 63 8d 04 05
	00 00		 movsxd	 rcx, DWORD PTR i$[rbp]
  00530	48 8d 8c 8d d0
	00 00 00	 lea	 rcx, QWORD PTR pal$[rbp+rcx*4]
  00538	ba 01 00 00 00	 mov	 edx, 1
  0053d	48 6b d2 01	 imul	 rdx, rdx, 1
  00541	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5131 :             pal[i][0] = stbi__get8(s);

  00544	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0054b	e8 00 00 00 00	 call	 stbi__get8
  00550	48 63 8d 04 05
	00 00		 movsxd	 rcx, DWORD PTR i$[rbp]
  00557	48 8d 8c 8d d0
	00 00 00	 lea	 rcx, QWORD PTR pal$[rbp+rcx*4]
  0055f	ba 01 00 00 00	 mov	 edx, 1
  00564	48 6b d2 00	 imul	 rdx, rdx, 0
  00568	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5132 :             if (info.hsz != 12) stbi__get8(s);

  0056b	83 bd d0 05 00
	00 0c		 cmp	 DWORD PTR info$[rbp+8], 12
  00572	74 0c		 je	 SHORT $LN58@stbi__bmp_
  00574	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0057b	e8 00 00 00 00	 call	 stbi__get8
$LN58@stbi__bmp_:

; 5133 :             pal[i][3] = 255;

  00580	48 63 85 04 05
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  00587	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  0058f	b9 01 00 00 00	 mov	 ecx, 1
  00594	48 6b c9 03	 imul	 rcx, rcx, 3
  00598	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 5134 :         }

  0059c	e9 35 ff ff ff	 jmp	 $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5135 :         stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

  005a1	83 bd d0 05 00
	00 0c		 cmp	 DWORD PTR info$[rbp+8], 12
  005a8	75 0c		 jne	 SHORT $LN115@stbi__bmp_
  005aa	c7 85 f4 0c 00
	00 03 00 00 00	 mov	 DWORD PTR tv257[rbp], 3
  005b4	eb 0a		 jmp	 SHORT $LN116@stbi__bmp_
$LN115@stbi__bmp_:
  005b6	c7 85 f4 0c 00
	00 04 00 00 00	 mov	 DWORD PTR tv257[rbp], 4
$LN116@stbi__bmp_:
  005c0	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+32]
  005c6	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  005cc	2b c8		 sub	 ecx, eax
  005ce	8b c1		 mov	 eax, ecx
  005d0	2b 85 d0 05 00
	00		 sub	 eax, DWORD PTR info$[rbp+8]
  005d6	8b 8d e4 04 00
	00		 mov	 ecx, DWORD PTR psize$[rbp]
  005dc	0f af 8d f4 0c
	00 00		 imul	 ecx, DWORD PTR tv257[rbp]
  005e3	2b c1		 sub	 eax, ecx
  005e5	8b d0		 mov	 edx, eax
  005e7	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  005ee	e8 00 00 00 00	 call	 stbi__skip

; 5136 :         if (info.bpp == 1) width = (s->img_x + 7) >> 3;

  005f3	83 bd c8 05 00
	00 01		 cmp	 DWORD PTR info$[rbp], 1
  005fa	75 17		 jne	 SHORT $LN59@stbi__bmp_
  005fc	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00603	8b 00		 mov	 eax, DWORD PTR [rax]
  00605	83 c0 07	 add	 eax, 7
  00608	c1 e8 03	 shr	 eax, 3
  0060b	89 85 44 05 00
	00		 mov	 DWORD PTR width$[rbp], eax
  00611	eb 76		 jmp	 SHORT $LN60@stbi__bmp_
$LN59@stbi__bmp_:

; 5137 :         else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

  00613	83 bd c8 05 00
	00 04		 cmp	 DWORD PTR info$[rbp], 4
  0061a	75 15		 jne	 SHORT $LN61@stbi__bmp_
  0061c	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00623	8b 00		 mov	 eax, DWORD PTR [rax]
  00625	ff c0		 inc	 eax
  00627	d1 e8		 shr	 eax, 1
  00629	89 85 44 05 00
	00		 mov	 DWORD PTR width$[rbp], eax
  0062f	eb 58		 jmp	 SHORT $LN62@stbi__bmp_
$LN61@stbi__bmp_:

; 5138 :         else if (info.bpp == 8) width = s->img_x;

  00631	83 bd c8 05 00
	00 08		 cmp	 DWORD PTR info$[rbp], 8
  00638	75 11		 jne	 SHORT $LN63@stbi__bmp_
  0063a	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00641	8b 00		 mov	 eax, DWORD PTR [rax]
  00643	89 85 44 05 00
	00		 mov	 DWORD PTR width$[rbp], eax
  00649	eb 3e		 jmp	 SHORT $LN64@stbi__bmp_
$LN63@stbi__bmp_:

; 5139 :         else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

  0064b	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  0064f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00655	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07JNJHIMGH@bad?5bpp@
  0065c	e8 00 00 00 00	 call	 stbi__err
  00661	85 c0		 test	 eax, eax
  00663	74 0d		 je	 SHORT $LN117@stbi__bmp_
  00665	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv276[rbp], 0
  00670	eb 0b		 jmp	 SHORT $LN118@stbi__bmp_
$LN117@stbi__bmp_:
  00672	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv276[rbp], 0
$LN118@stbi__bmp_:
  0067d	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv276[rbp]
  00684	e9 7d 0c 00 00	 jmp	 $LN1@stbi__bmp_
$LN64@stbi__bmp_:
$LN62@stbi__bmp_:
$LN60@stbi__bmp_:

; 5140 :         pad = (-width) & 3;

  00689	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  0068f	f7 d8		 neg	 eax
  00691	83 e0 03	 and	 eax, 3
  00694	89 85 84 05 00
	00		 mov	 DWORD PTR pad$[rbp], eax

; 5141 :         if (info.bpp == 1) {

  0069a	83 bd c8 05 00
	00 01		 cmp	 DWORD PTR info$[rbp], 1
  006a1	0f 85 d5 01 00
	00		 jne	 $LN65@stbi__bmp_

; 5142 :             for (j = 0; j < (int)s->img_y; ++j) {

  006a7	c7 85 24 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  006b1	eb 0e		 jmp	 SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
  006b3	8b 85 24 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  006b9	ff c0		 inc	 eax
  006bb	89 85 24 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN7@stbi__bmp_:
  006c1	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  006c8	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  006cb	39 85 24 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  006d1	0f 8d a0 01 00
	00		 jge	 $LN6@stbi__bmp_

; 5143 :                 int bit_offset = 7, v = stbi__get8(s);

  006d7	c7 85 84 06 00
	00 07 00 00 00	 mov	 DWORD PTR bit_offset$9[rbp], 7
  006e1	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  006e8	e8 00 00 00 00	 call	 stbi__get8
  006ed	0f b6 c0	 movzx	 eax, al
  006f0	89 85 a4 06 00
	00		 mov	 DWORD PTR v$10[rbp], eax

; 5144 :                 for (i = 0; i < (int)s->img_x; ++i) {

  006f6	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00700	eb 0e		 jmp	 SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
  00702	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00708	ff c0		 inc	 eax
  0070a	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN10@stbi__bmp_:
  00710	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00717	8b 00		 mov	 eax, DWORD PTR [rax]
  00719	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  0071f	0f 8d 3b 01 00
	00		 jge	 $LN9@stbi__bmp_

; 5145 :                     int color = (v >> bit_offset) & 0x1;

  00725	8b 85 84 06 00
	00		 mov	 eax, DWORD PTR bit_offset$9[rbp]
  0072b	0f b6 c8	 movzx	 ecx, al
  0072e	8b 85 a4 06 00
	00		 mov	 eax, DWORD PTR v$10[rbp]
  00734	d3 f8		 sar	 eax, cl
  00736	83 e0 01	 and	 eax, 1
  00739	89 85 c4 06 00
	00		 mov	 DWORD PTR color$11[rbp], eax

; 5146 :                     out[z++] = pal[color][0];

  0073f	48 63 85 c4 06
	00 00		 movsxd	 rax, DWORD PTR color$11[rbp]
  00746	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  0074e	b9 01 00 00 00	 mov	 ecx, 1
  00753	48 6b c9 00	 imul	 rcx, rcx, 0
  00757	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  0075e	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  00762	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00766	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0076a	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00770	ff c0		 inc	 eax
  00772	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5147 :                     out[z++] = pal[color][1];

  00778	48 63 85 c4 06
	00 00		 movsxd	 rax, DWORD PTR color$11[rbp]
  0077f	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  00787	b9 01 00 00 00	 mov	 ecx, 1
  0078c	48 6b c9 01	 imul	 rcx, rcx, 1
  00790	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  00797	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  0079b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0079f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  007a3	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  007a9	ff c0		 inc	 eax
  007ab	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5148 :                     out[z++] = pal[color][2];

  007b1	48 63 85 c4 06
	00 00		 movsxd	 rax, DWORD PTR color$11[rbp]
  007b8	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  007c0	b9 01 00 00 00	 mov	 ecx, 1
  007c5	48 6b c9 02	 imul	 rcx, rcx, 2
  007c9	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  007d0	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  007d4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007d8	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  007dc	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  007e2	ff c0		 inc	 eax
  007e4	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5149 :                     if (target == 4) out[z++] = 255;

  007ea	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  007f1	75 1d		 jne	 SHORT $LN67@stbi__bmp_
  007f3	48 63 85 64 06
	00 00		 movsxd	 rax, DWORD PTR z$8[rbp]
  007fa	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  007fe	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00802	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00808	ff c0		 inc	 eax
  0080a	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax
$LN67@stbi__bmp_:

; 5150 :                     if (i + 1 == (int)s->img_x) break;

  00810	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00816	ff c0		 inc	 eax
  00818	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0081f	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00821	75 02		 jne	 SHORT $LN68@stbi__bmp_
  00823	eb 3b		 jmp	 SHORT $LN9@stbi__bmp_
$LN68@stbi__bmp_:

; 5151 :                     if ((--bit_offset) < 0) {

  00825	8b 85 84 06 00
	00		 mov	 eax, DWORD PTR bit_offset$9[rbp]
  0082b	ff c8		 dec	 eax
  0082d	89 85 84 06 00
	00		 mov	 DWORD PTR bit_offset$9[rbp], eax
  00833	83 bd 84 06 00
	00 00		 cmp	 DWORD PTR bit_offset$9[rbp], 0
  0083a	7d 1f		 jge	 SHORT $LN69@stbi__bmp_

; 5152 :                         bit_offset = 7;

  0083c	c7 85 84 06 00
	00 07 00 00 00	 mov	 DWORD PTR bit_offset$9[rbp], 7

; 5153 :                         v = stbi__get8(s);

  00846	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0084d	e8 00 00 00 00	 call	 stbi__get8
  00852	0f b6 c0	 movzx	 eax, al
  00855	89 85 a4 06 00
	00		 mov	 DWORD PTR v$10[rbp], eax
$LN69@stbi__bmp_:

; 5154 :                     }
; 5155 :                 }

  0085b	e9 a2 fe ff ff	 jmp	 $LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 5156 :                 stbi__skip(s, pad);

  00860	8b 95 84 05 00
	00		 mov	 edx, DWORD PTR pad$[rbp]
  00866	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0086d	e8 00 00 00 00	 call	 stbi__skip

; 5157 :             }

  00872	e9 3c fe ff ff	 jmp	 $LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 5158 :         }

  00877	e9 b4 02 00 00	 jmp	 $LN66@stbi__bmp_
$LN65@stbi__bmp_:

; 5159 :         else {
; 5160 :             for (j = 0; j < (int)s->img_y; ++j) {

  0087c	c7 85 24 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  00886	eb 0e		 jmp	 SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
  00888	8b 85 24 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  0088e	ff c0		 inc	 eax
  00890	89 85 24 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN13@stbi__bmp_:
  00896	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0089d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  008a0	39 85 24 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  008a6	0f 8d 84 02 00
	00		 jge	 $LN12@stbi__bmp_

; 5161 :                 for (i = 0; i < (int)s->img_x; i += 2) {

  008ac	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  008b6	eb 0f		 jmp	 SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
  008b8	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  008be	83 c0 02	 add	 eax, 2
  008c1	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN16@stbi__bmp_:
  008c7	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  008ce	8b 00		 mov	 eax, DWORD PTR [rax]
  008d0	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  008d6	0f 8d 3d 02 00
	00		 jge	 $LN15@stbi__bmp_

; 5162 :                     int v = stbi__get8(s), v2 = 0;

  008dc	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  008e3	e8 00 00 00 00	 call	 stbi__get8
  008e8	0f b6 c0	 movzx	 eax, al
  008eb	89 85 e4 06 00
	00		 mov	 DWORD PTR v$12[rbp], eax
  008f1	c7 85 04 07 00
	00 00 00 00 00	 mov	 DWORD PTR v2$13[rbp], 0

; 5163 :                     if (info.bpp == 4) {

  008fb	83 bd c8 05 00
	00 04		 cmp	 DWORD PTR info$[rbp], 4
  00902	75 1e		 jne	 SHORT $LN70@stbi__bmp_

; 5164 :                         v2 = v & 15;

  00904	8b 85 e4 06 00
	00		 mov	 eax, DWORD PTR v$12[rbp]
  0090a	83 e0 0f	 and	 eax, 15
  0090d	89 85 04 07 00
	00		 mov	 DWORD PTR v2$13[rbp], eax

; 5165 :                         v >>= 4;

  00913	8b 85 e4 06 00
	00		 mov	 eax, DWORD PTR v$12[rbp]
  00919	c1 f8 04	 sar	 eax, 4
  0091c	89 85 e4 06 00
	00		 mov	 DWORD PTR v$12[rbp], eax
$LN70@stbi__bmp_:

; 5166 :                     }
; 5167 :                     out[z++] = pal[v][0];

  00922	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  00929	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  00931	b9 01 00 00 00	 mov	 ecx, 1
  00936	48 6b c9 00	 imul	 rcx, rcx, 0
  0093a	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  00941	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  00945	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00949	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0094d	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00953	ff c0		 inc	 eax
  00955	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5168 :                     out[z++] = pal[v][1];

  0095b	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  00962	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  0096a	b9 01 00 00 00	 mov	 ecx, 1
  0096f	48 6b c9 01	 imul	 rcx, rcx, 1
  00973	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  0097a	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  0097e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00982	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00986	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  0098c	ff c0		 inc	 eax
  0098e	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5169 :                     out[z++] = pal[v][2];

  00994	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  0099b	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  009a3	b9 01 00 00 00	 mov	 ecx, 1
  009a8	48 6b c9 02	 imul	 rcx, rcx, 2
  009ac	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  009b3	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  009b7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  009bb	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  009bf	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  009c5	ff c0		 inc	 eax
  009c7	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5170 :                     if (target == 4) out[z++] = 255;

  009cd	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  009d4	75 1d		 jne	 SHORT $LN71@stbi__bmp_
  009d6	48 63 85 64 06
	00 00		 movsxd	 rax, DWORD PTR z$8[rbp]
  009dd	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  009e1	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  009e5	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  009eb	ff c0		 inc	 eax
  009ed	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax
$LN71@stbi__bmp_:

; 5171 :                     if (i + 1 == (int)s->img_x) break;

  009f3	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  009f9	ff c0		 inc	 eax
  009fb	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00a02	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00a04	75 05		 jne	 SHORT $LN72@stbi__bmp_
  00a06	e9 0e 01 00 00	 jmp	 $LN15@stbi__bmp_
$LN72@stbi__bmp_:

; 5172 :                     v = (info.bpp == 8) ? stbi__get8(s) : v2;

  00a0b	83 bd c8 05 00
	00 08		 cmp	 DWORD PTR info$[rbp], 8
  00a12	75 17		 jne	 SHORT $LN119@stbi__bmp_
  00a14	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00a1b	e8 00 00 00 00	 call	 stbi__get8
  00a20	0f b6 c0	 movzx	 eax, al
  00a23	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv384[rbp], eax
  00a29	eb 0c		 jmp	 SHORT $LN120@stbi__bmp_
$LN119@stbi__bmp_:
  00a2b	8b 85 04 07 00
	00		 mov	 eax, DWORD PTR v2$13[rbp]
  00a31	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv384[rbp], eax
$LN120@stbi__bmp_:
  00a37	8b 85 f4 0c 00
	00		 mov	 eax, DWORD PTR tv384[rbp]
  00a3d	89 85 e4 06 00
	00		 mov	 DWORD PTR v$12[rbp], eax

; 5173 :                     out[z++] = pal[v][0];

  00a43	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  00a4a	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  00a52	b9 01 00 00 00	 mov	 ecx, 1
  00a57	48 6b c9 00	 imul	 rcx, rcx, 0
  00a5b	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  00a62	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  00a66	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a6a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00a6e	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00a74	ff c0		 inc	 eax
  00a76	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5174 :                     out[z++] = pal[v][1];

  00a7c	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  00a83	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  00a8b	b9 01 00 00 00	 mov	 ecx, 1
  00a90	48 6b c9 01	 imul	 rcx, rcx, 1
  00a94	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  00a9b	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  00a9f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00aa3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00aa7	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00aad	ff c0		 inc	 eax
  00aaf	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5175 :                     out[z++] = pal[v][2];

  00ab5	48 63 85 e4 06
	00 00		 movsxd	 rax, DWORD PTR v$12[rbp]
  00abc	48 8d 84 85 d0
	00 00 00	 lea	 rax, QWORD PTR pal$[rbp+rax*4]
  00ac4	b9 01 00 00 00	 mov	 ecx, 1
  00ac9	48 6b c9 02	 imul	 rcx, rcx, 2
  00acd	48 63 95 64 06
	00 00		 movsxd	 rdx, DWORD PTR z$8[rbp]
  00ad4	4c 8b 45 08	 mov	 r8, QWORD PTR out$[rbp]
  00ad8	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00adc	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00ae0	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00ae6	ff c0		 inc	 eax
  00ae8	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax

; 5176 :                     if (target == 4) out[z++] = 255;

  00aee	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  00af5	75 1d		 jne	 SHORT $LN73@stbi__bmp_
  00af7	48 63 85 64 06
	00 00		 movsxd	 rax, DWORD PTR z$8[rbp]
  00afe	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00b02	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00b06	8b 85 64 06 00
	00		 mov	 eax, DWORD PTR z$8[rbp]
  00b0c	ff c0		 inc	 eax
  00b0e	89 85 64 06 00
	00		 mov	 DWORD PTR z$8[rbp], eax
$LN73@stbi__bmp_:

; 5177 :                 }

  00b14	e9 9f fd ff ff	 jmp	 $LN14@stbi__bmp_
$LN15@stbi__bmp_:

; 5178 :                 stbi__skip(s, pad);

  00b19	8b 95 84 05 00
	00		 mov	 edx, DWORD PTR pad$[rbp]
  00b1f	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00b26	e8 00 00 00 00	 call	 stbi__skip

; 5179 :             }

  00b2b	e9 58 fd ff ff	 jmp	 $LN11@stbi__bmp_
$LN12@stbi__bmp_:
$LN66@stbi__bmp_:

; 5180 :         }
; 5181 :     }

  00b30	e9 ab 05 00 00	 jmp	 $LN55@stbi__bmp_
$LN54@stbi__bmp_:

; 5182 :     else {
; 5183 :         int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;

  00b35	c7 85 24 07 00
	00 00 00 00 00	 mov	 DWORD PTR rshift$14[rbp], 0
  00b3f	c7 85 44 07 00
	00 00 00 00 00	 mov	 DWORD PTR gshift$15[rbp], 0
  00b49	c7 85 64 07 00
	00 00 00 00 00	 mov	 DWORD PTR bshift$16[rbp], 0
  00b53	c7 85 84 07 00
	00 00 00 00 00	 mov	 DWORD PTR ashift$17[rbp], 0
  00b5d	c7 85 a4 07 00
	00 00 00 00 00	 mov	 DWORD PTR rcount$18[rbp], 0
  00b67	c7 85 c4 07 00
	00 00 00 00 00	 mov	 DWORD PTR gcount$19[rbp], 0
  00b71	c7 85 e4 07 00
	00 00 00 00 00	 mov	 DWORD PTR bcount$20[rbp], 0
  00b7b	c7 85 04 08 00
	00 00 00 00 00	 mov	 DWORD PTR acount$21[rbp], 0

; 5184 :         int z = 0;

  00b85	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR z$22[rbp], 0

; 5185 :         int easy = 0;

  00b8f	c7 85 44 08 00
	00 00 00 00 00	 mov	 DWORD PTR easy$23[rbp], 0

; 5186 :         stbi__skip(s, info.offset - info.extra_read - info.hsz);

  00b99	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp+32]
  00b9f	8b 8d cc 05 00
	00		 mov	 ecx, DWORD PTR info$[rbp+4]
  00ba5	2b c8		 sub	 ecx, eax
  00ba7	8b c1		 mov	 eax, ecx
  00ba9	2b 85 d0 05 00
	00		 sub	 eax, DWORD PTR info$[rbp+8]
  00baf	8b d0		 mov	 edx, eax
  00bb1	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00bb8	e8 00 00 00 00	 call	 stbi__skip

; 5187 :         if (info.bpp == 24) width = 3 * s->img_x;

  00bbd	83 bd c8 05 00
	00 18		 cmp	 DWORD PTR info$[rbp], 24
  00bc4	75 12		 jne	 SHORT $LN74@stbi__bmp_
  00bc6	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00bcd	6b 00 03	 imul	 eax, DWORD PTR [rax], 3
  00bd0	89 85 44 05 00
	00		 mov	 DWORD PTR width$[rbp], eax
  00bd6	eb 26		 jmp	 SHORT $LN75@stbi__bmp_
$LN74@stbi__bmp_:

; 5188 :         else if (info.bpp == 16) width = 2 * s->img_x;

  00bd8	83 bd c8 05 00
	00 10		 cmp	 DWORD PTR info$[rbp], 16
  00bdf	75 13		 jne	 SHORT $LN76@stbi__bmp_
  00be1	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00be8	8b 00		 mov	 eax, DWORD PTR [rax]
  00bea	d1 e0		 shl	 eax, 1
  00bec	89 85 44 05 00
	00		 mov	 DWORD PTR width$[rbp], eax
  00bf2	eb 0a		 jmp	 SHORT $LN77@stbi__bmp_
$LN76@stbi__bmp_:

; 5189 :         else /* bpp = 32 and pad = 0 */ width = 0;

  00bf4	c7 85 44 05 00
	00 00 00 00 00	 mov	 DWORD PTR width$[rbp], 0
$LN77@stbi__bmp_:
$LN75@stbi__bmp_:

; 5190 :         pad = (-width) & 3;

  00bfe	8b 85 44 05 00
	00		 mov	 eax, DWORD PTR width$[rbp]
  00c04	f7 d8		 neg	 eax
  00c06	83 e0 03	 and	 eax, 3
  00c09	89 85 84 05 00
	00		 mov	 DWORD PTR pad$[rbp], eax

; 5191 :         if (info.bpp == 24) {

  00c0f	83 bd c8 05 00
	00 18		 cmp	 DWORD PTR info$[rbp], 24
  00c16	75 0c		 jne	 SHORT $LN78@stbi__bmp_

; 5192 :             easy = 1;

  00c18	c7 85 44 08 00
	00 01 00 00 00	 mov	 DWORD PTR easy$23[rbp], 1

; 5193 :         }

  00c22	eb 3a		 jmp	 SHORT $LN79@stbi__bmp_
$LN78@stbi__bmp_:

; 5194 :         else if (info.bpp == 32) {

  00c24	83 bd c8 05 00
	00 20		 cmp	 DWORD PTR info$[rbp], 32 ; 00000020H
  00c2b	75 31		 jne	 SHORT $LN80@stbi__bmp_

; 5195 :             if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

  00c2d	81 7d 64 ff 00
	00 00		 cmp	 DWORD PTR mb$[rbp], 255	; 000000ffH
  00c34	75 28		 jne	 SHORT $LN81@stbi__bmp_
  00c36	81 7d 44 00 ff
	00 00		 cmp	 DWORD PTR mg$[rbp], 65280 ; 0000ff00H
  00c3d	75 1f		 jne	 SHORT $LN81@stbi__bmp_
  00c3f	81 7d 24 00 00
	ff 00		 cmp	 DWORD PTR mr$[rbp], 16711680 ; 00ff0000H
  00c46	75 16		 jne	 SHORT $LN81@stbi__bmp_
  00c48	81 bd 84 00 00
	00 00 00 00 ff	 cmp	 DWORD PTR ma$[rbp], -16777216 ; ff000000H
  00c52	75 0a		 jne	 SHORT $LN81@stbi__bmp_

; 5196 :                 easy = 2;

  00c54	c7 85 44 08 00
	00 02 00 00 00	 mov	 DWORD PTR easy$23[rbp], 2
$LN81@stbi__bmp_:
$LN80@stbi__bmp_:
$LN79@stbi__bmp_:

; 5197 :         }
; 5198 :         if (!easy) {

  00c5e	83 bd 44 08 00
	00 00		 cmp	 DWORD PTR easy$23[rbp], 0
  00c65	0f 85 34 01 00
	00		 jne	 $LN82@stbi__bmp_

; 5199 :             if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00c6b	83 7d 24 00	 cmp	 DWORD PTR mr$[rbp], 0
  00c6f	74 0c		 je	 SHORT $LN84@stbi__bmp_
  00c71	83 7d 44 00	 cmp	 DWORD PTR mg$[rbp], 0
  00c75	74 06		 je	 SHORT $LN84@stbi__bmp_
  00c77	83 7d 64 00	 cmp	 DWORD PTR mb$[rbp], 0
  00c7b	75 3e		 jne	 SHORT $LN83@stbi__bmp_
$LN84@stbi__bmp_:
  00c7d	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00c81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00c87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DAEBACAB@bad?5masks@
  00c8e	e8 00 00 00 00	 call	 stbi__err
  00c93	85 c0		 test	 eax, eax
  00c95	74 0d		 je	 SHORT $LN121@stbi__bmp_
  00c97	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv445[rbp], 0
  00ca2	eb 0b		 jmp	 SHORT $LN122@stbi__bmp_
$LN121@stbi__bmp_:
  00ca4	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv445[rbp], 0
$LN122@stbi__bmp_:
  00caf	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv445[rbp]
  00cb6	e9 4b 06 00 00	 jmp	 $LN1@stbi__bmp_
$LN83@stbi__bmp_:

; 5200 :             // right shift amt to put high bit in position #7
; 5201 :             rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);

  00cbb	8b 4d 24	 mov	 ecx, DWORD PTR mr$[rbp]
  00cbe	e8 00 00 00 00	 call	 stbi__high_bit
  00cc3	83 e8 07	 sub	 eax, 7
  00cc6	89 85 24 07 00
	00		 mov	 DWORD PTR rshift$14[rbp], eax
  00ccc	8b 4d 24	 mov	 ecx, DWORD PTR mr$[rbp]
  00ccf	e8 00 00 00 00	 call	 stbi__bitcount
  00cd4	89 85 a4 07 00
	00		 mov	 DWORD PTR rcount$18[rbp], eax

; 5202 :             gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);

  00cda	8b 4d 44	 mov	 ecx, DWORD PTR mg$[rbp]
  00cdd	e8 00 00 00 00	 call	 stbi__high_bit
  00ce2	83 e8 07	 sub	 eax, 7
  00ce5	89 85 44 07 00
	00		 mov	 DWORD PTR gshift$15[rbp], eax
  00ceb	8b 4d 44	 mov	 ecx, DWORD PTR mg$[rbp]
  00cee	e8 00 00 00 00	 call	 stbi__bitcount
  00cf3	89 85 c4 07 00
	00		 mov	 DWORD PTR gcount$19[rbp], eax

; 5203 :             bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);

  00cf9	8b 4d 64	 mov	 ecx, DWORD PTR mb$[rbp]
  00cfc	e8 00 00 00 00	 call	 stbi__high_bit
  00d01	83 e8 07	 sub	 eax, 7
  00d04	89 85 64 07 00
	00		 mov	 DWORD PTR bshift$16[rbp], eax
  00d0a	8b 4d 64	 mov	 ecx, DWORD PTR mb$[rbp]
  00d0d	e8 00 00 00 00	 call	 stbi__bitcount
  00d12	89 85 e4 07 00
	00		 mov	 DWORD PTR bcount$20[rbp], eax

; 5204 :             ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);

  00d18	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR ma$[rbp]
  00d1e	e8 00 00 00 00	 call	 stbi__high_bit
  00d23	83 e8 07	 sub	 eax, 7
  00d26	89 85 84 07 00
	00		 mov	 DWORD PTR ashift$17[rbp], eax
  00d2c	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR ma$[rbp]
  00d32	e8 00 00 00 00	 call	 stbi__bitcount
  00d37	89 85 04 08 00
	00		 mov	 DWORD PTR acount$21[rbp], eax

; 5205 :             if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00d3d	83 bd a4 07 00
	00 08		 cmp	 DWORD PTR rcount$18[rbp], 8
  00d44	7f 1b		 jg	 SHORT $LN86@stbi__bmp_
  00d46	83 bd c4 07 00
	00 08		 cmp	 DWORD PTR gcount$19[rbp], 8
  00d4d	7f 12		 jg	 SHORT $LN86@stbi__bmp_
  00d4f	83 bd e4 07 00
	00 08		 cmp	 DWORD PTR bcount$20[rbp], 8
  00d56	7f 09		 jg	 SHORT $LN86@stbi__bmp_
  00d58	83 bd 04 08 00
	00 08		 cmp	 DWORD PTR acount$21[rbp], 8
  00d5f	7e 3e		 jle	 SHORT $LN85@stbi__bmp_
$LN86@stbi__bmp_:
  00d61	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00d65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00d6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DAEBACAB@bad?5masks@
  00d72	e8 00 00 00 00	 call	 stbi__err
  00d77	85 c0		 test	 eax, eax
  00d79	74 0d		 je	 SHORT $LN123@stbi__bmp_
  00d7b	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv474[rbp], 0
  00d86	eb 0b		 jmp	 SHORT $LN124@stbi__bmp_
$LN123@stbi__bmp_:
  00d88	48 c7 85 f8 0c
	00 00 00 00 00
	00		 mov	 QWORD PTR tv474[rbp], 0
$LN124@stbi__bmp_:
  00d93	48 8b 85 f8 0c
	00 00		 mov	 rax, QWORD PTR tv474[rbp]
  00d9a	e9 67 05 00 00	 jmp	 $LN1@stbi__bmp_
$LN85@stbi__bmp_:
$LN82@stbi__bmp_:

; 5206 :         }
; 5207 :         for (j = 0; j < (int)s->img_y; ++j) {

  00d9f	c7 85 24 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  00da9	eb 0e		 jmp	 SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
  00dab	8b 85 24 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  00db1	ff c0		 inc	 eax
  00db3	89 85 24 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN19@stbi__bmp_:
  00db9	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00dc0	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00dc3	39 85 24 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  00dc9	0f 8d 11 03 00
	00		 jge	 $LN18@stbi__bmp_

; 5208 :             if (easy) {

  00dcf	83 bd 44 08 00
	00 00		 cmp	 DWORD PTR easy$23[rbp], 0
  00dd6	0f 84 1b 01 00
	00		 je	 $LN87@stbi__bmp_

; 5209 :                 for (i = 0; i < (int)s->img_x; ++i) {

  00ddc	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00de6	eb 0e		 jmp	 SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
  00de8	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00dee	ff c0		 inc	 eax
  00df0	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN22@stbi__bmp_:
  00df6	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00dfd	8b 00		 mov	 eax, DWORD PTR [rax]
  00dff	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00e05	0f 8d e7 00 00
	00		 jge	 $LN21@stbi__bmp_

; 5210 :                     unsigned char a;
; 5211 :                     out[z + 2] = stbi__get8(s);

  00e0b	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e12	e8 00 00 00 00	 call	 stbi__get8
  00e17	8b 8d 24 08 00
	00		 mov	 ecx, DWORD PTR z$22[rbp]
  00e1d	83 c1 02	 add	 ecx, 2
  00e20	48 63 c9	 movsxd	 rcx, ecx
  00e23	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00e27	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5212 :                     out[z + 1] = stbi__get8(s);

  00e2a	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e31	e8 00 00 00 00	 call	 stbi__get8
  00e36	8b 8d 24 08 00
	00		 mov	 ecx, DWORD PTR z$22[rbp]
  00e3c	ff c1		 inc	 ecx
  00e3e	48 63 c9	 movsxd	 rcx, ecx
  00e41	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00e45	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5213 :                     out[z + 0] = stbi__get8(s);

  00e48	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e4f	e8 00 00 00 00	 call	 stbi__get8
  00e54	8b 8d 24 08 00
	00		 mov	 ecx, DWORD PTR z$22[rbp]
  00e5a	48 63 c9	 movsxd	 rcx, ecx
  00e5d	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00e61	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5214 :                     z += 3;

  00e64	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  00e6a	83 c0 03	 add	 eax, 3
  00e6d	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax

; 5215 :                     a = (easy == 2 ? stbi__get8(s) : 255);

  00e73	83 bd 44 08 00
	00 02		 cmp	 DWORD PTR easy$23[rbp], 2
  00e7a	75 17		 jne	 SHORT $LN125@stbi__bmp_
  00e7c	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00e83	e8 00 00 00 00	 call	 stbi__get8
  00e88	0f b6 c0	 movzx	 eax, al
  00e8b	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv505[rbp], eax
  00e91	eb 0a		 jmp	 SHORT $LN126@stbi__bmp_
$LN125@stbi__bmp_:
  00e93	c7 85 f4 0c 00
	00 ff 00 00 00	 mov	 DWORD PTR tv505[rbp], 255 ; 000000ffH
$LN126@stbi__bmp_:
  00e9d	0f b6 85 f4 0c
	00 00		 movzx	 eax, BYTE PTR tv505[rbp]
  00ea4	88 85 64 08 00
	00		 mov	 BYTE PTR a$24[rbp], al

; 5216 :                     all_a |= a;

  00eaa	0f b6 85 64 08
	00 00		 movzx	 eax, BYTE PTR a$24[rbp]
  00eb1	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR all_a$[rbp]
  00eb7	0b c8		 or	 ecx, eax
  00eb9	8b c1		 mov	 eax, ecx
  00ebb	89 85 a4 00 00
	00		 mov	 DWORD PTR all_a$[rbp], eax

; 5217 :                     if (target == 4) out[z++] = a;

  00ec1	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  00ec8	75 23		 jne	 SHORT $LN89@stbi__bmp_
  00eca	48 63 85 24 08
	00 00		 movsxd	 rax, DWORD PTR z$22[rbp]
  00ed1	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  00ed5	0f b6 95 64 08
	00 00		 movzx	 edx, BYTE PTR a$24[rbp]
  00edc	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00edf	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  00ee5	ff c0		 inc	 eax
  00ee7	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax
$LN89@stbi__bmp_:

; 5218 :                 }

  00eed	e9 f6 fe ff ff	 jmp	 $LN20@stbi__bmp_
$LN21@stbi__bmp_:

; 5219 :             }

  00ef2	e9 d2 01 00 00	 jmp	 $LN88@stbi__bmp_
$LN87@stbi__bmp_:

; 5220 :             else {
; 5221 :                 int bpp = info.bpp;

  00ef7	8b 85 c8 05 00
	00		 mov	 eax, DWORD PTR info$[rbp]
  00efd	89 85 84 08 00
	00		 mov	 DWORD PTR bpp$25[rbp], eax

; 5222 :                 for (i = 0; i < (int)s->img_x; ++i) {

  00f03	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  00f0d	eb 0e		 jmp	 SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
  00f0f	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  00f15	ff c0		 inc	 eax
  00f17	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN25@stbi__bmp_:
  00f1d	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00f24	8b 00		 mov	 eax, DWORD PTR [rax]
  00f26	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00f2c	0f 8d 97 01 00
	00		 jge	 $LN24@stbi__bmp_

; 5223 :                     stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));

  00f32	83 bd 84 08 00
	00 10		 cmp	 DWORD PTR bpp$25[rbp], 16
  00f39	75 14		 jne	 SHORT $LN127@stbi__bmp_
  00f3b	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00f42	e8 00 00 00 00	 call	 stbi__get16le
  00f47	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv522[rbp], eax
  00f4d	eb 12		 jmp	 SHORT $LN128@stbi__bmp_
$LN127@stbi__bmp_:
  00f4f	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00f56	e8 00 00 00 00	 call	 stbi__get32le
  00f5b	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv522[rbp], eax
$LN128@stbi__bmp_:
  00f61	8b 85 f4 0c 00
	00		 mov	 eax, DWORD PTR tv522[rbp]
  00f67	89 85 a4 08 00
	00		 mov	 DWORD PTR v$26[rbp], eax

; 5224 :                     unsigned int a;
; 5225 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

  00f6d	8b 45 24	 mov	 eax, DWORD PTR mr$[rbp]
  00f70	8b 8d a4 08 00
	00		 mov	 ecx, DWORD PTR v$26[rbp]
  00f76	23 c8		 and	 ecx, eax
  00f78	8b c1		 mov	 eax, ecx
  00f7a	44 8b 85 a4 07
	00 00		 mov	 r8d, DWORD PTR rcount$18[rbp]
  00f81	8b 95 24 07 00
	00		 mov	 edx, DWORD PTR rshift$14[rbp]
  00f87	8b c8		 mov	 ecx, eax
  00f89	e8 00 00 00 00	 call	 stbi__shiftsigned
  00f8e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f93	48 63 8d 24 08
	00 00		 movsxd	 rcx, DWORD PTR z$22[rbp]
  00f9a	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00f9e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00fa1	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  00fa7	ff c0		 inc	 eax
  00fa9	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax

; 5226 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

  00faf	8b 45 44	 mov	 eax, DWORD PTR mg$[rbp]
  00fb2	8b 8d a4 08 00
	00		 mov	 ecx, DWORD PTR v$26[rbp]
  00fb8	23 c8		 and	 ecx, eax
  00fba	8b c1		 mov	 eax, ecx
  00fbc	44 8b 85 c4 07
	00 00		 mov	 r8d, DWORD PTR gcount$19[rbp]
  00fc3	8b 95 44 07 00
	00		 mov	 edx, DWORD PTR gshift$15[rbp]
  00fc9	8b c8		 mov	 ecx, eax
  00fcb	e8 00 00 00 00	 call	 stbi__shiftsigned
  00fd0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fd5	48 63 8d 24 08
	00 00		 movsxd	 rcx, DWORD PTR z$22[rbp]
  00fdc	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  00fe0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00fe3	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  00fe9	ff c0		 inc	 eax
  00feb	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax

; 5227 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

  00ff1	8b 45 64	 mov	 eax, DWORD PTR mb$[rbp]
  00ff4	8b 8d a4 08 00
	00		 mov	 ecx, DWORD PTR v$26[rbp]
  00ffa	23 c8		 and	 ecx, eax
  00ffc	8b c1		 mov	 eax, ecx
  00ffe	44 8b 85 e4 07
	00 00		 mov	 r8d, DWORD PTR bcount$20[rbp]
  01005	8b 95 64 07 00
	00		 mov	 edx, DWORD PTR bshift$16[rbp]
  0100b	8b c8		 mov	 ecx, eax
  0100d	e8 00 00 00 00	 call	 stbi__shiftsigned
  01012	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01017	48 63 8d 24 08
	00 00		 movsxd	 rcx, DWORD PTR z$22[rbp]
  0101e	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  01022	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01025	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  0102b	ff c0		 inc	 eax
  0102d	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax

; 5228 :                     a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

  01033	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR ma$[rbp], 0
  0103a	74 2c		 je	 SHORT $LN129@stbi__bmp_
  0103c	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR ma$[rbp]
  01042	8b 8d a4 08 00
	00		 mov	 ecx, DWORD PTR v$26[rbp]
  01048	23 c8		 and	 ecx, eax
  0104a	8b c1		 mov	 eax, ecx
  0104c	44 8b 85 04 08
	00 00		 mov	 r8d, DWORD PTR acount$21[rbp]
  01053	8b 95 84 07 00
	00		 mov	 edx, DWORD PTR ashift$17[rbp]
  01059	8b c8		 mov	 ecx, eax
  0105b	e8 00 00 00 00	 call	 stbi__shiftsigned
  01060	89 85 f4 0c 00
	00		 mov	 DWORD PTR tv562[rbp], eax
  01066	eb 0a		 jmp	 SHORT $LN130@stbi__bmp_
$LN129@stbi__bmp_:
  01068	c7 85 f4 0c 00
	00 ff 00 00 00	 mov	 DWORD PTR tv562[rbp], 255 ; 000000ffH
$LN130@stbi__bmp_:
  01072	8b 85 f4 0c 00
	00		 mov	 eax, DWORD PTR tv562[rbp]
  01078	89 85 c4 08 00
	00		 mov	 DWORD PTR a$27[rbp], eax

; 5229 :                     all_a |= a;

  0107e	8b 85 c4 08 00
	00		 mov	 eax, DWORD PTR a$27[rbp]
  01084	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR all_a$[rbp]
  0108a	0b c8		 or	 ecx, eax
  0108c	8b c1		 mov	 eax, ecx
  0108e	89 85 a4 00 00
	00		 mov	 DWORD PTR all_a$[rbp], eax

; 5230 :                     if (target == 4) out[z++] = STBI__BYTECAST(a);

  01094	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  0109b	75 27		 jne	 SHORT $LN90@stbi__bmp_
  0109d	8b 85 c4 08 00
	00		 mov	 eax, DWORD PTR a$27[rbp]
  010a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  010a8	48 63 8d 24 08
	00 00		 movsxd	 rcx, DWORD PTR z$22[rbp]
  010af	48 8b 55 08	 mov	 rdx, QWORD PTR out$[rbp]
  010b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  010b6	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR z$22[rbp]
  010bc	ff c0		 inc	 eax
  010be	89 85 24 08 00
	00		 mov	 DWORD PTR z$22[rbp], eax
$LN90@stbi__bmp_:

; 5231 :                 }

  010c4	e9 46 fe ff ff	 jmp	 $LN23@stbi__bmp_
$LN24@stbi__bmp_:
$LN88@stbi__bmp_:

; 5232 :             }
; 5233 :             stbi__skip(s, pad);

  010c9	8b 95 84 05 00
	00		 mov	 edx, DWORD PTR pad$[rbp]
  010cf	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  010d6	e8 00 00 00 00	 call	 stbi__skip

; 5234 :         }

  010db	e9 cb fc ff ff	 jmp	 $LN17@stbi__bmp_
$LN18@stbi__bmp_:
$LN55@stbi__bmp_:

; 5235 :     }
; 5236 : 
; 5237 :     // if alpha channel is all 0s, replace with all 255s
; 5238 :     if (target == 4 && all_a == 0)

  010e0	83 bd a4 05 00
	00 04		 cmp	 DWORD PTR target$[rbp], 4
  010e7	75 53		 jne	 SHORT $LN91@stbi__bmp_
  010e9	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR all_a$[rbp], 0
  010f0	75 4a		 jne	 SHORT $LN91@stbi__bmp_

; 5239 :         for (i = 4 * s->img_x * s->img_y - 1; i >= 0; i -= 4)

  010f2	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  010f9	8b 00		 mov	 eax, DWORD PTR [rax]
  010fb	c1 e0 02	 shl	 eax, 2
  010fe	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  01105	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  01109	ff c8		 dec	 eax
  0110b	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
  01111	eb 0f		 jmp	 SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
  01113	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  01119	83 e8 04	 sub	 eax, 4
  0111c	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN28@stbi__bmp_:
  01122	83 bd 04 05 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  01129	7c 11		 jl	 SHORT $LN27@stbi__bmp_

; 5240 :             out[i] = 255;

  0112b	48 63 85 04 05
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  01132	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  01136	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0113a	eb d7		 jmp	 SHORT $LN26@stbi__bmp_
$LN27@stbi__bmp_:
$LN91@stbi__bmp_:

; 5241 : 
; 5242 :     if (flip_vertically) {

  0113c	83 bd 64 05 00
	00 00		 cmp	 DWORD PTR flip_vertically$[rbp], 0
  01143	0f 84 21 01 00
	00		 je	 $LN92@stbi__bmp_

; 5243 :         stbi_uc t;
; 5244 :         for (j = 0; j < (int)s->img_y >> 1; ++j) {

  01149	c7 85 24 05 00
	00 00 00 00 00	 mov	 DWORD PTR j$[rbp], 0
  01153	eb 0e		 jmp	 SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
  01155	8b 85 24 05 00
	00		 mov	 eax, DWORD PTR j$[rbp]
  0115b	ff c0		 inc	 eax
  0115d	89 85 24 05 00
	00		 mov	 DWORD PTR j$[rbp], eax
$LN31@stbi__bmp_:
  01163	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0116a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0116d	d1 f8		 sar	 eax, 1
  0116f	39 85 24 05 00
	00		 cmp	 DWORD PTR j$[rbp], eax
  01175	0f 8d ef 00 00
	00		 jge	 $LN30@stbi__bmp_

; 5245 :             stbi_uc* p1 = out + j * s->img_x * target;

  0117b	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  01182	8b 8d 24 05 00
	00		 mov	 ecx, DWORD PTR j$[rbp]
  01188	0f af 08	 imul	 ecx, DWORD PTR [rax]
  0118b	8b c1		 mov	 eax, ecx
  0118d	0f af 85 a4 05
	00 00		 imul	 eax, DWORD PTR target$[rbp]
  01194	8b c0		 mov	 eax, eax
  01196	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  0119a	48 03 c8	 add	 rcx, rax
  0119d	48 8b c1	 mov	 rax, rcx
  011a0	48 89 85 08 09
	00 00		 mov	 QWORD PTR p1$29[rbp], rax

; 5246 :             stbi_uc* p2 = out + (s->img_y - 1 - j) * s->img_x * target;

  011a7	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  011ae	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  011b1	ff c8		 dec	 eax
  011b3	2b 85 24 05 00
	00		 sub	 eax, DWORD PTR j$[rbp]
  011b9	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  011c0	0f af 01	 imul	 eax, DWORD PTR [rcx]
  011c3	0f af 85 a4 05
	00 00		 imul	 eax, DWORD PTR target$[rbp]
  011ca	8b c0		 mov	 eax, eax
  011cc	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  011d0	48 03 c8	 add	 rcx, rax
  011d3	48 8b c1	 mov	 rax, rcx
  011d6	48 89 85 28 09
	00 00		 mov	 QWORD PTR p2$30[rbp], rax

; 5247 :             for (i = 0; i < (int)s->img_x * target; ++i) {

  011dd	c7 85 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR i$[rbp], 0
  011e7	eb 0e		 jmp	 SHORT $LN34@stbi__bmp_
$LN32@stbi__bmp_:
  011e9	8b 85 04 05 00
	00		 mov	 eax, DWORD PTR i$[rbp]
  011ef	ff c0		 inc	 eax
  011f1	89 85 04 05 00
	00		 mov	 DWORD PTR i$[rbp], eax
$LN34@stbi__bmp_:
  011f7	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  011fe	8b 00		 mov	 eax, DWORD PTR [rax]
  01200	0f af 85 a4 05
	00 00		 imul	 eax, DWORD PTR target$[rbp]
  01207	39 85 04 05 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  0120d	7d 56		 jge	 SHORT $LN33@stbi__bmp_

; 5248 :                 t = p1[i]; p1[i] = p2[i]; p2[i] = t;

  0120f	48 63 85 04 05
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  01216	48 8b 8d 08 09
	00 00		 mov	 rcx, QWORD PTR p1$29[rbp]
  0121d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01221	88 85 e4 08 00
	00		 mov	 BYTE PTR t$28[rbp], al
  01227	48 63 85 04 05
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0122e	48 63 8d 04 05
	00 00		 movsxd	 rcx, DWORD PTR i$[rbp]
  01235	48 8b 95 08 09
	00 00		 mov	 rdx, QWORD PTR p1$29[rbp]
  0123c	4c 8b 85 28 09
	00 00		 mov	 r8, QWORD PTR p2$30[rbp]
  01243	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01248	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0124b	48 63 85 04 05
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  01252	48 8b 8d 28 09
	00 00		 mov	 rcx, QWORD PTR p2$30[rbp]
  01259	0f b6 95 e4 08
	00 00		 movzx	 edx, BYTE PTR t$28[rbp]
  01260	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5249 :             }

  01263	eb 84		 jmp	 SHORT $LN32@stbi__bmp_
$LN33@stbi__bmp_:

; 5250 :         }

  01265	e9 eb fe ff ff	 jmp	 $LN29@stbi__bmp_
$LN30@stbi__bmp_:
$LN92@stbi__bmp_:

; 5251 :     }
; 5252 : 
; 5253 :     if (req_comp && req_comp != target) {

  0126a	83 bd 50 0d 00
	00 00		 cmp	 DWORD PTR req_comp$[rbp], 0
  01271	74 4d		 je	 SHORT $LN93@stbi__bmp_
  01273	8b 85 a4 05 00
	00		 mov	 eax, DWORD PTR target$[rbp]
  01279	39 85 50 0d 00
	00		 cmp	 DWORD PTR req_comp$[rbp], eax
  0127f	74 3f		 je	 SHORT $LN93@stbi__bmp_

; 5254 :         out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

  01281	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  01288	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0128b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0128f	48 8b 85 30 0d
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  01296	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  01299	44 8b 85 50 0d
	00 00		 mov	 r8d, DWORD PTR req_comp$[rbp]
  012a0	8b 95 a4 05 00
	00		 mov	 edx, DWORD PTR target$[rbp]
  012a6	48 8b 4d 08	 mov	 rcx, QWORD PTR out$[rbp]
  012aa	e8 00 00 00 00	 call	 stbi__convert_format
  012af	48 89 45 08	 mov	 QWORD PTR out$[rbp], rax

; 5255 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  012b3	48 83 7d 08 00	 cmp	 QWORD PTR out$[rbp], 0
  012b8	75 06		 jne	 SHORT $LN94@stbi__bmp_
  012ba	48 8b 45 08	 mov	 rax, QWORD PTR out$[rbp]
  012be	eb 46		 jmp	 SHORT $LN1@stbi__bmp_
$LN94@stbi__bmp_:
$LN93@stbi__bmp_:

; 5256 :     }
; 5257 : 
; 5258 :     *x = s->img_x;

  012c0	48 8b 85 38 0d
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  012c7	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  012ce	8b 09		 mov	 ecx, DWORD PTR [rcx]
  012d0	89 08		 mov	 DWORD PTR [rax], ecx

; 5259 :     *y = s->img_y;

  012d2	48 8b 85 40 0d
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  012d9	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  012e0	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  012e3	89 08		 mov	 DWORD PTR [rax], ecx

; 5260 :     if (comp) *comp = s->img_n;

  012e5	48 83 bd 48 0d
	00 00 00	 cmp	 QWORD PTR comp$[rbp], 0
  012ed	74 13		 je	 SHORT $LN95@stbi__bmp_
  012ef	48 8b 85 48 0d
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  012f6	48 8b 8d 30 0d
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  012fd	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  01300	89 08		 mov	 DWORD PTR [rax], ecx
$LN95@stbi__bmp_:

; 5261 :     return out;

  01302	48 8b 45 08	 mov	 rax, QWORD PTR out$[rbp]
$LN1@stbi__bmp_:

; 5262 : }

  01306	48 8b f8	 mov	 rdi, rax
  01309	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0130d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmp_load$rtcFrameData
  01314	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01319	48 8b c7	 mov	 rax, rdi
  0131c	48 8b 8d 00 0d
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  01323	48 33 cd	 xor	 rcx, rbp
  01326	e8 00 00 00 00	 call	 __security_check_cookie
  0132b	48 8d a5 18 0d
	00 00		 lea	 rsp, QWORD PTR [rbp+3352]
  01332	5f		 pop	 rdi
  01333	5d		 pop	 rbp
  01334	c3		 ret	 0
stbi__bmp_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__bmp_test
_TEXT	SEGMENT
r$ = 4
s$ = 256
stbi__bmp_test PROC					; COMDAT

; 4882 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4883 :     int r = stbi__bmp_test_raw(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__bmp_test_raw
  0002b	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 4884 :     stbi__rewind(s);

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__rewind

; 4885 :     return r;

  0003a	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 4886 : }

  0003d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
stbi__bmp_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__png_is16
_TEXT	SEGMENT
p$ = 8
__$ArrayPad$ = 248
s$ = 288
stbi__png_is16 PROC					; COMDAT

; 4850 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 12 00 00 00	 mov	 ecx, 18
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 f8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4851 :     stbi__png p;
; 4852 :     p.s = s;

  00049	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00050	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax

; 4853 :     if (!stbi__png_info_raw(&p, NULL, NULL, NULL))

  00054	45 33 c9	 xor	 r9d, r9d
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	33 d2		 xor	 edx, edx
  0005c	48 8d 4d 08	 lea	 rcx, QWORD PTR p$[rbp]
  00060	e8 00 00 00 00	 call	 stbi__png_info_raw
  00065	85 c0		 test	 eax, eax
  00067	75 04		 jne	 SHORT $LN2@stbi__png_

; 4854 :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 18		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 4855 :     if (p.depth != 16) {

  0006d	83 7d 28 10	 cmp	 DWORD PTR p$[rbp+32], 16
  00071	74 0d		 je	 SHORT $LN3@stbi__png_

; 4856 :         stbi__rewind(p.s);

  00073	48 8b 4d 08	 mov	 rcx, QWORD PTR p$[rbp]
  00077	e8 00 00 00 00	 call	 stbi__rewind

; 4857 :         return 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN1@stbi__png_
$LN3@stbi__png_:

; 4858 :     }
; 4859 :     return 1;

  00080	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 4860 : }

  00085	48 8b f8	 mov	 rdi, rax
  00088	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_is16$rtcFrameData
  00093	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00098	48 8b c7	 mov	 rax, rdi
  0009b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000a2	48 33 cd	 xor	 rcx, rbp
  000a5	e8 00 00 00 00	 call	 __security_check_cookie
  000aa	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000b1	5f		 pop	 rdi
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
stbi__png_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__png_info
_TEXT	SEGMENT
p$ = 8
__$ArrayPad$ = 248
s$ = 288
x$ = 296
y$ = 304
comp$ = 312
stbi__png_info PROC					; COMDAT

; 4843 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 12 00 00 00	 mov	 ecx, 18
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 f8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4844 :     stbi__png p;
; 4845 :     p.s = s;

  00058	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0005f	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax

; 4846 :     return stbi__png_info_raw(&p, x, y, comp);

  00063	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0006a	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00071	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00078	48 8d 4d 08	 lea	 rcx, QWORD PTR p$[rbp]
  0007c	e8 00 00 00 00	 call	 stbi__png_info_raw

; 4847 : }

  00081	48 8b f8	 mov	 rdi, rax
  00084	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_info$rtcFrameData
  0008f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00094	48 8b c7	 mov	 rax, rdi
  00097	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0009e	48 33 cd	 xor	 rcx, rbp
  000a1	e8 00 00 00 00	 call	 __security_check_cookie
  000a6	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000ad	5f		 pop	 rdi
  000ae	5d		 pop	 rbp
  000af	c3		 ret	 0
stbi__png_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__png_load
_TEXT	SEGMENT
p$ = 8
__$ArrayPad$ = 248
s$ = 288
x$ = 296
y$ = 304
comp$ = 312
req_comp$ = 320
ri$ = 328
stbi__png_load PROC					; COMDAT

; 4816 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 12 00 00 00	 mov	 ecx, 18
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR [rsp+344]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 f8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4817 :     stbi__png p;
; 4818 :     p.s = s;

  00058	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0005f	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax

; 4819 :     return stbi__do_png(&p, x, y, comp, req_comp, ri);

  00063	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR ri$[rbp]
  0006a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006f	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00080	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00087	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008e	48 8d 4d 08	 lea	 rcx, QWORD PTR p$[rbp]
  00092	e8 00 00 00 00	 call	 stbi__do_png

; 4820 : }

  00097	48 8b f8	 mov	 rdi, rax
  0009a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_load$rtcFrameData
  000a5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000aa	48 8b c7	 mov	 rax, rdi
  000ad	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b4	48 33 cd	 xor	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi__png_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__png_test
_TEXT	SEGMENT
r$ = 4
s$ = 256
stbi__png_test PROC					; COMDAT

; 4823 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4824 :     int r;
; 4825 :     r = stbi__check_png_header(s);

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00026	e8 00 00 00 00	 call	 stbi__check_png_header
  0002b	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 4826 :     stbi__rewind(s);

  0002e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00035	e8 00 00 00 00	 call	 stbi__rewind

; 4827 :     return r;

  0003a	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 4828 : }

  0003d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
stbi__png_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_info
_TEXT	SEGMENT
result$ = 4
j$ = 40
s$ = 288
x$ = 296
y$ = 304
comp$ = 312
stbi__jpeg_info PROC					; COMDAT

; 3560 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3561 :     int result;
; 3562 :     stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));

  0002e	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00033	e8 00 00 00 00	 call	 stbi__malloc
  00038	48 89 45 28	 mov	 QWORD PTR j$[rbp], rax

; 3563 :     if (!j) return stbi__err("outofmem", "Out of memory");

  0003c	48 83 7d 28 00	 cmp	 QWORD PTR j$[rbp], 0
  00041	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	eb 4d		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3564 :     memset(j, 0, sizeof(stbi__jpeg));

  00051	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  00057	33 d2		 xor	 edx, edx
  00059	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  0005d	e8 00 00 00 00	 call	 memset

; 3565 :     j->s = s;

  00062	48 8b 45 28	 mov	 rax, QWORD PTR j$[rbp]
  00066	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0006d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3566 :     result = stbi__jpeg_info_raw(j, x, y, comp);

  00070	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00077	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0007e	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00085	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00089	e8 00 00 00 00	 call	 stbi__jpeg_info_raw
  0008e	89 45 04	 mov	 DWORD PTR result$[rbp], eax

; 3567 :     STBI_FREE(j);

  00091	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3568 :     return result;

  0009b	8b 45 04	 mov	 eax, DWORD PTR result$[rbp]
$LN1@stbi__jpeg:

; 3569 : }

  0009e	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000a5	5f		 pop	 rdi
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
stbi__jpeg_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_load
_TEXT	SEGMENT
result$ = 8
j$ = 40
tv70 = 248
s$ = 288
x$ = 296
y$ = 304
comp$ = 312
req_comp$ = 320
ri$ = 328
stbi__jpeg_load PROC					; COMDAT

; 3520 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3521 :     unsigned char* result;
; 3522 :     stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

  0002e	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00033	e8 00 00 00 00	 call	 stbi__malloc
  00038	48 89 45 28	 mov	 QWORD PTR j$[rbp], rax

; 3523 :     if (!j) return stbi__errpuc("outofmem", "Out of memory");

  0003c	48 83 7d 28 00	 cmp	 QWORD PTR j$[rbp], 0
  00041	75 31		 jne	 SHORT $LN2@stbi__jpeg
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0d		 je	 SHORT $LN4@stbi__jpeg
  00053	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv70[rbp], 0
  0005e	eb 0b		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:
  00060	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv70[rbp], 0
$LN5@stbi__jpeg:
  0006b	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv70[rbp]
  00072	eb 62		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3524 :     memset(j, 0, sizeof(stbi__jpeg));

  00074	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  0007a	33 d2		 xor	 edx, edx
  0007c	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00080	e8 00 00 00 00	 call	 memset

; 3525 :     STBI_NOTUSED(ri);
; 3526 :     j->s = s;

  00085	48 8b 45 28	 mov	 rax, QWORD PTR j$[rbp]
  00089	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00090	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3527 :     stbi__setup_jpeg(j);

  00093	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00097	e8 00 00 00 00	 call	 stbi__setup_jpeg

; 3528 :     result = load_jpeg_image(j, x, y, comp, req_comp);

  0009c	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  000a2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a6	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  000ad	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  000b4	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  000bb	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  000bf	e8 00 00 00 00	 call	 load_jpeg_image
  000c4	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 3529 :     STBI_FREE(j);

  000c8	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3530 :     return result;

  000d2	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi__jpeg:

; 3531 : }

  000d6	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000dd	5f		 pop	 rdi
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
stbi__jpeg_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__jpeg_test
_TEXT	SEGMENT
r$ = 4
j$ = 40
s$ = 288
stbi__jpeg_test PROC					; COMDAT

; 3534 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3535 :     int r;
; 3536 :     stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

  0001f	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00024	e8 00 00 00 00	 call	 stbi__malloc
  00029	48 89 45 28	 mov	 QWORD PTR j$[rbp], rax

; 3537 :     if (!j) return stbi__err("outofmem", "Out of memory");

  0002d	48 83 7d 28 00	 cmp	 QWORD PTR j$[rbp], 0
  00032	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0003b	e8 00 00 00 00	 call	 stbi__err
  00040	eb 52		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3538 :     memset(j, 0, sizeof(stbi__jpeg));

  00042	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  0004e	e8 00 00 00 00	 call	 memset

; 3539 :     j->s = s;

  00053	48 8b 45 28	 mov	 rax, QWORD PTR j$[rbp]
  00057	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3540 :     stbi__setup_jpeg(j);

  00061	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00065	e8 00 00 00 00	 call	 stbi__setup_jpeg

; 3541 :     r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

  0006a	ba 01 00 00 00	 mov	 edx, 1
  0006f	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  00073	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  00078	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 3542 :     stbi__rewind(s);

  0007b	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00082	e8 00 00 00 00	 call	 stbi__rewind

; 3543 :     STBI_FREE(j);

  00087	48 8b 4d 28	 mov	 rcx, QWORD PTR j$[rbp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3544 :     return r;

  00091	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]
$LN1@stbi__jpeg:

; 3545 : }

  00094	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0009b	5f		 pop	 rdi
  0009c	5d		 pop	 rbp
  0009d	c3		 ret	 0
stbi__jpeg_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__rewind
_TEXT	SEGMENT
s$ = 224
stbi__rewind PROC					; COMDAT

; 338  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 339  :     // conceptually rewind SHOULD rewind to the beginning of the stream,
; 340  :     // but we just rewind to the beginning of the initial buffer, because
; 341  :     // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 342  :     s->img_buffer = s->img_buffer_original;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00026	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002d	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00034	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 343  :     s->img_buffer_end = s->img_buffer_original_end;

  0003b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00042	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00049	48 8b 89 d8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+216]
  00050	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 344  : }

  00057	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
stbi__rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__start_file
_TEXT	SEGMENT
s$ = 224
f$ = 232
stbi__start_file PROC					; COMDAT

; 329  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 330  :     stbi__start_callbacks(s, &stbi__stdio_callbacks, (void*)f);

  00024	4c 8b 85 e8 00
	00 00		 mov	 r8, QWORD PTR f$[rbp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__stdio_callbacks
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00039	e8 00 00 00 00	 call	 stbi__start_callbacks

; 331  : }

  0003e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00045	5f		 pop	 rdi
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
stbi__start_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__stdio_eof
_TEXT	SEGMENT
tv70 = 192
user$ = 240
stbi__stdio_eof PROC					; COMDAT

; 317  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 318  :     return feof((FILE*)user) || ferror((FILE*)user);

  0001f	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR user$[rbp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  0002c	85 c0		 test	 eax, eax
  0002e	75 1d		 jne	 SHORT $LN3@stbi__stdi
  00030	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR user$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  0003d	85 c0		 test	 eax, eax
  0003f	75 0c		 jne	 SHORT $LN3@stbi__stdi
  00041	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv70[rbp], 0
  0004b	eb 0a		 jmp	 SHORT $LN4@stbi__stdi
$LN3@stbi__stdi:
  0004d	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv70[rbp], 1
$LN4@stbi__stdi:
  00057	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]

; 319  : }

  0005d	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00064	5f		 pop	 rdi
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
stbi__stdio_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__stdio_skip
_TEXT	SEGMENT
ch$ = 4
user$ = 256
n$ = 264
stbi__stdio_skip PROC					; COMDAT

; 307  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :     int ch;
; 309  :     fseek((FILE*)user, n, SEEK_CUR);

  00023	41 b8 01 00 00
	00		 mov	 r8d, 1
  00029	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  0002f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR user$[rbp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 310  :     ch = fgetc((FILE*)user);  /* have to read a byte to reset feof()'s flag */

  0003c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR user$[rbp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00049	89 45 04	 mov	 DWORD PTR ch$[rbp], eax

; 311  :     if (ch != EOF) {

  0004c	83 7d 04 ff	 cmp	 DWORD PTR ch$[rbp], -1
  00050	74 10		 je	 SHORT $LN2@stbi__stdi

; 312  :         ungetc(ch, (FILE*)user);  /* push byte back onto stream if valid. */

  00052	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR user$[rbp]
  00059	8b 4d 04	 mov	 ecx, DWORD PTR ch$[rbp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
$LN2@stbi__stdi:

; 313  :     }
; 314  : }

  00062	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
stbi__stdio_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__stdio_read
_TEXT	SEGMENT
user$ = 224
data$ = 232
size$ = 240
stbi__stdio_read PROC					; COMDAT

; 302  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 303  :     return (int)fread(data, 1, size, (FILE*)user);

  00029	48 63 85 f0 00
	00 00		 movsxd	 rax, DWORD PTR size$[rbp]
  00030	4c 8b 8d e0 00
	00 00		 mov	 r9, QWORD PTR user$[rbp]
  00037	4c 8b c0	 mov	 r8, rax
  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 304  : }

  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
stbi__stdio_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__start_callbacks
_TEXT	SEGMENT
tv72 = 192
s$ = 240
c$ = 248
user$ = 256
stbi__start_callbacks PROC				; COMDAT

; 288  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 289  :     s->io = *c;

  0002a	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00031	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  00035	48 8b b5 f8 00
	00 00		 mov	 rsi, QWORD PTR c$[rbp]
  0003c	b9 18 00 00 00	 mov	 ecx, 24
  00041	f3 a4		 rep movsb

; 290  :     s->io_user_data = user;

  00043	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0004a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR user$[rbp]
  00051	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 291  :     s->buflen = sizeof(s->buffer_start);

  00055	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0005c	c7 40 34 80 00
	00 00		 mov	 DWORD PTR [rax+52], 128	; 00000080H

; 292  :     s->read_from_callbacks = 1;

  00063	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0006a	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [rax+48], 1

; 293  :     s->callback_already_read = 0;

  00071	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00078	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 294  :     s->img_buffer = s->img_buffer_original = s->buffer_start;

  00082	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00089	48 83 c0 38	 add	 rax, 56			; 00000038H
  0008d	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv72[rbp], rax
  00094	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0009b	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv72[rbp]
  000a2	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  000a9	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000b0	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv72[rbp]
  000b7	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 295  :     stbi__refill_buffer(s);

  000be	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c5	e8 00 00 00 00	 call	 stbi__refill_buffer

; 296  :     s->img_buffer_original_end = s->img_buffer_end;

  000ca	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000d1	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000d8	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000df	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 297  : }

  000e6	48 8d a5 d0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+208]
  000ed	5f		 pop	 rdi
  000ee	5e		 pop	 rsi
  000ef	5d		 pop	 rbp
  000f0	c3		 ret	 0
stbi__start_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__start_mem
_TEXT	SEGMENT
tv72 = 192
s$ = 240
buffer$ = 248
len$ = 256
stbi__start_mem PROC					; COMDAT

; 278  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 279  :     s->io.read = NULL;

  00029	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00030	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 280  :     s->read_from_callbacks = 0;

  00038	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0003f	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 281  :     s->callback_already_read = 0;

  00046	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0004d	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 282  :     s->img_buffer = s->img_buffer_original = (stbi_uc*)buffer;

  00057	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0005e	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00065	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0006c	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00073	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  0007a	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 283  :     s->img_buffer_end = s->img_buffer_original_end = (stbi_uc*)buffer + len;

  00081	48 63 85 00 01
	00 00		 movsxd	 rax, DWORD PTR len$[rbp]
  00088	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  0008f	48 03 c8	 add	 rcx, rax
  00092	48 89 8d c0 00
	00 00		 mov	 QWORD PTR tv72[rbp], rcx
  00099	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000a0	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv72[rbp]
  000a7	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
  000ae	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000b5	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv72[rbp]
  000bc	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 284  : }

  000c3	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000ca	5f		 pop	 rdi
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
stbi__start_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__refill_buffer
_TEXT	SEGMENT
n$ = 4
s$ = 256
stbi__refill_buffer PROC				; COMDAT

; 1058 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1059 :     int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);

  0001f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00026	48 83 c0 38	 add	 rax, 56			; 00000038H
  0002a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00031	44 8b 41 34	 mov	 r8d, DWORD PTR [rcx+52]
  00035	48 8b d0	 mov	 rdx, rax
  00038	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0003f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  0004a	ff 50 10	 call	 QWORD PTR [rax+16]
  0004d	89 45 04	 mov	 DWORD PTR n$[rbp], eax

; 1060 :     s->callback_already_read += (int)(s->img_buffer - s->img_buffer_original);

  00050	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00057	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0005e	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00065	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006c	48 2b c1	 sub	 rax, rcx
  0006f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00076	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  0007c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00083	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1061 :     if (n == 0) {

  00089	83 7d 04 00	 cmp	 DWORD PTR n$[rbp], 0
  0008d	75 53		 jne	 SHORT $LN2@stbi__refi

; 1062 :         // at end of file, treat same as if from memory, but need to handle case
; 1063 :         // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1064 :         s->read_from_callbacks = 0;

  0008f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  00096	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1065 :         s->img_buffer = s->buffer_start;

  0009d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000a4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a8	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000af	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1066 :         s->img_buffer_end = s->buffer_start + 1;

  000b6	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000bd	48 83 c0 39	 add	 rax, 57			; 00000039H
  000c1	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000c8	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1067 :         *s->img_buffer = 0;

  000cf	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000d6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000dd	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1068 :     }

  000e0	eb 37		 jmp	 SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1069 :     else {
; 1070 :         s->img_buffer = s->buffer_start;

  000e2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR s$[rbp]
  000e9	48 83 c0 38	 add	 rax, 56			; 00000038H
  000ed	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  000f4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1071 :         s->img_buffer_end = s->buffer_start + n;

  000fb	48 63 45 04	 movsxd	 rax, DWORD PTR n$[rbp]
  000ff	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00106	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  0010b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  00112	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax
$LN3@stbi__refi:

; 1072 :     }
; 1073 : }

  00119	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00120	5f		 pop	 rdi
  00121	5d		 pop	 rbp
  00122	c3		 ret	 0
stbi__refill_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__sse2_available
_TEXT	SEGMENT
info3$ = 4
tv68 = 212
stbi__sse2_available PROC				; COMDAT

; 207  : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 208  :     int info3 = stbi__cpuid3();

  0001b	e8 00 00 00 00	 call	 stbi__cpuid3
  00020	89 45 04	 mov	 DWORD PTR info3$[rbp], eax

; 209  :     return ((info3 >> 26) & 1) != 0;

  00023	8b 45 04	 mov	 eax, DWORD PTR info3$[rbp]
  00026	c1 f8 1a	 sar	 eax, 26
  00029	83 e0 01	 and	 eax, 1
  0002c	85 c0		 test	 eax, eax
  0002e	74 0c		 je	 SHORT $LN3@stbi__sse2
  00030	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv68[rbp], 1
  0003a	eb 0a		 jmp	 SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
  0003c	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv68[rbp], 0
$LN4@stbi__sse2:
  00046	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv68[rbp]

; 210  : }

  0004c	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
stbi__sse2_available ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi__cpuid3
_TEXT	SEGMENT
info$ = 8
__$ArrayPad$ = 232
stbi__cpuid3 PROC					; COMDAT

; 185  : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00015	b9 0c 00 00 00	 mov	 ecx, 12
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c5	 xor	 rax, rbp
  0002b	48 89 85 e8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00039	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 186  :     int info[4];
; 187  :     __cpuid(info, 1);

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	33 c9		 xor	 ecx, ecx
  00045	0f a2		 cpuid
  00047	4c 8d 45 08	 lea	 r8, QWORD PTR info$[rbp]
  0004b	41 89 00	 mov	 DWORD PTR [r8], eax
  0004e	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  00052	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  00056	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 188  :     return info[3];

  0005a	b8 04 00 00 00	 mov	 eax, 4
  0005f	48 6b c0 03	 imul	 rax, rax, 3
  00063	8b 44 05 08	 mov	 eax, DWORD PTR info$[rbp+rax]

; 189  : }

  00067	8b f8		 mov	 edi, eax
  00069	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__cpuid3$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	8b c7		 mov	 eax, edi
  0007b	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00082	48 33 cd	 xor	 rcx, rbp
  00085	e8 00 00 00 00	 call	 __security_check_cookie
  0008a	48 8d a5 f0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+240]
  00091	5f		 pop	 rdi
  00092	5b		 pop	 rbx
  00093	5d		 pop	 rbp
  00094	c3		 ret	 0
stbi__cpuid3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_noheader_buffer
_TEXT	SEGMENT
a$ = 16
__$ArrayPad$ = 5656
obuffer$ = 5696
olen$ = 5704
ibuffer$ = 5712
ilen$ = 5720
stbi_zlib_decode_noheader_buffer PROC			; COMDAT

; 4067 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	b8 58 16 00 00	 mov	 eax, 5720		; 00001658H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00027	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002c	b9 0a 04 00 00	 mov	 ecx, 1034		; 0000040aH
  00031	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00036	f3 ab		 rep stosd
  00038	48 8b 8c 24 78
	16 00 00	 mov	 rcx, QWORD PTR [rsp+5752]
  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00047	48 33 c5	 xor	 rax, rbp
  0004a	48 89 85 18 16
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00058	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4068 :     stbi__zbuf a;
; 4069 :     a.zbuffer = (stbi_uc*)ibuffer;

  0005d	48 8b 85 50 16
	00 00		 mov	 rax, QWORD PTR ibuffer$[rbp]
  00064	48 89 45 10	 mov	 QWORD PTR a$[rbp], rax

; 4070 :     a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

  00068	48 63 85 58 16
	00 00		 movsxd	 rax, DWORD PTR ilen$[rbp]
  0006f	48 8b 8d 50 16
	00 00		 mov	 rcx, QWORD PTR ibuffer$[rbp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 45 18	 mov	 QWORD PTR a$[rbp+8], rax

; 4071 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

  00080	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	44 8b 85 48 16
	00 00		 mov	 r8d, DWORD PTR olen$[rbp]
  00092	48 8b 95 40 16
	00 00		 mov	 rdx, QWORD PTR obuffer$[rbp]
  00099	48 8d 4d 10	 lea	 rcx, QWORD PTR a$[rbp]
  0009d	e8 00 00 00 00	 call	 stbi__do_zlib
  000a2	85 c0		 test	 eax, eax
  000a4	74 12		 je	 SHORT $LN2@stbi_zlib_

; 4072 :         return (int)(a.zout - a.zout_start);

  000a6	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000aa	48 8b 4d 28	 mov	 rcx, QWORD PTR a$[rbp+24]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  000b6	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4073 :     else
; 4074 :         return -1;

  000b8	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4075 : }

  000bd	48 8b f8	 mov	 rdi, rax
  000c0	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_noheader_buffer$rtcFrameData
  000cb	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d0	48 8b c7	 mov	 rax, rdi
  000d3	48 8b 8d 18 16
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000da	48 33 cd	 xor	 rcx, rbp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 8d a5 28 16
	00 00		 lea	 rsp, QWORD PTR [rbp+5672]
  000e9	5f		 pop	 rdi
  000ea	5d		 pop	 rbp
  000eb	c3		 ret	 0
stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_noheader_malloc
_TEXT	SEGMENT
a$ = 16
p$ = 4136
__$ArrayPad$ = 5688
buffer$ = 5728
len$ = 5736
outlen$ = 5744
stbi_zlib_decode_noheader_malloc PROC			; COMDAT

; 4050 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	b8 78 16 00 00	 mov	 eax, 5752		; 00001678H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 12 04 00 00	 mov	 ecx, 1042		; 00000412H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 98
	16 00 00	 mov	 rcx, QWORD PTR [rsp+5784]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 38 16
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4051 :     stbi__zbuf a;
; 4052 :     char* p = (char*)stbi__malloc(16384);

  00058	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0005d	e8 00 00 00 00	 call	 stbi__malloc
  00062	48 89 85 28 10
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 4053 :     if (p == NULL) return NULL;

  00069	48 83 bd 28 10
	00 00 00	 cmp	 QWORD PTR p$[rbp], 0
  00071	75 07		 jne	 SHORT $LN2@stbi_zlib_
  00073	33 c0		 xor	 eax, eax
  00075	e9 80 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4054 :     a.zbuffer = (stbi_uc*)buffer;

  0007a	48 8b 85 60 16
	00 00		 mov	 rax, QWORD PTR buffer$[rbp]
  00081	48 89 45 10	 mov	 QWORD PTR a$[rbp], rax

; 4055 :     a.zbuffer_end = (stbi_uc*)buffer + len;

  00085	48 63 85 68 16
	00 00		 movsxd	 rax, DWORD PTR len$[rbp]
  0008c	48 8b 8d 60 16
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 45 18	 mov	 QWORD PTR a$[rbp+8], rax

; 4056 :     if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

  0009d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000a5	41 b9 01 00 00
	00		 mov	 r9d, 1
  000ab	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  000b1	48 8b 95 28 10
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  000b8	48 8d 4d 10	 lea	 rcx, QWORD PTR a$[rbp]
  000bc	e8 00 00 00 00	 call	 stbi__do_zlib
  000c1	85 c0		 test	 eax, eax
  000c3	74 29		 je	 SHORT $LN3@stbi_zlib_

; 4057 :         if (outlen) *outlen = (int)(a.zout - a.zout_start);

  000c5	48 83 bd 70 16
	00 00 00	 cmp	 QWORD PTR outlen$[rbp], 0
  000cd	74 17		 je	 SHORT $LN5@stbi_zlib_
  000cf	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000d3	48 8b 4d 28	 mov	 rcx, QWORD PTR a$[rbp+24]
  000d7	48 2b c8	 sub	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 8b 8d 70 16
	00 00		 mov	 rcx, QWORD PTR outlen$[rbp]
  000e4	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4058 :         return a.zout_start;

  000e6	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000ea	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4059 :     }

  000ec	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4060 :     else {
; 4061 :         STBI_FREE(a.zout_start);

  000ee	48 8b 4d 30	 mov	 rcx, QWORD PTR a$[rbp+32]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4062 :         return NULL;

  000f8	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4063 :     }
; 4064 : }

  000fa	48 8b f8	 mov	 rdi, rax
  000fd	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_noheader_malloc$rtcFrameData
  00108	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0010d	48 8b c7	 mov	 rax, rdi
  00110	48 8b 8d 38 16
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00117	48 33 cd	 xor	 rcx, rbp
  0011a	e8 00 00 00 00	 call	 __security_check_cookie
  0011f	48 8d a5 48 16
	00 00		 lea	 rsp, QWORD PTR [rbp+5704]
  00126	5f		 pop	 rdi
  00127	5d		 pop	 rbp
  00128	c3		 ret	 0
stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_buffer
_TEXT	SEGMENT
a$ = 16
__$ArrayPad$ = 5656
obuffer$ = 5696
olen$ = 5704
ibuffer$ = 5712
ilen$ = 5720
stbi_zlib_decode_buffer PROC				; COMDAT

; 4039 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	b8 58 16 00 00	 mov	 eax, 5720		; 00001658H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00027	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002c	b9 0a 04 00 00	 mov	 ecx, 1034		; 0000040aH
  00031	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00036	f3 ab		 rep stosd
  00038	48 8b 8c 24 78
	16 00 00	 mov	 rcx, QWORD PTR [rsp+5752]
  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00047	48 33 c5	 xor	 rax, rbp
  0004a	48 89 85 18 16
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00058	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4040 :     stbi__zbuf a;
; 4041 :     a.zbuffer = (stbi_uc*)ibuffer;

  0005d	48 8b 85 50 16
	00 00		 mov	 rax, QWORD PTR ibuffer$[rbp]
  00064	48 89 45 10	 mov	 QWORD PTR a$[rbp], rax

; 4042 :     a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

  00068	48 63 85 58 16
	00 00		 movsxd	 rax, DWORD PTR ilen$[rbp]
  0006f	48 8b 8d 50 16
	00 00		 mov	 rcx, QWORD PTR ibuffer$[rbp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 45 18	 mov	 QWORD PTR a$[rbp+8], rax

; 4043 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

  00080	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	44 8b 85 48 16
	00 00		 mov	 r8d, DWORD PTR olen$[rbp]
  00092	48 8b 95 40 16
	00 00		 mov	 rdx, QWORD PTR obuffer$[rbp]
  00099	48 8d 4d 10	 lea	 rcx, QWORD PTR a$[rbp]
  0009d	e8 00 00 00 00	 call	 stbi__do_zlib
  000a2	85 c0		 test	 eax, eax
  000a4	74 12		 je	 SHORT $LN2@stbi_zlib_

; 4044 :         return (int)(a.zout - a.zout_start);

  000a6	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000aa	48 8b 4d 28	 mov	 rcx, QWORD PTR a$[rbp+24]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  000b6	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4045 :     else
; 4046 :         return -1;

  000b8	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4047 : }

  000bd	48 8b f8	 mov	 rdi, rax
  000c0	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_buffer$rtcFrameData
  000cb	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d0	48 8b c7	 mov	 rax, rdi
  000d3	48 8b 8d 18 16
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000da	48 33 cd	 xor	 rcx, rbp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 8d a5 28 16
	00 00		 lea	 rsp, QWORD PTR [rbp+5672]
  000e9	5f		 pop	 rdi
  000ea	5d		 pop	 rbp
  000eb	c3		 ret	 0
stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_malloc
_TEXT	SEGMENT
buffer$ = 224
len$ = 232
outlen$ = 240
stbi_zlib_decode_malloc PROC				; COMDAT

; 4017 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4018 :     return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

  00028	4c 8b 8d f0 00
	00 00		 mov	 r9, QWORD PTR outlen$[rbp]
  0002f	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00035	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR len$[rbp]
  0003b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00042	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize

; 4019 : }

  00047	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004e	5f		 pop	 rdi
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_malloc_guesssize_headerflag
_TEXT	SEGMENT
a$ = 16
p$ = 4136
__$ArrayPad$ = 5688
buffer$ = 5728
len$ = 5736
initial_size$ = 5744
outlen$ = 5752
parse_header$ = 5760
stbi_zlib_decode_malloc_guesssize_headerflag PROC	; COMDAT

; 4022 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	b8 78 16 00 00	 mov	 eax, 5752		; 00001678H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00027	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002c	b9 12 04 00 00	 mov	 ecx, 1042		; 00000412H
  00031	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00036	f3 ab		 rep stosd
  00038	48 8b 8c 24 98
	16 00 00	 mov	 rcx, QWORD PTR [rsp+5784]
  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00047	48 33 c5	 xor	 rax, rbp
  0004a	48 89 85 38 16
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00058	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4023 :     stbi__zbuf a;
; 4024 :     char* p = (char*)stbi__malloc(initial_size);

  0005d	48 63 85 70 16
	00 00		 movsxd	 rax, DWORD PTR initial_size$[rbp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 stbi__malloc
  0006c	48 89 85 28 10
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 4025 :     if (p == NULL) return NULL;

  00073	48 83 bd 28 10
	00 00 00	 cmp	 QWORD PTR p$[rbp], 0
  0007b	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0007d	33 c0		 xor	 eax, eax
  0007f	e9 83 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4026 :     a.zbuffer = (stbi_uc*)buffer;

  00084	48 8b 85 60 16
	00 00		 mov	 rax, QWORD PTR buffer$[rbp]
  0008b	48 89 45 10	 mov	 QWORD PTR a$[rbp], rax

; 4027 :     a.zbuffer_end = (stbi_uc*)buffer + len;

  0008f	48 63 85 68 16
	00 00		 movsxd	 rax, DWORD PTR len$[rbp]
  00096	48 8b 8d 60 16
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  0009d	48 03 c8	 add	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 89 45 18	 mov	 QWORD PTR a$[rbp+8], rax

; 4028 :     if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

  000a7	8b 85 80 16 00
	00		 mov	 eax, DWORD PTR parse_header$[rbp]
  000ad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b1	41 b9 01 00 00
	00		 mov	 r9d, 1
  000b7	44 8b 85 70 16
	00 00		 mov	 r8d, DWORD PTR initial_size$[rbp]
  000be	48 8b 95 28 10
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  000c5	48 8d 4d 10	 lea	 rcx, QWORD PTR a$[rbp]
  000c9	e8 00 00 00 00	 call	 stbi__do_zlib
  000ce	85 c0		 test	 eax, eax
  000d0	74 29		 je	 SHORT $LN3@stbi_zlib_

; 4029 :         if (outlen) *outlen = (int)(a.zout - a.zout_start);

  000d2	48 83 bd 78 16
	00 00 00	 cmp	 QWORD PTR outlen$[rbp], 0
  000da	74 17		 je	 SHORT $LN5@stbi_zlib_
  000dc	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000e0	48 8b 4d 28	 mov	 rcx, QWORD PTR a$[rbp+24]
  000e4	48 2b c8	 sub	 rcx, rax
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	48 8b 8d 78 16
	00 00		 mov	 rcx, QWORD PTR outlen$[rbp]
  000f1	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4030 :         return a.zout_start;

  000f3	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000f7	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4031 :     }

  000f9	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4032 :     else {
; 4033 :         STBI_FREE(a.zout_start);

  000fb	48 8b 4d 30	 mov	 rcx, QWORD PTR a$[rbp+32]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4034 :         return NULL;

  00105	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4035 :     }
; 4036 : }

  00107	48 8b f8	 mov	 rdi, rax
  0010a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcFrameData
  00115	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0011a	48 8b c7	 mov	 rax, rdi
  0011d	48 8b 8d 38 16
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00124	48 33 cd	 xor	 rcx, rbp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 8d a5 48 16
	00 00		 lea	 rsp, QWORD PTR [rbp+5704]
  00133	5f		 pop	 rdi
  00134	5d		 pop	 rbp
  00135	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_zlib_decode_malloc_guesssize
_TEXT	SEGMENT
a$ = 16
p$ = 4136
__$ArrayPad$ = 5688
buffer$ = 5728
len$ = 5736
initial_size$ = 5744
outlen$ = 5752
stbi_zlib_decode_malloc_guesssize PROC			; COMDAT

; 4000 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	b8 78 16 00 00	 mov	 eax, 5752		; 00001678H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00027	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  0002c	b9 12 04 00 00	 mov	 ecx, 1042		; 00000412H
  00031	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00036	f3 ab		 rep stosd
  00038	48 8b 8c 24 98
	16 00 00	 mov	 rcx, QWORD PTR [rsp+5784]
  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00047	48 33 c5	 xor	 rax, rbp
  0004a	48 89 85 38 16
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00058	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4001 :     stbi__zbuf a;
; 4002 :     char* p = (char*)stbi__malloc(initial_size);

  0005d	48 63 85 70 16
	00 00		 movsxd	 rax, DWORD PTR initial_size$[rbp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 stbi__malloc
  0006c	48 89 85 28 10
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 4003 :     if (p == NULL) return NULL;

  00073	48 83 bd 28 10
	00 00 00	 cmp	 QWORD PTR p$[rbp], 0
  0007b	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0007d	33 c0		 xor	 eax, eax
  0007f	e9 81 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4004 :     a.zbuffer = (stbi_uc*)buffer;

  00084	48 8b 85 60 16
	00 00		 mov	 rax, QWORD PTR buffer$[rbp]
  0008b	48 89 45 10	 mov	 QWORD PTR a$[rbp], rax

; 4005 :     a.zbuffer_end = (stbi_uc*)buffer + len;

  0008f	48 63 85 68 16
	00 00		 movsxd	 rax, DWORD PTR len$[rbp]
  00096	48 8b 8d 60 16
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  0009d	48 03 c8	 add	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 89 45 18	 mov	 QWORD PTR a$[rbp+8], rax

; 4006 :     if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

  000a7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000af	41 b9 01 00 00
	00		 mov	 r9d, 1
  000b5	44 8b 85 70 16
	00 00		 mov	 r8d, DWORD PTR initial_size$[rbp]
  000bc	48 8b 95 28 10
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  000c3	48 8d 4d 10	 lea	 rcx, QWORD PTR a$[rbp]
  000c7	e8 00 00 00 00	 call	 stbi__do_zlib
  000cc	85 c0		 test	 eax, eax
  000ce	74 29		 je	 SHORT $LN3@stbi_zlib_

; 4007 :         if (outlen) *outlen = (int)(a.zout - a.zout_start);

  000d0	48 83 bd 78 16
	00 00 00	 cmp	 QWORD PTR outlen$[rbp], 0
  000d8	74 17		 je	 SHORT $LN5@stbi_zlib_
  000da	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000de	48 8b 4d 28	 mov	 rcx, QWORD PTR a$[rbp+24]
  000e2	48 2b c8	 sub	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	48 8b 8d 78 16
	00 00		 mov	 rcx, QWORD PTR outlen$[rbp]
  000ef	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4008 :         return a.zout_start;

  000f1	48 8b 45 30	 mov	 rax, QWORD PTR a$[rbp+32]
  000f5	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4009 :     }

  000f7	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4010 :     else {
; 4011 :         STBI_FREE(a.zout_start);

  000f9	48 8b 4d 30	 mov	 rcx, QWORD PTR a$[rbp+32]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4012 :         return NULL;

  00103	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4013 :     }
; 4014 : }

  00105	48 8b f8	 mov	 rdi, rax
  00108	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_malloc_guesssize$rtcFrameData
  00113	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00118	48 8b c7	 mov	 rax, rdi
  0011b	48 8b 8d 38 16
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00122	48 33 cd	 xor	 rcx, rbp
  00125	e8 00 00 00 00	 call	 __security_check_cookie
  0012a	48 8d a5 48 16
	00 00		 lea	 rsp, QWORD PTR [rbp+5704]
  00131	5f		 pop	 rdi
  00132	5d		 pop	 rbp
  00133	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_set_flip_vertically_on_load_thread
_TEXT	SEGMENT
flag_true_if_should_flip$ = 224
stbi_set_flip_vertically_on_load_thread PROC		; COMDAT

; 578  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 579  :     stbi__vertically_flip_on_load_local = flag_true_if_should_flip;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  00023	8b c0		 mov	 eax, eax
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00034	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00038	8b 95 e0 00 00
	00		 mov	 edx, DWORD PTR flag_true_if_should_flip$[rbp]
  0003e	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 580  :     stbi__vertically_flip_on_load_set = 1;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  00046	8b c0		 mov	 eax, eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00057	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0005b	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 581  : }

  00062	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
stbi_set_flip_vertically_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_convert_iphone_png_to_rgb_thread
_TEXT	SEGMENT
flag_true_if_should_convert$ = 224
stbi_convert_iphone_png_to_rgb_thread PROC		; COMDAT

; 4534 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4535 :     stbi__de_iphone_flag_local = flag_true_if_should_convert;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_local
  00023	8b c0		 mov	 eax, eax
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00034	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00038	8b 95 e0 00 00
	00		 mov	 edx, DWORD PTR flag_true_if_should_convert$[rbp]
  0003e	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 4536 :     stbi__de_iphone_flag_set = 1;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_set
  00046	8b c0		 mov	 eax, eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00057	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0005b	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 4537 : }

  00062	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
stbi_convert_iphone_png_to_rgb_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_set_unpremultiply_on_load_thread
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 224
stbi_set_unpremultiply_on_load_thread PROC		; COMDAT

; 4528 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4529 :     stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_local
  00023	8b c0		 mov	 eax, eax
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00034	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00038	8b 95 e0 00 00
	00		 mov	 edx, DWORD PTR flag_true_if_should_unpremultiply$[rbp]
  0003e	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 4530 :     stbi__unpremultiply_on_load_set = 1;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_set
  00046	8b c0		 mov	 eax, eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00057	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0005b	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 4531 : }

  00062	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
stbi_set_unpremultiply_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_set_flip_vertically_on_load
_TEXT	SEGMENT
flag_true_if_should_flip$ = 224
stbi_set_flip_vertically_on_load PROC			; COMDAT

; 568  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 569  :     stbi__vertically_flip_on_load_global = flag_true_if_should_flip;

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR flag_true_if_should_flip$[rbp]
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__vertically_flip_on_load_global, eax

; 570  : }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_convert_iphone_png_to_rgb
_TEXT	SEGMENT
flag_true_if_should_convert$ = 224
stbi_convert_iphone_png_to_rgb PROC			; COMDAT

; 4516 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4517 :     stbi__de_iphone_flag_global = flag_true_if_should_convert;

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR flag_true_if_should_convert$[rbp]
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__de_iphone_flag_global, eax

; 4518 : }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_set_unpremultiply_on_load
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 224
stbi_set_unpremultiply_on_load PROC			; COMDAT

; 4511 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4512 :     stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR flag_true_if_should_unpremultiply$[rbp]
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__unpremultiply_on_load_global, eax

; 4513 : }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_16_bit_from_file
_TEXT	SEGMENT
r$ = 4
s$ = 48
pos$ = 292
__$ArrayPad$ = 504
f$ = 544
stbi_is_16_bit_from_file PROC				; COMDAT

; 7292 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR [rsp+584]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 f8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7293 :     int r;
; 7294 :     stbi__context s;
; 7295 :     long pos = ftell(f);

  00049	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00056	89 85 24 01 00
	00		 mov	 DWORD PTR pos$[rbp], eax

; 7296 :     stbi__start_file(&s, f);

  0005c	48 8b 95 20 02
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  00063	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00067	e8 00 00 00 00	 call	 stbi__start_file

; 7297 :     r = stbi__is_16_main(&s);

  0006c	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00070	e8 00 00 00 00	 call	 stbi__is_16_main
  00075	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 7298 :     fseek(f, pos, SEEK_SET);

  00078	45 33 c0	 xor	 r8d, r8d
  0007b	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR pos$[rbp]
  00081	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 7299 :     return r;

  0008e	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 7300 : }

  00091	8b f8		 mov	 edi, eax
  00093	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_file$rtcFrameData
  0009e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a3	8b c7		 mov	 eax, edi
  000a5	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000ac	48 33 cd	 xor	 rcx, rbp
  000af	e8 00 00 00 00	 call	 __security_check_cookie
  000b4	48 8d a5 08 02
	00 00		 lea	 rsp, QWORD PTR [rbp+520]
  000bb	5f		 pop	 rdi
  000bc	5d		 pop	 rbp
  000bd	c3		 ret	 0
stbi_is_16_bit_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_16_bit
_TEXT	SEGMENT
f$ = 8
result$ = 36
filename$ = 288
stbi_is_16_bit PROC					; COMDAT

; 7282 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7283 :     FILE* f = stbi__fopen(filename, "rb");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00026	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0002d	e8 00 00 00 00	 call	 stbi__fopen
  00032	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 7284 :     int result;
; 7285 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  00036	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  0003b	75 0e		 jne	 SHORT $LN2@stbi_is_16
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  00044	e8 00 00 00 00	 call	 stbi__err
  00049	eb 19		 jmp	 SHORT $LN1@stbi_is_16
$LN2@stbi_is_16:

; 7286 :     result = stbi_is_16_bit_from_file(f);

  0004b	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  0004f	e8 00 00 00 00	 call	 stbi_is_16_bit_from_file
  00054	89 45 24	 mov	 DWORD PTR result$[rbp], eax

; 7287 :     fclose(f);

  00057	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 7288 :     return result;

  00061	8b 45 24	 mov	 eax, DWORD PTR result$[rbp]
$LN1@stbi_is_16:

; 7289 : }

  00064	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
stbi_is_16_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_info_from_file
_TEXT	SEGMENT
r$ = 4
s$ = 48
pos$ = 292
__$ArrayPad$ = 504
f$ = 544
x$ = 552
y$ = 560
comp$ = 568
stbi_info_from_file PROC				; COMDAT

; 7271 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR [rsp+584]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 f8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7272 :     int r;
; 7273 :     stbi__context s;
; 7274 :     long pos = ftell(f);

  00058	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00065	89 85 24 01 00
	00		 mov	 DWORD PTR pos$[rbp], eax

; 7275 :     stbi__start_file(&s, f);

  0006b	48 8b 95 20 02
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  00072	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00076	e8 00 00 00 00	 call	 stbi__start_file

; 7276 :     r = stbi__info_main(&s, x, y, comp);

  0007b	4c 8b 8d 38 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00082	4c 8b 85 30 02
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00089	48 8b 95 28 02
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00090	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00094	e8 00 00 00 00	 call	 stbi__info_main
  00099	89 45 04	 mov	 DWORD PTR r$[rbp], eax

; 7277 :     fseek(f, pos, SEEK_SET);

  0009c	45 33 c0	 xor	 r8d, r8d
  0009f	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR pos$[rbp]
  000a5	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 7278 :     return r;

  000b2	8b 45 04	 mov	 eax, DWORD PTR r$[rbp]

; 7279 : }

  000b5	8b f8		 mov	 edi, eax
  000b7	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_file$rtcFrameData
  000c2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000c7	8b c7		 mov	 eax, edi
  000c9	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000d0	48 33 cd	 xor	 rcx, rbp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 8d a5 08 02
	00 00		 lea	 rsp, QWORD PTR [rbp+520]
  000df	5f		 pop	 rdi
  000e0	5d		 pop	 rbp
  000e1	c3		 ret	 0
stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_info
_TEXT	SEGMENT
f$ = 8
result$ = 36
filename$ = 288
x$ = 296
y$ = 304
comp$ = 312
stbi_info PROC						; COMDAT

; 7261 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7262 :     FILE* f = stbi__fopen(filename, "rb");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00035	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fopen
  00041	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 7263 :     int result;
; 7264 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  00045	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  0004a	75 0e		 jne	 SHORT $LN2@stbi_info
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  00053	e8 00 00 00 00	 call	 stbi__err
  00058	eb 2e		 jmp	 SHORT $LN1@stbi_info
$LN2@stbi_info:

; 7265 :     result = stbi_info_from_file(f, x, y, comp);

  0005a	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00061	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00068	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  00073	e8 00 00 00 00	 call	 stbi_info_from_file
  00078	89 45 24	 mov	 DWORD PTR result$[rbp], eax

; 7266 :     fclose(f);

  0007b	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 7267 :     return result;

  00085	8b 45 24	 mov	 eax, DWORD PTR result$[rbp]
$LN1@stbi_info:

; 7268 : }

  00088	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_16_bit_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
c$ = 480
user$ = 488
stbi_is_16_bit_from_callbacks PROC			; COMDAT

; 7325 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001d	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00038	48 33 c5	 xor	 rax, rbp
  0003b	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00049	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7326 :     stbi__context s;
; 7327 :     stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);

  0004e	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  00055	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR c$[rbp]
  0005c	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00060	e8 00 00 00 00	 call	 stbi__start_callbacks

; 7328 :     return stbi__is_16_main(&s);

  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__is_16_main

; 7329 : }

  0006e	48 8b f8	 mov	 rdi, rax
  00071	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_callbacks$rtcFrameData
  0007c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00081	48 8b c7	 mov	 rax, rdi
  00084	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0008b	48 33 cd	 xor	 rcx, rbp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  0009a	5f		 pop	 rdi
  0009b	5d		 pop	 rbp
  0009c	c3		 ret	 0
stbi_is_16_bit_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_16_bit_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
stbi_is_16_bit_from_memory PROC				; COMDAT

; 7318 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7319 :     stbi__context s;
; 7320 :     stbi__start_mem(&s, buffer, len);

  0004d	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  00054	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  0005b	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__start_mem

; 7321 :     return stbi__is_16_main(&s);

  00064	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00068	e8 00 00 00 00	 call	 stbi__is_16_main

; 7322 : }

  0006d	48 8b f8	 mov	 rdi, rax
  00070	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_memory$rtcFrameData
  0007b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00080	48 8b c7	 mov	 rax, rdi
  00083	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0008a	48 33 cd	 xor	 rcx, rbp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  00099	5f		 pop	 rdi
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
stbi_is_16_bit_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_info_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
c$ = 480
user$ = 488
x$ = 496
y$ = 504
comp$ = 512
stbi_info_from_callbacks PROC				; COMDAT

; 7311 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00027	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7312 :     stbi__context s;
; 7313 :     stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);

  00058	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  0005f	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR c$[rbp]
  00066	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__start_callbacks

; 7314 :     return stbi__info_main(&s, x, y, comp);

  0006f	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00076	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0007d	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00084	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00088	e8 00 00 00 00	 call	 stbi__info_main

; 7315 : }

  0008d	48 8b f8	 mov	 rdi, rax
  00090	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_callbacks$rtcFrameData
  0009b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a0	48 8b c7	 mov	 rax, rdi
  000a3	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000aa	48 33 cd	 xor	 rcx, rbp
  000ad	e8 00 00 00 00	 call	 __security_check_cookie
  000b2	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000b9	5f		 pop	 rdi
  000ba	5d		 pop	 rbp
  000bb	c3		 ret	 0
stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_info_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
x$ = 496
y$ = 504
comp$ = 512
stbi_info_from_memory PROC				; COMDAT

; 7304 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00026	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7305 :     stbi__context s;
; 7306 :     stbi__start_mem(&s, buffer, len);

  00057	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  0005e	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__start_mem

; 7307 :     return stbi__info_main(&s, x, y, comp);

  0006e	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00075	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  0007c	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00083	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00087	e8 00 00 00 00	 call	 stbi__info_main

; 7308 : }

  0008c	48 8b f8	 mov	 rdi, rax
  0008f	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_memory$rtcFrameData
  0009a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009f	48 8b c7	 mov	 rax, rdi
  000a2	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000a9	48 33 cd	 xor	 rcx, rbp
  000ac	e8 00 00 00 00	 call	 __security_check_cookie
  000b1	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000b8	5f		 pop	 rdi
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_image_free
_TEXT	SEGMENT
retval_from_stbi_load$ = 224
stbi_image_free PROC					; COMDAT

; 553  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 554  :     STBI_FREE(retval_from_stbi_load);

  0001f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR retval_from_stbi_load$[rbp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 555  : }

  0002c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00033	5f		 pop	 rdi
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_failure_reason
_TEXT	SEGMENT
stbi_failure_reason PROC				; COMDAT

; 424  : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 425  :     return stbi__g_failure_reason;

  0001b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  00020	8b c0		 mov	 eax, eax
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00028	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00031	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00035	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]

; 426  : }

  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_hdr_from_file
_TEXT	SEGMENT
pos$ = 4
res$ = 36
s$ = 80
__$ArrayPad$ = 504
f$ = 544
stbi_is_hdr_from_file PROC				; COMDAT

; 1004 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR [rsp+584]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 f8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1005 : #ifndef STBI_NO_HDR
; 1006 :     long pos = ftell(f);

  00049	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00056	89 45 04	 mov	 DWORD PTR pos$[rbp], eax

; 1007 :     int res;
; 1008 :     stbi__context s;
; 1009 :     stbi__start_file(&s, f);

  00059	48 8b 95 20 02
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  00060	48 8d 4d 50	 lea	 rcx, QWORD PTR s$[rbp]
  00064	e8 00 00 00 00	 call	 stbi__start_file

; 1010 :     res = stbi__hdr_test(&s);

  00069	48 8d 4d 50	 lea	 rcx, QWORD PTR s$[rbp]
  0006d	e8 00 00 00 00	 call	 stbi__hdr_test
  00072	89 45 24	 mov	 DWORD PTR res$[rbp], eax

; 1011 :     fseek(f, pos, SEEK_SET);

  00075	45 33 c0	 xor	 r8d, r8d
  00078	8b 55 04	 mov	 edx, DWORD PTR pos$[rbp]
  0007b	48 8b 8d 20 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1012 :     return res;

  00088	8b 45 24	 mov	 eax, DWORD PTR res$[rbp]

; 1013 : #else
; 1014 :     STBI_NOTUSED(f);
; 1015 :     return 0;
; 1016 : #endif
; 1017 : }

  0008b	8b f8		 mov	 edi, eax
  0008d	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_file$rtcFrameData
  00098	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009d	8b c7		 mov	 eax, edi
  0009f	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000a6	48 33 cd	 xor	 rcx, rbp
  000a9	e8 00 00 00 00	 call	 __security_check_cookie
  000ae	48 8d a5 08 02
	00 00		 lea	 rsp, QWORD PTR [rbp+520]
  000b5	5f		 pop	 rdi
  000b6	5d		 pop	 rbp
  000b7	c3		 ret	 0
stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_hdr
_TEXT	SEGMENT
f$ = 8
result$ = 36
filename$ = 288
stbi_is_hdr PROC					; COMDAT

; 993  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 994  :     FILE* f = stbi__fopen(filename, "rb");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00026	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0002d	e8 00 00 00 00	 call	 stbi__fopen
  00032	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 995  :     int result = 0;

  00036	c7 45 24 00 00
	00 00		 mov	 DWORD PTR result$[rbp], 0

; 996  :     if (f) {

  0003d	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  00042	74 16		 je	 SHORT $LN2@stbi_is_hd

; 997  :         result = stbi_is_hdr_from_file(f);

  00044	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  00048	e8 00 00 00 00	 call	 stbi_is_hdr_from_file
  0004d	89 45 24	 mov	 DWORD PTR result$[rbp], eax

; 998  :         fclose(f);

  00050	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
$LN2@stbi_is_hd:

; 999  :     }
; 1000 :     return result;

  0005a	8b 45 24	 mov	 eax, DWORD PTR result$[rbp]

; 1001 : }

  0005d	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00064	5f		 pop	 rdi
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_hdr_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
stbi_is_hdr_from_memory PROC				; COMDAT

; 979  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 980  : #ifndef STBI_NO_HDR
; 981  :     stbi__context s;
; 982  :     stbi__start_mem(&s, buffer, len);

  0004d	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  00054	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  0005b	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0005f	e8 00 00 00 00	 call	 stbi__start_mem

; 983  :     return stbi__hdr_test(&s);

  00064	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00068	e8 00 00 00 00	 call	 stbi__hdr_test

; 984  : #else
; 985  :     STBI_NOTUSED(buffer);
; 986  :     STBI_NOTUSED(len);
; 987  :     return 0;
; 988  : #endif
; 989  : }

  0006d	48 8b f8	 mov	 rdi, rax
  00070	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_memory$rtcFrameData
  0007b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00080	48 8b c7	 mov	 rax, rdi
  00083	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0008a	48 33 cd	 xor	 rcx, rbp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  00099	5f		 pop	 rdi
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_is_hdr_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
clbk$ = 480
user$ = 488
stbi_is_hdr_from_callbacks PROC				; COMDAT

; 1021 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001d	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00038	48 33 c5	 xor	 rax, rbp
  0003b	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00049	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1022 : #ifndef STBI_NO_HDR
; 1023 :     stbi__context s;
; 1024 :     stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

  0004e	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  00055	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR clbk$[rbp]
  0005c	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00060	e8 00 00 00 00	 call	 stbi__start_callbacks

; 1025 :     return stbi__hdr_test(&s);

  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__hdr_test

; 1026 : #else
; 1027 :     STBI_NOTUSED(clbk);
; 1028 :     STBI_NOTUSED(user);
; 1029 :     return 0;
; 1030 : #endif
; 1031 : }

  0006e	48 8b f8	 mov	 rdi, rax
  00071	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_callbacks$rtcFrameData
  0007c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00081	48 8b c7	 mov	 rax, rdi
  00084	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0008b	48 33 cd	 xor	 rcx, rbp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  0009a	5f		 pop	 rdi
  0009b	5d		 pop	 rbp
  0009c	c3		 ret	 0
stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_ldr_to_hdr_scale
_TEXT	SEGMENT
scale$ = 224
stbi_ldr_to_hdr_scale PROC				; COMDAT

; 1037 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	55		 push	 rbp
  00007	57		 push	 rdi
  00008	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	f3 0f 10 85 e0
	00 00 00	 movss	 xmm0, DWORD PTR scale$[rbp]
  00028	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__l2h_scale, xmm0
  00030	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00037	5f		 pop	 rdi
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_ldr_to_hdr_gamma
_TEXT	SEGMENT
gamma$ = 224
stbi_ldr_to_hdr_gamma PROC				; COMDAT

; 1036 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	55		 push	 rbp
  00007	57		 push	 rdi
  00008	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	f3 0f 10 85 e0
	00 00 00	 movss	 xmm0, DWORD PTR gamma$[rbp]
  00028	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__l2h_gamma, xmm0
  00030	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00037	5f		 pop	 rdi
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_hdr_to_ldr_scale
_TEXT	SEGMENT
scale$ = 224
stbi_hdr_to_ldr_scale PROC				; COMDAT

; 1043 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	55		 push	 rbp
  00007	57		 push	 rdi
  00008	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00028	f3 0f 5e 85 e0
	00 00 00	 divss	 xmm0, DWORD PTR scale$[rbp]
  00030	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__h2l_scale_i, xmm0
  00038	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003f	5f		 pop	 rdi
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_hdr_to_ldr_gamma
_TEXT	SEGMENT
gamma$ = 224
stbi_hdr_to_ldr_gamma PROC				; COMDAT

; 1042 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	55		 push	 rbp
  00007	57		 push	 rdi
  00008	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00028	f3 0f 5e 85 e0
	00 00 00	 divss	 xmm0, DWORD PTR gamma$[rbp]
  00030	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__h2l_gamma_i, xmm0
  00038	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003f	5f		 pop	 rdi
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_loadf_from_file
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
f$ = 480
x$ = 488
y$ = 496
comp$ = 504
req_comp$ = 512
stbi_loadf_from_file PROC				; COMDAT

; 965  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 966  :     stbi__context s;
; 967  :     stbi__start_file(&s, f);

  00058	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  0005f	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00063	e8 00 00 00 00	 call	 stbi__start_file

; 968  :     return stbi__loadf_main(&s, x, y, comp, req_comp);

  00068	8b 85 00 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0006e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00072	4c 8b 8d f8 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00079	4c 8b 85 f0 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00080	48 8b 95 e8 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00087	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0008b	e8 00 00 00 00	 call	 stbi__loadf_main

; 969  : }

  00090	48 8b f8	 mov	 rdi, rax
  00093	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_file$rtcFrameData
  0009e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a3	48 8b c7	 mov	 rax, rdi
  000a6	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000ad	48 33 cd	 xor	 rcx, rbp
  000b0	e8 00 00 00 00	 call	 __security_check_cookie
  000b5	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000bc	5f		 pop	 rdi
  000bd	5d		 pop	 rbp
  000be	c3		 ret	 0
stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_loadf
_TEXT	SEGMENT
result$ = 8
f$ = 40
tv71 = 248
filename$ = 288
x$ = 296
y$ = 304
comp$ = 312
req_comp$ = 320
stbi_loadf PROC						; COMDAT

; 955  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 956  :     float* result;
; 957  :     FILE* f = stbi__fopen(filename, "rb");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00035	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fopen
  00041	48 89 45 28	 mov	 QWORD PTR f$[rbp], rax

; 958  :     if (!f) return stbi__errpf("can't fopen", "Unable to open file");

  00045	48 83 7d 28 00	 cmp	 QWORD PTR f$[rbp], 0
  0004a	75 31		 jne	 SHORT $LN2@stbi_loadf
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  00053	e8 00 00 00 00	 call	 stbi__err
  00058	85 c0		 test	 eax, eax
  0005a	74 0d		 je	 SHORT $LN4@stbi_loadf
  0005c	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
  00067	eb 0b		 jmp	 SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
  00069	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
$LN5@stbi_loadf:
  00074	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv71[rbp]
  0007b	eb 3a		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 959  :     result = stbi_loadf_from_file(f, x, y, comp, req_comp);

  0007d	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00083	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00087	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0008e	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00095	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0009c	48 8b 4d 28	 mov	 rcx, QWORD PTR f$[rbp]
  000a0	e8 00 00 00 00	 call	 stbi_loadf_from_file
  000a5	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 960  :     fclose(f);

  000a9	48 8b 4d 28	 mov	 rcx, QWORD PTR f$[rbp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 961  :     return result;

  000b3	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi_loadf:

; 962  : }

  000b7	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000be	5f		 pop	 rdi
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_loadf_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
clbk$ = 480
user$ = 488
x$ = 496
y$ = 504
comp$ = 512
req_comp$ = 520
stbi_loadf_from_callbacks PROC				; COMDAT

; 947  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 948  :     stbi__context s;
; 949  :     stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

  00058	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  0005f	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR clbk$[rbp]
  00066	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__start_callbacks

; 950  :     return stbi__loadf_main(&s, x, y, comp, req_comp);

  0006f	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00080	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00087	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008e	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00092	e8 00 00 00 00	 call	 stbi__loadf_main

; 951  : }

  00097	48 8b f8	 mov	 rdi, rax
  0009a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_callbacks$rtcFrameData
  000a5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000aa	48 8b c7	 mov	 rax, rdi
  000ad	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b4	48 33 cd	 xor	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_loadf_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
x$ = 496
y$ = 504
comp$ = 512
req_comp$ = 520
stbi_loadf_from_memory PROC				; COMDAT

; 940  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 941  :     stbi__context s;
; 942  :     stbi__start_mem(&s, buffer, len);

  00057	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  0005e	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__start_mem

; 943  :     return stbi__loadf_main(&s, x, y, comp, req_comp);

  0006e	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0007f	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00086	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008d	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00091	e8 00 00 00 00	 call	 stbi__loadf_main

; 944  : }

  00096	48 8b f8	 mov	 rdi, rax
  00099	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_memory$rtcFrameData
  000a4	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a9	48 8b c7	 mov	 rax, rdi
  000ac	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b3	48 33 cd	 xor	 rcx, rbp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_from_file_16
_TEXT	SEGMENT
result$ = 8
s$ = 48
__$ArrayPad$ = 472
f$ = 512
x$ = 520
y$ = 528
comp$ = 536
req_comp$ = 544
stbi_load_from_file_16 PROC				; COMDAT

; 852  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR [rsp+568]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 d8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 853  :     stbi__uint16* result;
; 854  :     stbi__context s;
; 855  :     stbi__start_file(&s, f);

  00058	48 8b 95 00 02
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  0005f	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00063	e8 00 00 00 00	 call	 stbi__start_file

; 856  :     result = stbi__load_and_postprocess_16bit(&s, x, y, comp, req_comp);

  00068	8b 85 20 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0006e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00072	4c 8b 8d 18 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00079	4c 8b 85 10 02
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00080	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00087	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  0008b	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit
  00090	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 857  :     if (result) {

  00094	48 83 7d 08 00	 cmp	 QWORD PTR result$[rbp], 0
  00099	74 2b		 je	 SHORT $LN2@stbi_load_

; 858  :         // need to 'unget' all the characters in the IO buffer
; 859  :         fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);

  0009b	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp+192]
  000a2	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp+200]
  000a9	48 2b c8	 sub	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	f7 d8		 neg	 eax
  000b1	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b7	8b d0		 mov	 edx, eax
  000b9	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
$LN2@stbi_load_:

; 860  :     }
; 861  :     return result;

  000c6	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]

; 862  : }

  000ca	48 8b f8	 mov	 rdi, rax
  000cd	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_file_16$rtcFrameData
  000d8	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000dd	48 8b c7	 mov	 rax, rdi
  000e0	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000e7	48 33 cd	 xor	 rcx, rbp
  000ea	e8 00 00 00 00	 call	 __security_check_cookie
  000ef	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  000f6	5f		 pop	 rdi
  000f7	5d		 pop	 rbp
  000f8	c3		 ret	 0
stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_16
_TEXT	SEGMENT
f$ = 8
result$ = 40
tv71 = 248
filename$ = 288
x$ = 296
y$ = 304
comp$ = 312
req_comp$ = 320
stbi_load_16 PROC					; COMDAT

; 865  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 866  :     FILE* f = stbi__fopen(filename, "rb");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00035	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fopen
  00041	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 867  :     stbi__uint16* result;
; 868  :     if (!f) return (stbi_us*)stbi__errpuc("can't fopen", "Unable to open file");

  00045	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  0004a	75 31		 jne	 SHORT $LN2@stbi_load_
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  00053	e8 00 00 00 00	 call	 stbi__err
  00058	85 c0		 test	 eax, eax
  0005a	74 0d		 je	 SHORT $LN4@stbi_load_
  0005c	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
  00067	eb 0b		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  00069	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
$LN5@stbi_load_:
  00074	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv71[rbp]
  0007b	eb 3a		 jmp	 SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 869  :     result = stbi_load_from_file_16(f, x, y, comp, req_comp);

  0007d	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00083	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00087	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0008e	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00095	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0009c	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  000a0	e8 00 00 00 00	 call	 stbi_load_from_file_16
  000a5	48 89 45 28	 mov	 QWORD PTR result$[rbp], rax

; 870  :     fclose(f);

  000a9	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 871  :     return result;

  000b3	48 8b 45 28	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi_load_:

; 872  : }

  000b7	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000be	5f		 pop	 rdi
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_16_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
clbk$ = 480
user$ = 488
x$ = 496
y$ = 504
channels_in_file$ = 512
desired_channels$ = 520
stbi_load_16_from_callbacks PROC			; COMDAT

; 884  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 885  :     stbi__context s;
; 886  :     stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

  00058	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  0005f	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR clbk$[rbp]
  00066	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__start_callbacks

; 887  :     return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);

  0006f	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR desired_channels$[rbp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR channels_in_file$[rbp]
  00080	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00087	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008e	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00092	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit

; 888  : }

  00097	48 8b f8	 mov	 rdi, rax
  0009a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_16_from_callbacks$rtcFrameData
  000a5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000aa	48 8b c7	 mov	 rax, rdi
  000ad	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b4	48 33 cd	 xor	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_16_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
x$ = 496
y$ = 504
channels_in_file$ = 512
desired_channels$ = 520
stbi_load_16_from_memory PROC				; COMDAT

; 877  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 878  :     stbi__context s;
; 879  :     stbi__start_mem(&s, buffer, len);

  00057	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  0005e	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__start_mem

; 880  :     return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);

  0006e	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR desired_channels$[rbp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR channels_in_file$[rbp]
  0007f	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00086	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008d	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00091	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit

; 881  : }

  00096	48 8b f8	 mov	 rdi, rax
  00099	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_16_from_memory$rtcFrameData
  000a4	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a9	48 8b c7	 mov	 rax, rdi
  000ac	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b3	48 33 cd	 xor	 rcx, rbp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_gif_from_memory
_TEXT	SEGMENT
result$ = 8
s$ = 48
tv88 = 468
__$ArrayPad$ = 472
buffer$ = 512
len$ = 520
delays$ = 528
x$ = 536
y$ = 544
z$ = 552
comp$ = 560
req_comp$ = 568
stbi_load_gif_from_memory PROC				; COMDAT

; 906  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  0001c	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00021	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00026	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR [rsp+584]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 d8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 907  :     unsigned char* result;
; 908  :     stbi__context s;
; 909  :     stbi__start_mem(&s, buffer, len);

  00057	44 8b 85 08 02
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  0005e	48 8b 95 00 02
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  00065	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__start_mem

; 910  : 
; 911  :     result = (unsigned char*)stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);

  0006e	8b 85 38 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00074	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00078	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  0008b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00090	4c 8b 8d 20 02
	00 00		 mov	 r9, QWORD PTR y$[rbp]
  00097	4c 8b 85 18 02
	00 00		 mov	 r8, QWORD PTR x$[rbp]
  0009e	48 8b 95 10 02
	00 00		 mov	 rdx, QWORD PTR delays$[rbp]
  000a5	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  000a9	e8 00 00 00 00	 call	 stbi__load_gif_main
  000ae	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 912  :     if (stbi__vertically_flip_on_load) {

  000b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  000b7	8b c0		 mov	 eax, eax
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000cc	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  000d0	74 25		 je	 SHORT $LN4@stbi_load_
  000d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  000d7	8b c0		 mov	 eax, eax
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000ec	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000ef	89 85 d4 01 00
	00		 mov	 DWORD PTR tv88[rbp], eax
  000f5	eb 0c		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  000f7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  000fd	89 85 d4 01 00
	00		 mov	 DWORD PTR tv88[rbp], eax
$LN5@stbi_load_:
  00103	83 bd d4 01 00
	00 00		 cmp	 DWORD PTR tv88[rbp], 0
  0010a	74 33		 je	 SHORT $LN2@stbi_load_

; 913  :         stbi__vertical_flip_slices(result, *x, *y, *z, *comp);

  0010c	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR comp$[rbp]
  00113	8b 00		 mov	 eax, DWORD PTR [rax]
  00115	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00119	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR z$[rbp]
  00120	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00123	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR y$[rbp]
  0012a	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0012d	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR x$[rbp]
  00134	8b 10		 mov	 edx, DWORD PTR [rax]
  00136	48 8b 4d 08	 mov	 rcx, QWORD PTR result$[rbp]
  0013a	e8 00 00 00 00	 call	 stbi__vertical_flip_slices
$LN2@stbi_load_:

; 914  :     }
; 915  : 
; 916  :     return result;

  0013f	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]

; 917  : }

  00143	48 8b f8	 mov	 rdi, rax
  00146	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_gif_from_memory$rtcFrameData
  00151	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00156	48 8b c7	 mov	 rax, rdi
  00159	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00160	48 33 cd	 xor	 rcx, rbp
  00163	e8 00 00 00 00	 call	 __security_check_cookie
  00168	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  0016f	5f		 pop	 rdi
  00170	5d		 pop	 rbp
  00171	c3		 ret	 0
stbi_load_gif_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_from_file
_TEXT	SEGMENT
result$ = 8
s$ = 48
__$ArrayPad$ = 472
f$ = 512
x$ = 520
y$ = 528
comp$ = 536
req_comp$ = 544
stbi_load_from_file PROC				; COMDAT

; 839  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR [rsp+568]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 d8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 840  :     unsigned char* result;
; 841  :     stbi__context s;
; 842  :     stbi__start_file(&s, f);

  00058	48 8b 95 00 02
	00 00		 mov	 rdx, QWORD PTR f$[rbp]
  0005f	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  00063	e8 00 00 00 00	 call	 stbi__start_file

; 843  :     result = stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

  00068	8b 85 20 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  0006e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00072	4c 8b 8d 18 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00079	4c 8b 85 10 02
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00080	48 8b 95 08 02
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  00087	48 8d 4d 30	 lea	 rcx, QWORD PTR s$[rbp]
  0008b	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit
  00090	48 89 45 08	 mov	 QWORD PTR result$[rbp], rax

; 844  :     if (result) {

  00094	48 83 7d 08 00	 cmp	 QWORD PTR result$[rbp], 0
  00099	74 2b		 je	 SHORT $LN2@stbi_load_

; 845  :         // need to 'unget' all the characters in the IO buffer
; 846  :         fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);

  0009b	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR s$[rbp+192]
  000a2	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp+200]
  000a9	48 2b c8	 sub	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	f7 d8		 neg	 eax
  000b1	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b7	8b d0		 mov	 edx, eax
  000b9	48 8b 8d 00 02
	00 00		 mov	 rcx, QWORD PTR f$[rbp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
$LN2@stbi_load_:

; 847  :     }
; 848  :     return result;

  000c6	48 8b 45 08	 mov	 rax, QWORD PTR result$[rbp]

; 849  : }

  000ca	48 8b f8	 mov	 rdi, rax
  000cd	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_file$rtcFrameData
  000d8	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000dd	48 8b c7	 mov	 rax, rdi
  000e0	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000e7	48 33 cd	 xor	 rcx, rbp
  000ea	e8 00 00 00 00	 call	 __security_check_cookie
  000ef	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  000f6	5f		 pop	 rdi
  000f7	5d		 pop	 rbp
  000f8	c3		 ret	 0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_to_target
_TEXT	SEGMENT
f$ = 8
result$ = 40
filename$ = 288
x$ = 296
y$ = 304
target$ = 312
comp$ = 320
req_comp$ = 328
stbi_load_to_target PROC				; COMDAT

; 827  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 828  :     FILE* f = stbi__fopen(filename, "rb");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00035	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fopen
  00041	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 829  :     unsigned char* result;
; 830  :     if (!f)

  00045	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  0004a	75 12		 jne	 SHORT $LN2@stbi_load_

; 831  :     {
; 832  :         *target = "can't fopen, Unable to open file"; return;

  0004c	48 8b 85 38 01
	00 00		 mov	 rax, QWORD PTR target$[rbp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@DDANHPKI@can?8t?5fopen?0?5Unable?5to?5open?5fil@
  0005a	88 08		 mov	 BYTE PTR [rax], cl
  0005c	eb 36		 jmp	 SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 833  :     }
; 834  :     result = stbi_load_from_file(f, x, y, comp, req_comp);

  0005e	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00064	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00068	4c 8b 8d 40 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0006f	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00076	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0007d	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  00081	e8 00 00 00 00	 call	 stbi_load_from_file
  00086	48 89 45 28	 mov	 QWORD PTR result$[rbp], rax

; 835  :     fclose(f);

  0008a	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
$LN1@stbi_load_:

; 836  : }

  00094	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0009b	5f		 pop	 rdi
  0009c	5d		 pop	 rbp
  0009d	c3		 ret	 0
stbi_load_to_target ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load
_TEXT	SEGMENT
f$ = 8
result$ = 40
tv71 = 248
filename$ = 288
x$ = 296
y$ = 304
comp$ = 312
req_comp$ = 320
stbi_load PROC						; COMDAT

; 817  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 818  :     FILE* f = stbi__fopen(filename, "rb");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00035	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR filename$[rbp]
  0003c	e8 00 00 00 00	 call	 stbi__fopen
  00041	48 89 45 08	 mov	 QWORD PTR f$[rbp], rax

; 819  :     unsigned char* result;
; 820  :     if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

  00045	48 83 7d 08 00	 cmp	 QWORD PTR f$[rbp], 0
  0004a	75 31		 jne	 SHORT $LN2@stbi_load
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  00053	e8 00 00 00 00	 call	 stbi__err
  00058	85 c0		 test	 eax, eax
  0005a	74 0d		 je	 SHORT $LN4@stbi_load
  0005c	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
  00067	eb 0b		 jmp	 SHORT $LN5@stbi_load
$LN4@stbi_load:
  00069	48 c7 85 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv71[rbp], 0
$LN5@stbi_load:
  00074	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv71[rbp]
  0007b	eb 3a		 jmp	 SHORT $LN1@stbi_load
$LN2@stbi_load:

; 821  :     result = stbi_load_from_file(f, x, y, comp, req_comp);

  0007d	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00083	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00087	4c 8b 8d 38 01
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0008e	4c 8b 85 30 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00095	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0009c	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  000a0	e8 00 00 00 00	 call	 stbi_load_from_file
  000a5	48 89 45 28	 mov	 QWORD PTR result$[rbp], rax

; 822  :     fclose(f);

  000a9	48 8b 4d 08	 mov	 rcx, QWORD PTR f$[rbp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 823  :     return result;

  000b3	48 8b 45 28	 mov	 rax, QWORD PTR result$[rbp]
$LN1@stbi_load:

; 824  : }

  000b7	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000be	5f		 pop	 rdi
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_from_callbacks
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
clbk$ = 480
user$ = 488
x$ = 496
y$ = 504
comp$ = 512
req_comp$ = 520
stbi_load_from_callbacks PROC				; COMDAT

; 898  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c5	 xor	 rax, rbp
  00045	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 899  :     stbi__context s;
; 900  :     stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

  00058	4c 8b 85 e8 01
	00 00		 mov	 r8, QWORD PTR user$[rbp]
  0005f	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR clbk$[rbp]
  00066	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  0006a	e8 00 00 00 00	 call	 stbi__start_callbacks

; 901  :     return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

  0006f	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  00080	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00087	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008e	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00092	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit

; 902  : }

  00097	48 8b f8	 mov	 rdi, rax
  0009a	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_callbacks$rtcFrameData
  000a5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000aa	48 8b c7	 mov	 rax, rdi
  000ad	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b4	48 33 cd	 xor	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\NitloadIndustry\\1-Flagship\TH2020\ProjectFile\\StgSharpC\stb_image.c
;	COMDAT stbi_load_from_memory
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 440
buffer$ = 480
len$ = 488
x$ = 496
y$ = 504
comp$ = 512
req_comp$ = 520
stbi_load_from_memory PROC				; COMDAT

; 891  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c5	 xor	 rax, rbp
  00044	48 89 85 b8 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C5A6C9A6_stb_image@c
  00052	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 892  :     stbi__context s;
; 893  :     stbi__start_mem(&s, buffer, len);

  00057	44 8b 85 e8 01
	00 00		 mov	 r8d, DWORD PTR len$[rbp]
  0005e	48 8b 95 e0 01
	00 00		 mov	 rdx, QWORD PTR buffer$[rbp]
  00065	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00069	e8 00 00 00 00	 call	 stbi__start_mem

; 894  :     return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

  0006e	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR req_comp$[rbp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8d 00 02
	00 00		 mov	 r9, QWORD PTR comp$[rbp]
  0007f	4c 8b 85 f8 01
	00 00		 mov	 r8, QWORD PTR y$[rbp]
  00086	48 8b 95 f0 01
	00 00		 mov	 rdx, QWORD PTR x$[rbp]
  0008d	48 8d 4d 10	 lea	 rcx, QWORD PTR s$[rbp]
  00091	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit

; 895  : }

  00096	48 8b f8	 mov	 rdi, rax
  00099	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_memory$rtcFrameData
  000a4	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a9	48 8b c7	 mov	 rax, rdi
  000ac	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000b3	48 33 cd	 xor	 rcx, rbp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
stbi_load_from_memory ENDP
_TEXT	ENDS
END
