<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StgSharp</name>
    </assembly>
    <members>
        <member name="M:StgSharp.Operation.GetKeyStatus(StgSharp.Graphics.Form,StgSharp.Operation.Key)">
            <summary>
            Get the status of a certain key on the keyboard.
            </summary>
            <param name="form"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:StgSharp.Graphics.glLoader">
            <summary>
            Function handler to load an opengl function by serching its name.
            </summary>
            <param name="name">the name of the Opengl function</param>
            <returns>An intptr value representing the pointer to the function</returns>
        </member>
        <member name="T:StgSharp.Graphics.Form">
             <summary>
            
             </summary>
        </member>
        <member name="P:StgSharp.Graphics.Form.Height">
            <summary>
            Height of this form, represent in <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="P:StgSharp.Graphics.Form.Size">
            <summary>
            Width of this form, represent in <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="P:StgSharp.Graphics.Form.Width">
            <summary>
            Width of this form, represent in <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.Form.Init">
            <summary>
            Necessary operation to init graphic elements this form.
            </summary>
            <param name="gl">OpenGL library binded to current form.</param>
        </member>
        <member name="M:StgSharp.Graphics.Form.Main">
            <summary>
            Behaviour of current form when in a frame cycle.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.Form.MakeAsCurrentContext">
            <summary>
            Init an OpenGl context if current form has not been binded to any context. and set the context binded to
            current form as current OpenGL context.
            </summary>
            <exception cref="T:System.Exception">
            Something goes wrong and StgSharp fails in creating a new OpenGL context.
            </exception>
        </member>
        <member name="M:StgSharp.Graphics.Form.SetMetadata(System.Int32,System.Int32,System.String,System.IntPtr,StgSharp.Graphics.Form)">
            <summary>
            Set all necessary metadata to current form instance
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.Form.SetSize(StgSharp.Math.Vec2d)">
            <summary>
            Resize the current form
            </summary>
            <param name="size">
            A <see cref="T:StgSharp.Math.Vec2d"/> (width,height) representing the new size of current form
            </param>
        </member>
        <member name="M:StgSharp.Graphics.Form.SetSize(System.Int32,System.Int32)">
            <summary>
            Resize the current form
            </summary>
            <param name="width">New width of the window</param>
            <param name="height">New height of the window</param>
        </member>
        <member name="M:StgSharp.Graphics.Form.SetSizeLimit(StgSharp.Math.Vec2d,StgSharp.Math.Vec2d)">
            <summary>
            Set the size limit of current form
            </summary>
            <param name="minSize">
            Minimun size of current form. In form of a <see cref="T:StgSharp.Math.Vec2d"/> of (width,height)
            </param>
            <param name="maxSize">
            Maximum size of current form. In form of a <see cref="T:StgSharp.Math.Vec2d"/> of (width,height)
            </param>
        </member>
        <member name="M:StgSharp.Graphics.Form.SetSizeLimit(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the size limit of current form
            </summary>
            <param name="minWidth">Minimum width of current form</param>
            <param name="minHeight">Minimum height of current form</param>
            <param name="maxWidth">Maximum width of current form</param>
            <param name="maxHeight">Maximum height of current form</param>
        </member>
        <member name="M:StgSharp.Graphics.Form.Show">
            <summary>
            Init this form and render it on screen, and respond with operation
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.Form.CreateElementBuffer(System.Int32)">
            <summary>
            Create a set of <see cref="T:StgSharp.Graphics.ElementBuffer"/>.
            </summary>
            <param name="count">Amount of EBO to be created.</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.Form.CreateTexture(System.Int32)">
            <summary>
            Create a sets of <see cref="T:StgSharp.Graphics.Texture"/>
            </summary>
            <param name="count">Amount of textures to be crated.</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.Form.CreateVertexArray(System.Int32)">
            <summary>
            Create a set of <see cref="T:StgSharp.Graphics.VertexArray"/>.
            </summary>
            <param name="count">Amount of VAO to be crated.</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.Form.CreateVertexBuffer(System.Int32)">
            <summary>
            Create aset of <see cref="T:StgSharp.Graphics.VertexBuffer"/>.
            </summary>
            <param name="count">Amount of Object to be created.</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.Form.CreateShaderProgram">
            <summary>
            Create an instance of <see cref="T:StgSharp.Graphics.Shader"/> program
            </summary>
            <returns>New instance of <see cref="T:StgSharp.Graphics.Shader"/> instance. </returns>
        </member>
        <member name="T:StgSharp.Graphics.RenderActivityAttribute">
            <summary>
            Mark that a method in a <see cref="T:StgSharp.Graphics.Form"/> 
            should be called when rendering.
            </summary>
        </member>
        <member name="T:StgSharp.Graphics.RenderPriority">
            <summary>
            Priority level of a render activity.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Pre_1">
            <summary>
            One level higher than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Pre_2">
            <summary>
            Two level higher than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Pre_3">
            <summary>
            Three level higher than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Aft_1">
            <summary>
            One level lower than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Aft_2">
            <summary>
            Two level lower than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Aft_3">
            <summary>
            Three level lower than <see  cref="F:StgSharp.Graphics.RenderPriority.Default"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Highest">
            <summary>
            Highest priority, in <see cref="T:StgSharp.Graphics.RenderPriority"/>, it is <see cref="F:StgSharp.Graphics.RenderPriority.Pre_3"/>.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Default">
            <summary>
            Default priority, usually <see cref="M:StgSharp.Graphics.Form.Main"/> is in this priority.
            </summary>
        </member>
        <member name="F:StgSharp.Graphics.RenderPriority.Least">
            <summary>
            Lowest priority, in <see cref="T:StgSharp.Graphics.RenderPriority"/>, it is <see cref="F:StgSharp.Graphics.RenderPriority.Aft_3"/>.
            </summary>
        </member>
        <member name="T:StgSharp.Graphics.BufferObjectBase">
            <summary>
            Interface of all kinds OpenGL buffer objects
            </summary>
        </member>
        <member name="P:StgSharp.Graphics.BufferObjectBase.Item(System.Int32)">
            <summary>
            Get the only handle to one of the Object instance
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.BufferObjectBase.Bind(System.Int32)">
            <summary>
            Bind a buffer instance to OpenGL
            </summary>
            <param name="index">Index of handle of the object in this instance to be bind</param>
        </member>
        <member name="M:StgSharp.Graphics.BufferObjectBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:StgSharp.Graphics.ElementBuffer">
            <summary>
            A collecion of handle to Element Buffer Object in OpenGL.
            Each <see langword="uint"/> value indexed from instance of this class this
            is the only handle to one Element Buffer Object.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.Texture.LoadTexture(System.Int32,System.String,StgSharp.Graphics.ImageLoader)">
            <summary>
            </summary>
            <param name="name"> </param>
            <param name="index"> </param>
            <param name="loader"> </param>
        </member>
        <member name="M:StgSharp.Graphics.VertexBuffer.SetValue``1(System.Int32,``0,StgSharp.Graphics.BufferUsage)">
            <summary>
            Set data to current vertex buffer object
            </summary>
            <typeparam name="T">Type of bufferData</typeparam>
            <param name="index">Index to find certain VBO in this instance</param>
            <param name="bufferData">Data to write in</param>
            <param name="usage">How OpenGL use these data, defined by <see cref="T:StgSharp.Graphics.BufferUsage"/></param>
        </member>
        <member name="M:StgSharp.Graphics.VertexBuffer.SetValueArray``1(System.Int32,``0[],StgSharp.Graphics.BufferUsage)">
            <summary>
            Set data to current vertex buffer object
            </summary>
            <typeparam name="T">Type of bufferData</typeparam>
            <param name="index">Index to find certain VBO in this instance</param>
            <param name="bufferArray">A array of data to write in</param>
            <param name="usage">How OpenGL use these data, defined by <see cref="T:StgSharp.Graphics.BufferUsage"/></param>
        </member>
        <member name="M:StgSharp.Graphics.VertexBuffer.Unbind">
             <summary>
            
             </summary>
        </member>
        <member name="M:StgSharp.Graphics.glManager.LoadGLapi(StgSharp.Graphics.Form)">
            <summary>
            Load all aupportable OpenGL APIs and bind them to given <see cref="T:StgSharp.Graphics.Form"/> context.
            </summary>
            <param name="form">The <see cref="T:StgSharp.Graphics.Form"/> used as current OpenGL context</param>
            <param name="loader">A delegate to get address of OprnGL api</param>
        </member>
        <member name="M:StgSharp.Graphics.glManager.LoadGLfunc(System.String)">
            <summary>
            Get the function pointer of given OpenGL api name
            </summary>
            <param name="name">Name of the OpenGL api</param>
            <returns>The funtion pointer of the api in form of <see cref="T:System.IntPtr"/></returns>
        </member>
        <member name="T:StgSharp.Graphics.glHandle">
            <summary>
            A handle to an OpenGL object,
            must be indexed from a <see cref="T:StgSharp.Graphics.glHandleSet"/>.
            Direct call will cause <see langword="InvalidOperationException"/>
            </summary>
        </member>
        <member name="T:StgSharp.Graphics.glHandleSet">
            <summary>
            A handle to an OpenGL object.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.glHandleSet.Release">
            <summary>
            Release all resource in this handle.
            This will release all resource in this <see cref="T:StgSharp.Graphics.glHandle"/>.
            This <see langword="glHandle"/> will be not usable.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderEdit.IglConvertable.SetAllUniforms">
            <summary>
            
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderEdit.IglConvertable.GainAllUniforms(StgSharp.Graphics.ShaderProgram,System.String[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderEdit.IglConvertable.DisplayGLtypeDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderEdit.IglConvertable.GetConvertedGLtype">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.Shader.AttachTo(System.Int32,StgSharp.Graphics.ShaderProgram)">
            <summary>
            Attach one shader code to a shader program.
            </summary>
            <param name="target">Shader program to attach</param>
            <param name="index">Index of shader code in current shader code set.</param>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.#ctor(StgSharp.Graphics.Form)">
            <summary>
            Init a program with no shader attached.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.GetUniform``1(System.String)">
            <summary>
            Get a uniform form current shader,
            the value type of the uniform should be provided.
            </summary>
            <param name="name">Name of the Uniform in shader code</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.GetUniform``2(System.String)">
            <summary>
            Get a uniform form current shader,
            the value type of the uniform should be provided.
            </summary>
            <param name="name">Name of the Uniform in shader code</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.GetUniform``3(System.String)">
            <summary>
            Get a uniform form current shader,
            the value type of the uniform should be provided.
            </summary>
            <param name="name">Name of the Uniform in shader code</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.GetUniform``4(System.String)">
            <summary>
            Get a uniform form current shader,
            the value type of the uniform should be provided.
            </summary>
            <param name="name">Name of the Uniform in shader code</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.Link">
            <summary>
            Link the shader to current context.
            </summary>
        </member>
        <member name="M:StgSharp.Graphics.ShaderProgram.Use">
            <summary>
            Let the current context use this shader.
            </summary>
        </member>
        <member name="P:StgSharp.IEntity.CollisionSensor">
            <summary>
            A sensor used for cheking out if a bullet hit a player or something else
            </summary>
        </member>
        <member name="P:StgSharp.IEntity.Location">
            <summary>
            A 2D vector presenting the position of an enemy entity, position can also be visited by X, Y
            </summary>
        </member>
        <member name="P:StgSharp.IEntity.X">
            <summary>
            X position of an enenmy entity
            </summary>
        </member>
        <member name="P:StgSharp.IEntity.Y">
            <summary>
            Y position of an enemy entity
            </summary>
        </member>
        <member name="M:StgSharp.StgSharp.InitGL(System.Int32,System.Int32)">
            <summary>
            Init an instance of OpenGL program,
            This method should be called before any other StgSharp api.
            </summary>
        </member>
        <member name="F:StgSharp.StgSharp.version">
            <summary>
            Version of current StgSharp platform.
            Main version represent in hundred's digit,
            and sub version represent in ten's digit.
            </summary>
        </member>
        <member name="M:StgSharp.StgSharp.WriteLog(System.String,StgSharp.LogType)">
            <summary>
            Write a log message to log file, and mark the level of this message.
            </summary>
            <param name="message">A string contains information of how current evironment runs.</param>
            <param name="logType">The severity of current message.</param>
        </member>
        <member name="T:StgSharp.Math.GLclampf">
            <summary>
            OpenGL numeric type.
            An IEEE-754 floating-point value, clamped to the range [0,1].
            </summary>
        </member>
        <member name="T:StgSharp.Math.GLclampd">
            <summary>
            OpenGL numeric type.
            An IEEE-754 double precision floating-point value, clamped to the range [0,1].
            </summary>
        </member>
        <member name="T:StgSharp.Math.Vec2d">
            <summary>
            A two dimension vector defined by two elements.
            Vec2Ds in StgSharp are defaultly usaed as colum vector. 
            </summary>
        </member>
        <member name="M:StgSharp.Math.Scaler.ASin(System.Single)">
            <summary>
            Reurns the value of ArcSin(x)
            </summary>
            <param name="x">The sine value of the angle</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:StgSharp.Math.Scaler.Exp(System.Single)">
            <summary>
            Get the value of E ^ x;
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Math.Scaler.Log(System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns>
            Returns the value of ln(x).
            </returns>
        </member>
        <member name="M:StgSharp.Math.Scaler.Pow(System.Single,System.Single)">
            <summary>
            calculate the value of x^y
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>Returns the value of x^y</returns>
        </member>
        <member name="M:StgSharp.Math.Scaler.LowProceisionRandom">
            <summary>
            returns a random float number between 0 and 1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Math.Scaler.Random">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Math.Scaler.RandomSeed">
            <summary>
            Generates a random seed in int value.
            </summary>
            <returns></returns>
        </member>
        <member name="T:StgSharp.Geometries.Arc">
            <summary>
            Part of a circle. All points on a arc has the same distance to their center.
            </summary>
        </member>
        <member name="T:StgSharp.Geometries.Circle">
            <summary>
            A collection of all point on the same plain and has the same distance to a point
            </summary>
        </member>
        <member name="F:StgSharp.Geometries.PartialPlainCoordinate.origin">
            <summary>
            The origin of this coordinate.
            </summary>
        </member>
        <member name="P:StgSharp.Geometries.PartialPlainCoordinate.axis_H">
            <summary>
            The horizontial axis of the coordinate.
            Point to the right direction.
            </summary>
        </member>
        <member name="P:StgSharp.Geometries.PartialPlainCoordinate.axis_V">
            <summary>
            The vertical axis of the coordinate.
            Point to the top direction.
            </summary>
        </member>
        <member name="T:StgSharp.Geometries.UnusedVertexException">
            <summary>
            当几何体调用了过多的CalcVec方法时，产生UnusedVertexException异常
            </summary>
        </member>
        <member name="T:StgSharp.Geometries.GetLocationHandler">
            <summary>
            Caculate the movement of a point.
            </summary>
            <param name="tick">The game tick represent time passed by</param>
            <returns>A 3d vector representing movement</returns>
        </member>
        <member name="M:StgSharp.Geometries.Line.MoveBeginPoint(System.Int32)">
            <summary>
            Move begin side of a line.
            It is recommended to override this function rather than
            loading an <see cref="T:StgSharp.Geometries.GetLocationHandler"/> with same function.
            </summary>
            <param name="tick">Time passed since current line was created.</param>
        </member>
        <member name="M:StgSharp.Geometries.Line.MoveEndPoint(System.Int32)">
            <summary>
            Move end side of a line.
            It is recommended to override this function rather than
            loading an <see cref="T:StgSharp.Geometries.GetLocationHandler"/> with same function.
            </summary>
            <param name="tick">Time passed since current line was created.</param>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Geometries.Parallelogram.MoveVertex2(System.Int32)">
            <summary>
            Move the third vertix. this is a useless method for Parallelograms.
            </summary>
            <param name="tick">Current time tick</param>
            <returns></returns>
            <exception cref="T:StgSharp.Geometries.UnusedVertexException">Geometry overdefined</exception>
        </member>
        <member name="M:StgSharp.Geometries.Parallelogram.MoveVertex3(System.Int32)">
            <summary>
            Move the third vertix. This method is useless for Parallelograms.
            </summary>
            <param name="tick">Current time tick</param>
            <returns></returns>
            <exception cref="T:StgSharp.Geometries.UnusedVertexException">Geometry overdefined</exception>
        </member>
        <member name="T:StgSharp.Geometries.PlainGeometry">
            <summary>
            平面几何体。包含三角形，对称四边形，自由多边形等。最多可由16个点参数定义。
            </summary>
        </member>
        <member name="P:StgSharp.Geometries.PlainGeometry.BornTime">
            <summary>
            Tick time this geometry eas crested
            </summary>
        </member>
        <member name="M:StgSharp.Geometries.PlainGeometry.GetAllSides">
            <summary>
            Get all sides of this <see cref="T:StgSharp.Geometries.PlainGeometry"/>.
            </summary>
            <returns>A array contains all straight <see cref="T:StgSharp.Geometries.Line"/>s of current geometry item.</returns>
        </member>
        <member name="M:StgSharp.Geometries.PlainGeometry.GetPlain">
            <summary>
            Get a flat <see cref="T:StgSharp.Geometries.Plain"/> cincide with current geometry.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StgSharp.Geometries.Point.Update(System.UInt32)">
            <summary>
            Update the coordinate of the point. If this is a moving point,
            (Points on sides or surface if other geometry items)
            please do not define any motion here, codes will be ignored by program
            </summary>
            <param name="tick">Time passes since the program begin, counted by frames</param>
        </member>
        <member name="M:StgSharp.Geometries.Rectangle.MovCenter(System.UInt32)">
            <summary>
            计算中心点相对于参考原点的位移
            </summary>
            <param name="tick">当前游戏刻</param>
            <returns></returns>
        </member>
        <member name="T:StgSharp.Geometries.Square">
            <summary>
            A square
            </summary>
        </member>
        <member name="T:StgSharp.Logic.DynamicArrayList`1">
            <summary>
            A linear data structure with dynamic length.
            It contains a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:System.Array"/>,
            each <see cref="T:System.Array"/> is twice longer than the former one.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StgSharp.Logic.DynamicArrayList`1.#ctor(System.Int32)">
            <summary>
            Init a <see cref="T:StgSharp.Logic.DynamicArrayList`1"/> with a certain amount of elements prepared.
            </summary>
            <param name="count">Amount of elements to be prepared.</param>
        </member>
        <member name="M:StgSharp.Logic.DynamicArrayList`1.#ctor(System.Int32,`0)">
            <summary>
            Create a new instance of <see cref="T:StgSharp.Logic.DynamicArrayList`1"/>,
            and fill the begining ones of elemtns as given instance.
            </summary>
            <param name="count">Amount of beginning elements to be filled</param>
            <param name="instace"></param>
        </member>
        <member name="P:StgSharp.Logic.DynamicArrayList`1.Length">
            <summary>
            Length of this <see cref="T:StgSharp.Logic.DynamicArrayList`1"/>
            </summary>
        </member>
        <member name="T:StgSharp.Logic.Bool2">
            <summary>
            A pair of <see cref="T:System.Boolean"/> value
            </summary>
        </member>
        <member name="F:StgSharp.Logic.Bool2.bool0">
            <summary>
            The first <see cref="T:System.Boolean"/> value.
            </summary>
        </member>
        <member name="F:StgSharp.Logic.Bool2.bool1">
            <summary>
            The second <see cref="T:System.Boolean"/> value.
            </summary>
        </member>
        <member name="F:StgSharp.Logic.Bool2.Value">
            <summary>
            A <see cref="T:System.UInt16"/> value.
            The lower byte is <see cref="F:StgSharp.Logic.Bool2.bool0"/>,
            and higher byte is <see cref="F:StgSharp.Logic.Bool2.bool1"/>.
            </summary>
        </member>
        <member name="T:StgSharp.TimeSpanProvider">
            <summary>
            A microsecond-accuracy timer. It will refresh every a certain time span.
            </summary>
        </member>
        <member name="M:StgSharp.TimeSpanProvider.#ctor(System.Int64,StgSharpDebug.Logic.TimeSourceProviderBase)">
            <summary>
            Create a new <see cref="T:StgSharp.TimeSpanProvider"/> and define the length of time span. Length of a single time span is defined in microseconds.
            </summary>
            <param name="spanLength"></param>
            <parma name="provider"></parma>
        </member>
        <member name="M:StgSharp.TimeSpanProvider.#ctor(System.Double,StgSharpDebug.Logic.TimeSourceProviderBase)">
            <summary>
            Create a new <see cref="T:StgSharp.TimeSpanProvider"/> and define the length of time span. 
            Length of a single time span is defined in seconds.
            </summary>
            <param name="spanLength"></param>
            <parma name="provider"></parma>
        </member>
        <member name="M:StgSharp.TimeSpanProvider.#ctor(System.Int64,System.Int32,StgSharpDebug.Logic.TimeSourceProviderBase)">
            <summary>
            Create a new <see cref="T:StgSharp.TimeSpanProvider"/> and define the length of time span. Length of a single time span is defined in microseconds.
            </summary>
            <param name="spanLength"></param>
            <parma name="provider"></parma>
        </member>
        <member name="P:StgSharp.TimeSpanProvider.DefaultProvider">
            <summary>
            Time source provider provided in <see cref="T:StgSharp.StgSharp"/> internal framework.
            </summary>
        </member>
        <member name="P:StgSharp.TimeSpanProvider.SpanRefreshCallback">
            <summary>
            The method this <see cref="T:StgSharp.TimeSpanProvider"/> will call every time a new time span started.
            </summary>
        </member>
        <member name="M:StgSharp.Graphic.Camera.GainAllUniforms(StgSharp.Graphics.ShaderProgram,System.String[])">
            <summary>
            Get all uniform related to this <see cref="T:StgSharp.Graphic.Camera"/>.
            </summary>
            <param name="source">Shader program requires this camera.</param>
            <param name="uniformName">
            Name of all related uniforms.
            If you fallow form from <see cref="M:StgSharp.Graphics.ShaderEdit.IglConvertable.DisplayGLtypeDefinition"/>
            </param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:Windows.Win32.Foundation.COLORREF">
            <summary>The COLORREF value is used to specify an RGB color.</summary>
            <remarks>
            <para>When specifying an explicit [RGB](/windows/desktop/api/Wingdi/nf-wingdi-rgb) color, the **COLORREF** value has the following hexadecimal form: `0x00bbggrr` The low-order byte contains a value for the relative intensity of red; the second byte contains a value for green; and the third byte contains a value for blue. The high-order byte must be zero. The maximum value for a single byte is 0xFF. To create a **COLORREF** color value, use the [RGB](/windows/desktop/api/Wingdi/nf-wingdi-rgb) macro. To extract the individual values for the red, green, and blue components of a color value, use the [**GetRValue**](/windows/desktop/api/Wingdi/nf-wingdi-getrvalue), [GetGValue](/windows/desktop/api/Wingdi/nf-wingdi-getgvalue), and [GetBValue](/windows/desktop/api/Wingdi/nf-wingdi-getbvalue) macros, respectively.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/colorref#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.PCSTR">
            <summary>
            A pointer to a null-terminated, constant, ANSI character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.RECT">
            <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
            <remarks>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.left">
            <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.top">
            <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.right">
            <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.bottom">
            <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.MSG">
            <summary>Contains message information from a thread's message queue.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.hwnd">
            <summary>
            <para>Type: <b>HWND</b> A handle to the window whose window procedure receives the message. This member is <b>NULL</b> when the message is a thread message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.message">
            <summary>
            <para>Type: <b>UINT</b> The message identifier. Applications can only use the low word; the high word is reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.wParam">
            <summary>
            <para>Type: <b>WPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.lParam">
            <summary>
            <para>Type: <b>LPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.time">
            <summary>
            <para>Type: <b>DWORD</b> The time at which the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.pt">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> The cursor position, in screen coordinates, when the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA">
            <summary>Contains the window class attributes that are registered by the RegisterClass function. (ANSI)</summary>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines WNDCLASS as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.style">
            <summary>
            <para>Type: <b>UINT</b> The class style(s). This member can be any combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes#class-styles">Class Styles</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.lpfnWndProc">
            <summary>
            <para>Type: <b>WNDPROC</b> A pointer to the window procedure. You must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the window procedure. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.cbClsExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.cbWndExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an application uses <b>WNDCLASS</b> to register a dialog box created by using the <b>CLASS</b> directive in the resource file, it must set this member to <b>DLGWINDOWEXTRA</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.hInstance">
            <summary>
            <para>Type: <b>HINSTANCE</b> A handle to the instance that contains the window procedure for the class.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.hIcon">
            <summary>
            <para>Type: <b>HICON</b> A handle to the class icon. This member must be a handle to an icon resource. If this member is <b>NULL</b>, the system provides a default icon.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.hCursor">
            <summary>
            <para>Type: <b>HCURSOR</b> A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <b>NULL</b>, an application must explicitly set the cursor shape whenever the mouse moves into the application's window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.hbrBackground">
            <summary>
            <para>Type: <b>HBRUSH</b> A handle to the class background brush. This member can be a handle to the physical brush to be used for painting the background, or it can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the chosen color). If a color value is given, you must convert it to one of the following <b>HBRUSH</b> types:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.lpszMenuName">
            <summary>
            <para>Type: <b>LPCTSTR</b> The resource name of the class menu, as the name appears in the resource file. If you use an integer to identify the menu, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. If this member is <b>NULL</b>, windows belonging to this class have no default menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSA.lpszClassName">
            <summary>
            <para>Type: <b>LPCTSTR</b> A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <b>lpszClassName</b>; the high-order word must be zero.</para>
            <para>If <b>lpszClassName</b> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. The maximum length for <b>lpszClassName</b> is 256. If <b>lpszClassName</b> is greater than the maximum length, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function will fail.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassa#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW">
            <summary>Contains the window class attributes that are registered by the RegisterClass function. (Unicode)</summary>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines WNDCLASS as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.style">
            <summary>
            <para>Type: <b>UINT</b> The class style(s). This member can be any combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">Class Styles</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.lpfnWndProc">
            <summary>
            <para>Type: <b>WNDPROC</b> A pointer to the window procedure. You must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the window procedure. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.cbClsExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.cbWndExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an application uses <b>WNDCLASS</b> to register a dialog box created by using the <b>CLASS</b> directive in the resource file, it must set this member to <b>DLGWINDOWEXTRA</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.hInstance">
            <summary>
            <para>Type: <b>HINSTANCE</b> A handle to the instance that contains the window procedure for the class.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.hIcon">
            <summary>
            <para>Type: <b>HICON</b> A handle to the class icon. This member must be a handle to an icon resource. If this member is <b>NULL</b>, the system provides a default icon.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.hCursor">
            <summary>
            <para>Type: <b>HCURSOR</b> A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <b>NULL</b>, an application must explicitly set the cursor shape whenever the mouse moves into the application's window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.hbrBackground">
            <summary>
            <para>Type: <b>HBRUSH</b> A handle to the class background brush. This member can be a handle to the physical brush to be used for painting the background, or it can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the chosen color). If a color value is given, you must convert it to one of the following <b>HBRUSH</b> types:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.lpszMenuName">
            <summary>
            <para>Type: <b>LPCTSTR</b> The resource name of the class menu, as the name appears in the resource file. If you use an integer to identify the menu, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. If this member is <b>NULL</b>, windows belonging to this class have no default menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW.lpszClassName">
            <summary>
            <para>Type: <b>LPCTSTR</b> A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <b>lpszClassName</b>; the high-order word must be zero.</para>
            <para>If <b>lpszClassName</b> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. The maximum length for <b>lpszClassName</b> is 256. If <b>lpszClassName</b> is greater than the maximum length, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function will fail.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.DestroyCursorSafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.DestroyCursor(Windows.Win32.UI.WindowsAndMessaging.HCURSOR)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.FreeLibrarySafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT">
            <summary>The GLYPHMETRICSFLOAT structure contains information about the placement and orientation of a glyph in a character cell.</summary>
            <remarks>The values of <b>GLYPHMETRICSFLOAT</b> are specified as notional units.</remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT.gmfBlackBoxX">
            <summary>Specifies the width of the smallest rectangle (the glyph's black box) that completely encloses the glyph.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT.gmfBlackBoxY">
            <summary>Specifies the height of the smallest rectangle (the glyph's black box) that completely encloses the glyph.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT.gmfptGlyphOrigin">
            <summary>Specifies the x and y coordinates of the upper-left corner of the smallest rectangle that completely encloses the glyph.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT.gmfCellIncX">
            <summary>Specifies the horizontal distance from the origin of the current character cell to the origin of the next character cell.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT.gmfCellIncY">
            <summary>Specifies the vertical distance from the origin of the current character cell to the origin of the next character cell.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR">
            <summary>The LAYERPLANEDESCRIPTOR structure describes the pixel format of a drawing surface.</summary>
            <remarks>Please notice, as documented above, that certain layer plane properties are not supported in the current implementation. The implementation is the Microsoft GDI software implementation of OpenGL. Hardware manufacturers that enhance parts of OpenGL may support some layer plane properties not supported by the generic implementation.</remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.nSize">
            <summary>Specifies the size of this data structure. Set this value to <b>sizeof</b>(<b>LAYERPLANEDESCRIPTOR</b>).</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.nVersion">
            <summary>Specifies the version of this data structure. Set this value to 1.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.dwFlags">
            <summary>
            <para>A set of bit flags that specify properties of the layer plane. The properties are generally not mutually exclusive; any combination of bit flags can be set, with the exceptions noted. The following bit flag constants are defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-layerplanedescriptor#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.iPixelType">
            <summary>
            <para>Specifies the type of pixel data. The following types are defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-layerplanedescriptor#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cColorBits">
            <summary>Specifies the number of color bitplanes in each color buffer. For RGBA pixel types, it is the size of the color buffer, excluding the alpha bitplanes. For color-index pixels, it is the size of the color-index buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cRedBits">
            <summary>Specifies the number of red bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cRedShift">
            <summary>Specifies the shift count for red bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cGreenBits">
            <summary>Specifies the number of green bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cGreenShift">
            <summary>Specifies the shift count for green bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cBlueBits">
            <summary>Specifies the number of blue bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cBlueShift">
            <summary>Specifies the shift count for blue bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAlphaBits">
            <summary>Specifies the number of alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAlphaShift">
            <summary>Specifies the shift count for alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAccumBits">
            <summary>Specifies the total number of bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAccumRedBits">
            <summary>Specifies the number of red bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAccumGreenBits">
            <summary>Specifies the number of green bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAccumBlueBits">
            <summary>Specifies the number of blue bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAccumAlphaBits">
            <summary>Specifies the number of alpha bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cDepthBits">
            <summary>Specifies the depth of the depth (z-axis) buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cStencilBits">
            <summary>Specifies the depth of the stencil buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.cAuxBuffers">
            <summary>Specifies the number of auxiliary buffers. Auxiliary buffers are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.iLayerPlane">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.bReserved">
            <summary>Not used. Must be zero.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR.crTransparent">
            <summary>When the LPD_TRANSPARENT flag is set, specifies the transparent color or index value. Typically the value is zero.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR">
            <summary>The PIXELFORMATDESCRIPTOR structure describes the pixel format of a drawing surface.</summary>
            <remarks>Please notice carefully, as documented above, that certain pixel format properties are not supported in the current generic implementation. The generic implementation is the Microsoft GDI software implementation of OpenGL. Hardware manufacturers may enhance parts of OpenGL, and may support some pixel format properties not supported by the generic implementation.</remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.nSize">
            <summary>Specifies the size of this data structure. This value should be set to <b>sizeof</b>(<b>PIXELFORMATDESCRIPTOR</b>).</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.nVersion">
            <summary>Specifies the version of this data structure. This value should be set to 1.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.dwFlags">
            <summary>
            <para>A set of bit flags that specify properties of the pixel buffer. The properties are generally not mutually exclusive; you can set any combination of bit flags, with the exceptions noted. The following bit flag constants are defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-pixelformatdescriptor#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.iPixelType">
            <summary>
            <para>Specifies the type of pixel data. The following types are defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-pixelformatdescriptor#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cColorBits">
            <summary>Specifies the number of color bitplanes in each color buffer. For RGBA pixel types, it is the size of the color buffer, excluding the alpha bitplanes. For color-index pixels, it is the size of the color-index buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cRedBits">
            <summary>Specifies the number of red bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cRedShift">
            <summary>Specifies the shift count for red bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cGreenBits">
            <summary>Specifies the number of green bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cGreenShift">
            <summary>Specifies the shift count for green bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cBlueBits">
            <summary>Specifies the number of blue bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cBlueShift">
            <summary>Specifies the shift count for blue bitplanes in each RGBA color buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAlphaBits">
            <summary>Specifies the number of alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAlphaShift">
            <summary>Specifies the shift count for alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAccumBits">
            <summary>Specifies the total number of bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAccumRedBits">
            <summary>Specifies the number of red bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAccumGreenBits">
            <summary>Specifies the number of green bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAccumBlueBits">
            <summary>Specifies the number of blue bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAccumAlphaBits">
            <summary>Specifies the number of alpha bitplanes in the accumulation buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cDepthBits">
            <summary>Specifies the depth of the depth (z-axis) buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cStencilBits">
            <summary>Specifies the depth of the stencil buffer.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.cAuxBuffers">
            <summary>Specifies the number of auxiliary buffers. Auxiliary buffers are not supported.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.bReserved">
            <summary>Specifies the number of overlay and underlay planes. Bits 0 through 3 specify up to 15 overlay planes and bits 4 through 7 specify up to 15 underlay planes.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.dwLayerMask">
            <summary>Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.dwVisibleMask">
            <summary>Specifies the transparent color or index of an underlay plane. When the pixel type is RGBA, <b>dwVisibleMask</b> is a transparent RGB color value. When the pixel type is color index, it is a transparent index value.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR.dwDamageMask">
            <summary>Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.OpenGL.POINTFLOAT">
            <summary>The POINTFLOAT structure contains the x and y coordinates of a point.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-pointfloat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.POINTFLOAT.x">
            <summary>Specifies the horizontal (x) coordinate of a point.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.OpenGL.POINTFLOAT.y">
            <summary>Specifies the vertical (y) coordinate of a point.</summary>
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "GDI32.dll".
            </content>
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "OPENGL32.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeleteObject(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
            <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-deleteobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ChoosePixelFormat(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.ChoosePixelFormat(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.ChoosePixelFormat(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)">
            <summary>The ChoosePixelFormat function attempts to match an appropriate pixel format supported by a device context to a given pixel format specification.</summary>
            <param name="hdc">Specifies the device context that the function examines to determine the best match for the pixel format descriptor pointed to by <i>ppfd</i>.</param>
            <param name="ppfd">
            <para>Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that specifies the requested pixel format. In this context, the members of the <b>PIXELFORMATDESCRIPTOR</b> structure that <i>ppfd</i> points to are used as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-choosepixelformat#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a pixel format index (one-based) that is the closest match to the given pixel format descriptor. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>You must ensure that the pixel format matched by the <b>ChoosePixelFormat</b> function satisfies your requirements. For example, if you request a pixel format with a 24-bit RGB color buffer but the device context offers only 8-bit RGB color buffers, the function returns a pixel format with an 8-bit RGB color buffer.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DescribePixelFormat(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.UInt32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)">
            <summary>The DescribePixelFormat function obtains information about the pixel format identified by iPixelFormat of the device associated with hdc. The function sets the members of the PIXELFORMATDESCRIPTOR structure pointed to by ppfd with that pixel format data.</summary>
            <param name="hdc">Specifies the device context.</param>
            <param name="iPixelFormat">Index that specifies the pixel format. The pixel formats that a device context supports are identified by positive one-based integer indexes.</param>
            <param name="nBytes">The size, in bytes, of the structure pointed to by <i>ppfd</i>. The <b>DescribePixelFormat</b> function stores no more than <i>nBytes</i> bytes of data to that structure. Set this value to <b>sizeof</b>(<b>PIXELFORMATDESCRIPTOR</b>).</param>
            <param name="ppfd">Pointer to a <b>PIXELFORMATDESCRIPTOR</b> structure whose members the function sets with pixel format data. The function stores the number of bytes copied to the structure in the structure's <b>nSize</b> member. If, upon entry, <i>ppfd</i> is <b>NULL</b>, the function writes no data to the structure. This is useful when you only want to obtain the maximum pixel format index of a device context.</param>
            <returns>
            <para>If the function succeeds, the return value is the maximum pixel format index of the device context. In addition, the function sets the members of the <b>PIXELFORMATDESCRIPTOR</b> structure pointed to by <i>ppfd</i> according to the specified pixel format. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-describepixelformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeleteEnhMetaFile(Windows.Win32.Graphics.Gdi.HENHMETAFILE)">
            <summary>The DeleteEnhMetaFile function deletes an enhanced-format metafile or an enhanced-format metafile handle.</summary>
            <param name="hmf">A handle to an enhanced metafile.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>If the <i>hemf</i> parameter identifies an enhanced metafile stored in memory, the <b>DeleteEnhMetaFile</b> function deletes the metafile. If <i>hemf</i> identifies a metafile stored on a disk, the function deletes the metafile handle but does not destroy the actual metafile. An application can retrieve the file by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getenhmetafilea">GetEnhMetaFile</a> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetEnhMetaFilePixelFormat(System.Runtime.InteropServices.SafeHandle,System.UInt32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetEnhMetaFilePixelFormat(Windows.Win32.Graphics.Gdi.HENHMETAFILE,System.UInt32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetEnhMetaFilePixelFormat(Windows.Win32.Graphics.Gdi.HENHMETAFILE,System.UInt32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)">
            <summary>The GetEnhMetaFilePixelFormat function retrieves pixel format information for an enhanced metafile.</summary>
            <param name="hemf">Identifies the enhanced metafile.</param>
            <param name="cbBuffer">Specifies the size, in bytes, of the buffer into which the pixel format information is copied.</param>
            <param name="ppfd">Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that contains the logical pixel format specification. The metafile uses this structure to record the logical pixel format specification.</param>
            <returns>
            <para>If the function succeeds and finds a pixel format, the return value is the size of the metafile's pixel format. If no pixel format is present, the return value is zero. If an error occurs and the function fails, the return value is GDI_ERROR. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>When an enhanced metafile specifies a pixel format in its <b>ENHMETAHEADER</b> structure and the pixel format fits in the buffer, the pixel format information is copied into <i>ppfd</i>. When <i>cbBuffer</i> is too small to contain the pixel format of the metafile, the pixel format is not copied to the buffer. In either case, the function returns the size of the metafile's pixel format. For information on metafile recording and other operations, see Enhanced Metafile Operations.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getenhmetafilepixelformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetPixelFormat(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The GetPixelFormat function obtains the index of the currently selected pixel format of the specified device context.</summary>
            <param name="hdc">Specifies the device context of the currently selected pixel format index returned by the function.</param>
            <returns>
            <para>If the function succeeds, the return value is the currently selected pixel format index of the specified device context. This is a positive, one-based index value. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getpixelformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetPixelFormat(Windows.Win32.Graphics.Gdi.HDC,System.Int32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.SetPixelFormat(Windows.Win32.Graphics.Gdi.HDC,System.Int32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetPixelFormat(Windows.Win32.Graphics.Gdi.HDC,System.Int32,Windows.Win32.Graphics.OpenGL.PIXELFORMATDESCRIPTOR*)">
            <summary>The SetPixelFormat function sets the pixel format of the specified device context to the format specified by the iPixelFormat index.</summary>
            <param name="hdc">Specifies the device context whose pixel format the function attempts to set.</param>
            <param name="format">Index that identifies the pixel format to set. The various pixel formats supported by a device context are identified by one-based indexes.</param>
            <param name="ppfd">Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that contains the logical pixel format specification. The system's metafile component uses this structure to record the logical pixel format specification. The structure has no other effect upon the behavior of the <b>SetPixelFormat</b> function.</param>
            <returns>
            <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If <i>hdc</i> references a window, calling the <b>SetPixelFormat</b> function also changes the pixel format of the window. Setting the pixel format of a window more than once can lead to significant complications for the Window Manager and for multithread applications, so it is not allowed. An application can only set the pixel format of a window one time. Once a window's pixel format is set, it cannot be changed. You should select a pixel format in the device context before calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglcreatecontext">wglCreateContext</a> function. The <b>wglCreateContext</b> function creates a rendering context for drawing on the device in the selected pixel format of the device context. An OpenGL window has its own pixel format. Because of this, only device contexts retrieved for the client area of an OpenGL window are allowed to draw into the window. As a result, an OpenGL window should be created with the WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. Additionally, the window class attribute should not include the CS_PARENTDC style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-setpixelformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SwapBuffers(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The SwapBuffers function exchanges the front and back buffers if the current pixel format for the window referenced by the specified device context includes a back buffer.</summary>
            <returns>
            <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If the current pixel format for the window referenced by the device context does not include a back buffer, this call has no effect and the content of the back buffer is undefined when the function returns. With multithread applications, flush the drawing commands in any other threads drawing to the same window before calling <b>SwapBuffers</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-swapbuffers#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)">
            <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process. (Unicode)</summary>
            <param name="lpModuleName">
            <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
            <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process. If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com/windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> to specify a memory location rather than a DLL name. The <b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the <b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely. This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetProcAddress(System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetProcAddress(Windows.Win32.Foundation.HMODULE,Windows.Win32.Foundation.PCSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetProcAddress(Windows.Win32.Foundation.HMODULE,Windows.Win32.Foundation.PCSTR)">
            <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
            <param name="hModule">
            <para>A handle to the DLL module that contains the function or variable. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            <para>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The spelling and case of a function name pointed to by <i>lpProcName</i> must be identical to that in the <b>EXPORTS</b> statement of the source DLL's module-definition (.def) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. The <i>lpProcName</i> parameter can identify the DLL function by specifying an ordinal value associated with the function in the <b>EXPORTS</b> statement. <b>GetProcAddress</b> verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the .def file. The function then uses the ordinal as an index to read the function's address from a function table. If the .def file does not number the functions consecutively from 1 to <i>N</i> (where <i>N</i> is the number of exported functions), an error can occur where <b>GetProcAddress</b> returns an invalid, non-NULL address, even though there is no function with the specified ordinal. If the function might not exist in the DLL module—for example, if the function  is available only on Windows Vista but the application  might be running on Windows XP—specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available, as shown in the following code fragment.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified module into the address space of the calling process. (LoadLibraryW)</summary>
            <param name="lpLibFileName">
            <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexw">LoadLibraryEx</a> with the `DONT_RESOLVE_DLL_REFERENCES` flag. The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension ".DLL" to the module name. To prevent the function from appending ".DLL" to the module name, include a trailing point character (.) in the module name string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>To enable or disable error messages displayed by the loader during DLL loads, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function. <b>LoadLibrary</b> can be used to load a library module into the address space of the process and return a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> to get the address of a DLL function. <b>LoadLibrary</b> can also be used to load other executable modules. For example, the function can specify an .exe file to get a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a>. However, do not use <b>LoadLibrary</b> to run an .exe file. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function. If the specified module is a DLL that is not already loaded for the calling process, the system calls the DLL's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function with the <b>DLL_PROCESS_ATTACH</b> value. If <b>DllMain</b> returns <b>TRUE</b>, <b>LoadLibrary</b> returns a handle to the module. If <b>DllMain</b> returns <b>FALSE</b>, the system unloads the DLL from the process address space and <b>LoadLibrary</b> returns <b>NULL</b>. It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>. For more information, see the Remarks section in <b>DllMain</b>. Module handles are not global or inheritable. A call to <b>LoadLibrary</b> by one process does not produce a handle that another process can use — for example, in calling <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>. The other process must make its own call to <b>LoadLibrary</b> for the module before calling <b>GetProcAddress</b>. If <i>lpFileName</i> does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first. If no file name extension is specified in the <i>lpFileName</i> parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file. The first directory searched is the directory containing the image file used to create the calling process (for more information, see the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function). Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process's installed directory to the PATH environment variable. If a relative path is specified, the entire relative path is appended to every token in the DLL search path list. To load a module from a relative path without searching any other path, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a> to get a nonrelative path and call <b>LoadLibrary</b> with the nonrelative path. For more information on the DLL search order, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>. The search path can be altered using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setdlldirectorya">SetDllDirectory</a> function. This solution is recommended instead of using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a> or hard-coding the full path to the DLL. If a path is specified and there is a redirection file for the application, the function searches for the module in the application's directory. If the module exists in the application's directory, <b>LoadLibrary</b> ignores the specified path and loads the module from the application's directory. If the module does not exist in the application's directory, <b>LoadLibrary</b> loads the module from the specified directory. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>. If you call <b>LoadLibrary</b> with the name of an assembly without a path specification and the assembly is listed in the system compatible manifest, the call is automatically redirected to the side-by-side assembly. The system maintains a per-process reference count on all loaded modules. Calling <b>LoadLibrary</b> increments the reference count. Calling the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function decrements the reference count. The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the reference count). <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables: <b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the DLL explicitly using <b>LoadLibrary</b> on versions of Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local storage functions instead of <b>_declspec(thread)</b>. For an example, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>. <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3> Do not use the <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function to retrieve a path to a DLL for a subsequent <b>LoadLibrary</b> call. The <b>SearchPath</b> function uses a different search order than <b>LoadLibrary</b> and it does not use safe process search mode unless this is explicitly enabled by calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore, <b>SearchPath</b> is likely to first search the user’s current working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current working directory, the path retrieved by <b>SearchPath</b> will point to the malicious DLL, which <b>LoadLibrary</b> will then load. Do not make assumptions about the operating system version based on a <b>LoadLibrary</b> call that searches for a DLL. If the application is running in an environment where the DLL is legitimately not present but a malicious version of the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended techniques described in <a href="https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetProcAddress(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglGetProcAddress(Windows.Win32.Foundation.PCSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetProcAddress(Windows.Win32.Foundation.PCSTR)">
            <summary>The wglGetProcAddress function returns the address of an OpenGL extension function for use with the current OpenGL rendering context.</summary>
            <returns>
            <para>When the function succeeds, the return value is the address of the extension function. When no current rendering context exists or the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The OpenGL library supports multiple implementations of its functions. Extension functions supported in one rendering context are not necessarily available in a separate rendering context. Thus, for a given rendering context in an application, use the function addresses returned by the <b>wglGetProcAddress</b> function only. The spelling and the case of the extension function pointed to by <i>lpszProc</i> must be identical to that of a function supported and implemented by OpenGL. Because extension functions are not exported by OpenGL, you must use <b>wglGetProcAddress</b> to get the addresses of vendor-specific extension functions. The extension function addresses are unique for each pixel format. All rendering contexts of a given pixel format share the same extension function addresses.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglDeleteContext(Windows.Win32.Graphics.OpenGL.HGLRC)">
            <summary>The wglDeleteContext function deletes a specified OpenGL rendering context.</summary>
            <returns>
            <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>It is an error to delete an OpenGL rendering context that is the current context of another thread. However, if a rendering context is the calling thread's current context, the <b>wglDeleteContext</b> function changes the rendering context to being not current before deleting it. The <b>wglDeleteContext</b> function does not delete the device context associated with the OpenGL rendering context when you call the <b>wglMakeCurrent</b> function. After calling <b>wglDeleteContext</b>, you must call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> to delete the associated device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wgldeletecontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCreateContext_SafeHandle(Windows.Win32.Graphics.Gdi.HDC)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglCreateContext(Windows.Win32.Graphics.Gdi.HDC)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCreateContext(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The wglCreateContext function creates a new OpenGL rendering context, which is suitable for drawing on the device referenced by hdc. The rendering context has the same pixel format as the device context.</summary>
            <returns>
            <para>If the function succeeds, the return value is a valid handle to an OpenGL rendering context. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A rendering context is not the same as a device context. Set the pixel format of the device context before creating a rendering context. For more information on setting the device context's pixel format, see the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setpixelformat">SetPixelFormat</a> function. To use OpenGL, you create a rendering context, select it as a thread's current rendering context, and then call OpenGL functions. When you are finished with the rendering context, you dispose of it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wgldeletecontext">wglDeleteContext</a> function. The following code example shows <b>wglCreateContext</b> usage.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcreatecontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCreateLayerContext_SafeHandle(Windows.Win32.Graphics.Gdi.HDC,System.Int32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglCreateLayerContext(Windows.Win32.Graphics.Gdi.HDC,System.Int32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCreateLayerContext(Windows.Win32.Graphics.Gdi.HDC,System.Int32)">
            <summary>The wglCreateLayerContext function creates a new OpenGL rendering context for drawing to a specified layer plane on a device context.</summary>
            <returns>
            <para>If the function succeeds, the return value is a handle to an OpenGL rendering context. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A rendering context is a port through which all OpenGL commands pass. Every thread that makes OpenGL calls must have one current, active rendering context. A rendering context is not the same as a device context; a rendering context contains information specific to OpenGL, while a device context contains information specific to GDI. Before you create a rendering context, set the pixel format of the device context with the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setpixelformat">SetPixelFormat</a> function. You can use a rendering context in a specified layer plane of a window with identical pixel formats only. With OpenGL applications that use multiple threads, you create a rendering context, select it as the current rendering context of a thread, and make OpenGL calls for the specified thread. When you are finished with the rendering context of the thread, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wgldeletecontext">wglDeleteContext</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcreatelayercontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCopyContext(System.Runtime.InteropServices.SafeHandle,System.Runtime.InteropServices.SafeHandle,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglCopyContext(Windows.Win32.Graphics.OpenGL.HGLRC,Windows.Win32.Graphics.OpenGL.HGLRC,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglCopyContext(Windows.Win32.Graphics.OpenGL.HGLRC,Windows.Win32.Graphics.OpenGL.HGLRC,System.UInt32)">
            <summary>The wglCopyContext function copies selected groups of rendering states from one OpenGL rendering context to another.</summary>
            <returns>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
            <remarks>
            <para>Using the <b>wglCopyContext</b> function, you can synchronize the rendering state of two rendering contexts. You can only copy the rendering state between two rendering contexts within the same process. The rendering contexts must be from the same OpenGL implementation. For example, you can always copy a rendering state between two rendering contexts with identical pixel format in the same process. You can copy the same state information available only with the <b>glPushAttrib</b> function. You cannot copy some state information, such as pixel pack/unpack state, render mode state, select state, and feedback state. When you call <b>wglCopyContext</b>, make sure that the destination rendering context, <i>hglrcDst</i>, is not current to any thread.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcopycontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglDescribeLayerPlane(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.UInt32,Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglDescribeLayerPlane(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.UInt32,Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglDescribeLayerPlane(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.UInt32,Windows.Win32.Graphics.OpenGL.LAYERPLANEDESCRIPTOR*)">
            <summary>The wglDescribeLayerPlane function obtains information about the layer planes of a given pixel format.</summary>
            <returns>
            <para>If the function succeeds, the return value is <b>TRUE</b>. In addition, the <b>wglDescribeLayerPlane</b> function sets the members of the <b>LAYERPLANEDESCRIPTOR</b> structure pointed to by <i>plpd</i> according to the specified layer plane (<i>iLayerPlane</i> ) of the specified pixel format (<i>iPixelFormat</i> ). If the function fails, the return value is <b>FALSE</b>.</para>
            </returns>
            <remarks>The numbering of planes (<i>iLayerPlane</i> ) determines their order. Higher-numbered planes overlay lower-numbered planes.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetCurrentContext_SafeHandle">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglGetCurrentContext"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetCurrentContext">
            <summary>The wglGetCurrentContext function obtains a handle to the current OpenGL rendering context of the calling thread.</summary>
            <returns>If the calling thread has a current OpenGL rendering context, <b>wglGetCurrentContext</b> returns a handle to that rendering context. Otherwise, the return value is <b>NULL</b>.</returns>
            <remarks>The current OpenGL rendering context of a thread is associated with a device context by means of the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentDC</b> function to obtain a handle to the device context associated with the current OpenGL rendering context.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetCurrentDC">
            <summary>The wglGetCurrentDC function obtains a handle to the device context that is associated with the current OpenGL rendering context of the calling thread.</summary>
            <returns>If the calling thread has a current OpenGL rendering context, the function returns a handle to the device context associated with that rendering context by means of the <b>wglMakeCurrent</b> function. Otherwise, the return value is <b>NULL</b>.</returns>
            <remarks>You associate a device context with an OpenGL rendering context when it calls the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentContext</b> function to obtain a handle to the calling thread's current OpenGL rendering context.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglGetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglGetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF*)">
            <summary>Retrieves the palette entries from a given color-index layer plane for a specified device context.</summary>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the number of entries that were set in the palette in the specified layer plane of the window. If the function fails or when no pixel format is selected, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Each color-index layer plane in a window has a palette with a size 2^<i>n</i>, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette. Use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglrealizelayerpalette">wglRealizeLayerPalette</a> function to realize the layer palette. Initially the layer palette contains only entries for white.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetlayerpaletteentries#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglMakeCurrent(Windows.Win32.Graphics.Gdi.HDC,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglMakeCurrent(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.OpenGL.HGLRC)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglMakeCurrent(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.OpenGL.HGLRC)">
            <summary>The wglMakeCurrent function makes a specified OpenGL rendering context the calling thread's current rendering context.</summary>
            <returns>When the <b>wglMakeCurrent</b> function succeeds, the return value is <b>TRUE</b>; otherwise the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
            <remarks>
            <para>The <i>hdc</i> parameter must refer to a drawing surface supported by OpenGL. It need not be the same <i>hdc</i> that was passed to <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglcreatecontext">wglCreateContext</a> when <i>hglrc</i> was created, but it must be on the same device and have the same pixel format. GDI transformation and clipping in <i>hdc</i> are not supported by the rendering context. The current rendering context uses the <i>hdc</i> device context until the rendering context is no longer current. Before switching to the new rendering context, OpenGL flushes any previous rendering context that was current to the calling thread. A thread can have one current rendering context. A process can have multiple rendering contexts by means of multithreading. A thread must set a current rendering context before calling any OpenGL functions. Otherwise, all OpenGL calls are ignored. A rendering context can be current to only one thread at a time. You cannot make a rendering context current to multiple threads. An application can perform multithread drawing by making different rendering contexts current to different threads, supplying each thread with its own rendering context and device context. If an error occurs, the <b>wglMakeCurrent</b> function makes the thread's current rendering context not current before returning.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglmakecurrent#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglRealizeLayerPalette(Windows.Win32.Graphics.Gdi.HDC,System.Int32,Windows.Win32.Foundation.BOOL)">
            <summary>The wglRealizeLayerPalette function maps palette entries from a given color-index layer plane into the physical palette or initializes the palette of an RGBA layer plane.</summary>
            <returns>If the function succeeds, the return value is <b>TRUE</b>, even if <i>bRealize</i> is <b>TRUE</b> and the physical palette is not available. If the function fails or when no pixel format is selected, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
            <remarks>
            <para>The physical palette for a layer plane is a shared resource among windows with layer planes. When more than one window attempts to realize a palette for a given physical layer plane, only one palette at a time is realized. When you call the <b>wglRealizeLayerPalette</b> function, the layer palette of a foreground window is always realized first. When a window's layer palette is realized, its palette entries are always mapped one-to-one into the physical palette. Unlike GDI logical palettes, with <b>wglRealizeLayerPalette</b> there is no mapping of other windows' layer palettes to the current physical palette. Whenever a window becomes the foreground window, call <b>wglRealizeLayerPalette</b> to realize its layer palettes again, even if the pixel type of the layer plane is RGBA. Because <b>wglRealizeLayerPalette</b> doesn't realize the palette of the main plane, use GDI palette functions to realize the main plane palette.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglrealizelayerpalette#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglSetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglSetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglSetLayerPaletteEntries(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.COLORREF*)">
            <summary>Sets the palette entries in a given color-index layer plane for a specified device context.</summary>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the number of entries that were set in the palette in the specified layer plane of the window. If the function fails or no pixel format is selected, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Each color-index plane in a window has a palette with a size 2^n, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette. Use the <b>wglRealizeLayerPalette</b> function to realize the layer palette. Initially the layer palette contains only entries for white. The <b>wglSetLayerPaletteEntries</b> function doesn't set the palette entries of the main plane palette. To update the main plane palette, use GDI palette functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglsetlayerpaletteentries#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglShareLists(System.Runtime.InteropServices.SafeHandle,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglShareLists(Windows.Win32.Graphics.OpenGL.HGLRC,Windows.Win32.Graphics.OpenGL.HGLRC)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglShareLists(Windows.Win32.Graphics.OpenGL.HGLRC,Windows.Win32.Graphics.OpenGL.HGLRC)">
            <summary>The wglShareLists function enables multiple OpenGL rendering contexts to share a single display-list space.</summary>
            <returns>
            <para>When the function succeeds, the return value is <b>TRUE</b>. When the function fails, the return value is <b>FALSE</b> and the display lists are not shared. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>When you create an OpenGL rendering context, it has its own display-list space. The <b>wglShareLists</b> function enables a rendering context to share the display-list space of another rendering context; any number of rendering contexts can share a single display-list space. Once a rendering context shares a display-list space, the rendering context always uses the display-list space until the rendering context is deleted. When the last rendering context of a shared display-list space is deleted, the shared display-list space is deleted. All the indexes and definitions of display lists in a shared display-list space are shared. You can only share display lists with rendering contexts within the same process. However, not all rendering contexts in a process can share display lists. Rendering contexts can share display lists only if they use the same implementation of OpenGL functions. All client rendering contexts of a given pixel format can always share display lists. All rendering contexts of a shared display list must use an identical pixel format. Otherwise the results depend on the implementation of OpenGL used. <div class="alert"><b>Note</b>  The <b>wglShareLists</b> function is only available with OpenGL version 1.01 or later. To determine the version number of the implementation of OpenGL, call <b>glGetString</b>.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglsharelists#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglSwapLayerBuffers(Windows.Win32.Graphics.Gdi.HDC,System.UInt32)">
            <summary>The wglSwapLayerBuffers function swaps the front and back buffers in the overlay, underlay, and main planes of the window referenced by a specified device context.</summary>
            <returns>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
            <remarks>
            <para>When a layer plane doesn't include a back buffer, calling the <b>wglSwapLayerBuffers</b> function has no effect on that layer plane. After you call <b>wglSwapLayerBuffers</b>, the state of the back buffer content is given in the corresponding <b>LAYERPLANEDESCRIPTOR</b> structure of the layer plane or in the <b>PIXELFORMATDESCRIPTOR</b> structure of the main plane. The <b>wglSwapLayerBuffers</b> function swaps the front and back buffers in the specified layer planes simultaneously. Some devices don't support swapping layer planes individually; they swap all layer planes as a group. When the PFD_SWAP_LAYER_BUFFERS flag of the <b>PIXELFORMATDESCRIPTOR</b> structure is set, it indicates that a device can swap individual layer planes and that you can call <b>wglSwapLayerBuffers</b>. With applications that use multiple threads, before calling <b>wglSwapLayerBuffers</b>, clear all drawing commands in all threads drawing to the same window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglswaplayerbuffers#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglUseFontBitmaps(Windows.Win32.Graphics.Gdi.HDC,System.UInt32,System.UInt32,System.UInt32)">
            <summary>The wglUseFontBitmaps function creates a set of bitmap display lists for use in the current OpenGL rendering context. (Unicode)</summary>
            <returns>
            <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com/windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it. The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL. In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context. The function determines the parameters of each call to <b>glBitmap</b> as follows. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontbitmapsw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglUseFontOutlines(Windows.Win32.Graphics.Gdi.HDC,System.UInt32,System.UInt32,System.UInt32,System.Single,System.Single,System.Int32,Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.wglUseFontOutlines(Windows.Win32.Graphics.Gdi.HDC,System.UInt32,System.UInt32,System.UInt32,System.Single,System.Single,System.Int32,Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.wglUseFontOutlines(Windows.Win32.Graphics.Gdi.HDC,System.UInt32,System.UInt32,System.UInt32,System.Single,System.Single,System.Int32,Windows.Win32.Graphics.OpenGL.GLYPHMETRICSFLOAT*)">
            <summary>The wglUseFontOutlines function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. (Unicode)</summary>
            <returns>
            <para>When the function succeeds, the return value is <b>TRUE</b>. When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported. Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number. The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontoutlinesw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyIcon(Windows.Win32.UI.WindowsAndMessaging.HICON)">
            <summary>Destroys an icon and frees any memory the icon occupied.</summary>
            <param name="hIcon">
            <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyCursor(Windows.Win32.UI.WindowsAndMessaging.HCURSOR)">
            <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
            <param name="hCursor">
            <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.AdjustWindowRect(Windows.Win32.Foundation.RECT@,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.AdjustWindowRect(Windows.Win32.Foundation.RECT*,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.AdjustWindowRect(Windows.Win32.Foundation.RECT*,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,Windows.Win32.Foundation.BOOL)">
            <summary>Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then be passed to the CreateWindow function to create a window whose client area is the desired size.</summary>
            <param name="lpRect">
            <para>Type: <b>LPRECT</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwStyle">
            <para>Type: <b>DWORD</b> The <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="bMenu">
            <para>Type: <b>BOOL</b> Indicates whether the window has a menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that completely encloses the window, which includes the client area and the nonclient area. The <b>AdjustWindowRect</b> function does not add extra space when a menu bar wraps to two or more rows. The <b>AdjustWindowRect</b> function does not take the <b>WS_VSCROLL</b> or <b>WS_HSCROLL</b> styles into account. To account for the scroll bars, call the  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function with <b>SM_CXVSCROLL</b> or <b>SM_CYHSCROLL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyMenu(Windows.Win32.UI.WindowsAndMessaging.HMENU)">
            <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to the menu to be destroyed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes. <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,System.String,System.String,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,System.Runtime.InteropServices.SafeHandle,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)">
            <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)</summary>
            <param name="dwExStyle">
            <para>Type: <b>DWORD</b> The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <b>LPCTSTR</b> A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpWindowName">
            <para>Type: <b>LPCTSTR</b> The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwStyle">
            <para>Type: <b>DWORD</b> The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="X">
            <para>Type: <b>int</b> The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Y">
            <para>Type: <b>int</b> The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
            <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nWidth">
            <para>Type: <b>int</b> The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nHeight">
            <para>Type: <b>int</b> The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <b>HWND</b> A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows. To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hInstance">
            <para>Type: <b>HINSTANCE</b> A handle to the instance of the module to be associated with the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpParam">
            <para>Type: <b>LPVOID</b> Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns. If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the new window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function typically fails for one of the following reasons: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost). For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DefWindowProc(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window procedure that received the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value is the result of the message processing and depends on the message.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyWindow(Windows.Win32.Foundation.HWND)">
            <summary>Destroys the specified window.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window to be destroyed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A thread cannot use <b>DestroyWindow</b> to destroy a window created by a different thread. If the window being destroyed is a child window that does not have the <b>WS_EX_NOPARENTNOTIFY</b> style, a <a href="https://docs.microsoft.com/windows/win32/inputmsg/wm-parentnotify">WM_PARENTNOTIFY</a> message is sent to the parent.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)">
            <summary>Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function. (DispatchMessageW)</summary>
            <param name="lpMsg">
            <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to a structure that contains the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</para>
            </returns>
            <remarks>
            <para>The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure must contain valid message values. If the <i>lpmsg</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message and the <i>lParam</i> parameter of the <b>WM_TIMER</b> message is not <b>NULL</b>, <i>lParam</i> points to a function that is called instead of the window procedure. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetDC(Windows.Win32.Foundation.HWND)">
            <summary>The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDC</b> retrieves the DC for the entire screen.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the DC for the specified window's client area. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>The <b>GetDC</b> function retrieves a common, class, or private DC depending on the class style of the specified window. For class and private DCs, <b>GetDC</b> leaves the previously assigned attributes unchanged. However, for common DCs, <b>GetDC</b> assigns default attributes to the DC each time it is retrieved. For example, the default font is System, which is a bitmap font. Because of this, the handle to a common DC returned by <b>GetDC</b> does not tell you what font, color, or brush was used when the window was drawn. To determine the font, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextfacea">GetTextFace</a>. Note that the handle to the DC can only be used by a single thread at any one time. After painting with a common DC, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-releasedc">ReleaseDC</a> function must be called to release the DC. Class and private DCs do not have to be released. <b>ReleaseDC</b> must be called from the same thread that called <b>GetDC</b>. The number of DCs is limited only by available memory.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadCursor(System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadCursor(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadCursor(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance. (Unicode)</summary>
            <param name="hInstance">
            <para>Type: <b>HINSTANCE</b> A handle to an instance of the module whose executable file contains the cursor to be loaded.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpCursorName">
            <para>Type: <b>LPCTSTR</b> The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can also be used to create this value. To use one of the predefined cursors, the application must set the <i>hInstance</i> parameter to <b>NULL</b> and the <i>lpCursorName</i> parameter to one the following values. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HCURSOR</b> If the function succeeds, the return value is the handle to the newly loaded cursor. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>LoadCursor</b> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the <i>lpCursorName</i> parameter is a pointer to a cursor resource. If <i>lpCursorName</i> is a pointer to any type of resource other than a cursor (such as an icon), the return value is not <b>NULL</b>, even though it is not a valid cursor handle. The <b>LoadCursor</b> function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap. <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3> This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)">
            <summary>Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist). (Unicode)</summary>
            <param name="lpMsg">
            <para>Type: <b>LPMSG</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>If <i>hWnd</i> is <b>NULL</b>, <b>PeekMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed. If <i>hWnd</i> is -1, <b>PeekMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>, that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <b>UINT</b> The value of the first message in the range of messages to be examined. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <b>UINT</b> The value of the last message in the range of messages to be examined. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wRemoveMsg">Type: <b>UINT</b></param>
            <returns>
            <para>Type: <b>BOOL</b> If a message is available, the return value is nonzero. If no messages are available, the return value is zero.</para>
            </returns>
            <remarks>
            <para><b>PeekMessage</b> retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system. Note that <b>PeekMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>. During this call, the system dispatches (<a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a>) pending,  nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.PostQuitMessage(System.Int32)">
            <summary>Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.</summary>
            <param name="nExitCode">
            <para>Type: <b>int</b> The application exit code. This value is used as the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postquitmessage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <remarks>
            <para>The <b>PostQuitMessage</b> function posts a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future. When the thread retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the <i>wParam</i> parameter of the <b>WM_QUIT</b> message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postquitmessage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegisterClass(Windows.Win32.UI.WindowsAndMessaging.WNDCLASSW@)">
            <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassW)</summary>
            <param name="lpWndClass">
            <para>Type: <b>const WNDCLASS*</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>ATOM</b> If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If you register the window class by using <b>RegisterClassA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using <b>RegisterClassW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. All window classes that an application registers are unregistered when it terminates. No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ReleaseDC(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.</summary>
            <param name="hWnd">A handle to the window whose DC is to be released.</param>
            <param name="hDC">A handle to the DC to be released.</param>
            <returns>
            <para>The return value indicates whether the DC was released. If the DC was released, the return value is 1. If the DC was not released, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The application must call the <b>ReleaseDC</b> function for each call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowdc">GetWindowDC</a> function and for each call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a> function that retrieves a common DC. An application cannot use the <b>ReleaseDC</b> function to release a DC that was created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdca">CreateDC</a> function; instead, it must use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> function. <b>ReleaseDC</b> must be called from the same thread that called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-releasedc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ShowWindow(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD)">
            <summary>Sets the specified window's show state.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nCmdShow">Type: <b>int</b></param>
            <returns>
            <para>Type: <b>BOOL</b> If the window was previously visible, the return value is nonzero. If the window was previously hidden, the return value is zero.</para>
            </returns>
            <remarks>
            <para>To perform certain special effects when showing or hiding a window, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>. The first time an application calls <b>ShowWindow</b>, it should use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a> function's <i>nCmdShow</i> parameter as its <i>nCmdShow</i> parameter. Subsequent calls to <b>ShowWindow</b> must use one of the values in the given list, instead of the one specified by the <b>WinMain</b> function's <i>nCmdShow</i> parameter. As noted in the discussion of the <i>nCmdShow</i> parameter, the <i>nCmdShow</i> value is ignored in the first call to <b>ShowWindow</b> if the program that launched the application specifies startup information in the  structure. In this case, <b>ShowWindow</b> uses the information specified in the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> structure to show the window. On subsequent calls, the application must call <b>ShowWindow</b> with <i>nCmdShow</i> set to <b>SW_SHOWDEFAULT</b> to use the startup information provided by the program that launched the application. This behavior is designed for the following situations: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)">
            <summary>Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.</summary>
            <param name="lpMsg">
            <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero. If the message is <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>, or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a>, the return value is nonzero, regardless of the translation. If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <b>TranslateMessage</b> function does not modify the message pointed to by the <i>lpMsg</i> parameter.</para>
            <para><a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-deadchar">WM_DEADCHAR</a> message. <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syschar">WM_SYSCHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-sysdeadchar">WM_SYSDEADCHAR</a> message. <b>TranslateMessage</b> produces <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> messages only for keys that are mapped to ASCII characters by the keyboard driver. If applications process virtual-key messages for some other purpose, they should not call <b>TranslateMessage</b>. For instance, an application should not call <b>TranslateMessage</b> if the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translateacceleratora">TranslateAccelerator</a> function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.UpdateWindow(Windows.Win32.Foundation.HWND)">
            <summary>The UpdateWindow function updates the client area of the specified window by sending a WM_PAINT message to the window if the window's update region is not empty.</summary>
            <param name="hWnd">Handle to the window to be updated.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-updatewindow">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.wglDeleteContextSafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.wglDeleteContext(Windows.Win32.Graphics.OpenGL.HGLRC)"/>.
            </summary>
        </member>
    </members>
</doc>
